import { createGmEnvironmentPageApp } from "./features/environment-ui.js";
import { createGmDowntimePageApp } from "./features/downtime-ui.js";
import { createGmMerchantsPageApp } from "./features/merchants-ui.js";
import { createGmLootPageApp } from "./features/loot-ui.js";
import { createRestFeatureModule } from "./features/rest-feature.js";
import { createMarchFeatureModule } from "./features/march-feature.js";
import {
  MERCHANT_SOURCE_TYPES as DOMAIN_MERCHANT_SOURCE_TYPES,
  MERCHANT_SCARCITY_LEVELS as DOMAIN_MERCHANT_SCARCITY_LEVELS,
  MERCHANT_SCARCITY_PROFILES as DOMAIN_MERCHANT_SCARCITY_PROFILES,
  MERCHANT_ALLOWED_ITEM_TYPES as DOMAIN_MERCHANT_ALLOWED_ITEM_TYPES,
  MERCHANT_ALLOWED_ITEM_TYPE_LIST as DOMAIN_MERCHANT_ALLOWED_ITEM_TYPE_LIST,
  MERCHANT_EDITOR_CANDIDATE_LIMIT as DOMAIN_MERCHANT_EDITOR_CANDIDATE_LIMIT,
  MERCHANT_PREVIEW_ITEM_LIMIT as DOMAIN_MERCHANT_PREVIEW_ITEM_LIMIT,
  MERCHANT_ACCESS_LOG_LIMIT as DOMAIN_MERCHANT_ACCESS_LOG_LIMIT,
  MERCHANT_ACCESS_LOG_THROTTLE_MS as DOMAIN_MERCHANT_ACCESS_LOG_THROTTLE_MS,
  MERCHANT_DEFAULTS as DOMAIN_MERCHANT_DEFAULTS,
  MERCHANT_STARTER_BLUEPRINTS as DOMAIN_MERCHANT_STARTER_BLUEPRINTS,
  normalizeMerchantTagList as normalizeMerchantTagListDomain,
  normalizeMerchantKeywordList as normalizeMerchantKeywordListDomain,
  normalizeMerchantSourcePackIds as normalizeMerchantSourcePackIdsDomain,
  normalizeMerchantAllowedItemTypes as normalizeMerchantAllowedItemTypesDomain,
  normalizeMerchantCuratedItemUuids as normalizeMerchantCuratedItemUuidsDomain,
  parseMerchantUuidListInput as parseMerchantUuidListInputDomain,
  formatMerchantUuidListInput as formatMerchantUuidListInputDomain,
  normalizeMerchantSourceType as normalizeMerchantSourceTypeDomain,
  normalizeMerchantScarcity as normalizeMerchantScarcityDomain,
  getMerchantScarcityProfile as getMerchantScarcityProfileDomain,
  normalizeMerchantRace as normalizeMerchantRaceDomain,
  normalizeMerchantRarity as normalizeMerchantRarityDomain,
  getMerchantRarityBucket as getMerchantRarityBucketDomain,
  normalizeMerchantRarityWeights as normalizeMerchantRarityWeightsDomain,
  normalizeMerchantCityList as normalizeMerchantCityListDomain,
  parseMerchantCityListInput as parseMerchantCityListInputDomain,
  formatMerchantCityListInput as formatMerchantCityListInputDomain,
  getMerchantRaceKey as getMerchantRaceKeyDomain,
  getMerchantEditorRaceOptions as getMerchantEditorRaceOptionsDomain,
  pickRandomMerchantRace as pickRandomMerchantRaceDomain,
  pickRandomMerchantTitle as pickRandomMerchantTitleDomain,
  pickRandomMerchantNamePart as pickRandomMerchantNamePartDomain,
  generateRandomMerchantName as generateRandomMerchantNameDomain,
  generateRandomMerchantNameUnbound as generateRandomMerchantNameUnboundDomain,
  buildMerchantOfferTagOptions as buildMerchantOfferTagOptionsDomain,
  resolveMerchantAllowedTypesFromOfferTags as resolveMerchantAllowedTypesFromOfferTagsDomain,
  getMerchantEditorSourceTypeOptions as getMerchantEditorSourceTypeOptionsDomain,
  normalizeMerchantFolderAlias as normalizeMerchantFolderAliasDomain,
  findMerchantFolderByAliases as findMerchantFolderByAliasesDomain,
  buildStarterMerchantPatch as buildStarterMerchantPatchDomain,
  buildMerchantDefinitionPatchFromEditorForm as buildMerchantDefinitionPatchFromEditorFormDomain,
  buildMerchantCityOptions as buildMerchantCityOptionsDomain,
  formatMerchantCp as formatMerchantCpDomain,
  getMerchantItemUnitPriceCp as getMerchantItemUnitPriceCpDomain,
  getMerchantSourceRefOptionsForEditor as getMerchantSourceRefOptionsForEditorDomain,
  getMerchantTargetStockCount as getMerchantTargetStockCountDomain,
  shuffleMerchantRows as shuffleMerchantRowsDomain,
  selectMerchantStockRows as selectMerchantStockRowsDomain,
  buildMerchantStockCandidateRows as buildMerchantStockCandidateRowsDomain
} from "./features/merchant-domain.js";
const DEBUG_LOG = false;
if (DEBUG_LOG) console.log("party-operations: script loaded");

const PRIMARY_MODULE_ID = "party-operations";
const PREMIUM_MODULE_ID = "party-operations-premium";
const MODULE_ID = (() => {
  try {
    const candidates = [PRIMARY_MODULE_ID, PREMIUM_MODULE_ID];
    for (const id of candidates) {
      if (globalThis.game?.modules?.get(id)?.active) return id;
    }
    for (const id of candidates) {
      if (globalThis.game?.modules?.has?.(id) || globalThis.game?.modules?.get(id)) return id;
    }
  } catch {
    // Ignore and fall back to the primary channel id.
  }
  return PRIMARY_MODULE_ID;
})();
const { ApplicationV2, HandlebarsApplicationMixin } = foundry.applications.api;
const FEATURE_MODULES = Object.freeze([
  createRestFeatureModule(),
  createMarchFeatureModule()
]);

function registerFeatureModules() {
  for (const feature of FEATURE_MODULES) {
    if (typeof feature?.register === "function") feature.register();
  }
}

const PO_ESCAPE_HTML_FALLBACK = (value) => String(value ?? "")
  .replace(/&/g, "&amp;")
  .replace(/</g, "&lt;")
  .replace(/>/g, "&gt;")
  .replace(/\"/g, "&quot;")
  .replace(/'/g, "&#39;");

const poEscapeHtml = (value) => {
  try {
    const escapeFn = foundry?.utils?.escapeHTML;
    if (typeof escapeFn === "function") return escapeFn(String(value ?? ""));
  } catch {
    // Fall through to fallback encoder.
  }
  return PO_ESCAPE_HTML_FALLBACK(value);
};

function buildUuidJournalLink(uuid, label) {
  const safeLabel = poEscapeHtml(String(label ?? "").trim() || "Unknown");
  const safeUuid = String(uuid ?? "").trim();
  if (!safeUuid) return safeLabel;
  return `@UUID[${safeUuid}]{${safeLabel}}`;
}

try {
  if (typeof foundry?.utils?.escapeHTML !== "function" && foundry?.utils && typeof foundry.utils === "object") {
    foundry.utils.escapeHTML = PO_ESCAPE_HTML_FALLBACK;
  }
} catch {
  // Ignore shim failures; local fallbacks exist in some call-sites.
}

export const SETTINGS = {
  REST_STATE: "restWatchState",
  REST_COMMITTED: "restWatchStateLastCommitted",
  MARCH_STATE: "marchingOrderState",
  MARCH_COMMITTED: "marchingOrderStateLastCommitted",
  REST_ACTIVITIES: "restActivities",
  OPS_LEDGER: "operationsLedger",
  GATHER_ROLL_MODE: "gatherRollMode",
  GATHER_ENABLED: "gatherEnabled",
  GATHER_MIN_HOURS: "gatherMinimumHours",
  GATHER_DISALLOW_COMBAT: "gatherDisallowCombat",
  GATHER_DC_LUSH: "gatherBaseDcLushForest",
  GATHER_DC_TEMPERATE: "gatherBaseDcTemperateHills",
  GATHER_DC_SPARSE: "gatherBaseDcSparsePlains",
  GATHER_DC_COLD: "gatherBaseDcColdMountains",
  GATHER_DC_DESERT: "gatherBaseDcDesert",
  GATHER_DEFAULT_SEASON_MOD: "gatherDefaultSeasonMod",
  GATHER_DEFAULT_WEATHER_MOD: "gatherDefaultWeatherMod",
  GATHER_DEFAULT_CORRUPTION_MOD: "gatherDefaultCorruptionMod",
  GATHER_ENABLE_HERBALISM_ADVANTAGE: "gatherEnableHerbalismAdvantage",
  GATHER_ENABLE_HOSTILE_FAIL_FLAG: "gatherEnableHostileEncounterFlag",
  GATHER_ENABLE_FAIL_BY5_COMPLICATION: "gatherEnableFailBy5Complication",
  GATHER_ENABLE_SUCCESS_BY5_DOUBLE: "gatherEnableSuccessBy5Double",
  GATHER_ENABLE_NAT20_BONUS: "gatherEnableNat20Bonus",
  GATHER_ENABLE_NAT1_FLAG: "gatherEnableNat1Complication",
  GATHER_ENABLE_CORRUPTION_WATER_CHECK: "gatherEnableCorruptionWaterCheck",
  GATHER_CORRUPTION_SAVE_DC: "gatherCorruptionConSaveDc",
  GATHER_ENABLE_WATER_AUTO_FOUND: "gatherEnableWaterAutoFound",
  GATHER_ENABLE_TRAVEL_TRADEOFF: "gatherEnableTravelTradeoff",
  GATHER_TRAVEL_TRADEOFF_DEFAULT: "gatherTravelTradeoffDefault",
  GATHER_TRAVEL_CON_SAVE_DC: "gatherTravelConSaveDc",
  INJURY_RECOVERY: "injuryRecoveryState",
  INJURY_REMINDER_DAY: "injuryReminderDay",
  LOOT_SOURCE_CONFIG: "lootSourceConfig",
  INTEGRATION_MODE: "integrationMode",
  SESSION_AUTOPILOT_SNAPSHOT: "sessionAutopilotSnapshot",
  LAUNCHER_PLACEMENT: "launcherPlacement",
  FLOATING_LAUNCHER_POS: "floatingLauncherPos",
  FLOATING_LAUNCHER_LOCKED: "floatingLauncherLocked",
  FLOATING_LAUNCHER_RESET: "floatingLauncherReset",
  PLAYER_AUTO_OPEN_REST: "playerAutoOpenRest",
  SHARED_GM_PERMISSIONS: "sharedGmPermissions",
  DEBUG_ENABLED: "debugEnabled",
  LOOT_SCARCITY: "lootScarcity",
  REST_AUTOMATION_ENABLED: "restAutomationEnabled",
  MARCHING_ORDER_LOCK_PLAYERS: "marchingOrderLockPlayers",
  PARTY_OPS_CONFIG: "partyOpsConfig",
  JOURNAL_ENTRY_VISIBILITY: "journalEntryVisibility",
  JOURNAL_FILTER_DEBOUNCE_MS: "journalFilterDebounceMs",
  SESSION_SUMMARY_RANGE: "sessionSummaryRange",
  JOURNAL_FOLDER_CACHE: "journalFolderCache",
  INVENTORY_HOOK_MODE: "inventoryHookMode",
  AUTO_INV_ENABLED: "autoInventoryEnabled",
  AUTO_INV_WEAPON_PACK: "autoInventoryWeaponPackId",
  AUTO_INV_ARMOR_PACK: "autoInventoryArmorPackId",
  AUTO_INV_GEAR_PACK: "autoInventoryGearPackId",
  AUTO_INV_CONSUMABLES_PACK: "autoInventoryConsumablesPackId",
  AUTO_INV_CURRENCY_ENABLED: "autoInventoryCurrencyEnabled",
  AUTO_INV_ITEM_CHANCE_SCALAR: "autoInventoryItemChanceScalar",
  AUTO_INV_CONSUMABLE_CHANCE_SCALAR: "autoInventoryConsumableChanceScalar",
  AUTO_INV_CURRENCY_SCALAR: "autoInventoryCurrencyScalar",
  AUTO_INV_QUALITY_SHIFT: "autoInventoryQualityShift"
};

const SOCKET_CHANNEL = `module.${MODULE_ID}`;
let restWatchAppInstance = null;
let marchingOrderAppInstance = null;
let restWatchPlayerAppInstance = null;
let globalModifierSummaryAppInstance = null;
let gmEnvironmentPageAppInstance = null;
let gmLootPageAppInstance = null;
let gmDowntimePageAppInstance = null;
let gmMerchantsPageAppInstance = null;
let gmLootClaimsBoardAppInstance = null;
const pendingScrollRestore = new WeakMap();
const pendingUiRestore = new WeakMap();
const pendingWindowRestore = new WeakMap();
let latestCanvasRestoreRequestId = 0;
const journalFilterDebounceTimers = new WeakMap();
const sopNoteDebounceTimers = new WeakMap();
const restWatchNoteDebounceTimers = new WeakMap();
const marchingNoteDebounceTimers = new WeakMap();
const suppressedSettingRefreshKeys = new Map();
let refreshOpenAppsQueued = false;
let integrationSyncTimeoutId = null;
let integrationSyncInFlight = false;
let integrationSyncQueued = false;
let integrationSyncQueuedReason = "";
const integrationSyncWaiters = [];
let sopPendingSyncInFlight = false;
let sopPendingSyncScheduled = false;
const activeEffectDeleteLocks = new Set();
let launcherRecoveryScheduled = false;
let partyOpsHooksRegistered = false;
let lootManifestFolderSyncPromise = null;
const pendingInventoryRefreshByActor = new Map();
const autoInventoryPackIndexCache = new Map();
const merchantUiAccessThrottleByKey = new Map();
const merchantBarterResolutionByKey = new Map();
const LAUNCHER_RECOVERY_DELAYS_MS = [120, 500, 1400, 3200];
const LAUNCHER_PLACEMENTS = {
  FLOATING: "floating",
  SIDEBAR: "sidebar",
  BOTH: "both"
};
const GATHER_TRAVEL_CHOICES = Object.freeze({
  PACE: "pace",
  FELL_BEHIND: "fell-behind"
});
const GATHER_ENVIRONMENT_KEYS = Object.freeze([
  "lush_forest_or_river_valley",
  "temperate_hills_or_light_woodland",
  "sparse_plains_or_rocky",
  "cold_mountains_or_swamp",
  "desert_blighted_wasteland"
]);
const GATHER_ENVIRONMENT_LABELS = Object.freeze({
  lush_forest_or_river_valley: "Lush Forest / River Valley",
  temperate_hills_or_light_woodland: "Temperate Hills / Light Woodland",
  sparse_plains_or_rocky: "Sparse Plains / Rocky Terrain",
  cold_mountains_or_swamp: "Cold Mountains / Swamp",
  desert_blighted_wasteland: "Desert / Blighted Wasteland"
});
const GATHER_DEFAULTS = Object.freeze({
  enabled: true,
  minimumHours: 4,
  disallowCombat: true,
  baseDc: {
    lush_forest_or_river_valley: 10,
    temperate_hills_or_light_woodland: 12,
    sparse_plains_or_rocky: 14,
    cold_mountains_or_swamp: 15,
    desert_blighted_wasteland: 19
  },
  seasonMod: 0,
  weatherMod: 0,
  corruptionMod: 0,
  herbalismAdvantageEnabled: false,
  hostileEncounterFlagEnabled: true,
  failBy5ComplicationEnabled: true,
  successBy5DoubleEnabled: true,
  nat20BonusEnabled: true,
  nat1ComplicationEnabled: true,
  corruptionWaterCheckEnabled: false,
  corruptionConSaveDc: 13,
  waterAutoFoundEnabled: true,
  travelTradeoffEnabled: true,
  travelTradeoffDefault: GATHER_TRAVEL_CHOICES.PACE,
  travelConSaveDc: 10
});
const GATHER_QUICK_PRESETS = Object.freeze([
  {
    id: "lush-food-sweep",
    label: "Lush Food Sweep",
    description: "Low-risk food pass in lush terrain.",
    options: {
      environment: "lush_forest_or_river_valley",
      resourceType: "food",
      gatherMode: "plant",
      seasonMod: 0,
      weatherMod: 0,
      corruptionMod: 0,
      hostileTerrain: false,
      isCorruptedRegion: false,
      waterAutoFound: false,
      duringTravel: false,
      travelTradeoff: GATHER_TRAVEL_CHOICES.PACE
    }
  },
  {
    id: "river-water-run",
    label: "River Water Run",
    description: "Quick water gather at obvious source.",
    options: {
      environment: "lush_forest_or_river_valley",
      resourceType: "water",
      gatherMode: "standard",
      seasonMod: 0,
      weatherMod: 0,
      corruptionMod: 0,
      hostileTerrain: false,
      isCorruptedRegion: false,
      waterAutoFound: true,
      duringTravel: false,
      travelTradeoff: GATHER_TRAVEL_CHOICES.PACE
    }
  },
  {
    id: "temperate-travel-forage",
    label: "Temperate Travel Forage",
    description: "On-the-move forage with pace reduction tradeoff.",
    options: {
      environment: "temperate_hills_or_light_woodland",
      resourceType: "food",
      gatherMode: "standard",
      seasonMod: 0,
      weatherMod: 1,
      corruptionMod: 0,
      hostileTerrain: false,
      isCorruptedRegion: false,
      waterAutoFound: false,
      duringTravel: true,
      travelTradeoff: GATHER_TRAVEL_CHOICES.PACE
    }
  },
  {
    id: "wasteland-water-risk",
    label: "Wasteland Water Risk",
    description: "High-risk water gather in blighted terrain.",
    options: {
      environment: "desert_blighted_wasteland",
      resourceType: "water",
      gatherMode: "standard",
      seasonMod: 0,
      weatherMod: 2,
      corruptionMod: 2,
      hostileTerrain: true,
      isCorruptedRegion: true,
      waterAutoFound: false,
      duringTravel: true,
      travelTradeoff: GATHER_TRAVEL_CHOICES.FELL_BEHIND
    }
  }
]);

const PO_TEMPLATE_MAP = Object.freeze({
  "rest-watch": "modules/party-operations/templates/rest-watch.hbs",
  "rest-watch-player": "modules/party-operations/templates/rest-watch-player.hbs",
  "marching-order": "modules/party-operations/templates/marching-order.hbs",
  "global-modifiers": "modules/party-operations/templates/global-modifiers.hbs",
  "gm-environment": "modules/party-operations/templates/gm-environment.hbs",
  "gm-downtime": "modules/party-operations/templates/gm-downtime.hbs",
  "gm-merchants": "modules/party-operations/templates/gm-merchants.hbs",
  "gm-loot": "modules/party-operations/templates/gm-loot.hbs",
  "gm-loot-claims-board": "modules/party-operations/templates/gm-loot-claims-board.hbs"
});

const APP_WINDOW_SIZE_PROFILES = Object.freeze({
  default: Object.freeze({
    width: 980,
    height: 760,
    minWidth: 700,
    minHeight: 520,
    maxWidthRatio: 0.95,
    maxHeightRatio: 0.92
  }),
  "rest-watch": Object.freeze({
    width: 1020,
    height: 820,
    minWidth: 760,
    minHeight: 560,
    maxWidthRatio: 0.96,
    maxHeightRatio: 0.94
  }),
  "rest-watch-player": Object.freeze({
    width: 760,
    height: 620,
    minWidth: 620,
    minHeight: 500,
    maxWidthRatio: 0.9,
    maxHeightRatio: 0.88
  }),
  "marching-order": Object.freeze({
    width: 1320,
    height: 920,
    minWidth: 880,
    minHeight: 620,
    maxWidthRatio: 0.97,
    maxHeightRatio: 0.95
  }),
  "global-modifiers": Object.freeze({
    width: 900,
    height: 720,
    minWidth: 700,
    minHeight: 520,
    maxWidthRatio: 0.92,
    maxHeightRatio: 0.9
  }),
  "gm-environment": Object.freeze({
    width: 980,
    height: 760,
    minWidth: 760,
    minHeight: 560,
    maxWidthRatio: 0.95,
    maxHeightRatio: 0.93
  }),
  "gm-downtime": Object.freeze({
    width: 980,
    height: 760,
    minWidth: 760,
    minHeight: 560,
    maxWidthRatio: 0.95,
    maxHeightRatio: 0.93
  }),
  "gm-merchants": Object.freeze({
    width: 1120,
    height: 920,
    minWidth: 860,
    minHeight: 620,
    maxWidthRatio: 0.97,
    maxHeightRatio: 0.95
  }),
  "gm-loot": Object.freeze({
    width: 980,
    height: 760,
    minWidth: 760,
    minHeight: 560,
    maxWidthRatio: 0.95,
    maxHeightRatio: 0.93
  }),
  "gm-loot-claims-board": Object.freeze({
    width: 920,
    height: 760,
    minWidth: 720,
    minHeight: 560,
    maxWidthRatio: 0.94,
    maxHeightRatio: 0.92
  })
});

const APP_WINDOW_PROFILE_BY_ID = Object.freeze({
  "rest-watch-app": "rest-watch",
  "rest-watch-player-app": "rest-watch-player",
  "marching-order-app": "marching-order",
  "party-operations-global-modifier-summary": "global-modifiers",
  "party-operations-gm-environment-page": "gm-environment",
  "party-operations-gm-downtime-page": "gm-downtime",
  "party-operations-gm-merchants-page": "gm-merchants",
  "party-operations-gm-loot-page": "gm-loot",
  "party-operations-gm-loot-claims-board": "gm-loot-claims-board"
});

function normalizeWindowProfileId(profileOrApp) {
  if (typeof profileOrApp === "string") {
    const normalized = String(profileOrApp ?? "").trim().toLowerCase();
    if (Object.prototype.hasOwnProperty.call(APP_WINDOW_SIZE_PROFILES, normalized)) return normalized;
    return "default";
  }
  const appId = String(profileOrApp?.options?.id ?? profileOrApp?.id ?? "").trim();
  const mappedProfileId = APP_WINDOW_PROFILE_BY_ID[appId];
  if (mappedProfileId && Object.prototype.hasOwnProperty.call(APP_WINDOW_SIZE_PROFILES, mappedProfileId)) return mappedProfileId;
  return "default";
}

function getUiViewportSize() {
  const rawWidth = Number(globalThis?.window?.innerWidth ?? document?.documentElement?.clientWidth ?? 1600);
  const rawHeight = Number(globalThis?.window?.innerHeight ?? document?.documentElement?.clientHeight ?? 900);
  const width = Number.isFinite(rawWidth) && rawWidth > 0 ? Math.floor(rawWidth) : 1600;
  const height = Number.isFinite(rawHeight) && rawHeight > 0 ? Math.floor(rawHeight) : 900;
  return {
    width: Math.max(480, width),
    height: Math.max(360, height)
  };
}

function clampWindowMetric(value, min, max, fallback) {
  const raw = Number(value);
  if (!Number.isFinite(raw)) return fallback;
  return Math.max(min, Math.min(max, Math.floor(raw)));
}

function getResponsiveWindowPosition(profileOrApp, overrides = {}) {
  const profileId = normalizeWindowProfileId(profileOrApp);
  const profile = APP_WINDOW_SIZE_PROFILES[profileId] ?? APP_WINDOW_SIZE_PROFILES.default;
  const patch = overrides && typeof overrides === "object" ? overrides : {};
  const merged = {
    width: Number(patch.width ?? profile.width),
    height: Number(patch.height ?? profile.height),
    minWidth: Number(patch.minWidth ?? profile.minWidth),
    minHeight: Number(patch.minHeight ?? profile.minHeight),
    maxWidthRatio: Number(patch.maxWidthRatio ?? profile.maxWidthRatio),
    maxHeightRatio: Number(patch.maxHeightRatio ?? profile.maxHeightRatio)
  };
  const viewport = getUiViewportSize();
  const minWidth = Math.max(420, Math.floor(Number.isFinite(merged.minWidth) ? merged.minWidth : 700));
  const minHeight = Math.max(320, Math.floor(Number.isFinite(merged.minHeight) ? merged.minHeight : 520));
  const maxWidthRatio = Math.max(0.6, Math.min(0.99, Number.isFinite(merged.maxWidthRatio) ? merged.maxWidthRatio : 0.95));
  const maxHeightRatio = Math.max(0.6, Math.min(0.99, Number.isFinite(merged.maxHeightRatio) ? merged.maxHeightRatio : 0.92));
  const maxWidth = Math.max(minWidth, Math.floor(viewport.width * maxWidthRatio));
  const maxHeight = Math.max(minHeight, Math.floor(viewport.height * maxHeightRatio));
  const widthFallback = clampWindowMetric(profile.width, minWidth, maxWidth, maxWidth);
  const heightFallback = clampWindowMetric(profile.height, minHeight, maxHeight, maxHeight);
  return {
    width: clampWindowMetric(merged.width, minWidth, maxWidth, widthFallback),
    height: clampWindowMetric(merged.height, minHeight, maxHeight, heightFallback)
  };
}

function clampWindowPositionToViewport(position, options = {}) {
  const viewport = getUiViewportSize();
  const padding = Math.max(0, Math.floor(Number(options.padding ?? 8) || 8));
  const width = Number(position?.width);
  const height = Number(position?.height);
  const left = Number(position?.left);
  const top = Number(position?.top);
  const maxLeft = Number.isFinite(width) ? Math.max(padding, viewport.width - Math.floor(width) - padding) : undefined;
  const maxTop = Number.isFinite(height) ? Math.max(padding, viewport.height - Math.floor(height) - padding) : undefined;
  return {
    left: Number.isFinite(left) && Number.isFinite(maxLeft) ? Math.max(padding, Math.min(maxLeft, Math.floor(left))) : undefined,
    top: Number.isFinite(top) && Number.isFinite(maxTop) ? Math.max(padding, Math.min(maxTop, Math.floor(top))) : undefined
  };
}

function getResponsiveWindowOptions(profileId, options = {}) {
  const patch = options && typeof options === "object" ? options : {};
  const overridePosition = patch.position && typeof patch.position === "object" ? patch.position : {};
  return foundry.utils.mergeObject(patch, {
    position: getResponsiveWindowPosition(profileId, overridePosition)
  }, { inplace: false, overwrite: true });
}

function normalizePreservedRenderOptions(renderOptions = null) {
  const patch = renderOptions && typeof renderOptions === "object" ? renderOptions : {};
  return foundry.utils.mergeObject({
    force: true,
    parts: ["main"],
    focus: false
  }, patch, { inplace: false, overwrite: true });
}

function captureCanvasViewState() {
  try {
    const liveCanvas = globalThis?.canvas;
    if (!liveCanvas?.ready || !liveCanvas?.stage) return null;
    const sceneId = String(liveCanvas.scene?.id ?? "");
    if (!sceneId) return null;
    const x = Number(liveCanvas.stage.pivot?.x);
    const y = Number(liveCanvas.stage.pivot?.y);
    const scale = Number(liveCanvas.stage.scale?.x ?? liveCanvas.stage.scale?.y ?? 1);
    if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(scale)) return null;
    return {
      sceneId,
      x,
      y,
      scale,
      capturedAt: Date.now()
    };
  } catch {
    return null;
  }
}

function hasCanvasViewShifted(previous, current, options = {}) {
  if (!previous || !current) return false;
  if (String(previous.sceneId ?? "") !== String(current.sceneId ?? "")) return false;
  const tolerancePx = Math.max(0.25, Number(options.tolerancePx ?? 1.5));
  const toleranceScale = Math.max(0.0005, Number(options.toleranceScale ?? 0.0025));
  return Math.abs(Number(current.x ?? 0) - Number(previous.x ?? 0)) > tolerancePx
    || Math.abs(Number(current.y ?? 0) - Number(previous.y ?? 0)) > tolerancePx
    || Math.abs(Number(current.scale ?? 1) - Number(previous.scale ?? 1)) > toleranceScale;
}

function restoreCanvasViewState(snapshot, options = {}) {
  try {
    if (!snapshot) return false;
    const liveCanvas = globalThis?.canvas;
    if (!liveCanvas?.ready || !liveCanvas?.stage) return false;
    if (String(liveCanvas.scene?.id ?? "") !== String(snapshot.sceneId ?? "")) return false;
    const current = captureCanvasViewState();
    if (!hasCanvasViewShifted(snapshot, current, options)) return false;
    const panData = {
      x: Number(snapshot.x ?? 0),
      y: Number(snapshot.y ?? 0),
      scale: Number(snapshot.scale ?? 1),
      duration: 0
    };
    if (typeof liveCanvas.animatePan === "function") {
      void liveCanvas.animatePan(panData);
      return true;
    }
    if (typeof liveCanvas.pan === "function") {
      liveCanvas.pan(panData);
      return true;
    }
  } catch {
    return false;
  }
  return false;
}

function queueCanvasViewRestore(snapshot, options = {}) {
  if (!snapshot) return;
  const latestOnly = options?.latestOnly !== false;
  const requestId = latestOnly ? ++latestCanvasRestoreRequestId : 0;
  const maxAgeMs = Math.max(80, Math.floor(Number(options.maxAgeMs ?? 1500)));
  const runRestore = () => {
    if ((Date.now() - Number(snapshot.capturedAt ?? 0)) > maxAgeMs) return;
    if (latestOnly && requestId !== latestCanvasRestoreRequestId) return;
    restoreCanvasViewState(snapshot, options);
  };
  requestAnimationFrame(() => {
    requestAnimationFrame(runRestore);
  });
  try {
    window.setTimeout(runRestore, 64);
  } catch {
    // Ignore timer failures in non-browser execution contexts.
  }
}

function shouldPreserveCanvasForUiEvent(event, actionElement, actionInput = "") {
  const eventType = String(event?.type ?? "").trim().toLowerCase();
  if (eventType === "change" || eventType === "input") return true;
  const action = String(actionInput ?? actionElement?.dataset?.action ?? "").trim().toLowerCase();
  if (action === "ping") return false;
  const tag = String(actionElement?.tagName ?? "").trim().toUpperCase();
  if (tag === "INPUT" || tag === "SELECT" || tag === "TEXTAREA") return true;
  return false;
}

function renderAppWithPreservedState(app, renderOptions = { force: true, parts: ["main"], focus: false }, options = {}) {
  if (!app?.render) return;
  const uiState = captureUiState(app);
  if (uiState) pendingUiRestore.set(app, uiState);
  const scrollState = captureScrollState(app);
  if (scrollState.length > 0) pendingScrollRestore.set(app, scrollState);
  const preserveWindow = options?.preserveWindow !== false;
  if (preserveWindow) {
    const windowState = captureWindowState(app);
    if (windowState) pendingWindowRestore.set(app, windowState);
  }
  const normalizedOptions = normalizePreservedRenderOptions(renderOptions);
  const preserveCanvas = options?.preserveCanvas !== false;
  const canvasSnapshot = preserveCanvas ? captureCanvasViewState() : null;
  app.render(normalizedOptions);
  if (preserveCanvas) {
    queueCanvasViewRestore(canvasSnapshot, {
      action: String(options?.action ?? ""),
      eventType: String(options?.eventType ?? "")
    });
  }
}

const PO_MAIN_TAB_IDS = new Set(["rest-watch", "marching-order", "operations", "gm"]);

const PO_SIDEBAR_VIEW_ITEMS = Object.freeze([
  { id: "rest-watch", action: "rest", label: "Rest", icon: "fas fa-moon", title: "Open Rest Watch", target: "po-panel-rest-watch" },
  { id: "operations", action: "operations", label: "Ops", icon: "fas fa-clipboard-list", title: "Open Operations", target: "po-panel-operations" },
  { id: "marching-order", action: "march", label: "March", icon: "fas fa-arrow-up", title: "Open Marching Order", target: "po-march-overview" },
  { id: "gm", action: "gm", label: "GM", icon: "fas fa-user-shield", title: "Open GM Section", target: "po-panel-operations", gmOnly: true }
]);

const PO_MAIN_TAB_ACTIONS = Object.freeze({
  "rest-watch": "rest",
  operations: "operations",
  "marching-order": "march",
  gm: "gm"
});

const PO_SWITCH_TAB_IDS = new Set(["rest", "march", "operations", "gm"]);

const PO_SWITCH_TO_MAIN_TAB = Object.freeze({
  rest: "rest-watch",
  march: "marching-order",
  operations: "operations",
  gm: "gm"
});

const PO_MAIN_TO_SWITCH_TAB = Object.freeze({
  "rest-watch": "rest",
  "marching-order": "march",
  operations: "operations",
  gm: "gm"
});

function writePoBrowserHistoryEntry(_destination, _options = {}) {
  // Browser history integration intentionally disabled.
}

function bindPoBrowserBackNavigation() {
  // Browser back/forward handling intentionally disabled.
}

function getTemplateForMainTab(tabId) {
  const normalized = String(tabId ?? "").trim().toLowerCase();
  if (normalized === "marching-order") return PO_TEMPLATE_MAP["marching-order"];
  if (normalized === "rest-watch") return PO_TEMPLATE_MAP["rest-watch"];
  if (normalized === "operations" || normalized === "gm") return PO_TEMPLATE_MAP["rest-watch"];
  return PO_TEMPLATE_MAP["rest-watch"];
}

function normalizeMainTabId(value, fallback = "rest-watch") {
  const normalized = String(value ?? "").trim().toLowerCase();
  if (PO_SWITCH_TAB_IDS.has(normalized)) return PO_SWITCH_TO_MAIN_TAB[normalized] ?? fallback;
  if (normalized === "rest") return "rest-watch";
  if (normalized === "march") return "marching-order";
  if (!PO_MAIN_TAB_IDS.has(normalized)) return fallback;
  return normalized;
}

function normalizeSwitchTabId(value, fallback = "rest") {
  const normalized = String(value ?? "").trim().toLowerCase();
  if (PO_SWITCH_TAB_IDS.has(normalized)) return normalized;
  const mainTab = normalizeMainTabId(normalized, PO_SWITCH_TO_MAIN_TAB[fallback] ?? "rest-watch");
  return PO_MAIN_TO_SWITCH_TAB[mainTab] ?? fallback;
}

function getSwitchTabIdFromMainTabId(mainTabId) {
  const normalized = normalizeMainTabId(mainTabId, "rest-watch");
  return PO_MAIN_TO_SWITCH_TAB[normalized] ?? "rest";
}

function logUiDebug(scope, message, details = null) {
  if (!isModuleDebugEnabled()) return;
  if (details === null) {
    console.debug(`[${MODULE_ID}][${scope}] ${message}`);
    return;
  }
  console.debug(`[${MODULE_ID}][${scope}] ${message}`, details);
}

function logUiFailure(scope, message, error, details = null) {
  const payload = details && typeof details === "object" ? { ...details } : {};
  payload.error = String(error?.message ?? error ?? "Unknown error");
  console.error(`[${MODULE_ID}][${scope}] ${message}`, payload, error);
}

function summarizeClickTarget(target) {
  const element = target instanceof Element ? target : null;
  if (!element) return "unknown";
  const tag = String(element.tagName ?? "").toLowerCase();
  const action = element.closest?.("[data-action]")?.dataset?.action ?? "";
  const panel = element.closest?.("[data-panel]")?.dataset?.panel ?? "";
  const tab = element.closest?.("[data-tab]")?.dataset?.tab ?? "";
  const id = element.id ? `#${element.id}` : "";
  const classes = typeof element.className === "string"
    ? element.className.trim().split(/\s+/).filter(Boolean).slice(0, 3).join(".")
    : "";
  const classSuffix = classes ? `.${classes}` : "";
  return `${tag}${id}${classSuffix}${action ? ` [action=${action}]` : ""}${panel ? ` [panel=${panel}]` : ""}${tab ? ` [tab=${tab}]` : ""}`;
}

function getRequestedPanelIdFromElement(element) {
  if (!element) return "rest-watch";
  const panel = String(element?.dataset?.panel ?? "").trim();
  if (panel) return panel;
  const tab = String(element?.dataset?.tab ?? "").trim();
  if (tab) return tab;
  return "rest-watch";
}

function getMainTabIdFromAction(action) {
  const normalizedAction = String(action ?? "").trim().toLowerCase();
  for (const [tabId, tabAction] of Object.entries(PO_MAIN_TAB_ACTIONS)) {
    if (tabAction === normalizedAction) return tabId;
  }
  return null;
}

function getActionFromMainTabId(tabId) {
  const normalized = normalizeMainTabId(tabId, "rest-watch");
  return PO_MAIN_TAB_ACTIONS[normalized] ?? "rest";
}

function diagnoseRenderedMainTabs(root, scope = "ui") {
  if (!root || !isModuleDebugEnabled()) return;
  const renderedTabs = Array.from(root.querySelectorAll(".po-tabs-main .po-tab[data-panel], .po-tabs-main .po-tab[data-tab]"))
    .map((node) => normalizeMainTabId(node?.dataset?.panel ?? node?.dataset?.tab, "rest-watch"))
    .filter(Boolean);
  const expected = Array.from(PO_MAIN_TAB_IDS).filter((id) => id !== "gm" || canAccessAllPlayerOps());
  const missing = expected.filter((id) => !renderedTabs.includes(id));
  const unknown = renderedTabs.filter((id) => !PO_MAIN_TAB_IDS.has(id));
  logUiDebug(scope, "rendered main-tab diagnostics", { expected, renderedTabs, missing, unknown });
}

async function validatePartyOperationsTemplates() {
  const templates = [...new Set(Object.values(PO_TEMPLATE_MAP))];
  for (const templatePath of templates) {
    try {
      await getTemplate(templatePath);
      logUiDebug("templates", "template resolved", { templatePath });
    } catch (error) {
      console.error(`${MODULE_ID}: failed to load template`, { templatePath, error });
    }
  }
}

const INTEGRATION_MODES = {
  AUTO: "auto",
  OFF: "off",
  FLAGS: "flags",
  DAE: "dae"
};

const LOOT_SCARCITY_LEVELS = {
  ABUNDANT: "abundant",
  NORMAL: "normal",
  SCARCE: "scarce"
};

const PARTY_OPS_LOOT_RARITIES = ["common", "uncommon", "rare", "veryRare", "legendary"];
const DEFAULT_PARTY_OPS_CONFIG = Object.freeze({
  debugEnabled: false,
  lootScarcity: LOOT_SCARCITY_LEVELS.NORMAL,
  rarityWeights: {
    common: 50,
    uncommon: 30,
    rare: 12,
    veryRare: 6,
    legendary: 2
  },
  crGoldMultiplier: 1
});

const INVENTORY_HOOK_MODES = {
  OFF: "off",
  REFRESH: "refresh",
  SYNC: "sync"
};

let partyOpsConfigNormalizationInProgress = false;

const CONFIG_SCHEMA = Object.freeze({
  launcherPlacement: [LAUNCHER_PLACEMENTS.FLOATING, LAUNCHER_PLACEMENTS.SIDEBAR, LAUNCHER_PLACEMENTS.BOTH],
  integrationMode: [INTEGRATION_MODES.AUTO, INTEGRATION_MODES.OFF, INTEGRATION_MODES.FLAGS, INTEGRATION_MODES.DAE],
  inventoryHookMode: [INVENTORY_HOOK_MODES.OFF, INVENTORY_HOOK_MODES.REFRESH, INVENTORY_HOOK_MODES.SYNC]
});

const NON_PARTY_SYNC_SCOPES = {
  SCENE: "scene",
  WORLD_NON_PARTY: "world-non-party",
  WORLD_ALL: "world-all"
};

const INTEGRATION_EFFECT_ORIGIN = `module.${MODULE_ID}`;
const INTEGRATION_EFFECT_NAME = "Party Operations Sync";
const INJURY_EFFECT_ORIGIN = `module.${MODULE_ID}.injury`;
const INJURY_EFFECT_NAME_PREFIX = "Injury:";
const ENVIRONMENT_EFFECT_ORIGIN = `module.${MODULE_ID}.environment`;
const ENVIRONMENT_EFFECT_NAME_PREFIX = "Environment:";

const SCROLL_STATE_SELECTORS = [
  ".po-body",
  ".po-window",
  ".window-content",
  ".po-content",
  ".po-grid",
  ".po-cards",
  ".po-ranks",
  ".po-gm-panel"
];

const RESOURCE_TRACK_KEYS = ["food", "water", "torches"];
const STEWARD_POOL_KEYS = ["food", "water", "torches"];
const STEWARD_POOL_MODES = Object.freeze({
  NONE: "none",
  FINITE: "finite",
  INFINITE: "infinite"
});
const STEWARD_POOL_LABELS = Object.freeze({
  food: "Food Rations",
  water: "Water Rations",
  torches: "Torches"
});
const STEWARD_POOL_LEGACY_FIELD_BY_KEY = Object.freeze({
  food: "partyFoodRations",
  water: "partyWaterRations",
  torches: "torches"
});
const DEFAULT_MARCH_LIGHT_BRIGHT = 20;
const DEFAULT_MARCH_LIGHT_DIM = 40;
const SOP_KEYS = ["campSetup", "watchRotation", "dungeonBreach", "urbanEntry", "prisonerHandling", "retreatProtocol"];
const LOOT_WORLD_ITEMS_SOURCE_ID = "__world_items__";
const LOOT_MANIFEST_PACK_NAME = "party-operations-loot-manifest";
const LOOT_MANIFEST_PACK_LABEL = "Party Operations Built Items";
const LOOT_DEFAULT_ITEM_TYPES = ["weapon", "equipment", "consumable", "loot"];
const LOOT_ITEM_TYPE_LABELS = {
  weapon: "Weapons",
  equipment: "Equipment",
  consumable: "Consumables",
  loot: "Treasure/Loot",
  tool: "Tools",
  backpack: "Containers",
  armor: "Armor",
  ammunition: "Ammunition",
  trinket: "Trinkets",
  spell: "Spell Items",
  feat: "Feat-like Items",
  class: "Class Features",
  race: "Race Features"
};
const LOOT_MANIFEST_FOLDER_LABELS = Object.freeze({
  weapon: "Weapons",
  equipment: "Equipment",
  consumable: "Consumables",
  loot: "Treasure",
  tool: "Tools",
  backpack: "Containers",
  armor: "Armor",
  ammunition: "Ammunition",
  trinket: "Trinkets",
  spell: "Spells",
  feat: "Features",
  class: "Class Features",
  race: "Racial Features",
  other: "Other"
});
const LOOT_MANIFEST_FOLDER_TYPE_PRIORITY = Object.freeze([
  "weapon",
  "equipment",
  "consumable",
  "loot",
  "tool",
  "backpack",
  "armor",
  "ammunition",
  "trinket",
  "spell",
  "feat",
  "class",
  "race",
  "other"
]);
const LOOT_TABLE_TYPE_OPTIONS = [
  { value: "currency", label: "Currency" },
  { value: "gems", label: "Gems" },
  { value: "art", label: "Art Objects" },
  { value: "equipment", label: "Equipment" },
  { value: "consumables", label: "Consumables" },
  { value: "special", label: "Special Drops" }
];
const LOOT_RARITY_OPTIONS = [
  { value: "", label: "No Floor/Ceiling" },
  { value: "common", label: "Common" },
  { value: "uncommon", label: "Uncommon" },
  { value: "rare", label: "Rare" },
  { value: "very-rare", label: "Very Rare" },
  { value: "legendary", label: "Legendary" }
];
const LOOT_PREVIEW_MODE_OPTIONS = [
  { value: "horde", label: "Horde Loot" },
  { value: "defeated", label: "Defeated Enemy Loot" },
  { value: "encounter", label: "Encounter Assignment Loot" }
];
const LOOT_PREVIEW_PROFILE_OPTIONS = [
  { value: "poor", label: "Poorly Equipped" },
  { value: "standard", label: "Standard Equipment" },
  { value: "well", label: "Well Equipped" }
];
const LOOT_PREVIEW_CHALLENGE_OPTIONS = [
  { value: "low", label: "Low (CR 0-4)" },
  { value: "mid", label: "Mid (CR 5-10)" },
  { value: "high", label: "High (CR 11-16)" },
  { value: "epic", label: "Epic (CR 17+)" }
];
const LOOT_PREVIEW_SCALE_OPTIONS = [
  { value: "small", label: "Small" },
  { value: "medium", label: "Medium" },
  { value: "major", label: "Major" }
];
const LOOT_PREVIEW_DEFAULT_VALUE_BUDGET_SCALAR = 100;
const LOOT_PREVIEW_DEFAULT_VALUE_STRICTNESS = 180;
const LOOT_PREVIEW_MAX_ITEM_VALUE_GP_LIMIT = 100000;
const LOOT_PREVIEW_MAX_TOTAL_TARGET_VALUE_GP_LIMIT = 1000000;
const LOOT_PREVIEW_STRICTNESS_BANDS = Object.freeze([
  Object.freeze({ key: "very-strict", label: "Very Strict", min: 240, ratio: 0.05 }),
  Object.freeze({ key: "strict", label: "Strict", min: 180, ratio: 0.1 }),
  Object.freeze({ key: "normal", label: "Normal", min: 120, ratio: 0.2 }),
  Object.freeze({ key: "loose", label: "Loose", min: 0, ratio: 0.35 })
]);
const AUTO_INV_DEFAULT_ITEM_CHANCE_SCALAR = 100;
const AUTO_INV_DEFAULT_CONSUMABLE_CHANCE_SCALAR = 100;
const AUTO_INV_DEFAULT_CURRENCY_SCALAR = 100;
const AUTO_INV_DEFAULT_QUALITY_SHIFT = 0;
const UNLINKED_TOKEN_AUTO_LOOT_ITEM_TYPES = new Set([
  "weapon",
  "equipment",
  "consumable",
  "loot",
  "tool",
  "armor",
  "ammunition",
  "trinket",
  "backpack"
]);
const UNLINKED_TOKEN_AUTO_LOOT_TYPE_WEIGHTS = Object.freeze({
  default: { weapon: 1.1, equipment: 1.1, consumable: 1, loot: 1, tool: 0.9, armor: 1, ammunition: 0.9, trinket: 0.9, backpack: 0.7 },
  humanoid: { weapon: 1.9, equipment: 1.5, consumable: 1.1, loot: 0.85, tool: 1.15, armor: 1.55, ammunition: 1.35, trinket: 0.8, backpack: 0.95 },
  beast: { weapon: 0.12, equipment: 0.22, consumable: 1.5, loot: 1.2, tool: 0.08, armor: 0.06, ammunition: 0.08, trinket: 0.55, backpack: 0.08 },
  monstrosity: { weapon: 0.8, equipment: 0.7, consumable: 0.85, loot: 1.4, tool: 0.45, armor: 0.45, ammunition: 0.35, trinket: 1.1, backpack: 0.35 },
  undead: { weapon: 1.25, equipment: 0.95, consumable: 0.18, loot: 1.35, tool: 0.25, armor: 1.05, ammunition: 0.55, trinket: 1.25, backpack: 0.18 },
  fiend: { weapon: 1.45, equipment: 1.2, consumable: 0.55, loot: 1.8, tool: 0.55, armor: 1.25, ammunition: 0.85, trinket: 1.45, backpack: 0.3 },
  celestial: { weapon: 1.3, equipment: 1.1, consumable: 0.75, loot: 1.55, tool: 0.65, armor: 1.15, ammunition: 0.75, trinket: 1.35, backpack: 0.35 },
  construct: { weapon: 1.35, equipment: 1.2, consumable: 0.12, loot: 1.05, tool: 0.95, armor: 1.5, ammunition: 0.65, trinket: 1.1, backpack: 0.2 },
  dragon: { weapon: 0.55, equipment: 0.6, consumable: 0.45, loot: 2.1, tool: 0.35, armor: 0.4, ammunition: 0.25, trinket: 1.8, backpack: 0.2 },
  aberration: { weapon: 0.72, equipment: 0.65, consumable: 0.52, loot: 1.55, tool: 0.4, armor: 0.38, ammunition: 0.28, trinket: 1.5, backpack: 0.2 },
  elemental: { weapon: 0.65, equipment: 0.52, consumable: 0.2, loot: 1.3, tool: 0.2, armor: 0.32, ammunition: 0.18, trinket: 1.1, backpack: 0.1 },
  fey: { weapon: 1.15, equipment: 1.15, consumable: 1.2, loot: 1.25, tool: 0.9, armor: 0.9, ammunition: 0.95, trinket: 1.5, backpack: 0.4 },
  giant: { weapon: 1.5, equipment: 1.25, consumable: 0.8, loot: 1.05, tool: 0.7, armor: 1.2, ammunition: 0.7, trinket: 0.75, backpack: 0.45 },
  ooze: { weapon: 0.06, equipment: 0.1, consumable: 0.1, loot: 1.1, tool: 0.05, armor: 0.05, ammunition: 0.05, trinket: 0.8, backpack: 0.05 },
  plant: { weapon: 0.32, equipment: 0.32, consumable: 1.15, loot: 1.2, tool: 0.15, armor: 0.12, ammunition: 0.1, trinket: 0.92, backpack: 0.08 },
  swarm: { weapon: 0.08, equipment: 0.12, consumable: 1.05, loot: 1.1, tool: 0.05, armor: 0.05, ammunition: 0.05, trinket: 0.7, backpack: 0.05 }
});
const UNLINKED_TOKEN_AUTO_INV_CURATED = Object.freeze({
  weapon: Object.freeze({
    "cr-0-1": Object.freeze([
      { name: "Club", weight: 12 },
      { name: "Dagger", weight: 22 },
      { name: "Spear", weight: 14 },
      { name: "Mace", weight: 10 },
      { name: "Shortsword", weight: 6 },
      { name: "Quarterstaff", weight: 8 }
    ]),
    "cr-2-4": Object.freeze([
      { name: "Dagger", weight: 14 },
      { name: "Spear", weight: 10 },
      { name: "Shortsword", weight: 14 },
      { name: "Longsword", weight: 10 },
      { name: "Handaxe", weight: 9 },
      { name: "Scimitar", weight: 8 },
      { name: "Light Crossbow", weight: 8 }
    ]),
    "cr-5-8": Object.freeze([
      { name: "Longsword", weight: 14 },
      { name: "Battleaxe", weight: 10 },
      { name: "Warhammer", weight: 9 },
      { name: "Scimitar", weight: 8 },
      { name: "Rapier", weight: 8 },
      { name: "Longbow", weight: 7 },
      { name: "Heavy Crossbow", weight: 6 }
    ]),
    "cr-9-12": Object.freeze([
      { name: "Longsword", weight: 10 },
      { name: "Greatsword", weight: 8 },
      { name: "Glaive", weight: 7 },
      { name: "Rapier", weight: 7 },
      { name: "Longbow", weight: 7 },
      { name: "Heavy Crossbow", weight: 6 }
    ]),
    "cr-13+": Object.freeze([
      { name: "Longsword", weight: 9 },
      { name: "Greatsword", weight: 8 },
      { name: "Halberd", weight: 7 },
      { name: "Glaive", weight: 7 },
      { name: "Longbow", weight: 6 }
    ])
  }),
  armor: Object.freeze({
    "cr-0-1": Object.freeze([
      { name: "Leather Armor", weight: 16 },
      { name: "Padded Armor", weight: 9 }
    ]),
    "cr-2-4": Object.freeze([
      { name: "Leather Armor", weight: 8 },
      { name: "Chain Shirt", weight: 13 },
      { name: "Scale Mail", weight: 7 }
    ]),
    "cr-5-8": Object.freeze([
      { name: "Chain Shirt", weight: 6 },
      { name: "Scale Mail", weight: 8 },
      { name: "Chain Mail", weight: 10 },
      { name: "Breastplate", weight: 6 }
    ]),
    "cr-9-12": Object.freeze([
      { name: "Chain Mail", weight: 10 },
      { name: "Breastplate", weight: 8 },
      { name: "Half Plate Armor", weight: 7 },
      { name: "Splint Armor", weight: 5 }
    ]),
    "cr-13+": Object.freeze([
      { name: "Chain Mail", weight: 6 },
      { name: "Half Plate Armor", weight: 8 },
      { name: "Splint Armor", weight: 6 },
      { name: "Plate Armor", weight: 2 }
    ])
  }),
  gear: Object.freeze([
    { name: "Rations", weight: 18 },
    { name: "Waterskin", weight: 16 },
    { name: "Torch", weight: 18 },
    { name: "Rope, Hempen (50 feet)", weight: 9 },
    { name: "Lantern, Hooded", weight: 6 },
    { name: "Bedroll", weight: 6 }
  ]),
  utilityConsumables: Object.freeze([
    { name: "Antitoxin", weight: 7 },
    { name: "Alchemist's Fire", weight: 5 },
    { name: "Acid (vial)", weight: 4 }
  ]),
  healingByBand: Object.freeze({
    "cr-0-1": Object.freeze([{ name: "Potion of Healing", weight: 100 }]),
    "cr-2-4": Object.freeze([{ name: "Potion of Healing", weight: 100 }]),
    "cr-5-8": Object.freeze([{ name: "Potion of Healing", weight: 86 }, { name: "Potion of Greater Healing", weight: 14 }]),
    "cr-9-12": Object.freeze([{ name: "Potion of Greater Healing", weight: 78 }, { name: "Potion of Superior Healing", weight: 22 }]),
    "cr-13+": Object.freeze([{ name: "Potion of Greater Healing", weight: 48 }, { name: "Potion of Superior Healing", weight: 42 }, { name: "Potion of Supreme Healing", weight: 10 }])
  })
});
const UNLINKED_TOKEN_AUTO_INV_HEALING_CHANCE_BY_BAND = Object.freeze({
  "cr-0-1": 0.05,
  "cr-2-4": 0.1,
  "cr-5-8": 0.2,
  "cr-9-12": 0.3,
  "cr-13+": 0.4
});
const UNLINKED_TOKEN_AUTO_INV_BAND_ORDER = Object.freeze(["cr-0-1", "cr-2-4", "cr-5-8", "cr-9-12", "cr-13+"]);
const JOURNAL_VISIBILITY_MODES = {
  PUBLIC: "public",
  REDACTED: "redacted",
  GM_PRIVATE: "gm-private"
};
const SESSION_SUMMARY_RANGE_OPTIONS = {
  "last-24h": "Last 24 Hours",
  today: "Today",
  "last-7d": "Last 7 Days"
};
const JOURNAL_SORT_OPTIONS = [
  { value: "newest", label: "Newest" },
  { value: "oldest", label: "Oldest" },
  { value: "title", label: "Title" },
  { value: "folder", label: "Folder" }
];
const OPERATIONS_JOURNAL_ROOT_NAME = "Party Operations Logs";
const OPERATIONS_JOURNAL_ROOT_NAME_LEGACY = ["GM Folder"];
const OPERATIONS_JOURNAL_CATEGORIES = {
  downtime: "Downtime",
  reputation: "Reputation",
  environment: "Environment",
  "loot-claims": "Loot Claims",
  session: "Session"
};
const journalFolderEnsurePromises = new Map();

function getCurrentModuleVersion() {
  const module = game.modules?.get(MODULE_ID);
  return String(module?.version ?? module?.data?.version ?? "dev");
}
const DOWNTIME_ACTION_OPTIONS = [
  {
    key: "carousing",
    label: "Carousing",
    guidance: "Social networking, rumors, and contacts."
  },
  {
    key: "crafting",
    label: "Crafting",
    guidance: "Create mundane items and accrue work progress."
  },
  {
    key: "profession",
    label: "Practicing A Profession",
    guidance: "Earn coin through work during downtime."
  },
  {
    key: "recuperating",
    label: "Recuperating",
    guidance: "Recover condition and reduce stress/wounds."
  },
  {
    key: "research",
    label: "Research",
    guidance: "Discover clues, lore, or leads."
  },
  {
    key: "training",
    label: "Training",
    guidance: "Build progress toward a language/tool proficiency."
  }
];
const DOWNTIME_TUNING_ECONOMY_OPTIONS = [
  { value: "stingy", label: "Stingy Economy" },
  { value: "standard", label: "Standard Economy" },
  { value: "generous", label: "Generous Economy" }
];
const DOWNTIME_TUNING_RISK_OPTIONS = [
  { value: "safe", label: "Low Complication Risk" },
  { value: "standard", label: "Standard Risk" },
  { value: "hazardous", label: "High Complication Risk" }
];
const DOWNTIME_TUNING_DISCOVERY_OPTIONS = [
  { value: "low", label: "Sparse Discovery" },
  { value: "standard", label: "Standard Discovery" },
  { value: "high", label: "Rich Discovery" }
];
const DOWNTIME_SOCIAL_CONTRACT_OPTIONS = [
  {
    key: "",
    label: "None",
    summary: "No persistent social contract is attached to this result.",
    limitations: ""
  },
  {
    key: "potion-broker",
    label: "Potion Broker",
    summary: "City alchemy contact willing to buy and sell common potions.",
    limitations: "Only while in that city; common potions only; up to 2 transactions between downtime collections."
  },
  {
    key: "black-market-fence",
    label: "Black-Market Fence",
    summary: "Underworld buyer for discreet goods and contraband.",
    limitations: "No obvious military relics; fees and legal risk increase each use in the same district."
  },
  {
    key: "guild-supplier",
    label: "Guild Supplier",
    summary: "Trade guild quartermaster gives controlled access to materials.",
    limitations: "Requires a known guild hall; mundane supplies only; cannot bypass scarcity bans."
  },
  {
    key: "info-broker",
    label: "Information Broker",
    summary: "Reliable intermediary who can turn coin into targeted leads.",
    limitations: "One actionable lead purchase per downtime cycle; may trigger attention in high-heat regions."
  },
  {
    key: "noble-patron",
    label: "Noble Patron Channel",
    summary: "Court connection grants occasional introductions and permits.",
    limitations: "Political favors can be called in return; benefits are local to patron influence."
  }
];
const DOWNTIME_ENTRY_SORT_OPTIONS = [
  { value: "pending", label: "Pending First" },
  { value: "completed", label: "Completed First" },
  { value: "actor-asc", label: "Actor A-Z" },
  { value: "actor-desc", label: "Actor Z-A" },
  { value: "updated-desc", label: "Updated Newest" },
  { value: "updated-asc", label: "Updated Oldest" }
];
const DOWNTIME_LOG_SORT_OPTIONS = [
  { value: "resolved-desc", label: "Resolved Newest" },
  { value: "resolved-asc", label: "Resolved Oldest" },
  { value: "actor-asc", label: "Actor A-Z" },
  { value: "actor-desc", label: "Actor Z-A" },
  { value: "action-asc", label: "Action A-Z" }
];
const LOOT_CLAIMS_ARCHIVE_SORT_OPTIONS = [
  { value: "archived-desc", label: "Archived Newest" },
  { value: "archived-asc", label: "Archived Oldest" },
  { value: "published-desc", label: "Published Newest" },
  { value: "published-asc", label: "Published Oldest" },
  { value: "items-desc", label: "Most Items" },
  { value: "items-asc", label: "Fewest Items" }
];
const GATHER_HISTORY_SORT_OPTIONS = [
  { value: "newest", label: "Newest First" },
  { value: "oldest", label: "Oldest First" },
  { value: "actor-asc", label: "Actor A-Z" },
  { value: "actor-desc", label: "Actor Z-A" },
  { value: "rations-desc", label: "Rations High-Low" },
  { value: "rations-asc", label: "Rations Low-High" }
];
const GATHER_HISTORY_RESULT_FILTER_OPTIONS = [
  { value: "all", label: "All Results" },
  { value: "success", label: "Success" },
  { value: "fail", label: "Fail" }
];
const GATHER_HISTORY_RESOURCE_FILTER_OPTIONS = [
  { value: "all", label: "All Types" },
  { value: "food", label: "Food" },
  { value: "water", label: "Water" }
];
const DOWNTIME_RESOLVE_DEFAULT_HINT = "Set payouts and notes, then resolve.";
const DOWNTIME_SELECT_PENDING_WARNING = "Select a pending downtime entry.";
const DOWNTIME_STALE_PENDING_WARNING = "Selected downtime entry is no longer pending.";
const DOWNTIME_GM_ONLY_PRERESOLVE_WARNING = "Only the GM can pre-resolve downtime.";
const DOWNTIME_GM_ONLY_RESOLVE_WARNING = "Only the GM can resolve downtime.";
const DOWNTIME_ITEM_REWARD_DROP_LIMIT = 10;
const MERCHANT_SOURCE_TYPES = DOMAIN_MERCHANT_SOURCE_TYPES;
const MERCHANT_SCARCITY_LEVELS = DOMAIN_MERCHANT_SCARCITY_LEVELS;
const MERCHANT_SCARCITY_PROFILES = DOMAIN_MERCHANT_SCARCITY_PROFILES;
const MERCHANT_ALLOWED_ITEM_TYPES = DOMAIN_MERCHANT_ALLOWED_ITEM_TYPES;
const MERCHANT_ALLOWED_ITEM_TYPE_LIST = DOMAIN_MERCHANT_ALLOWED_ITEM_TYPE_LIST;
const MERCHANT_EDITOR_CANDIDATE_LIMIT = DOMAIN_MERCHANT_EDITOR_CANDIDATE_LIMIT;
const MERCHANT_PREVIEW_ITEM_LIMIT = DOMAIN_MERCHANT_PREVIEW_ITEM_LIMIT;
const MERCHANT_ACCESS_LOG_LIMIT = DOMAIN_MERCHANT_ACCESS_LOG_LIMIT;
const MERCHANT_ACCESS_LOG_THROTTLE_MS = DOMAIN_MERCHANT_ACCESS_LOG_THROTTLE_MS;
const MERCHANT_DEFAULTS = DOMAIN_MERCHANT_DEFAULTS;
const MERCHANT_STARTER_BLUEPRINTS = DOMAIN_MERCHANT_STARTER_BLUEPRINTS;
const MERCHANT_ACCESS_MODES = Object.freeze({
  ALL: "all",
  ASSIGNED: "assigned"
});
const MERCHANT_BARTER_ABILITY_LABELS = Object.freeze({
  str: "Strength",
  dex: "Dexterity",
  con: "Constitution",
  int: "Intelligence",
  wis: "Wisdom",
  cha: "Charisma"
});
const NON_GM_READONLY_ACTIONS = new Set([
  "set-role",
  "clear-role",
  "toggle-sop",
  "set-resource",
  "gather-resource-check",
  "run-gather-preset",
  "clear-gather-history",
  "remove-gather-history-entry",
  "set-comm-toggle",
  "set-comm-text",
  "set-recon-field",
  "run-recon-check",
  "set-reputation-score",
  "adjust-reputation-score",
  "set-reputation-note",
  "log-reputation-note",
  "load-reputation-note-log",
  "post-reputation-note-log",
  "set-reputation-label",
  "add-reputation-faction",
  "remove-reputation-faction",
  "set-base-ops-config",
  "upsert-base-site",
  "clear-base-site",
  "open-base-site-storage",
  "set-injury-config",
  "upsert-injury",
  "roll-injury-table",
  "set-injury-result",
  "stabilize-injury",
  "clear-injury",
  "apply-recovery-cycle",
  "set-downtime-hours",
  "set-downtime-tuning",
  "set-downtime-resolve-target",
  "prefill-downtime-resolution",
  "pre-resolve-selected-downtime-entry",
  "resolve-selected-downtime-entry",
  "edit-downtime-result",
  "unarchive-downtime-log",
  "clear-downtime-log",
  "clear-downtime-results",
  "merchant-settlement",
  "merchant-save-city-catalog",
  "merchant-assign-city",
  "merchant-new",
  "merchant-create-starters",
  "merchant-randomize-name",
  "merchant-randomize-race",
  "merchant-edit",
  "merchant-save",
  "merchant-delete",
  "merchant-refresh-stock",
  "merchant-refresh-all-stock",
  "merchant-assign-by-contract-key",
  "merchant-assign-toggle",
  "merchant-assign-all",
  "merchant-assign-none",
  "merchant-set-access-mode",
  "merchant-editor-draft-change",
  "toggle-merchant-pack-source",
  "toggle-merchant-allowed-type",
  "merchant-add-curated-item",
  "merchant-remove-curated-item",
  "merchant-clear-curated-items",
  "merchant-open-actor",
  "toggle-loot-pack-source",
  "set-loot-pack-weight",
  "toggle-loot-table-source",
  "set-loot-table-type",
  "toggle-loot-item-type",
  "set-loot-rarity-floor",
  "set-loot-rarity-ceiling",
  "reset-loot-source-config",
  "set-loot-preview-field",
  "roll-loot-preview",
  "add-loot-preview-item",
  "remove-loot-preview-item",
  "adjust-loot-preview-currency",
  "clear-loot-preview",
  "publish-loot-claims",
  "clear-loot-claims",
  "set-environment-preset",
  "set-environment-dc",
  "set-environment-note",
  "set-environment-successive",
  "set-environment-sync-non-party",
  "reset-environment-successive-defaults",
  "toggle-environment-actor",
  "add-environment-log",
  "edit-environment-log",
  "remove-environment-log",
  "clear-environment-effects",
  "gm-quick-add-faction",
  "gm-quick-add-modifier",
  "gm-quick-open-downtime",
  "gm-quick-save-modifier",
  "gm-quick-set-staged-field",
  "gm-quick-delete-staged-modifier",
  "gm-quick-delete-saved-modifier",
  "gm-quick-submit-faction",
  "gm-quick-submit-modifier",
  "gm-quick-sync-integrations",
  "gm-quick-log-weather",
  "gm-quick-session-autopilot",
  "gm-quick-undo-autopilot",
  "gm-quick-submit-weather",
  "gm-quick-weather-select",
  "gm-quick-weather-set",
  "gm-quick-weather-dae-key-preset",
  "gm-quick-weather-add-dae",
  "gm-quick-weather-remove-dae",
  "gm-quick-weather-save-preset",
  "gm-quick-weather-delete-preset"
]);
const UPKEEP_DUSK_MINUTES = 20 * 60;
const ENVIRONMENT_MOVE_PROMPT_COOLDOWN_MS = 6000;
const environmentMovePromptByActor = new Map();
const environmentMoveOriginByToken = new Map();
const SOCKET_NOTE_MAX_LENGTH = 4000;
const SOCKET_ACTIVITY_TYPES = new Set(["rested", "light", "heavy", "strenuous"]);
const SOCKET_REST_OPS = new Set(["assignMe", "clearEntry", "setEntryNotes"]);
const SOCKET_MARCH_OPS = new Set(["joinRank", "setNote"]);
const SOCKET_MARCH_RANKS = new Set(["front", "middle", "rear"]);

const ENVIRONMENT_PRESETS = [
  {
    key: "none",
    label: "None",
    description: "No active environmental penalty.",
    icon: "icons/svg/sun.svg",
    movementCheck: false,
    checkType: "skill",
    checkKey: "",
    checkLabel: "",
    effectChanges: []
  },
  {
    key: "slippery-surface",
    label: "Slippery Surface",
    description: "Ice, wet stone, blood-slick floors, or algae force balance control.",
    icon: "icons/svg/falling.svg",
    movementCheck: true,
    checkType: "skill",
    checkKey: "acr",
    checkLabel: "Acrobatics",
    defaultDc: 13,
    failStatusId: "prone",
    failBy5SlideFeet: 5,
    effectChanges: [{ key: "system.attributes.movement.walk", value: "-10" }]
  },
  {
    key: "unstable-footing",
    label: "Unstable Footing",
    description: "Loose gravel, rubble, corpses, and shifting sand punish hard movement.",
    icon: "icons/svg/hazard.svg",
    movementCheck: true,
    checkType: "save",
    checkKey: "dex",
    checkLabel: "Dexterity Save",
    defaultDc: 13,
    failSpeedZeroTurns: 1,
    failBy5StatusId: "prone",
    effectChanges: [{ key: "system.attributes.init.bonus", value: "-1" }]
  },
  {
    key: "extreme-cold",
    label: "Extreme Cold",
    description: "Freezing exposure tests endurance and shelter discipline.",
    icon: "icons/svg/snowflake.svg",
    movementCheck: true,
    checkType: "save",
    checkKey: "con",
    checkLabel: "Constitution Save",
    defaultDc: 15,
    failExhaustion: 1,
    effectChanges: [{ key: "system.bonuses.abilities.save", value: "-1" }]
  },
  {
    key: "extreme-heat",
    label: "Extreme Heat",
    description: "Heat stress drains stamina and worsens resource pressure.",
    icon: "icons/svg/fire.svg",
    movementCheck: true,
    checkType: "save",
    checkKey: "con",
    checkLabel: "Constitution Save",
    defaultDc: 14,
    failExhaustion: 1,
    failBy5DamageFormula: "1d6",
    failBy5DamageType: "fire",
    effectChanges: [{ key: "system.bonuses.abilities.save", value: "-1" }]
  },
  {
    key: "heavy-obscurement",
    label: "Heavy Obscurement",
    description: "Thick fog, smoke, or magical darkness blinds line-of-sight engagement.",
    icon: "icons/svg/blind.svg",
    movementCheck: false,
    checkType: "skill",
    checkKey: "prc",
    checkLabel: "Perception",
    alwaysStatusId: "blinded",
    effectChanges: [{ key: "system.skills.prc.bonuses.check", value: "-5" }]
  },
  {
    key: "necrotic-saturation",
    label: "Necrotic Saturation",
    description: "Blighted ritual zones erode flesh and vitality.",
    icon: "icons/svg/skull.svg",
    movementCheck: true,
    checkType: "save",
    checkKey: "con",
    checkLabel: "Constitution Save",
    defaultDc: 14,
    failDamageFormula: "1d6",
    failDamageType: "necrotic",
    failBy5MaxHpReductionFormula: "1d6",
    effectChanges: [{ key: "system.bonuses.abilities.save", value: "-1" }]
  },
  {
    key: "high-wind",
    label: "High Wind",
    description: "Gale force winds disrupt ranged pressure and force balance saves.",
    icon: "icons/svg/windmill.svg",
    movementCheck: true,
    checkType: "save",
    checkKey: "str",
    checkLabel: "Strength Save",
    defaultDc: 13,
    failSlideFeet: 5,
    effectChanges: [
      { key: "system.skills.prc.bonuses.check", value: "-1" },
      { key: "system.bonuses.rwak.attack", value: "-2" }
    ]
  },
  {
    key: "shifting-ground",
    label: "Shifting Ground",
    description: "Quicksand or moving stone catches and restrains movement.",
    icon: "icons/svg/swirl.svg",
    movementCheck: true,
    checkType: "skill",
    checkKey: "ath",
    checkLabel: "Athletics",
    defaultDc: 14,
    failStatusId: "restrained",
    effectChanges: [{ key: "system.attributes.movement.walk", value: "-10" }]
  },
  {
    key: "psychic-pressure-field",
    label: "Psychic Pressure Field",
    description: "Fractured timeline pressure and sigil echoes fracture resolve.",
    icon: "icons/svg/terror.svg",
    movementCheck: true,
    checkType: "save",
    checkKey: "wis",
    checkLabel: "Wisdom Save",
    defaultDc: 15,
    failStatusId: "frightened",
    failBy5StatusId: "incapacitated",
    effectChanges: [{ key: "system.bonuses.abilities.save", value: "-1" }]
  },
  {
    key: "corrosive-atmosphere",
    label: "Corrosive Atmosphere",
    description: "Acid mist and caustic vapors burn flesh and degrade gear.",
    icon: "icons/svg/acid.svg",
    movementCheck: true,
    checkType: "save",
    checkKey: "con",
    checkLabel: "Constitution Save",
    defaultDc: 13,
    failDamageFormula: "1d4",
    failDamageType: "acid",
    effectChanges: [{ key: "system.bonuses.abilities.save", value: "-1" }]
  }
];

function isFormActionElement(element) {
  if (!element?.tagName) return false;
  const tag = String(element.tagName).toUpperCase();
  return tag === "INPUT" || tag === "SELECT" || tag === "TEXTAREA";
}

function getAppRootElement(appOrElement) {
  if (!appOrElement) return null;
  const candidate = appOrElement?.element ?? appOrElement;
  if (candidate?.querySelector) return candidate;
  if (candidate?.[0]?.querySelector) return candidate[0];
  return null;
}

function isEditableTypingElement(element) {
  if (!(element instanceof HTMLElement)) return false;
  if (element instanceof HTMLTextAreaElement) {
    return !element.disabled && !element.readOnly;
  }
  if (element instanceof HTMLInputElement) {
    if (element.disabled || element.readOnly) return false;
    const type = String(element.type ?? "text").trim().toLowerCase();
    const typingTypes = new Set(["text", "search", "email", "url", "tel", "password", "number"]);
    return typingTypes.has(type);
  }
  if (element instanceof HTMLSelectElement) return false;
  return element.isContentEditable;
}

function appHasFocusedTypingInput(appOrElement) {
  const root = getAppRootElement(appOrElement);
  const active = document?.activeElement;
  if (!root || !(active instanceof HTMLElement)) return false;
  if (!root.contains(active)) return false;
  return isEditableTypingElement(active);
}

function refreshTabAccessibility(root) {
  if (!root?.querySelectorAll) return;
  const tablists = Array.from(root.querySelectorAll("[role='tablist']"));
  for (const tablist of tablists) {
    const tabs = Array.from(tablist.querySelectorAll(".po-tab"));
    if (tabs.length === 0) continue;

    const activeTab = tabs.find((tab) => tab.classList.contains("is-active")) ?? tabs[0];
    for (const tab of tabs) {
      const isActive = tab === activeTab;
      tab.setAttribute("role", "tab");
      tab.setAttribute("aria-selected", isActive ? "true" : "false");
      tab.setAttribute("tabindex", isActive ? "0" : "-1");
    }

    if (tablist.dataset.poTabA11yBound === "1") continue;
    tablist.dataset.poTabA11yBound = "1";
    tablist.addEventListener("keydown", (event) => {
      const key = String(event.key ?? "");
      if (!["ArrowRight", "ArrowLeft", "Home", "End"].includes(key)) return;
      const currentTabs = Array.from(tablist.querySelectorAll(".po-tab"));
      if (currentTabs.length === 0) return;
      const current = event.target?.closest?.(".po-tab");
      const currentIndex = Math.max(0, currentTabs.indexOf(current));
      let targetIndex = currentIndex;
      if (key === "ArrowRight") targetIndex = (currentIndex + 1) % currentTabs.length;
      if (key === "ArrowLeft") targetIndex = (currentIndex - 1 + currentTabs.length) % currentTabs.length;
      if (key === "Home") targetIndex = 0;
      if (key === "End") targetIndex = currentTabs.length - 1;
      const target = currentTabs[targetIndex];
      if (!target) return;
      event.preventDefault();
      target.focus();
      target.click();
    });
  }
}

function syncNotesDisclosureState(root) {
  if (!root?.querySelectorAll) return;
  root.querySelectorAll(".po-watch-entry").forEach((entry, index) => {
    const notes = entry.querySelector(".po-notes");
    const toggleButton = entry.querySelector("[data-action='toggle-notes']");
    if (!notes || !toggleButton) return;
    if (!notes.id) notes.id = `po-notes-auto-${index}-${foundry.utils.randomID()}`;
    const noteValue = String(notes.querySelector("textarea")?.value ?? "").trim();
    if (noteValue) notes.classList.add("is-active");
    const expanded = notes.classList.contains("is-active");
    toggleButton.setAttribute("aria-controls", notes.id);
    toggleButton.setAttribute("aria-expanded", expanded ? "true" : "false");
    notes.setAttribute("aria-hidden", expanded ? "false" : "true");
  });
}

function sanitizeSocketIdentifier(value, options = {}) {
  const maxLength = Number.isFinite(Number(options.maxLength)) ? Math.max(1, Math.floor(Number(options.maxLength))) : 128;
  const normalized = String(value ?? "").trim();
  if (!normalized || normalized.length > maxLength) return "";
  if (!/^[A-Za-z0-9._:-]+$/.test(normalized)) return "";
  return normalized;
}

function clampSocketText(value, maxLength = SOCKET_NOTE_MAX_LENGTH) {
  const cap = Number.isFinite(Number(maxLength)) ? Math.max(0, Math.floor(Number(maxLength))) : SOCKET_NOTE_MAX_LENGTH;
  return String(value ?? "").slice(0, cap);
}

function normalizeRestNoteSaveSource(value) {
  const normalized = String(value ?? "").trim().toLowerCase();
  return normalized === "manual" ? "manual" : "autosave";
}

function resolveRequester(userOrId, options = {}) {
  const allowGM = options.allowGM !== false;
  const requireActive = options.requireActive === true;
  const requester = typeof userOrId === "string" ? game.users.get(userOrId) : userOrId;
  if (!requester) return null;
  if (!allowGM && requester.isGM) return null;
  if (requireActive && !requester.active) return null;
  return requester;
}

function getSocketRequester(message, options = {}) {
  const userId = sanitizeSocketIdentifier(message?.userId, { maxLength: 64 });
  if (!userId) return null;
  return resolveRequester(userId, options);
}

function normalizeSocketActivityType(value) {
  const normalized = String(value ?? "").trim().toLowerCase();
  return SOCKET_ACTIVITY_TYPES.has(normalized) ? normalized : "";
}

function normalizeSocketRestRequest(request) {
  if (!request || typeof request !== "object") return null;
  const op = String(request.op ?? "").trim();
  if (!SOCKET_REST_OPS.has(op)) return null;
  const slotId = sanitizeSocketIdentifier(request.slotId, { maxLength: 64 });
  const actorId = sanitizeSocketIdentifier(request.actorId, { maxLength: 64 });
  if (!slotId || !actorId) return null;

  if (op === "setEntryNotes") {
    return {
      op,
      slotId,
      actorId,
      text: clampSocketText(request.text, SOCKET_NOTE_MAX_LENGTH),
      source: normalizeRestNoteSaveSource(request.source)
    };
  }
  return { op, slotId, actorId };
}

function normalizeSocketMarchRequest(request) {
  if (!request || typeof request !== "object") return null;
  const op = String(request.op ?? "").trim();
  if (!SOCKET_MARCH_OPS.has(op)) return null;
  const actorId = sanitizeSocketIdentifier(request.actorId, { maxLength: 64 });
  if (!actorId) return null;

  if (op === "joinRank") {
    const rankId = String(request.rankId ?? "").trim();
    if (!SOCKET_MARCH_RANKS.has(rankId)) return null;
    return { op, actorId, rankId };
  }

  return {
    op,
    actorId,
    text: clampSocketText(request.text, SOCKET_NOTE_MAX_LENGTH)
  };
}

function isWritableModuleSettingKey(settingKeyInput) {
  const settingKey = String(settingKeyInput ?? "").trim();
  if (!settingKey) return false;
  return Object.values(SETTINGS).includes(settingKey);
}


function canAccessAllPlayerOps(user = game.user) {
  if (!user) return false;
  if (Boolean(user?.isGM)) return true;
  try {
    return Boolean(game.settings?.get?.(MODULE_ID, SETTINGS.SHARED_GM_PERMISSIONS));
  } catch {
    return false;
  }
}

function hasActiveGmClient() {
  const users = game.users?.contents ?? game.users ?? [];
  return users.some((user) => Boolean(user?.active) && Boolean(user?.isGM));
}

function normalizeStewardPoolMode(value) {
  const normalized = String(value ?? "").trim().toLowerCase();
  if (normalized === STEWARD_POOL_MODES.FINITE) return STEWARD_POOL_MODES.FINITE;
  if (normalized === STEWARD_POOL_MODES.INFINITE) return STEWARD_POOL_MODES.INFINITE;
  return STEWARD_POOL_MODES.NONE;
}

function getStewardPoolLegacyField(poolKey) {
  return String(STEWARD_POOL_LEGACY_FIELD_BY_KEY[poolKey] ?? "").trim();
}

function normalizeStewardPoolEntry(entryInput, poolKey, resources) {
  const legacyField = getStewardPoolLegacyField(poolKey);
  const legacyRaw = Number(resources?.[legacyField] ?? 0);
  const legacyAmount = Number.isFinite(legacyRaw) ? Math.max(0, Math.floor(legacyRaw)) : 0;
  const entry = (entryInput && typeof entryInput === "object" && !Array.isArray(entryInput))
    ? entryInput
    : {};
  const hasExplicitMode = Object.prototype.hasOwnProperty.call(entry, "mode");
  let mode = normalizeStewardPoolMode(entry.mode);
  const amountRaw = Number(entry.amount);
  const amount = Number.isFinite(amountRaw) ? Math.max(0, Math.floor(amountRaw)) : legacyAmount;
  if (!hasExplicitMode) mode = amount > 0 ? STEWARD_POOL_MODES.FINITE : STEWARD_POOL_MODES.NONE;
  const source = String(entry.source ?? "").trim().slice(0, 180);
  return { mode, amount, source };
}

function ensureStewardPoolsState(resources) {
  if (!resources || typeof resources !== "object") return {};
  if (!resources.stewardPools || typeof resources.stewardPools !== "object" || Array.isArray(resources.stewardPools)) {
    resources.stewardPools = {};
  }
  for (const poolKey of STEWARD_POOL_KEYS) {
    const normalized = normalizeStewardPoolEntry(resources.stewardPools[poolKey], poolKey, resources);
    resources.stewardPools[poolKey] = normalized;
    const legacyField = getStewardPoolLegacyField(poolKey);
    if (legacyField) {
      resources[legacyField] = normalized.mode === STEWARD_POOL_MODES.FINITE ? normalized.amount : 0;
    }
  }
  return resources.stewardPools;
}

function getStewardPoolEntry(resources, poolKey) {
  const pools = ensureStewardPoolsState(resources);
  const pool = pools?.[poolKey];
  if (pool && typeof pool === "object") return pool;
  return { mode: STEWARD_POOL_MODES.NONE, amount: 0, source: "" };
}

function buildStewardPoolContext(resourcesState, poolKey) {
  const pool = getStewardPoolEntry(resourcesState, poolKey);
  const mode = normalizeStewardPoolMode(pool.mode);
  const amount = Math.max(0, Math.floor(Number(pool.amount ?? 0) || 0));
  const source = String(pool.source ?? "").trim();
  const modeOptions = [
    { value: STEWARD_POOL_MODES.NONE, label: "None", selected: mode === STEWARD_POOL_MODES.NONE },
    { value: STEWARD_POOL_MODES.INFINITE, label: "Surplus Source", selected: mode === STEWARD_POOL_MODES.INFINITE },
    { value: STEWARD_POOL_MODES.FINITE, label: "Finite Stock", selected: mode === STEWARD_POOL_MODES.FINITE }
  ];
  const modeLabel = mode === STEWARD_POOL_MODES.INFINITE
    ? "Surplus Source"
    : (mode === STEWARD_POOL_MODES.FINITE ? "Finite Stock" : "None");
  const amountDisplay = mode === STEWARD_POOL_MODES.FINITE
    ? String(amount)
    : (mode === STEWARD_POOL_MODES.INFINITE ? "Surplus" : "None");
  return {
    key: poolKey,
    label: STEWARD_POOL_LABELS[poolKey] ?? poolKey,
    mode,
    modeOptions,
    modeLabel,
    source,
    hasSource: source.length > 0,
    amount,
    amountDisplay,
    isNone: mode === STEWARD_POOL_MODES.NONE,
    isFinite: mode === STEWARD_POOL_MODES.FINITE,
    isInfinite: mode === STEWARD_POOL_MODES.INFINITE,
    summaryLabel: source.length > 0 ? `${amountDisplay} - ${source}` : amountDisplay
  };
}

function getStewardPoolFiniteAmount(pool) {
  if (!pool || typeof pool !== "object") return 0;
  if (normalizeStewardPoolMode(pool.mode) !== STEWARD_POOL_MODES.FINITE) return 0;
  return Math.max(0, Math.floor(Number(pool.amount ?? 0) || 0));
}

function isStewardPoolInfinite(pool) {
  if (!pool || typeof pool !== "object") return false;
  return normalizeStewardPoolMode(pool.mode) === STEWARD_POOL_MODES.INFINITE;
}

function ensureOperationalResourceConfig(resources) {
  if (!resources) return;
  const legacyFoodPool = Number(resources.partyRations);
  const configuredFoodPool = Number(resources.partyFoodRations);
  const configuredWaterPool = Number(resources.partyWaterRations);
  const configuredTorchPool = Number(resources.torches);
  resources.partyFoodRations = Number.isFinite(configuredFoodPool)
    ? Math.max(0, Math.floor(configuredFoodPool))
    : (Number.isFinite(legacyFoodPool) ? Math.max(0, Math.floor(legacyFoodPool)) : 0);
  resources.partyWaterRations = Number.isFinite(configuredWaterPool) ? Math.max(0, Math.floor(configuredWaterPool)) : 0;
  resources.torches = Number.isFinite(configuredTorchPool) ? Math.max(0, Math.floor(configuredTorchPool)) : 0;
  if (Object.prototype.hasOwnProperty.call(resources, "partyRations")) delete resources.partyRations;
  const upkeepTimestamp = Number(resources.upkeepLastAppliedTs);
  resources.upkeepLastAppliedTs = Number.isFinite(upkeepTimestamp) ? upkeepTimestamp : null;
  if (!resources.itemSelections) resources.itemSelections = {};
  for (const key of RESOURCE_TRACK_KEYS) {
    if (!resources.itemSelections[key]) resources.itemSelections[key] = { actorId: "", itemId: "" };
    if (typeof resources.itemSelections[key].actorId !== "string") resources.itemSelections[key].actorId = "";
    if (typeof resources.itemSelections[key].itemId !== "string") resources.itemSelections[key].itemId = "";
  }
  if (!resources.gather) resources.gather = {};
  if (!resources.gather.weatherMods) resources.gather.weatherMods = {};
  if (!Array.isArray(resources.gather.history)) resources.gather.history = [];
  resources.gather.history = resources.gather.history
    .map((entry) => {
      const source = (entry && typeof entry === "object") ? entry : {};
      const timestampRaw = Number(source.timestamp ?? source.createdAt ?? Date.now());
      const timestamp = Number.isFinite(timestampRaw) ? timestampRaw : Date.now();
      const resultRaw = String(source.result ?? "").trim().toLowerCase();
      const result = resultRaw === "success" || resultRaw === "fail" ? resultRaw : (Boolean(source.success) ? "success" : "fail");
      return {
        id: String(source.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID(),
        timestamp,
        actorId: String(source.actorId ?? "").trim(),
        actorName: String(source.actorName ?? "Unknown Actor").trim() || "Unknown Actor",
        dayKey: String(source.dayKey ?? "").trim(),
        result,
        success: result === "success",
        resourceType: normalizeGatherResourceType(source.resourceType),
        rations: Math.max(0, Math.floor(Number(source.rations ?? source.finalRations ?? 0) || 0)),
        checkTotal: Math.floor(Number(source.checkTotal ?? source.rollTotal ?? 0) || 0),
        dc: Math.max(1, Math.floor(Number(source.dc ?? 1) || 1)),
        environment: normalizeGatherEnvironmentKey(source.environment),
        flags: Array.isArray(source.flags) ? source.flags.map((flag) => String(flag ?? "").trim()).filter(Boolean) : [],
        complications: Array.isArray(source.complications) ? source.complications.map((flag) => String(flag ?? "").trim()).filter(Boolean) : [],
        notes: Array.isArray(source.notes) ? source.notes.map((note) => String(note ?? "").trim()).filter(Boolean) : [],
        gatherMode: String(source.gatherMode ?? "standard").trim().toLowerCase() === "plant" ? "plant" : "standard",
        appliedToLedger: Boolean(source.appliedToLedger),
        inventoryGainSource: String(source.inventoryGainSource ?? "").trim(),
        inventoryGainAmount: Math.max(0, Math.floor(Number(source.inventoryGainAmount ?? 0) || 0)),
        createdBy: String(source.createdBy ?? "GM").trim() || "GM"
      };
    })
    .sort((a, b) => Number(b.timestamp ?? 0) - Number(a.timestamp ?? 0));
  if (typeof resources.gather.foodCoveredNextUpkeep !== "boolean") resources.gather.foodCoveredNextUpkeep = false;
  if (typeof resources.gather.waterCoveredNextUpkeep !== "boolean") resources.gather.waterCoveredNextUpkeep = false;
  const foodCoverageDueKey = Number(resources.gather.foodCoverageDueKey);
  resources.gather.foodCoverageDueKey = Number.isFinite(foodCoverageDueKey) ? foodCoverageDueKey : null;
  const waterCoverageDueKey = Number(resources.gather.waterCoverageDueKey);
  resources.gather.waterCoverageDueKey = Number.isFinite(waterCoverageDueKey) ? waterCoverageDueKey : null;
  const defaultWeatherMods = {
    clear: 0,
    "light-rain": 2,
    "heavy-rain": 5,
    wind: 2,
    fog: 3,
    extreme: 5
  };
  for (const [key, value] of Object.entries(defaultWeatherMods)) {
    const current = Number(resources.gather.weatherMods[key]);
    resources.gather.weatherMods[key] = Number.isFinite(current) ? current : value;
  }
  if (!resources.upkeep) resources.upkeep = {};
  ensureStewardPoolsState(resources);
}

function ensurePartyOperationsClass(appOrElement) {
  const root = getAppRootElement(appOrElement);
  if (!(root instanceof HTMLElement)) return;
  const frame = root.matches(".window-app, .application")
    ? root
    : root.closest(".window-app, .application");
  if (!frame?.classList) return;
  frame.classList.add("party-operations");
}

function applyNonGmOperationsReadonly(appOrElement) {
  if (canAccessAllPlayerOps()) return;
  const root = getAppRootElement(appOrElement);
  if (!root) return;
  const operationsWindow = root.querySelector(".po-window[data-main-tab='operations'], .po-window[data-main-tab='gm']");
  if (!operationsWindow) return;

  operationsWindow.querySelectorAll("[data-action]").forEach((element) => {
    const action = String(element?.dataset?.action ?? "").trim();
    if (!NON_GM_READONLY_ACTIONS.has(action)) return;
    if ("disabled" in element) element.disabled = true;
    element.setAttribute("aria-disabled", "true");
    element.dataset.poReadonly = "true";
    const existingTitle = String(element.getAttribute("title") ?? "").trim();
    if (!existingTitle.includes("GM only")) {
      const suffix = existingTitle ? ` ${existingTitle}` : "";
      element.setAttribute("title", `GM only.${suffix}`.trim());
    }
  });

  const selector = [
    ".po-base-site-editor input",
    ".po-base-site-editor select",
    ".po-injury-editor input",
    ".po-injury-editor select",
    ".po-injury-editor textarea",
    ".po-reputation-gm-tools input[name='repFactionName']"
  ].join(", ");
  operationsWindow.querySelectorAll(selector).forEach((element) => {
    if ("disabled" in element) element.disabled = true;
    element.setAttribute("aria-disabled", "true");
    element.dataset.poReadonly = "true";
  });
}

function suppressNextSettingRefresh(fullSettingKey) {
  if (!fullSettingKey) return;
  const count = suppressedSettingRefreshKeys.get(fullSettingKey) ?? 0;
  suppressedSettingRefreshKeys.set(fullSettingKey, count + 1);
}

function consumeSuppressedSettingRefresh(fullSettingKey) {
  const count = suppressedSettingRefreshKeys.get(fullSettingKey) ?? 0;
  if (count <= 0) return false;
  if (count === 1) suppressedSettingRefreshKeys.delete(fullSettingKey);
  else suppressedSettingRefreshKeys.set(fullSettingKey, count - 1);
  return true;
}

async function setModuleSettingWithLocalRefreshSuppressed(settingKey, value) {
  const normalizedSettingKey = String(settingKey ?? "").trim();
  if (!normalizedSettingKey) return;
  const settingRecord = game.settings?.settings?.get?.(`${MODULE_ID}.${normalizedSettingKey}`) ?? null;
  const settingScope = String(settingRecord?.scope ?? "").trim().toLowerCase();

  if (!game.user?.isGM) {
    if (settingScope === "client") {
      const fullClientSettingKey = `${MODULE_ID}.${normalizedSettingKey}`;
      suppressNextSettingRefresh(fullClientSettingKey);
      await game.settings.set(MODULE_ID, normalizedSettingKey, value);
      return;
    }
    if (!canAccessAllPlayerOps(game.user)) return;
    const hasActiveGm = hasActiveGmClient();
    if (!hasActiveGm) {
      ui.notifications?.warn("Party Operations change blocked: no active GM client is available.");
      return;
    }
    game.socket.emit(SOCKET_CHANNEL, {
      type: "ops:setting-write",
      userId: game.user.id,
      settingKey: normalizedSettingKey,
      value: foundry.utils.deepClone(value)
    });
    return;
  }
  const fullSettingKey = `${MODULE_ID}.${normalizedSettingKey}`;
  suppressNextSettingRefresh(fullSettingKey);
  await game.settings.set(MODULE_ID, normalizedSettingKey, value);
}

function getIntegrationModeSetting() {
  return game.settings.get(MODULE_ID, SETTINGS.INTEGRATION_MODE) ?? INTEGRATION_MODES.AUTO;
}

function validatePartyOpsConfig(input) {
  const source = (input && typeof input === "object" && !Array.isArray(input)) ? input : {};
  const rarityRaw = (source.rarityWeights && typeof source.rarityWeights === "object" && !Array.isArray(source.rarityWeights))
    ? source.rarityWeights
    : {};

  const lootScarcityRaw = String(source.lootScarcity ?? DEFAULT_PARTY_OPS_CONFIG.lootScarcity).trim().toLowerCase();
  const lootScarcity = lootScarcityRaw === LOOT_SCARCITY_LEVELS.ABUNDANT || lootScarcityRaw === LOOT_SCARCITY_LEVELS.SCARCE
    ? lootScarcityRaw
    : LOOT_SCARCITY_LEVELS.NORMAL;

  const rarityWeights = {};
  for (const rarity of PARTY_OPS_LOOT_RARITIES) {
    const rawWeight = Number(rarityRaw[rarity]);
    rarityWeights[rarity] = Number.isFinite(rawWeight)
      ? Math.max(0, rawWeight)
      : DEFAULT_PARTY_OPS_CONFIG.rarityWeights[rarity];
  }

  const multiplierRaw = Number(source.crGoldMultiplier);
  const crGoldMultiplier = Number.isFinite(multiplierRaw) && multiplierRaw > 0
    ? multiplierRaw
    : DEFAULT_PARTY_OPS_CONFIG.crGoldMultiplier;

  return {
    debugEnabled: Boolean(source.debugEnabled),
    lootScarcity,
    rarityWeights,
    crGoldMultiplier
  };
}

function getPartyOpsConfigSetting() {
  const raw = game.settings.get(MODULE_ID, SETTINGS.PARTY_OPS_CONFIG);
  const normalized = validatePartyOpsConfig(raw);
  const rawSerialized = JSON.stringify(raw ?? null);
  const normalizedSerialized = JSON.stringify(normalized);
  if (!partyOpsConfigNormalizationInProgress && rawSerialized !== normalizedSerialized) {
    partyOpsConfigNormalizationInProgress = true;
    void setModuleSettingWithLocalRefreshSuppressed(SETTINGS.PARTY_OPS_CONFIG, normalized)
      .catch((error) => {
        console.warn(`${MODULE_ID}: failed to normalize partyOpsConfig on load`, error);
      })
      .finally(() => {
        partyOpsConfigNormalizationInProgress = false;
      });
  }
  return normalized;
}

async function savePartyOpsConfigSetting(input) {
  const normalized = validatePartyOpsConfig(input);
  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.PARTY_OPS_CONFIG, normalized);
  return normalized;
}

function registerPartyOpsSettings(onSettingsChanged = () => {}) {
  const notifySettingChanged = (key, value) => {
    try {
      onSettingsChanged(key, value);
    } catch (error) {
      console.warn(`${MODULE_ID}: settings onChange callback failed`, { key, value, error });
    }
  };

  game.settings.register(MODULE_ID, SETTINGS.DEBUG_ENABLED, {
    name: "Enable Debug Logging",
    hint: "Turn on verbose Party Operations debug output for troubleshooting.",
    scope: "world",
    config: true,
    type: Boolean,
    default: false,
    onChange: (value) => notifySettingChanged(SETTINGS.DEBUG_ENABLED, Boolean(value))
  });

  game.settings.register(MODULE_ID, SETTINGS.LOOT_SCARCITY, {
    name: "Loot Scarcity",
    hint: "Set overall loot availability used by Party Operations loot systems.",
    scope: "world",
    config: true,
    type: String,
    choices: {
      [LOOT_SCARCITY_LEVELS.ABUNDANT]: "Abundant",
      [LOOT_SCARCITY_LEVELS.NORMAL]: "Normal",
      [LOOT_SCARCITY_LEVELS.SCARCE]: "Scarce"
    },
    default: LOOT_SCARCITY_LEVELS.NORMAL,
    onChange: (value) => {
      const raw = String(value ?? LOOT_SCARCITY_LEVELS.NORMAL).trim().toLowerCase();
      const normalized = raw === LOOT_SCARCITY_LEVELS.ABUNDANT || raw === LOOT_SCARCITY_LEVELS.SCARCE
        ? raw
        : LOOT_SCARCITY_LEVELS.NORMAL;
      notifySettingChanged(SETTINGS.LOOT_SCARCITY, normalized);
    }
  });

  game.settings.register(MODULE_ID, SETTINGS.REST_AUTOMATION_ENABLED, {
    name: "Enable Rest Automation",
    hint: "Allow Party Operations to automate supported rest workflows.",
    scope: "world",
    config: true,
    type: Boolean,
    default: true,
    onChange: (value) => notifySettingChanged(SETTINGS.REST_AUTOMATION_ENABLED, Boolean(value))
  });

  game.settings.register(MODULE_ID, SETTINGS.MARCHING_ORDER_LOCK_PLAYERS, {
    name: "Lock Marching Order For Players",
    hint: "Prevent non-GM players from changing marching order positions.",
    scope: "world",
    config: true,
    type: Boolean,
    default: false,
    onChange: (value) => notifySettingChanged(SETTINGS.MARCHING_ORDER_LOCK_PLAYERS, Boolean(value))
  });

  game.settings.register(MODULE_ID, SETTINGS.PARTY_OPS_CONFIG, {
    name: "Party Operations Config",
    hint: "Validated module config payload for loot/scarcity tuning and debug wiring.",
    scope: "world",
    config: false,
    type: Object,
    default: foundry.utils.deepClone(DEFAULT_PARTY_OPS_CONFIG),
    onChange: (value) => {
      const normalized = validatePartyOpsConfig(value);
      notifySettingChanged(SETTINGS.PARTY_OPS_CONFIG, normalized);
      const incomingSerialized = JSON.stringify(value ?? null);
      const normalizedSerialized = JSON.stringify(normalized);
      if (partyOpsConfigNormalizationInProgress) return;
      if (incomingSerialized === normalizedSerialized) return;
      partyOpsConfigNormalizationInProgress = true;
      void setModuleSettingWithLocalRefreshSuppressed(SETTINGS.PARTY_OPS_CONFIG, normalized)
        .catch((error) => {
          console.warn(`${MODULE_ID}: failed to normalize partyOpsConfig on save`, error);
        })
        .finally(() => {
          partyOpsConfigNormalizationInProgress = false;
        });
    }
  });
}

function normalizeInventoryHookMode(value) {
  const raw = String(value ?? "").trim().toLowerCase();
  if (raw === INVENTORY_HOOK_MODES.OFF) return INVENTORY_HOOK_MODES.OFF;
  if (raw === INVENTORY_HOOK_MODES.REFRESH) return INVENTORY_HOOK_MODES.REFRESH;
  return INVENTORY_HOOK_MODES.SYNC;
}

function getInventoryHookModeSetting() {
  const configured = game.settings.get(MODULE_ID, SETTINGS.INVENTORY_HOOK_MODE);
  return normalizeInventoryHookMode(configured);
}

async function setInventoryHookMode(mode) {
  const normalized = normalizeInventoryHookMode(mode);
  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.INVENTORY_HOOK_MODE, normalized);
  return normalized;
}

function getModuleConfigSnapshot() {
  return {
    schema: CONFIG_SCHEMA,
    launcher: {
      placement: getLauncherPlacement(),
      floatingLocked: isFloatingLauncherLocked()
    },
    integration: {
      configuredMode: getIntegrationModeSetting(),
      resolvedMode: resolveIntegrationMode(),
      daeAvailable: isDaeAvailable()
    },
    journal: {
      visibility: getJournalVisibilityMode(),
      filterDebounceMs: getJournalFilterDebounceMs(),
      sessionSummaryRange: getSessionSummaryRangeSetting()
    },
    inventory: {
      hookMode: getInventoryHookModeSetting()
    },
    gather: {
      rollMode: getGatherRollModeSetting(),
      rules: foundry.utils.deepClone(getGatherResourceConfig())
    },
    typedConfig: {
      value: getPartyOpsConfigSetting()
    }
  };
}

function getGatherRollModeSetting() {
  return game.settings.get(MODULE_ID, SETTINGS.GATHER_ROLL_MODE) ?? "prefer-monks";
}

function clampGatherInteger(value, min, max, fallback) {
  const raw = Number(value);
  if (!Number.isFinite(raw)) return fallback;
  return Math.max(min, Math.min(max, Math.floor(raw)));
}

function clampGatherModifier(value, fallback = 0) {
  return clampGatherInteger(value, -20, 20, fallback);
}

function normalizeGatherTravelTradeoff(value) {
  const raw = String(value ?? "").trim().toLowerCase();
  if (raw === GATHER_TRAVEL_CHOICES.FELL_BEHIND) return GATHER_TRAVEL_CHOICES.FELL_BEHIND;
  return GATHER_TRAVEL_CHOICES.PACE;
}

function normalizeGatherEnvironmentKey(value) {
  const raw = String(value ?? "").trim().toLowerCase();
  return GATHER_ENVIRONMENT_KEYS.includes(raw) ? raw : GATHER_ENVIRONMENT_KEYS[0];
}

function normalizeGatherResourceType(value) {
  const raw = String(value ?? "").trim().toLowerCase();
  return raw === "water" ? "water" : "food";
}

function getGatherResourceConfig() {
  const getSetting = (key, fallback) => {
    try {
      const value = game.settings.get(MODULE_ID, key);
      return value === undefined ? fallback : value;
    } catch {
      return fallback;
    }
  };

  const config = {
    enabled: Boolean(getSetting(SETTINGS.GATHER_ENABLED, GATHER_DEFAULTS.enabled)),
    minimumHours: clampGatherInteger(getSetting(SETTINGS.GATHER_MIN_HOURS, GATHER_DEFAULTS.minimumHours), 1, 24, GATHER_DEFAULTS.minimumHours),
    disallowCombat: Boolean(getSetting(SETTINGS.GATHER_DISALLOW_COMBAT, GATHER_DEFAULTS.disallowCombat)),
    baseDc: {
      lush_forest_or_river_valley: clampGatherInteger(getSetting(SETTINGS.GATHER_DC_LUSH, GATHER_DEFAULTS.baseDc.lush_forest_or_river_valley), 1, 30, GATHER_DEFAULTS.baseDc.lush_forest_or_river_valley),
      temperate_hills_or_light_woodland: clampGatherInteger(getSetting(SETTINGS.GATHER_DC_TEMPERATE, GATHER_DEFAULTS.baseDc.temperate_hills_or_light_woodland), 1, 30, GATHER_DEFAULTS.baseDc.temperate_hills_or_light_woodland),
      sparse_plains_or_rocky: clampGatherInteger(getSetting(SETTINGS.GATHER_DC_SPARSE, GATHER_DEFAULTS.baseDc.sparse_plains_or_rocky), 1, 30, GATHER_DEFAULTS.baseDc.sparse_plains_or_rocky),
      cold_mountains_or_swamp: clampGatherInteger(getSetting(SETTINGS.GATHER_DC_COLD, GATHER_DEFAULTS.baseDc.cold_mountains_or_swamp), 1, 30, GATHER_DEFAULTS.baseDc.cold_mountains_or_swamp),
      desert_blighted_wasteland: clampGatherInteger(getSetting(SETTINGS.GATHER_DC_DESERT, GATHER_DEFAULTS.baseDc.desert_blighted_wasteland), 1, 30, GATHER_DEFAULTS.baseDc.desert_blighted_wasteland)
    },
    seasonMod: clampGatherModifier(getSetting(SETTINGS.GATHER_DEFAULT_SEASON_MOD, GATHER_DEFAULTS.seasonMod), GATHER_DEFAULTS.seasonMod),
    weatherMod: clampGatherModifier(getSetting(SETTINGS.GATHER_DEFAULT_WEATHER_MOD, GATHER_DEFAULTS.weatherMod), GATHER_DEFAULTS.weatherMod),
    corruptionMod: clampGatherModifier(getSetting(SETTINGS.GATHER_DEFAULT_CORRUPTION_MOD, GATHER_DEFAULTS.corruptionMod), GATHER_DEFAULTS.corruptionMod),
    herbalismAdvantageEnabled: Boolean(getSetting(SETTINGS.GATHER_ENABLE_HERBALISM_ADVANTAGE, GATHER_DEFAULTS.herbalismAdvantageEnabled)),
    hostileEncounterFlagEnabled: Boolean(getSetting(SETTINGS.GATHER_ENABLE_HOSTILE_FAIL_FLAG, GATHER_DEFAULTS.hostileEncounterFlagEnabled)),
    failBy5ComplicationEnabled: Boolean(getSetting(SETTINGS.GATHER_ENABLE_FAIL_BY5_COMPLICATION, GATHER_DEFAULTS.failBy5ComplicationEnabled)),
    successBy5DoubleEnabled: Boolean(getSetting(SETTINGS.GATHER_ENABLE_SUCCESS_BY5_DOUBLE, GATHER_DEFAULTS.successBy5DoubleEnabled)),
    nat20BonusEnabled: Boolean(getSetting(SETTINGS.GATHER_ENABLE_NAT20_BONUS, GATHER_DEFAULTS.nat20BonusEnabled)),
    nat1ComplicationEnabled: Boolean(getSetting(SETTINGS.GATHER_ENABLE_NAT1_FLAG, GATHER_DEFAULTS.nat1ComplicationEnabled)),
    corruptionWaterCheckEnabled: Boolean(getSetting(SETTINGS.GATHER_ENABLE_CORRUPTION_WATER_CHECK, GATHER_DEFAULTS.corruptionWaterCheckEnabled)),
    corruptionConSaveDc: clampGatherInteger(getSetting(SETTINGS.GATHER_CORRUPTION_SAVE_DC, GATHER_DEFAULTS.corruptionConSaveDc), 1, 30, GATHER_DEFAULTS.corruptionConSaveDc),
    waterAutoFoundEnabled: Boolean(getSetting(SETTINGS.GATHER_ENABLE_WATER_AUTO_FOUND, GATHER_DEFAULTS.waterAutoFoundEnabled)),
    travelTradeoffEnabled: Boolean(getSetting(SETTINGS.GATHER_ENABLE_TRAVEL_TRADEOFF, GATHER_DEFAULTS.travelTradeoffEnabled)),
    travelTradeoffDefault: normalizeGatherTravelTradeoff(getSetting(SETTINGS.GATHER_TRAVEL_TRADEOFF_DEFAULT, GATHER_DEFAULTS.travelTradeoffDefault)),
    travelConSaveDc: clampGatherInteger(getSetting(SETTINGS.GATHER_TRAVEL_CON_SAVE_DC, GATHER_DEFAULTS.travelConSaveDc), 1, 30, GATHER_DEFAULTS.travelConSaveDc)
  };
  return config;
}

function getGatherEnvironmentChoices(config = getGatherResourceConfig()) {
  const baseDc = config?.baseDc ?? GATHER_DEFAULTS.baseDc;
  return GATHER_ENVIRONMENT_KEYS.map((key) => ({
    value: key,
    label: `${GATHER_ENVIRONMENT_LABELS[key] ?? key} (DC ${Math.max(1, Math.floor(Number(baseDc?.[key] ?? 10) || 10))})`
  }));
}

function getGatherQuickPresets(config = getGatherResourceConfig()) {
  return GATHER_QUICK_PRESETS.map((entry) => {
    const source = entry?.options ?? {};
    const environment = normalizeGatherEnvironmentKey(source.environment);
    const resourceType = normalizeGatherResourceType(source.resourceType);
    return {
      id: String(entry?.id ?? "").trim(),
      label: String(entry?.label ?? "Preset").trim() || "Preset",
      description: String(entry?.description ?? "").trim(),
      options: {
        environment,
        resourceType,
        gatherMode: String(source.gatherMode ?? "standard").trim().toLowerCase() === "plant" ? "plant" : "standard",
        seasonMod: clampGatherModifier(source.seasonMod, config.seasonMod),
        weatherMod: clampGatherModifier(source.weatherMod, config.weatherMod),
        corruptionMod: clampGatherModifier(source.corruptionMod, config.corruptionMod),
        hostileTerrain: Boolean(source.hostileTerrain),
        isCorruptedRegion: Boolean(source.isCorruptedRegion),
        waterAutoFound: Boolean(source.waterAutoFound),
        duringTravel: Boolean(source.duringTravel),
        travelTradeoff: normalizeGatherTravelTradeoff(source.travelTradeoff ?? config.travelTradeoffDefault)
      }
    };
  });
}

function getGatherQuickPresetById(presetId, config = getGatherResourceConfig()) {
  const id = String(presetId ?? "").trim();
  if (!id) return null;
  return getGatherQuickPresets(config).find((entry) => entry.id === id) ?? null;
}

function getGatherResourceTypeLabel(value) {
  return normalizeGatherResourceType(value) === "water" ? "Water" : "Food";
}

function buildGatherPresetContext(config = getGatherResourceConfig()) {
  return getGatherQuickPresets(config).map((preset) => {
    const options = preset?.options ?? {};
    const environment = normalizeGatherEnvironmentKey(options.environment);
    const resourceType = normalizeGatherResourceType(options.resourceType);
    const gatherMode = String(options.gatherMode ?? "standard").trim().toLowerCase() === "plant" ? "plant" : "standard";
    const tagParts = [];
    if (Boolean(options.duringTravel)) tagParts.push("Travel");
    if (Boolean(options.hostileTerrain)) tagParts.push("Hostile");
    if (Boolean(options.isCorruptedRegion)) tagParts.push("Corrupted");
    if (resourceType === "water" && Boolean(options.waterAutoFound)) tagParts.push("Auto-water");
    return {
      id: String(preset?.id ?? "").trim(),
      label: String(preset?.label ?? "Preset").trim() || "Preset",
      description: String(preset?.description ?? "").trim(),
      summary: `${getGatherResourceTypeLabel(resourceType)} | ${GATHER_ENVIRONMENT_LABELS[environment] ?? environment} | ${gatherMode === "plant" ? "Plant" : "Standard"}`,
      tagsText: tagParts.join(" - "),
      hasTags: tagParts.length > 0
    };
  });
}

function buildGatherHistoryContext(resourcesState = null, options = {}) {
  const rows = Array.isArray(resourcesState?.gather?.history) ? resourcesState.gather.history : [];
  const viewStateRaw = options?.viewState ?? getGatherHistoryViewState();
  const viewState = {
    search: normalizeGatherHistorySearch(viewStateRaw?.search),
    result: normalizeGatherHistoryResultFilter(viewStateRaw?.result),
    resource: normalizeGatherHistoryResourceFilter(viewStateRaw?.resource),
    environment: normalizeGatherHistoryEnvironmentFilter(viewStateRaw?.environment),
    actor: normalizeGatherHistoryActorFilter(viewStateRaw?.actor),
    sort: normalizeGatherHistorySort(viewStateRaw?.sort)
  };

  const mappedRows = rows.map((entry) => {
    const source = entry && typeof entry === "object" ? entry : {};
    const timestamp = Number(source.timestamp ?? Date.now());
    const timestampDate = new Date(Number.isFinite(timestamp) ? timestamp : Date.now());
    const success = String(source.result ?? "").trim().toLowerCase() === "success" || source.success === true;
    const environment = normalizeGatherEnvironmentKey(source.environment);
    const environmentLabel = GATHER_ENVIRONMENT_LABELS[environment] ?? environment;
    const resourceType = normalizeGatherResourceType(source.resourceType);
    const resourceTypeLabel = getGatherResourceTypeLabel(resourceType);
    const flags = Array.isArray(source.flags) ? source.flags : [];
    const complications = Array.isArray(source.complications) ? source.complications : [];
    const notes = Array.isArray(source.notes) ? source.notes : [];
    const detailParts = [];
    if (flags.length > 0) detailParts.push(`Flags: ${flags.map((flag) => formatGatherFlagLabel(flag)).join(", ")}`);
    if (complications.length > 0) detailParts.push(`Complications: ${complications.map((flag) => formatGatherComplicationLabel(flag)).join(", ")}`);
    if (notes.length > 0) detailParts.push(`Notes: ${notes.join(" | ")}`);
    const inventoryGainAmount = Math.max(0, Number(source.inventoryGainAmount ?? 0) || 0);
    const inventoryGainSource = String(source.inventoryGainSource ?? "").trim();
    if (inventoryGainAmount > 0) {
      const sourceLabel = inventoryGainSource ? ` (${inventoryGainSource})` : "";
      detailParts.push(`Inventory +${inventoryGainAmount}${sourceLabel}`);
    }
    if (source.appliedToLedger === false && Math.max(0, Number(source.rations ?? 0) || 0) > 0) {
      detailParts.push("Not applied to party pools");
    }

    const checkTotal = Number(source.checkTotal ?? 0);
    const dc = Number(source.dc ?? 0);
    const rollLabel = Number.isFinite(checkTotal) ? `${Math.floor(checkTotal)}` : "-";
    const dcLabel = Number.isFinite(dc) ? `${Math.max(1, Math.floor(dc))}` : "-";
    const actorName = String(source.actorName ?? "Unknown Actor").trim() || "Unknown Actor";
    const actorKey = actorName.toLowerCase();
    const rations = Math.max(0, Math.floor(Number(source.rations ?? 0) || 0));
    const detailsText = detailParts.length > 0 ? detailParts.join(" - ") : "-";
    const createdBy = String(source.createdBy ?? "GM").trim() || "GM";
    const dayKey = String(source.dayKey ?? "").trim();
    const resultKey = success ? "success" : "fail";
    const resultLabel = success ? "Success" : "Fail";

    return {
      id: String(source.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID(),
      timestamp: Number.isFinite(timestamp) ? timestamp : Date.now(),
      timestampLabel: Number.isFinite(timestampDate.getTime()) ? timestampDate.toLocaleString() : "Unknown",
      dayKey,
      actorName,
      actorKey,
      environment,
      environmentLabel,
      resultKey,
      resultLabel,
      resultClass: success ? "is-success" : "is-fail",
      isSuccess: success,
      rollVsDc: `${rollLabel} vs ${dcLabel}`,
      resourceType,
      resourceTypeLabel,
      rations,
      detailsText,
      createdBy,
      searchText: `${actorName} ${environmentLabel} ${resultLabel} ${resourceTypeLabel} ${detailsText} ${dayKey} ${createdBy}`.toLowerCase()
    };
  });

  const actorMap = new Map();
  for (const row of mappedRows) {
    if (!row.actorKey || row.actorKey === "all") continue;
    if (!actorMap.has(row.actorKey)) actorMap.set(row.actorKey, row.actorName);
  }
  if (viewState.actor !== "all" && !actorMap.has(viewState.actor)) {
    viewState.actor = "all";
  }

  const filteredRows = mappedRows
    .filter((row) => {
      if (viewState.result !== "all" && row.resultKey !== viewState.result) return false;
      if (viewState.resource !== "all" && row.resourceType !== viewState.resource) return false;
      if (viewState.environment !== "all" && row.environment !== viewState.environment) return false;
      if (viewState.actor !== "all" && row.actorKey !== viewState.actor) return false;
      if (viewState.search && !row.searchText.includes(viewState.search.toLowerCase())) return false;
      return true;
    })
    .sort((left, right) => {
      switch (viewState.sort) {
        case "oldest":
          return Number(left.timestamp ?? 0) - Number(right.timestamp ?? 0);
        case "actor-asc": {
          const nameCompare = String(left.actorName ?? "").localeCompare(String(right.actorName ?? ""));
          if (nameCompare !== 0) return nameCompare;
          return Number(right.timestamp ?? 0) - Number(left.timestamp ?? 0);
        }
        case "actor-desc": {
          const nameCompare = String(right.actorName ?? "").localeCompare(String(left.actorName ?? ""));
          if (nameCompare !== 0) return nameCompare;
          return Number(right.timestamp ?? 0) - Number(left.timestamp ?? 0);
        }
        case "rations-asc": {
          const rationCompare = Number(left.rations ?? 0) - Number(right.rations ?? 0);
          if (rationCompare !== 0) return rationCompare;
          return Number(right.timestamp ?? 0) - Number(left.timestamp ?? 0);
        }
        case "rations-desc": {
          const rationCompare = Number(right.rations ?? 0) - Number(left.rations ?? 0);
          if (rationCompare !== 0) return rationCompare;
          return Number(right.timestamp ?? 0) - Number(left.timestamp ?? 0);
        }
        case "newest":
        default:
          return Number(right.timestamp ?? 0) - Number(left.timestamp ?? 0);
      }
    });

  const actorOptions = [
    { value: "all", label: "All Actors", selected: viewState.actor === "all" },
    ...Array.from(actorMap.entries())
      .sort((left, right) => String(left[1] ?? "").localeCompare(String(right[1] ?? "")))
      .map(([value, label]) => ({
        value,
        label,
        selected: viewState.actor === value
      }))
  ];

  const environmentOptions = [
    { value: "all", label: "All Environments", selected: viewState.environment === "all" },
    ...GATHER_ENVIRONMENT_KEYS.map((key) => ({
      value: key,
      label: GATHER_ENVIRONMENT_LABELS[key] ?? key,
      selected: viewState.environment === key
    }))
  ];

  return {
    rows: filteredRows,
    hasRows: filteredRows.length > 0,
    hasAnyRows: mappedRows.length > 0,
    totalCount: mappedRows.length,
    visibleCount: filteredRows.length,
    hiddenCount: Math.max(0, mappedRows.length - filteredRows.length),
    hasActiveFilters: Boolean(
      viewState.search
      || viewState.result !== "all"
      || viewState.resource !== "all"
      || viewState.environment !== "all"
      || viewState.actor !== "all"
    ),
    emptyMessage: mappedRows.length > 0
      ? "No gather checks match the current filters."
      : "No gather checks logged yet.",
    sortOptions: GATHER_HISTORY_SORT_OPTIONS.map((entry) => ({
      value: entry.value,
      label: entry.label,
      selected: viewState.sort === entry.value
    })),
    resultOptions: GATHER_HISTORY_RESULT_FILTER_OPTIONS.map((entry) => ({
      value: entry.value,
      label: entry.label,
      selected: viewState.result === entry.value
    })),
    resourceOptions: GATHER_HISTORY_RESOURCE_FILTER_OPTIONS.map((entry) => ({
      value: entry.value,
      label: entry.label,
      selected: viewState.resource === entry.value
    })),
    environmentOptions,
    actorOptions,
    filters: {
      ...viewState,
      searchPlaceholder: "Filter by actor, note, or result"
    }
  };
}

function getGatherDayKey(timestamp = getCurrentWorldTimestamp()) {
  const api = getSimpleCalendarApi();
  if (isSimpleCalendarActive() && api?.timestampToDate) {
    try {
      const date = api.timestampToDate(timestamp);
      return `Y${Number(date?.year ?? 0)}-M${Number(date?.month ?? 0)}-D${Number(date?.day ?? 0)}`;
    } catch {
      // Fall through.
    }
  }
  return `D${Math.floor(Number(timestamp ?? 0) / 86400)}`;
}

function buildGatherEnvironmentSignature(input = {}) {
  const environment = normalizeGatherEnvironmentKey(input.environment);
  const season = clampGatherModifier(input.seasonMod, 0);
  const weather = clampGatherModifier(input.weatherMod, 0);
  const corruption = clampGatherModifier(input.corruptionMod, 0);
  const hostile = Boolean(input.hostileTerrain) ? "hostile" : "calm";
  const corruptedRegion = Boolean(input.isCorruptedRegion) ? "corrupted" : "clean";
  return `${environment}|s${season}|w${weather}|c${corruption}|${hostile}|${corruptedRegion}`;
}

function getLegacyPartyOpsFlag(actor, flagKeyInput) {
  const flagKey = String(flagKeyInput ?? "").trim();
  if (!actor || !flagKey) return undefined;
  if (typeof actor.getFlag === "function") {
    try {
      return actor.getFlag("partyops", flagKey);
    } catch {
      // Legacy scope may be unavailable in newer Foundry versions.
    }
  }
  const getProperty = globalThis?.foundry?.utils?.getProperty;
  if (typeof getProperty === "function") {
    const direct = getProperty(actor, `flags.partyops.${flagKey}`);
    if (direct !== undefined) return direct;
  }
  const root = actor?.flags?.partyops;
  if (!root || typeof root !== "object") return undefined;
  return flagKey.split(".").reduce((value, segment) => {
    if (!value || typeof value !== "object") return undefined;
    return value[segment];
  }, root);
}

async function setLegacyPartyOpsFlagSilently(actor, flagKeyInput, value) {
  const flagKey = String(flagKeyInput ?? "").trim();
  if (!actor || !flagKey || typeof actor.setFlag !== "function") return false;
  try {
    await actor.setFlag("partyops", flagKey, value);
    return true;
  } catch {
    return false;
  }
}

function getGatherAttemptState(actor) {
  if (!actor) return { lastDay: "", lastEnvironmentSignature: "" };
  return {
    lastDay: String(
      actor.getFlag(MODULE_ID, "gather.lastDay")
      ?? getLegacyPartyOpsFlag(actor, "gather.lastDay")
      ?? ""
    ),
    lastEnvironmentSignature: String(
      actor.getFlag(MODULE_ID, "gather.lastEnvironmentSignature")
      ?? getLegacyPartyOpsFlag(actor, "gather.lastEnvironmentSignature")
      ?? ""
    )
  };
}

async function setGatherAttemptState(actor, dayKey, environmentSignature) {
  if (!actor) return;
  const payload = {
    "gather.lastDay": String(dayKey ?? ""),
    "gather.lastEnvironmentSignature": String(environmentSignature ?? ""),
    "gather.lastWorldTime": Number(getCurrentWorldTimestamp())
  };
  try {
    await actor.setFlag(MODULE_ID, "gather.lastDay", payload["gather.lastDay"]);
    await actor.setFlag(MODULE_ID, "gather.lastEnvironmentSignature", payload["gather.lastEnvironmentSignature"]);
    await actor.setFlag(MODULE_ID, "gather.lastWorldTime", payload["gather.lastWorldTime"]);
  } catch (error) {
    console.warn(`${MODULE_ID}: failed to persist gather attempt flags`, {
      actorId: actor.id,
      actorName: actor.name,
      error
    });
  }
  // Best-effort legacy mirror; do not fail or warn when legacy scope is unavailable.
  await setLegacyPartyOpsFlagSilently(actor, "gather.lastDay", payload["gather.lastDay"]);
  await setLegacyPartyOpsFlagSilently(actor, "gather.lastEnvironmentSignature", payload["gather.lastEnvironmentSignature"]);
  await setLegacyPartyOpsFlagSilently(actor, "gather.lastWorldTime", payload["gather.lastWorldTime"]);
}

function canAttemptGatherForDay(actor, dayKey, environmentSignature) {
  const state = getGatherAttemptState(actor);
  if (state.lastDay !== String(dayKey ?? "")) return true;
  return state.lastEnvironmentSignature !== String(environmentSignature ?? "");
}

function isActorInImmediateDanger(actor) {
  if (!actor) return false;
  const combat = game.combat;
  if (!combat) return false;
  const combatants = Array.from(combat.combatants ?? []);
  return combatants.some((entry) => {
    if (!entry) return false;
    if (entry.actorId !== actor.id) return false;
    if (entry.defeated) return false;
    return true;
  });
}

function mapGatherRationsFromD6(total) {
  const value = clampGatherInteger(total, 1, 6, 1);
  if (value <= 3) return 1;
  if (value <= 5) return 2;
  return 3;
}

function resolveGatherResourceOutcome(input = {}) {
  const resourceType = normalizeGatherResourceType(input.resourceType);
  const checkTotal = Math.floor(Number(input.checkTotal ?? 0) || 0);
  const dc = Math.max(1, Math.floor(Number(input.dc ?? 10) || 10));
  const natural = clampGatherInteger(input.natural, 0, 20, 0);
  const success = checkTotal >= dc;
  const successBy = success ? Math.max(0, checkTotal - dc) : 0;
  const failedBy = success ? 0 : Math.max(0, dc - checkTotal);
  const resultFlags = [];
  const complications = [];
  const notes = [];

  let rationDieTotal = null;
  let baseRations = 0;
  let bonusRations = 0;

  const waterAutoFound = Boolean(input.waterAutoFound) && resourceType === "water";
  if (success) {
    if (waterAutoFound) {
      baseRations = 1;
      notes.push("Water auto-found near obvious source.");
    } else {
      rationDieTotal = clampGatherInteger(input.rationDieTotal, 1, 6, 1);
      baseRations = mapGatherRationsFromD6(rationDieTotal);
    }

    if (Boolean(input.successBy5DoubleEnabled) && successBy >= 5) {
      baseRations *= 2;
      notes.push("Success by 5+: rations doubled.");
    }

    if (Boolean(input.nat20BonusEnabled) && natural === 20) {
      bonusRations = clampGatherInteger(input.nat20BonusDieTotal, 1, 4, 1);
      notes.push(`Natural 20 bonus: +${bonusRations} rations.`);
      resultFlags.push("safe-campsite-found");
    }
  } else {
    if (Boolean(input.hostileEncounterFlagEnabled) && Boolean(input.hostileTerrain)) {
      resultFlags.push("encounter-check-flag");
      notes.push("Hostile terrain encounter check flagged.");
    }
    if (Boolean(input.failBy5ComplicationEnabled) && failedBy >= 5) {
      complications.push("fail-by-5-complication");
      notes.push("Failed by 5+: complication triggered.");
    }
  }

  if (Boolean(input.nat1ComplicationEnabled) && natural === 1) {
    complications.push("natural-1-danger");
    notes.push("Natural 1: spoiled/poisoned/attract-danger complication.");
  }

  const finalRations = success ? Math.max(0, baseRations + bonusRations) : 0;
  const contaminationRoll = Number(input.contaminationRollTotal);
  const contaminatedWater = Boolean(success && resourceType === "water" && input.corruptionWaterCheckEnabled && input.isCorruptedRegion && contaminationRoll === 1);
  if (contaminatedWater) {
    resultFlags.push("water-contaminated");
    notes.push("Corrupted water contamination triggered.");
    if (input.corruptionSavePassed === false) {
      complications.push("contaminated-water-save-failed");
      notes.push("Constitution save failed against contamination.");
    }
  }

  const travelTradeoff = normalizeGatherTravelTradeoff(input.travelTradeoff);
  if (Boolean(input.duringTravel) && Boolean(input.travelTradeoffEnabled)) {
    if (travelTradeoff === GATHER_TRAVEL_CHOICES.PACE) {
      resultFlags.push("travel-pace-reduced-one-step");
      notes.push("Travel pace reduced by one step.");
    } else {
      resultFlags.push("travel-fell-behind");
      notes.push("Actor fell behind during travel.");
      const travelConSavePassed = Boolean(input.travelConSavePassed);
      if (!travelConSavePassed) {
        complications.push("travel-con-save-failed");
        notes.push("Constitution save failed after falling behind.");
      }
    }
  }

  return {
    success,
    checkTotal,
    dc,
    natural,
    successBy,
    failedBy,
    resourceType,
    waterAutoFound,
    rationDieTotal,
    baseRations,
    bonusRations,
    finalRations,
    contaminatedWater,
    contaminationRoll: Number.isFinite(contaminationRoll) ? contaminationRoll : null,
    resultFlags,
    complications,
    notes
  };
}

function isDaeAvailable() {
  return Boolean(game.modules.get("dae")?.active);
}

function resolveIntegrationMode() {
  const configured = getIntegrationModeSetting();
  if (configured === INTEGRATION_MODES.OFF) return INTEGRATION_MODES.OFF;
  if (configured === INTEGRATION_MODES.FLAGS) return INTEGRATION_MODES.FLAGS;
  if (configured === INTEGRATION_MODES.DAE) return isDaeAvailable() ? INTEGRATION_MODES.DAE : INTEGRATION_MODES.FLAGS;
  return isDaeAvailable() ? INTEGRATION_MODES.DAE : INTEGRATION_MODES.FLAGS;
}

function isTrackableCharacter(actor) {
  if (!actor) return false;
  return actor.type === "character" || actor.hasPlayerOwner;
}

function collectIntegrationActorIds() {
  const actorIds = new Set();

  const restState = getRestWatchState();
  for (const slot of restState.slots ?? []) {
    for (const entry of slot.entries ?? []) {
      if (entry?.actorId) actorIds.add(entry.actorId);
    }
    if (slot.actorId) actorIds.add(slot.actorId);
  }

  const marchState = getMarchingOrderState();
  for (const actorId of getOrderedMarchingActors(marchState)) {
    if (actorId) actorIds.add(actorId);
  }

  const ledger = getOperationsLedger();
  for (const actorId of Object.values(ledger.roles ?? {})) {
    if (actorId) actorIds.add(actorId);
  }

  const recovery = getInjuryRecoveryState();
  for (const actorId of Object.keys(recovery.injuries ?? {})) {
    if (actorId) actorIds.add(actorId);
  }

  for (const actor of getResourceSyncActors()) {
    if (actor?.id) actorIds.add(actor.id);
  }

  return Array.from(actorIds)
    .map((actorId) => game.actors.get(actorId))
    .filter((actor) => isTrackableCharacter(actor));
}

function buildIntegrationGlobalContext() {
  const restState = getRestWatchState();
  const marchState = getMarchingOrderState();
  const ledger = getOperationsLedger();
  const injuryRecovery = getInjuryRecoveryState();
  const operations = buildOperationsContext();
  const formation = normalizeMarchingFormation(marchState.formation ?? "default");
  const doctrineEffects = getDoctrineEffects(formation);
  const rankByActorId = {};
  for (const rank of ["front", "middle", "rear"]) {
    for (const actorId of marchState.ranks?.[rank] ?? []) {
      if (actorId && !rankByActorId[actorId]) rankByActorId[actorId] = rank;
    }
  }
  const watchSlotsByActorId = {};
  for (const slot of restState.slots ?? []) {
    for (const entry of slot.entries ?? []) {
      if (!entry?.actorId) continue;
      if (!watchSlotsByActorId[entry.actorId]) watchSlotsByActorId[entry.actorId] = [];
      watchSlotsByActorId[entry.actorId].push(slot.id);
    }
    if (slot.actorId) {
      if (!watchSlotsByActorId[slot.actorId]) watchSlotsByActorId[slot.actorId] = [];
      watchSlotsByActorId[slot.actorId].push(slot.id);
    }
  }
  const rolesByActorId = {};
  for (const [roleKey, actorId] of Object.entries(ledger.roles ?? {})) {
    if (!actorId) continue;
    if (!rolesByActorId[actorId]) rolesByActorId[actorId] = [];
    rolesByActorId[actorId].push(roleKey);
  }

  return {
    restState,
    marchState,
    ledger,
    injuryRecovery,
    operations,
    formation,
    doctrineEffects,
    rankByActorId,
    watchSlotsByActorId,
    rolesByActorId
  };
}

function buildActorIntegrationPayload(actorId, globalContext, options = {}) {
  const isNonParty = Boolean(options?.nonParty);
  const includeWorldGlobal = isNonParty ? options?.includeWorldGlobal !== false : false;
  const forceEnvironmentApply = Boolean(options?.forceEnvironmentApply);
  const injury = globalContext.injuryRecovery.injuries?.[actorId] ?? null;
  const roleKeys = globalContext.rolesByActorId[actorId] ?? [];
  const watchSlots = globalContext.watchSlotsByActorId[actorId] ?? [];
  const communicationReadiness = globalContext.operations.communication?.readiness ?? { ready: false, enabledCount: 0 };
  const reputationSummary = globalContext.operations.reputation?.summary ?? { hostileCount: 0, highStandingCount: 0 };
  const baseSummary = globalContext.operations.baseOperations ?? { maintenancePressure: 0, readiness: false, activeSites: 0 };
  const environment = globalContext.operations.environment ?? { presetKey: "none", movementDc: 12, appliedActorIds: [], preset: null };
  const environmentPreset = environment.preset ?? getEnvironmentPresetByKey(environment.presetKey);
  const environmentApplies = forceEnvironmentApply || (Array.isArray(environment.appliedActorIds) && environment.appliedActorIds.includes(actorId));
  const environmentCheck = getEnvironmentCheckMeta(environmentPreset);
  const summaryEffects = globalContext.operations.summary?.effects ?? {};
  const globalModifiers = isNonParty && includeWorldGlobal
    ? (summaryEffects.worldGlobalModifiers ?? {})
    : (summaryEffects.globalModifiers ?? {});
  const customDaeChanges = isNonParty
    ? (includeWorldGlobal
      ? (Array.isArray(summaryEffects.worldDaeChanges) ? summaryEffects.worldDaeChanges : [])
      : [])
    : (Array.isArray(summaryEffects.customDaeChanges) ? summaryEffects.customDaeChanges : []);

  return {
    moduleVersion: getCurrentModuleVersion(),
    operations: {
      prepEdge: Boolean(globalContext.operations.summary?.effects?.prepEdge),
      riskTier: globalContext.operations.summary?.effects?.riskTier ?? "moderate",
      roleCoverage: Number(globalContext.operations.summary?.roleCoverage ?? 0),
      roleTotal: Number(globalContext.operations.summary?.roleTotal ?? 0),
      activeSops: Number(globalContext.operations.summary?.activeSops ?? 0),
      sopTotal: Number(globalContext.operations.summary?.sopTotal ?? 0),
      communicationReady: Boolean(communicationReadiness.ready),
      communicationToggleCount: Number(communicationReadiness.enabledCount ?? 0),
      hostileFactions: Number(reputationSummary.hostileCount ?? 0),
      highStandingFactions: Number(reputationSummary.highStandingCount ?? 0),
      supplyPressure: Number(baseSummary.maintenancePressure ?? 0),
      supplyReadiness: Boolean(baseSummary.readiness),
      baseSites: Number(baseSummary.activeSites ?? 0),
      baseMaintenancePressure: Number(baseSummary.maintenancePressure ?? 0),
      baseReadiness: Boolean(baseSummary.readiness),
      minorInitiativeBonus: Number(globalModifiers.initiative ?? 0),
      minorAbilityCheckBonus: Number(globalModifiers.abilityChecks ?? 0),
      minorPerceptionBonus: Number(globalModifiers.perceptionChecks ?? 0),
      minorSavingThrowBonus: Number(globalModifiers.savingThrows ?? 0),
      customDaeChanges
    },
    doctrine: {
      formation: globalContext.formation,
      surprise: globalContext.doctrineEffects.surprise,
      ambush: globalContext.doctrineEffects.ambush
    },
    assignment: {
      watch: {
        assigned: watchSlots.length > 0,
        slots: watchSlots
      },
      marchingRank: globalContext.rankByActorId[actorId] ?? "unassigned",
      roles: roleKeys
    },
    injury: {
      active: Boolean(injury),
      name: String(injury?.injuryName ?? ""),
      effect: String(injury?.effect ?? ""),
      notes: String(injury?.notes ?? ""),
      stabilized: Boolean(injury?.stabilized),
      permanent: Boolean(injury?.permanent),
      severity: Number(injury?.severity ?? 0),
      recoveryDays: Number(injury?.recoveryDays ?? 0)
    },
    environment: {
      active: Boolean(environmentApplies && environmentPreset && environmentPreset.key !== "none"),
      presetKey: String(environmentPreset?.key ?? "none"),
      label: String(environmentPreset?.label ?? "None"),
      movementCheck: Boolean(environmentPreset?.movementCheck),
      checkType: environmentCheck.checkType,
      checkKey: environmentCheck.checkKey,
      checkSkill: environmentCheck.checkType === "skill" ? environmentCheck.checkKey : "",
      checkLabel: environmentCheck.checkLabel,
      movementDc: Math.max(1, Math.floor(Number(environment.movementDc ?? 12) || 12)),
      appliesToActor: Boolean(environmentApplies)
    },
    resources: {
      campfire: Boolean(globalContext.restState.campfire),
      foodDays: Number(globalContext.ledger.resources?.food ?? 0),
      waterDays: Number(globalContext.ledger.resources?.water ?? 0)
    }
  };
}

function getIntegrationEffect(actor) {
  return actor.effects.find((effect) => {
    if (effect.origin === INTEGRATION_EFFECT_ORIGIN) return true;
    if (effect.name === INTEGRATION_EFFECT_NAME && effect.getFlag(MODULE_ID, "integration") === true) return true;
    return false;
  });
}

function getInjuryStatusEffect(actor) {
  return actor.effects.find((effect) => {
    if (effect.origin === INJURY_EFFECT_ORIGIN) return true;
    if (effect.getFlag(MODULE_ID, "injuryStatus") === true) return true;
    return String(effect.name ?? "").startsWith(`${INJURY_EFFECT_NAME_PREFIX} `);
  });
}

function getEnvironmentStatusEffect(actor) {
  return actor.effects.find((effect) => {
    if (effect.origin === ENVIRONMENT_EFFECT_ORIGIN) return true;
    if (effect.getFlag(MODULE_ID, "environmentStatus") === true) return true;
    return String(effect.name ?? "").startsWith(`${ENVIRONMENT_EFFECT_NAME_PREFIX} `);
  });
}

function getEnvironmentPresetByKey(key) {
  return ENVIRONMENT_PRESETS.find((preset) => preset.key === key) ?? ENVIRONMENT_PRESETS[0];
}

function getEnvironmentCheckMeta(source = {}) {
  const checkType = String(source.checkType ?? "skill").toLowerCase() === "save" ? "save" : "skill";
  const fallbackKey = checkType === "save" ? "con" : "ath";
  const rawKey = String(source.checkKey ?? source.checkSkill ?? "").trim().toLowerCase();
  const movementCheck = Boolean(source.movementCheck);
  const checkKey = rawKey || (movementCheck ? fallbackKey : "");
  const defaultLabel = checkKey
    ? (checkType === "save" ? `${checkKey.toUpperCase()} Save` : checkKey.toUpperCase())
    : "";
  const checkLabel = String(source.checkLabel ?? defaultLabel).trim();
  return {
    checkType,
    checkKey,
    checkLabel
  };
}

function getStatusLabelById(statusId) {
  const id = String(statusId ?? "").trim();
  if (!id) return "";
  const match = CONFIG.statusEffects?.find((entry) => String(entry?.id ?? "") === id);
  return String(match?.name ?? id);
}

function getActiveEffectModeLabel(mode) {
  const numericMode = Math.floor(Number(mode ?? CONST.ACTIVE_EFFECT_MODES.ADD));
  const entry = Object.entries(CONST.ACTIVE_EFFECT_MODES ?? {}).find(([, value]) => Number(value) === numericMode);
  return entry ? entry[0] : "ADD";
}

const FRIENDLY_DAE_KEYS = [
  { key: "system.attributes.movement.walk", label: "Movement Speed (Walk)", hint: "Changes base walking speed." },
  { key: "system.attributes.movement.fly", label: "Movement Speed (Fly)", hint: "Changes base flying speed." },
  { key: "system.attributes.movement.swim", label: "Movement Speed (Swim)", hint: "Changes base swimming speed." },
  { key: "system.attributes.ac.value", label: "Armor Class", hint: "Changes AC value." },
  { key: "system.attributes.hp.value", label: "Current HP", hint: "Directly changes current HP." },
  { key: "system.attributes.hp.max", label: "Max HP", hint: "Changes maximum HP." },
  { key: "system.attributes.hp.temp", label: "Temporary HP", hint: "Adds or sets temporary HP." },
  { key: "system.attributes.init.bonus", label: "Initiative Bonus", hint: "Adds to initiative rolls." },
  { key: "system.bonuses.abilities.check", label: "All Ability Checks", hint: "Global bonus/penalty for ability checks." },
  { key: "system.bonuses.abilities.save", label: "All Saving Throws", hint: "Global bonus/penalty for saves." },
  { key: "system.bonuses.mwak.attack", label: "Melee Weapon Attacks", hint: "Bonus/penalty to melee weapon attacks." },
  { key: "system.bonuses.rwak.attack", label: "Ranged Weapon Attacks", hint: "Bonus/penalty to ranged weapon attacks." },
  { key: "system.bonuses.msak.attack", label: "Melee Spell Attacks", hint: "Bonus/penalty to melee spell attacks." },
  { key: "system.bonuses.rsak.attack", label: "Ranged Spell Attacks", hint: "Bonus/penalty to ranged spell attacks." },
  { key: "system.skills.ath.bonuses.check", label: "Athletics Checks", hint: "Bonus/penalty to Athletics checks." },
  { key: "system.skills.acr.bonuses.check", label: "Acrobatics Checks", hint: "Bonus/penalty to Acrobatics checks." },
  { key: "system.skills.prc.bonuses.check", label: "Perception Checks", hint: "Bonus/penalty to Perception checks." },
  { key: "system.skills.ste.bonuses.check", label: "Stealth Checks", hint: "Bonus/penalty to Stealth checks." }
];

let daeModifierCatalogCache = null;

function humanizeDaeKey(key) {
  return String(key ?? "")
    .split(".")
    .filter(Boolean)
    .slice(-2)
    .map((part) => part.replace(/([a-z])([A-Z])/g, "$1 $2").replace(/[-_]/g, " "))
    .join(" ")
    .replace(/\b\w/g, (char) => char.toUpperCase());
}

function collectObjectPaths(source, prefix = "", output = new Set(), depth = 0) {
  if (!source || typeof source !== "object" || depth > 8) return output;
  for (const [rawKey, value] of Object.entries(source)) {
    const key = String(rawKey ?? "").trim();
    if (!key) continue;
    const path = prefix ? `${prefix}.${key}` : key;
    if (path.startsWith("system.") || path.startsWith("flags.") || path.startsWith("prototypeToken.")) output.add(path);
    if (value && typeof value === "object") collectObjectPaths(value, path, output, depth + 1);
  }
  return output;
}

function extractDaeSpecKeys(rawSpecs) {
  const keys = new Set();
  if (!rawSpecs) return keys;

  const pushIfKey = (candidate) => {
    if (typeof candidate === "string") {
      const key = candidate.trim();
      if (key && key.includes(".")) keys.add(key);
      return;
    }
    if (!candidate || typeof candidate !== "object") return;
    const candidateKeys = [
      candidate.key,
      candidate.path,
      candidate.fieldSpec,
      candidate.spec,
      candidate.attr,
      candidate.value
    ];
    for (const raw of candidateKeys) {
      if (typeof raw !== "string") continue;
      const key = raw.trim();
      if (key && key.includes(".")) keys.add(key);
    }
  };

  if (Array.isArray(rawSpecs)) {
    for (const entry of rawSpecs) pushIfKey(entry);
    return keys;
  }

  if (rawSpecs instanceof Map) {
    for (const [mapKey, mapValue] of rawSpecs.entries()) {
      pushIfKey(mapKey);
      pushIfKey(mapValue);
    }
    return keys;
  }

  if (typeof rawSpecs === "object") {
    for (const [objectKey, objectValue] of Object.entries(rawSpecs)) {
      pushIfKey(objectKey);
      pushIfKey(objectValue);
    }
  }

  return keys;
}

function collectDaeCatalogSpecKeys() {
  const keys = new Set();
  const daeModuleApi = game.modules?.get("dae")?.api ?? null;
  const daeGlobal = globalThis.DAE ?? null;
  const specCandidates = [
    daeModuleApi?.ValidSpec?.allSpecsObj,
    daeModuleApi?.ValidSpec?.allSpecs,
    daeModuleApi?.validSpec,
    daeGlobal?.ValidSpec?.allSpecsObj,
    daeGlobal?.ValidSpec?.allSpecs,
    daeGlobal?.validSpec
  ];
  for (const candidate of specCandidates) {
    const extracted = extractDaeSpecKeys(candidate);
    for (const key of extracted) keys.add(key);
  }
  return keys;
}

function buildDaeModifierCatalog() {
  const map = new Map();
  for (const entry of FRIENDLY_DAE_KEYS) {
    map.set(entry.key, { key: entry.key, label: entry.label, hint: entry.hint });
  }

  const addCatalogKey = (rawKey, hintPrefix = "Effect field") => {
    const key = String(rawKey ?? "").trim();
    if (!key || map.has(key)) return;
    map.set(key, { key, label: humanizeDaeKey(key), hint: `${hintPrefix}: ${key}` });
  };

  for (const preset of ENVIRONMENT_PRESETS) {
    for (const change of preset.effectChanges ?? []) {
      addCatalogKey(change?.key, "System field");
    }
  }

  for (const specKey of collectDaeCatalogSpecKeys()) {
    addCatalogKey(specKey, "DAE spec");
  }

  const model = game.system?.model?.Actor ?? {};
  const discovered = new Set();
  for (const value of Object.values(model)) {
    collectObjectPaths(value, "system", discovered);
  }
  for (const key of discovered) {
    addCatalogKey(key, "System field");
  }

  for (const actor of game.actors?.contents ?? []) {
    const actorData = actor?.toObject?.();
    if (!actorData || typeof actorData !== "object") continue;
    const actorDiscovered = collectObjectPaths(actorData);
    for (const key of actorDiscovered) {
      addCatalogKey(key, "Actor field");
    }
  }

  return Array.from(map.values()).sort((a, b) => {
    const labelCompare = String(a.label).localeCompare(String(b.label));
    if (labelCompare !== 0) return labelCompare;
    return String(a.key).localeCompare(String(b.key));
  });
}

function getDaeModifierCatalog() {
  if (!daeModifierCatalogCache) daeModifierCatalogCache = buildDaeModifierCatalog();
  return daeModifierCatalogCache;
}

function buildEnvironmentDaeChangeKeyCatalog() {
  return getDaeModifierCatalog();
}

function buildDamageTypeOptions(selected = "") {
  const selectedValue = String(selected ?? "").trim().toLowerCase();
  const rawDamageTypes = CONFIG?.DND5E?.damageTypes ?? CONFIG?.damageTypes ?? {};
  const options = [
    { value: "", label: "None", selected: selectedValue === "" }
  ];

  const resolveDamageTypeLabel = (raw, fallback) => {
    if (typeof raw === "string") {
      return raw.includes(".") ? (game.i18n?.localize?.(raw) ?? raw) : raw;
    }
    if (raw && typeof raw === "object") {
      const candidate = String(raw.label ?? raw.name ?? raw.value ?? "").trim();
      if (candidate) return candidate.includes(".") ? (game.i18n?.localize?.(candidate) ?? candidate) : candidate;
    }
    return fallback;
  };

  for (const [valueRaw, labelRaw] of Object.entries(rawDamageTypes)) {
    const value = String(valueRaw ?? "").trim();
    if (!value) continue;
    const localized = resolveDamageTypeLabel(labelRaw, value);
    options.push({
      value,
      label: localized,
      selected: value.toLowerCase() === selectedValue
    });
  }

  if (selectedValue && !options.some((entry) => String(entry.value).toLowerCase() === selectedValue)) {
    options.push({ value: selectedValue, label: selectedValue, selected: true });
  }

  return options;
}

function buildPartyHealthModifierKeyCatalog() {
  return getDaeModifierCatalog();
}

function buildEnvironmentOutcomeSummary(preset) {
  const statusLabel = getStatusLabelById(preset?.failStatusId);
  const failParts = [];
  if (statusLabel) failParts.push(`Apply ${statusLabel}`);
  const failSlideFeet = Math.max(0, Number(preset?.failSlideFeet ?? 0) || 0);
  if (failSlideFeet > 0) failParts.push(`Slide ${failSlideFeet} ft`);
  const failSpeedZeroTurns = Math.max(0, Number(preset?.failSpeedZeroTurns ?? 0) || 0);
  if (failSpeedZeroTurns > 0) {
    const turnLabel = failSpeedZeroTurns === 1 ? "turn" : "turns";
    failParts.push(`Speed 0 for ${failSpeedZeroTurns} ${turnLabel}`);
  }
  const failDamageFormula = String(preset?.failDamageFormula ?? "").trim();
  const failDamageType = String(preset?.failDamageType ?? "").trim();
  if (failDamageFormula) failParts.push(`${failDamageFormula} ${failDamageType || "damage"}`.trim());
  const failExhaustion = Math.max(0, Number(preset?.failExhaustion ?? 0) || 0);
  if (failExhaustion > 0) {
    const levelLabel = failExhaustion === 1 ? "level" : "levels";
    failParts.push(`+${failExhaustion} exhaustion ${levelLabel}`);
  }

  const failBy5StatusLabel = getStatusLabelById(preset?.failBy5StatusId);
  const failBy5Parts = [];
  if (failBy5StatusLabel) failBy5Parts.push(`Apply ${failBy5StatusLabel}`);
  const failBy5SlideFeet = Math.max(0, Number(preset?.failBy5SlideFeet ?? 0) || 0);
  if (failBy5SlideFeet > 0) failBy5Parts.push(`Slide ${failBy5SlideFeet} ft`);
  const failBy5DamageFormula = String(preset?.failBy5DamageFormula ?? "").trim();
  const failBy5DamageType = String(preset?.failBy5DamageType ?? "").trim();
  if (failBy5DamageFormula) failBy5Parts.push(`${failBy5DamageFormula} ${failBy5DamageType || "damage"}`.trim());
  const failBy5MaxHpReductionFormula = String(preset?.failBy5MaxHpReductionFormula ?? "").trim();
  if (failBy5MaxHpReductionFormula) failBy5Parts.push(`Reduce max HP by ${failBy5MaxHpReductionFormula} (temporary effect)`);

  const successiveFailParts = [];
  const successiveFailStatusLabel = getStatusLabelById(preset?.successiveFailStatusId);
  if (successiveFailStatusLabel) successiveFailParts.push(`Apply ${successiveFailStatusLabel}`);
  const successiveFailSlideFeet = Math.max(0, Number(preset?.successiveFailSlideFeet ?? 0) || 0);
  if (successiveFailSlideFeet > 0) successiveFailParts.push(`Slide ${successiveFailSlideFeet} ft`);
  const successiveFailExhaustion = Math.max(0, Number(preset?.successiveFailExhaustion ?? (preset?.movementCheck ? 1 : 0)) || 0);
  if (successiveFailExhaustion > 0) {
    const levelLabel = successiveFailExhaustion === 1 ? "level" : "levels";
    successiveFailParts.push(`+${successiveFailExhaustion} exhaustion ${levelLabel}`);
  }
  const successiveFailDamageFormula = String(preset?.successiveFailDamageFormula ?? "").trim();
  const successiveFailDamageType = String(preset?.successiveFailDamageType ?? "").trim();
  if (successiveFailDamageFormula) {
    successiveFailParts.push(`${successiveFailDamageFormula} ${successiveFailDamageType || "damage"}`.trim());
  }
  const successiveFailMaxHpReductionFormula = String(preset?.successiveFailMaxHpReductionFormula ?? "").trim();
  if (successiveFailMaxHpReductionFormula) {
    successiveFailParts.push(`Reduce max HP by ${successiveFailMaxHpReductionFormula} (temporary effect)`);
  }
  const successiveFailDaeChangeKey = String(preset?.successiveFailDaeChangeKey ?? "").trim();
  const successiveFailDaeChangeValue = String(preset?.successiveFailDaeChangeValue ?? "").trim();
  const successiveFailDaeChangeMode = Math.floor(Number(preset?.successiveFailDaeChangeMode ?? CONST.ACTIVE_EFFECT_MODES.ADD));
  if (successiveFailDaeChangeKey && successiveFailDaeChangeValue) {
    const modeLabel = getActiveEffectModeLabel(successiveFailDaeChangeMode);
    successiveFailParts.push(`DAE Change ${successiveFailDaeChangeKey} (${modeLabel}) = ${successiveFailDaeChangeValue}`);
  }

  const alwaysStatusLabel = getStatusLabelById(preset?.alwaysStatusId);

  return {
    onSuccess: preset?.movementCheck
      ? "No failure consequences are applied."
      : "No movement check required.",
    onFail: failParts.length > 0 ? failParts.join("; ") : "No additional failure consequence.",
    onFailBy5: failBy5Parts.length > 0 ? failBy5Parts.join("; ") : "No additional fail-by-5 consequence.",
    onSuccessiveFail: successiveFailParts.length > 0
      ? `On 2+ consecutive failures: ${successiveFailParts.join("; ")}`
      : "No additional consecutive-failure consequence.",
    alwaysOn: alwaysStatusLabel || "None"
  };
}

function getEnvironmentSuccessiveDefaults(preset) {
  return {
    statusId: String(preset?.successiveFailStatusId ?? "").trim(),
    slideFeet: Math.max(0, Number(preset?.successiveFailSlideFeet ?? 0) || 0),
    exhaustion: Math.max(0, Number(preset?.successiveFailExhaustion ?? (preset?.movementCheck ? 1 : 0)) || 0),
    damageFormula: String(preset?.successiveFailDamageFormula ?? "").trim(),
    damageType: String(preset?.successiveFailDamageType ?? "").trim(),
    maxHpReductionFormula: String(preset?.successiveFailMaxHpReductionFormula ?? "").trim(),
    daeChangeKey: String(preset?.successiveFailDaeChangeKey ?? "").trim(),
    daeChangeMode: Math.floor(Number(preset?.successiveFailDaeChangeMode ?? CONST.ACTIVE_EFFECT_MODES.ADD)),
    daeChangeValue: String(preset?.successiveFailDaeChangeValue ?? "").trim()
  };
}

function normalizeEnvironmentSuccessiveOverride(raw = {}) {
  const rawMode = Math.floor(Number(raw?.daeChangeMode ?? CONST.ACTIVE_EFFECT_MODES.ADD));
  const validModes = new Set(Object.values(CONST.ACTIVE_EFFECT_MODES ?? {}).map((value) => Number(value)));
  return {
    statusId: String(raw?.statusId ?? "").trim(),
    slideFeet: Math.max(0, Math.min(500, Math.floor(Number(raw?.slideFeet ?? 0) || 0))),
    exhaustion: Math.max(0, Math.min(6, Math.floor(Number(raw?.exhaustion ?? 0) || 0))),
    damageFormula: String(raw?.damageFormula ?? "").trim(),
    damageType: String(raw?.damageType ?? "").trim(),
    maxHpReductionFormula: String(raw?.maxHpReductionFormula ?? "").trim(),
    daeChangeKey: String(raw?.daeChangeKey ?? "").trim(),
    daeChangeMode: validModes.has(rawMode) ? rawMode : Number(CONST.ACTIVE_EFFECT_MODES.ADD),
    daeChangeValue: String(raw?.daeChangeValue ?? "").trim()
  };
}

function getEnvironmentSuccessiveConfig(environmentState, preset) {
  const defaults = getEnvironmentSuccessiveDefaults(preset);
  const presetKey = String(preset?.key ?? "none");
  const rawOverride = environmentState?.successiveByPreset?.[presetKey] ?? null;
  if (!rawOverride || typeof rawOverride !== "object") return defaults;
  const override = normalizeEnvironmentSuccessiveOverride(rawOverride);
  return {
    statusId: override.statusId,
    slideFeet: override.slideFeet,
    exhaustion: override.exhaustion,
    damageFormula: override.damageFormula,
    damageType: override.damageType,
    maxHpReductionFormula: override.maxHpReductionFormula,
    daeChangeKey: override.daeChangeKey,
    daeChangeMode: override.daeChangeMode,
    daeChangeValue: override.daeChangeValue
  };
}

function applyEnvironmentSuccessiveConfigToPreset(preset, environmentState) {
  if (!preset || typeof preset !== "object") return preset;
  const config = getEnvironmentSuccessiveConfig(environmentState, preset);
  return {
    ...preset,
    successiveFailStatusId: config.statusId,
    successiveFailSlideFeet: config.slideFeet,
    successiveFailExhaustion: config.exhaustion,
    successiveFailDamageFormula: config.damageFormula,
    successiveFailDamageType: config.damageType,
    successiveFailMaxHpReductionFormula: config.maxHpReductionFormula,
    successiveFailDaeChangeKey: config.daeChangeKey,
    successiveFailDaeChangeMode: config.daeChangeMode,
    successiveFailDaeChangeValue: config.daeChangeValue
  };
}

function ensureEnvironmentState(ledger) {
  if (!ledger.environment || typeof ledger.environment !== "object") {
    ledger.environment = {
      presetKey: "none",
      movementDc: 12,
      appliedActorIds: [],
      syncToSceneNonParty: true,
      note: "",
      logs: [],
      failureStreaks: {},
      checkResults: [],
      successiveByPreset: {}
    };
  }
  ledger.environment.presetKey = getEnvironmentPresetByKey(String(ledger.environment.presetKey ?? "none")).key;
  const dc = Number(ledger.environment.movementDc ?? 12);
  ledger.environment.movementDc = Number.isFinite(dc) ? Math.max(1, Math.min(30, Math.floor(dc))) : 12;
  if (!Array.isArray(ledger.environment.appliedActorIds)) ledger.environment.appliedActorIds = [];
  ledger.environment.appliedActorIds = ledger.environment.appliedActorIds
    .map((actorId) => String(actorId ?? "").trim())
    .filter((actorId, index, arr) => actorId && arr.indexOf(actorId) === index);
  ledger.environment.syncToSceneNonParty = ledger.environment.syncToSceneNonParty !== false;
  ledger.environment.note = String(ledger.environment.note ?? "");
  if (!ledger.environment.failureStreaks || typeof ledger.environment.failureStreaks !== "object") {
    ledger.environment.failureStreaks = {};
  }
  const normalizedFailureStreaks = {};
  for (const [actorIdRaw, streakRaw] of Object.entries(ledger.environment.failureStreaks)) {
    const actorId = String(actorIdRaw ?? "").trim();
    const streak = Number(streakRaw ?? 0);
    if (!actorId) continue;
    if (!Number.isFinite(streak) || streak <= 0) continue;
    normalizedFailureStreaks[actorId] = Math.max(1, Math.min(99, Math.floor(streak)));
  }
  ledger.environment.failureStreaks = normalizedFailureStreaks;
  if (!ledger.environment.successiveByPreset || typeof ledger.environment.successiveByPreset !== "object") {
    ledger.environment.successiveByPreset = {};
  }
  const normalizedSuccessiveByPreset = {};
  for (const [presetKeyRaw, overrideRaw] of Object.entries(ledger.environment.successiveByPreset)) {
    const presetKey = getEnvironmentPresetByKey(String(presetKeyRaw ?? "none")).key;
    if (presetKey === "none") continue;
    normalizedSuccessiveByPreset[presetKey] = normalizeEnvironmentSuccessiveOverride(overrideRaw);
  }
  ledger.environment.successiveByPreset = normalizedSuccessiveByPreset;
  if (!Array.isArray(ledger.environment.logs)) ledger.environment.logs = [];
  ledger.environment.logs = ledger.environment.logs
    .map((entry) => {
      const logType = String(entry?.logType ?? "environment").trim().toLowerCase() === "weather"
        ? "weather"
        : "environment";
      const createdAt = Number(entry?.createdAt ?? Date.now());
      if (logType === "weather") {
        return {
          id: String(entry?.id ?? foundry.utils.randomID()),
          logType,
          label: String(entry?.label ?? "Weather").trim() || "Weather",
          weatherId: String(entry?.weatherId ?? "").trim(),
          darkness: Number.isFinite(Number(entry?.darkness)) ? Math.max(0, Math.min(1, Number(entry.darkness))) : 0,
          visibilityModifier: Number.isFinite(Number(entry?.visibilityModifier)) ? Math.max(-5, Math.min(5, Math.floor(Number(entry.visibilityModifier)))) : 0,
          note: String(entry?.note ?? ""),
          daeChanges: Array.isArray(entry?.daeChanges)
            ? entry.daeChanges.map((change) => normalizeWeatherDaeChange(change)).filter((change) => change.key && change.value)
            : [],
          createdAt: Number.isFinite(createdAt) ? createdAt : Date.now(),
          createdBy: String(entry?.createdBy ?? "GM")
        };
      }
      const actorIds = Array.isArray(entry?.actorIds)
        ? entry.actorIds.map((actorId) => String(actorId ?? "").trim()).filter((actorId, index, arr) => actorId && arr.indexOf(actorId) === index)
        : [];
      const checkMeta = getEnvironmentCheckMeta(entry);
      return {
        id: String(entry?.id ?? foundry.utils.randomID()),
        logType,
        presetKey: getEnvironmentPresetByKey(String(entry?.presetKey ?? "none")).key,
        movementDc: Math.max(1, Math.min(30, Math.floor(Number(entry?.movementDc ?? 12) || 12))),
        actorIds,
        syncToSceneNonParty: entry?.syncToSceneNonParty !== false,
        note: String(entry?.note ?? ""),
        checkType: checkMeta.checkType,
        checkKey: checkMeta.checkKey,
        checkLabel: checkMeta.checkLabel,
        createdAt: Number.isFinite(createdAt) ? createdAt : Date.now(),
        createdBy: String(entry?.createdBy ?? "GM")
      };
    })
    .filter((entry, index, arr) => entry.id && arr.findIndex((candidate) => candidate.id === entry.id) === index);
  if (!Array.isArray(ledger.environment.checkResults)) ledger.environment.checkResults = [];
  ledger.environment.checkResults = ledger.environment.checkResults
    .map((entry) => {
      const createdAt = Number(entry?.createdAt ?? Date.now());
      const rollTotalRaw = Number(entry?.rollTotal);
      const dcRaw = Number(entry?.dc);
      const streakRaw = Number(entry?.streak ?? 0);
      const resultValue = String(entry?.result ?? "").toLowerCase() === "fail" ? "fail" : "pass";
      const outcomeSummary = String(entry?.outcomeSummary ?? "").trim();
      return {
        id: String(entry?.id ?? foundry.utils.randomID()),
        actorId: String(entry?.actorId ?? "").trim(),
        actorName: String(entry?.actorName ?? "").trim(),
        presetKey: getEnvironmentPresetByKey(String(entry?.presetKey ?? "none")).key,
        result: resultValue,
        rollTotal: Number.isFinite(rollTotalRaw) ? Math.floor(rollTotalRaw) : null,
        dc: Number.isFinite(dcRaw) ? Math.floor(dcRaw) : null,
        streak: Number.isFinite(streakRaw) ? Math.max(0, Math.min(99, Math.floor(streakRaw))) : 0,
        outcomeSummary,
        createdAt: Number.isFinite(createdAt) ? createdAt : Date.now(),
        createdBy: String(entry?.createdBy ?? "GM")
      };
    })
    .filter((entry, index, arr) => entry.id && arr.findIndex((candidate) => candidate.id === entry.id) === index)
    .slice(0, 100);
  return ledger.environment;
}

function formatSignedModifier(value) {
  const numeric = Number(value ?? 0);
  if (!Number.isFinite(numeric) || numeric === 0) return "0";
  return numeric > 0 ? `+${Math.floor(numeric)}` : String(Math.floor(numeric));
}

function buildInjuryStatusSummary(injury = {}) {
  const notes = String(injury.notes ?? "").trim();
  const effectText = String(injury.effect ?? "").trim();
  const stabilized = Boolean(injury.stabilized);
  const permanent = Boolean(injury.permanent);
  const recoveryDays = Math.max(0, Number(injury.recoveryDays ?? 0));
  const stateLabel = permanent ? "Permanent" : (stabilized ? "Stabilized" : "Unstable");
  const recoveryLabel = permanent ? "Permanent" : `${recoveryDays} day(s) remaining`;
  const summary = [effectText, `State: ${stateLabel}`, `Recovery: ${recoveryLabel}`, notes ? `Notes: ${notes}` : ""]
    .filter(Boolean)
    .join(" | ");
  return {
    effectText,
    notes,
    stateLabel,
    recoveryLabel,
    summary
  };
}

function isParsableUuid(value) {
  const text = String(value ?? "").trim();
  if (!text) return false;
  const parser = foundry?.utils?.parseUuid;
  if (typeof parser === "function") {
    try {
      parser(text);
      return true;
    } catch {
      return false;
    }
  }
  return !text.startsWith("module.") && text.includes(".");
}

function getEffectOriginForActor(actor) {
  const uuid = String(actor?.uuid ?? "").trim();
  return uuid && isParsableUuid(uuid) ? uuid : "";
}

function isMissingActiveEffectError(error) {
  const message = String(error?.message ?? error ?? "").toLowerCase();
  return message.includes("activeeffect") && message.includes("does not exist");
}

function logIntegrationEffectDebug(message, details = null) {
  if (!isModuleDebugEnabled()) return;
  if (details === null) {
    console.debug(`[${MODULE_ID}][integration-effects] ${message}`);
    return;
  }
  console.debug(`[${MODULE_ID}][integration-effects] ${message}`, details);
}

async function safeDeleteActiveEffect(actor, effect, contextLabel = "sync") {
  if (!actor || !effect?.id) return false;
  const actorId = String(actor.id ?? "");
  const effectId = String(effect.id ?? "");
  const lockKey = `${actorId}:${effectId}`;
  if (activeEffectDeleteLocks.has(lockKey)) {
    logIntegrationEffectDebug("Skipping duplicate ActiveEffect delete request.", { contextLabel, actorId, effectId });
    return true;
  }
  activeEffectDeleteLocks.add(lockKey);
  try {
    const liveEffect = actor.effects?.get(effectId);
    if (!liveEffect) {
      logIntegrationEffectDebug("ActiveEffect already missing before delete.", { contextLabel, actorId, effectId });
      return true;
    }
    const currentOrigin = String(liveEffect.origin ?? effect.origin ?? "").trim();
    const actorOrigin = getEffectOriginForActor(actor);
    if (actorOrigin && currentOrigin && !isParsableUuid(currentOrigin)) {
      try {
        await liveEffect.update({ origin: actorOrigin });
      } catch {
        // Continue with best-effort deletion.
      }
    }
    try {
      await actor.deleteEmbeddedDocuments("ActiveEffect", [liveEffect.id]);
      return true;
    } catch (error) {
      if (isMissingActiveEffectError(error)) {
        logIntegrationEffectDebug("ActiveEffect missing during primary delete call.", { contextLabel, actorId, effectId });
        return true;
      }
      try {
        await liveEffect.delete();
        return true;
      } catch (fallbackError) {
        if (isMissingActiveEffectError(fallbackError)) {
          logIntegrationEffectDebug("ActiveEffect missing during fallback delete call.", { contextLabel, actorId, effectId });
          return true;
        }
        console.warn(`${MODULE_ID}: failed to delete ${contextLabel} effect ${effectId}`, error);
        return false;
      }
    }
  } finally {
    activeEffectDeleteLocks.delete(lockKey);
  }
}

async function upsertManagedEffect(actor, existing, data, contextLabel = "sync") {
  if (!actor || !data) return;
  if (!existing) {
    logIntegrationEffectDebug("Creating managed ActiveEffect.", {
      contextLabel,
      actorId: String(actor.id ?? ""),
      name: String(data?.name ?? "")
    });
    await actor.createEmbeddedDocuments("ActiveEffect", [data]);
    return;
  }

  const normalizeManagedEffectData = (source) => {
    const moduleFlags = foundry.utils.deepClone(source?.flags?.[MODULE_ID] ?? {});
    if (moduleFlags && typeof moduleFlags === "object") delete moduleFlags.syncedAt;
    return {
      name: String(source?.name ?? ""),
      img: String(source?.img ?? ""),
      origin: String(source?.origin ?? ""),
      disabled: Boolean(source?.disabled),
      transfer: Boolean(source?.transfer),
      description: String(source?.description ?? ""),
      statuses: Array.isArray(source?.statuses) ? [...source.statuses] : [],
      changes: Array.isArray(source?.changes) ? foundry.utils.deepClone(source.changes) : [],
      flags: moduleFlags
    };
  };

  const existingComparable = normalizeManagedEffectData(existing?.toObject?.() ?? existing);
  const nextComparable = normalizeManagedEffectData(data);
  if (JSON.stringify(existingComparable) === JSON.stringify(nextComparable)) return;

  try {
    await existing.update(data);
  } catch (error) {
    if (!isMissingActiveEffectError(error)) throw error;
    logIntegrationEffectDebug("Stale ActiveEffect reference encountered during update; recreating.", {
      contextLabel,
      actorId: String(actor.id ?? ""),
      effectId: String(existing.id ?? ""),
      name: String(data?.name ?? "")
    });
    console.warn(`${MODULE_ID}: stale ${contextLabel} effect reference ${existing.id}; recreating.`);
    await actor.createEmbeddedDocuments("ActiveEffect", [data]);
  }
}

function buildIntegrationEffectData(payload, actor = null) {
  const mode = CONST.ACTIVE_EFFECT_MODES.OVERRIDE;
  const addMode = CONST.ACTIVE_EFFECT_MODES.ADD;
  const priority = 20;
  const initiativeBonus = Number(payload.operations?.minorInitiativeBonus ?? 0);
  const abilityCheckBonus = Number(payload.operations?.minorAbilityCheckBonus ?? 0);
  const perceptionBonus = Number(payload.operations?.minorPerceptionBonus ?? 0);
  const saveBonus = Number(payload.operations?.minorSavingThrowBonus ?? 0);

  const changes = [
    {
      key: `flags.${MODULE_ID}.ae.prepEdge`,
      mode,
      value: payload.operations.prepEdge ? "1" : "0",
      priority
    },
    {
      key: `flags.${MODULE_ID}.ae.riskTier`,
      mode,
      value: String(payload.operations.riskTier ?? "moderate"),
      priority
    },
    {
      key: `flags.${MODULE_ID}.ae.formation`,
      mode,
      value: String(payload.doctrine.formation ?? "default"),
      priority
    },
    {
      key: `flags.${MODULE_ID}.ae.marchingRank`,
      mode,
      value: String(payload.assignment.marchingRank ?? "unassigned"),
      priority
    },
    {
      key: `flags.${MODULE_ID}.ae.injured`,
      mode,
      value: payload.injury.active ? "1" : "0",
      priority
    }
  ];

  if (initiativeBonus !== 0) {
    changes.push({ key: "system.attributes.init.bonus", mode: addMode, value: formatSignedModifier(initiativeBonus), priority });
  }
  if (abilityCheckBonus !== 0) {
    changes.push({ key: "system.bonuses.abilities.check", mode: addMode, value: formatSignedModifier(abilityCheckBonus), priority });
  }
  if (perceptionBonus !== 0) {
    changes.push({ key: "system.skills.prc.bonuses.check", mode: addMode, value: formatSignedModifier(perceptionBonus), priority });
  }
  if (saveBonus !== 0) {
    changes.push({ key: "system.bonuses.abilities.save", mode: addMode, value: formatSignedModifier(saveBonus), priority });
  }

  const customDaeChanges = Array.isArray(payload.operations?.customDaeChanges)
    ? payload.operations.customDaeChanges
    : [];
  for (const entry of customDaeChanges) {
    const key = String(entry?.key ?? "").trim();
    const value = String(entry?.value ?? "").trim();
    if (!key || !value) continue;
    const rawMode = Math.floor(Number(entry?.mode ?? addMode));
    const validModes = new Set(Object.values(CONST.ACTIVE_EFFECT_MODES ?? {}).map((modeValue) => Number(modeValue)));
    const mode = validModes.has(rawMode) ? rawMode : addMode;
    changes.push({ key, mode, value, priority });
  }

  const data = {
    name: INTEGRATION_EFFECT_NAME,
    img: "icons/svg/aura.svg",
    disabled: false,
    transfer: false,
    duration: {
      startTime: game.time?.worldTime ?? 0
    },
    changes,
    flags: {
      [MODULE_ID]: {
        integration: true
      }
    }
  };
  const origin = getEffectOriginForActor(actor);
  if (origin) data.origin = origin;
  return data;
}

function buildInjuryStatusEffectData(payload, actor = null) {
  const mode = CONST.ACTIVE_EFFECT_MODES.OVERRIDE;
  const priority = 20;
  const injury = payload?.injury ?? {};
  const injuryName = String(injury.name ?? "Injury").trim() || "Injury";
  const status = buildInjuryStatusSummary(injury);
  const notes = status.notes;
  const effectText = status.effectText;
  const stabilized = Boolean(injury.stabilized);
  const permanent = Boolean(injury.permanent);
  const recoveryDays = Math.max(0, Number(injury.recoveryDays ?? 0));
  const stateLabel = status.stateLabel;
  const recoveryLabel = status.recoveryLabel;
  const icon = permanent
    ? "icons/svg/skull.svg"
    : (stabilized ? "icons/svg/regen.svg" : "icons/svg/hazard.svg");

  const data = {
    name: `${INJURY_EFFECT_NAME_PREFIX} ${injuryName}`,
    img: icon,
    disabled: false,
    transfer: false,
    description: status.summary,
    duration: {
      startTime: game.time?.worldTime ?? 0
    },
    changes: [
      {
        key: `flags.${MODULE_ID}.ae.injuryName`,
        mode,
        value: injuryName,
        priority
      },
      {
        key: `flags.${MODULE_ID}.ae.injuryState`,
        mode,
        value: stateLabel,
        priority
      },
      {
        key: `flags.${MODULE_ID}.ae.injuryRecovery`,
        mode,
        value: recoveryLabel,
        priority
      }
    ],
    flags: {
      [MODULE_ID]: {
        injuryStatus: true,
        injury: {
          name: injuryName,
          effect: effectText,
          notes,
          stabilized,
          permanent,
          recoveryDays
        }
      }
    }
  };
  const origin = getEffectOriginForActor(actor);
  if (origin) data.origin = origin;
  return data;
}

function buildEnvironmentStatusEffectData(payload, actor = null) {
  const mode = CONST.ACTIVE_EFFECT_MODES.OVERRIDE;
  const addMode = CONST.ACTIVE_EFFECT_MODES.ADD;
  const priority = 20;
  const environment = payload?.environment ?? {};
  const label = String(environment.label ?? "Environment").trim() || "Environment";
  const icon = String(getEnvironmentPresetByKey(environment.presetKey).icon ?? "icons/svg/hazard.svg");
  const movementCheck = Boolean(environment.movementCheck);
  const check = getEnvironmentCheckMeta(environment);
  const description = movementCheck
    ? `${label} active. Movement checks required (${check.checkLabel || "check"}).`
    : `${label} active.`;

  const changes = [
    {
      key: `flags.${MODULE_ID}.ae.environmentPreset`,
      mode,
      value: String(environment.presetKey ?? "none"),
      priority
    },
    {
      key: `flags.${MODULE_ID}.ae.environmentActive`,
      mode,
      value: "1",
      priority
    }
  ];

  const preset = getEnvironmentPresetByKey(environment.presetKey);
  const alwaysStatusId = String(preset.alwaysStatusId ?? "").trim();
  for (const effectChange of preset.effectChanges ?? []) {
    if (!effectChange?.key || effectChange?.value === undefined || effectChange?.value === null) continue;
    changes.push({
      key: effectChange.key,
      mode: addMode,
      value: String(effectChange.value),
      priority
    });
  }

  const data = {
    name: `${ENVIRONMENT_EFFECT_NAME_PREFIX} ${label}`,
    img: icon,
    disabled: false,
    transfer: false,
    description,
    duration: {
      startTime: game.time?.worldTime ?? 0
    },
    statuses: alwaysStatusId ? [alwaysStatusId] : [],
    changes,
    flags: {
      [MODULE_ID]: {
        environmentStatus: true,
        environment: {
          presetKey: String(environment.presetKey ?? "none"),
          label,
          movementCheck,
          alwaysStatusId,
          checkType: check.checkType,
          checkKey: check.checkKey,
          checkSkill: check.checkType === "skill" ? check.checkKey : "",
          checkLabel: check.checkLabel
        }
      }
    }
  };
  const origin = getEffectOriginForActor(actor);
  if (origin) data.origin = origin;
  return data;
}

async function upsertIntegrationEffect(actor, payload) {
  const existing = getIntegrationEffect(actor);
  const data = buildIntegrationEffectData(payload, actor);
  await upsertManagedEffect(actor, existing, data, "integration");
}

async function removeIntegrationEffect(actor) {
  const existing = getIntegrationEffect(actor);
  if (!existing) return;
  await safeDeleteActiveEffect(actor, existing, "integration");
}

async function upsertInjuryStatusEffect(actor, payload) {
  const existing = getInjuryStatusEffect(actor);
  const injuryActive = Boolean(payload?.injury?.active);
  if (!injuryActive) {
    if (existing) await safeDeleteActiveEffect(actor, existing, "injury");
    return;
  }
  const data = buildInjuryStatusEffectData(payload, actor);
  await upsertManagedEffect(actor, existing, data, "injury");
}

async function removeInjuryStatusEffect(actor) {
  const existing = getInjuryStatusEffect(actor);
  if (!existing) return;
  await safeDeleteActiveEffect(actor, existing, "injury");
}

async function upsertEnvironmentStatusEffect(actor, payload) {
  const existing = getEnvironmentStatusEffect(actor);
  const active = Boolean(payload?.environment?.active);
  if (!active) {
    if (existing) await safeDeleteActiveEffect(actor, existing, "environment");
    return;
  }
  const data = buildEnvironmentStatusEffectData(payload, actor);
  await upsertManagedEffect(actor, existing, data, "environment");
}

async function removeEnvironmentStatusEffect(actor) {
  const existing = getEnvironmentStatusEffect(actor);
  if (!existing) return;
  await safeDeleteActiveEffect(actor, existing, "environment");
}

async function applyActorIntegrationPayload(actor, payload, resolvedMode) {
  const currentPayload = actor.getFlag(MODULE_ID, "sync") ?? null;
  const currentMode = String(actor.getFlag(MODULE_ID, "syncMode") ?? "");
  const nextMode = String(resolvedMode ?? "");
  const payloadChanged = JSON.stringify(currentPayload ?? null) !== JSON.stringify(payload ?? null);
  const modeChanged = currentMode !== nextMode;

  if (payloadChanged || modeChanged) {
    await actor.update({
      [`flags.${MODULE_ID}.sync`]: payload,
      [`flags.${MODULE_ID}.syncMode`]: resolvedMode
    });
  }

  await upsertIntegrationEffect(actor, payload);
  await upsertInjuryStatusEffect(actor, payload);
  await upsertEnvironmentStatusEffect(actor, payload);
}

async function clearActorIntegrationPayload(actor) {
  await removeIntegrationEffect(actor);
  await removeInjuryStatusEffect(actor);
  await removeEnvironmentStatusEffect(actor);
  await actor.update({
    [`flags.${MODULE_ID}.-=sync`]: null,
    [`flags.${MODULE_ID}.-=syncMode`]: null,
    [`flags.${MODULE_ID}.-=ae`]: null,
    [`flags.${MODULE_ID}.-=injury`]: null,
    [`flags.${MODULE_ID}.-=environment`]: null
  });
}

function getSceneNonPartySyncConfig(globalContext) {
  const context = globalContext ?? buildIntegrationGlobalContext();
  const partyHealth = context.operations?.partyHealth ?? {};
  const environment = context.operations?.environment ?? {};
  const scope = getNonPartySyncScope(partyHealth.nonPartySyncScope);
  const syncWorldGlobal = Boolean(partyHealth.syncToSceneNonParty);
  const syncEnvironment = Boolean(environment.syncToSceneNonParty && String(environment.presetKey ?? "none") !== "none");
  return {
    context,
    scope,
    scopeLabel: getNonPartySyncScopeLabel(scope),
    syncWorldGlobal,
    syncEnvironment,
    enabled: syncWorldGlobal || syncEnvironment
  };
}

async function syncSingleSceneNonPartyActor(actor, globalContext, resolvedMode, options = {}) {
  if (!actor) return { synced: false, cleared: false, skipped: true, enabled: false };
  const mode = resolvedMode ?? resolveIntegrationMode();
  const config = getSceneNonPartySyncConfig(globalContext);
  const enabled = Boolean(config.enabled);

  if (!enabled || mode === INTEGRATION_MODES.OFF) {
    const hasSync = Boolean(actor.getFlag(MODULE_ID, "sync"));
    const hasEffect = Boolean(getIntegrationEffect(actor));
    const hasInjuryEffect = Boolean(getInjuryStatusEffect(actor));
    const hasEnvironmentEffect = Boolean(getEnvironmentStatusEffect(actor));
    if (hasSync || hasEffect || hasInjuryEffect || hasEnvironmentEffect) {
      await clearActorIntegrationPayload(actor);
      return { synced: false, cleared: true, skipped: false, enabled };
    }
    return { synced: false, cleared: false, skipped: true, enabled };
  }

  const applyAsNonParty = options?.nonParty === false ? false : true;
  const payload = buildActorIntegrationPayload(actor.id, config.context, {
    nonParty: applyAsNonParty,
    includeWorldGlobal: config.syncWorldGlobal,
    forceEnvironmentApply: config.syncEnvironment && options.includeEnvironment === true
  });
  await applyActorIntegrationPayload(actor, payload, mode);
  return { synced: true, cleared: false, skipped: false, enabled };
}

async function syncSceneNonPartyIntegrationActors(globalContext, resolvedMode, options = {}) {
  if (!canAccessAllPlayerOps()) {
    return {
      synced: 0,
      cleared: 0,
      total: 0,
      enabled: false,
      scope: NON_PARTY_SYNC_SCOPES.SCENE,
      scopeLabel: getNonPartySyncScopeLabel(NON_PARTY_SYNC_SCOPES.SCENE),
      managedActorIds: []
    };
  }
  const mode = resolvedMode ?? resolveIntegrationMode();
  const config = getSceneNonPartySyncConfig(globalContext);
  const scope = getNonPartySyncScope(options.scope ?? config.scope);
  const targets = getNonPartyIntegrationTargets(scope);
  let synced = 0;
  let cleared = 0;
  const managedActorIds = new Set();

  for (const target of targets) {
    const actor = target?.actor;
    if (!actor) continue;
    const result = await syncSingleSceneNonPartyActor(actor, config.context, mode, {
      includeEnvironment: target.isSceneTarget === true,
      nonParty: true
    });
    if (result.synced) synced += 1;
    if (result.cleared) cleared += 1;
    if (result.synced) {
      const actorId = String(actor?.id ?? "").trim();
      if (actorId) managedActorIds.add(actorId);
    }
  }

  return {
    synced,
    cleared,
    total: targets.length,
    enabled: Boolean(config.enabled),
    scope,
    scopeLabel: getNonPartySyncScopeLabel(scope),
    managedActorIds: Array.from(managedActorIds)
  };
}

async function syncIntegrationState() {
  if (!canAccessAllPlayerOps()) return;

  const resolvedMode = resolveIntegrationMode();
  const trackedActors = collectIntegrationActorIds();
  const trackedIds = new Set(trackedActors.map((actor) => actor.id));

  if (resolvedMode === INTEGRATION_MODES.OFF) {
    const actorsToClear = game.actors.contents.filter((actor) => {
      if (!isTrackableCharacter(actor)) return false;
      const hasSync = Boolean(actor.getFlag(MODULE_ID, "sync"));
      const hasEffect = Boolean(getIntegrationEffect(actor));
      const hasInjuryEffect = Boolean(getInjuryStatusEffect(actor));
      const hasEnvironmentEffect = Boolean(getEnvironmentStatusEffect(actor));
      return hasSync || hasEffect || hasInjuryEffect || hasEnvironmentEffect;
    });
    for (const actor of actorsToClear) {
      await clearActorIntegrationPayload(actor);
    }
    await syncSceneNonPartyIntegrationActors(null, resolvedMode);
    return;
  }

  const globalContext = buildIntegrationGlobalContext();
  const nonPartySyncResult = await syncSceneNonPartyIntegrationActors(globalContext, resolvedMode);
  const nonPartyManagedActorIds = new Set(
    Array.isArray(nonPartySyncResult?.managedActorIds) ? nonPartySyncResult.managedActorIds : []
  );
  for (const actor of trackedActors) {
    const payload = buildActorIntegrationPayload(actor.id, globalContext);
    await applyActorIntegrationPayload(actor, payload, resolvedMode);
  }

  const staleActors = game.actors.contents.filter((actor) => {
    if (!isTrackableCharacter(actor)) return false;
    if (trackedIds.has(actor.id)) return false;
    if (nonPartyManagedActorIds.has(String(actor.id ?? ""))) return false;
    const hasSync = Boolean(actor.getFlag(MODULE_ID, "sync"));
    const hasEffect = Boolean(getIntegrationEffect(actor));
    const hasInjuryEffect = Boolean(getInjuryStatusEffect(actor));
    const hasEnvironmentEffect = Boolean(getEnvironmentStatusEffect(actor));
    return hasSync || hasEffect || hasInjuryEffect || hasEnvironmentEffect;
  });

  for (const actor of staleActors) {
    await clearActorIntegrationPayload(actor);
  }
}

function scheduleIntegrationSync(reason = "") {
  if (!game.user?.isGM) return;
  integrationSyncQueuedReason = String(reason ?? "").trim();
  integrationSyncQueued = true;
  if (integrationSyncInFlight) return;
  if (integrationSyncTimeoutId) clearTimeout(integrationSyncTimeoutId);
  integrationSyncTimeoutId = setTimeout(() => {
    integrationSyncTimeoutId = null;
    void flushIntegrationSyncQueue(reason);
  }, 100);
}

function resolveIntegrationSyncWaiters() {
  if (!integrationSyncWaiters.length) return;
  const waiters = integrationSyncWaiters.splice(0, integrationSyncWaiters.length);
  for (const resolve of waiters) {
    try {
      resolve();
    } catch {
      // Ignore waiter resolution failures.
    }
  }
}

async function flushIntegrationSyncQueue(reason = "") {
  if (!game.user?.isGM) return;
  const requestedReason = String(reason ?? "").trim();
  if (requestedReason) integrationSyncQueuedReason = requestedReason;
  integrationSyncQueued = true;
  if (integrationSyncTimeoutId) {
    clearTimeout(integrationSyncTimeoutId);
    integrationSyncTimeoutId = null;
  }
  if (integrationSyncInFlight) {
    await new Promise((resolve) => integrationSyncWaiters.push(resolve));
    return;
  }

  integrationSyncInFlight = true;
  try {
    do {
      const runReason = integrationSyncQueuedReason || requestedReason;
      integrationSyncQueuedReason = "";
      integrationSyncQueued = false;
      logIntegrationEffectDebug("Running integration sync pass.", { reason: runReason || "unspecified" });
      try {
        await syncIntegrationState();
      } catch (error) {
        console.warn(`${MODULE_ID}: integration sync failed (${runReason})`, error);
      }
    } while (integrationSyncQueued);
  } finally {
    integrationSyncInFlight = false;
    logIntegrationEffectDebug("Integration sync queue drained.");
    resolveIntegrationSyncWaiters();
  }
}

function getGmPanelTabStorageKey() {
  return `po-gm-panel-tab-${game.user?.id ?? "anon"}`;
}

function getActiveGmPanelTab() {
  const stored = sessionStorage.getItem(getGmPanelTabStorageKey());
  return stored === "operations" ? "operations" : "core";
}

function setActiveGmPanelTab(tab) {
  const value = tab === "operations" ? "operations" : "core";
  sessionStorage.setItem(getGmPanelTabStorageKey(), value);
}

function getRestMainTabStorageKey() {
  return `po-rest-main-tab-${game.user?.id ?? "anon"}`;
}

function getActiveRestMainTab() {
  const stored = normalizeMainTabId(sessionStorage.getItem(getRestMainTabStorageKey()), "rest-watch");
  if (stored === "gm" && canAccessAllPlayerOps()) return "gm";
  if (stored === "operations") return "operations";
  return "rest-watch";
}

function setActiveRestMainTab(tab) {
  const normalized = normalizeMainTabId(tab, "rest-watch");
  const value = normalized === "gm" && canAccessAllPlayerOps()
    ? "gm"
    : (normalized === "operations" ? "operations" : "rest-watch");
  sessionStorage.setItem(getRestMainTabStorageKey(), value);
}

function getRestMainTabLabel(tab = getActiveRestMainTab()) {
  const value = String(tab ?? "").trim().toLowerCase();
  if (value === "gm") return "GM";
  if (value === "operations") return "Operations";
  return "Rest Watch";
}

function getRestMainWindowTitle(tab = getActiveRestMainTab()) {
  return `Party Operations - ${getRestMainTabLabel(tab)}`;
}

function syncApplicationWindowTitle(app, title) {
  const label = String(title ?? "").trim();
  if (!app || !label) return;
  if (app.options?.window) app.options.window.title = label;
  const root = getAppRootElement(app);
  const frame = root?.closest?.(".application, .app") ?? null;
  const titleNode = frame?.querySelector?.(".window-title, .window-header .title") ?? null;
  if (titleNode) titleNode.textContent = label;
}

function getOperationsPageStorageKey() {
  return `po-operations-page-${game.user?.id ?? "anon"}`;
}

function getActiveOperationsPage() {
  const allowed = new Set(["planning", "readiness", "comms", "reputation", "base", "merchants", "downtime", "recovery", "gm"]);
  const stored = sessionStorage.getItem(getOperationsPageStorageKey()) ?? "planning";
  if (stored === "supply") return "base";
  if (stored === "gm" && !canAccessAllPlayerOps()) return "planning";
  return allowed.has(stored) ? stored : "planning";
}

function setActiveOperationsPage(page) {
  if (page === "supply") page = "base";
  const allowed = new Set(["planning", "readiness", "comms", "reputation", "base", "merchants", "downtime", "recovery", "gm"]);
  if (page === "gm" && !canAccessAllPlayerOps()) page = "planning";
  const value = allowed.has(page) ? page : "planning";
  sessionStorage.setItem(getOperationsPageStorageKey(), value);
}

function getOperationsPlanningTabStorageKey() {
  return `po-operations-planning-tab-${game.user?.id ?? "anon"}`;
}

function getReputationFilterStorageKey() {
  return `po-reputation-filter-${game.user?.id ?? "anon"}`;
}

function getReputationNoteLogSelectionStorageKey() {
  return `po-reputation-note-log-selection-${game.user?.id ?? "anon"}`;
}

function getReputationNoteLogSelections() {
  const raw = sessionStorage.getItem(getReputationNoteLogSelectionStorageKey());
  if (!raw) return {};
  try {
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) return {};
    const normalized = {};
    for (const [factionId, logId] of Object.entries(parsed)) {
      const key = String(factionId ?? "").trim();
      if (!key) continue;
      const value = String(logId ?? "").trim();
      if (!value) continue;
      normalized[key] = value;
    }
    return normalized;
  } catch {
    return {};
  }
}

function setReputationNoteLogSelection(factionIdInput, logIdInput) {
  const factionId = String(factionIdInput ?? "").trim();
  if (!factionId) return "";
  const logId = String(logIdInput ?? "").trim();
  const state = getReputationNoteLogSelections();
  if (!logId) {
    delete state[factionId];
  } else {
    state[factionId] = logId;
  }
  sessionStorage.setItem(getReputationNoteLogSelectionStorageKey(), JSON.stringify(state));
  return logId;
}

function getReputationNoteLogSelection(factionIdInput) {
  const factionId = String(factionIdInput ?? "").trim();
  if (!factionId) return "";
  const state = getReputationNoteLogSelections();
  return String(state[factionId] ?? "").trim();
}

function getGatherHistoryViewStorageKey() {
  return `po-gather-history-view-${game.user?.id ?? "anon"}`;
}

function normalizeGatherHistorySort(value) {
  const normalized = String(value ?? "").trim().toLowerCase();
  const allowed = new Set(GATHER_HISTORY_SORT_OPTIONS.map((entry) => entry.value));
  return allowed.has(normalized) ? normalized : "newest";
}

function normalizeGatherHistoryResultFilter(value) {
  const normalized = String(value ?? "").trim().toLowerCase();
  const allowed = new Set(GATHER_HISTORY_RESULT_FILTER_OPTIONS.map((entry) => entry.value));
  return allowed.has(normalized) ? normalized : "all";
}

function normalizeGatherHistoryResourceFilter(value) {
  const normalized = String(value ?? "").trim().toLowerCase();
  const allowed = new Set(GATHER_HISTORY_RESOURCE_FILTER_OPTIONS.map((entry) => entry.value));
  return allowed.has(normalized) ? normalized : "all";
}

function normalizeGatherHistoryEnvironmentFilter(value) {
  const normalized = String(value ?? "").trim().toLowerCase();
  if (normalized === "all") return "all";
  return GATHER_ENVIRONMENT_KEYS.includes(normalized) ? normalized : "all";
}

function normalizeGatherHistoryActorFilter(value) {
  const normalized = String(value ?? "").trim().toLowerCase().slice(0, 120);
  return normalized || "all";
}

function normalizeGatherHistorySearch(value) {
  return String(value ?? "").replace(/\s+/g, " ").trim().slice(0, 120);
}

function getGatherHistoryViewState() {
  const fallback = {
    search: "",
    result: "all",
    resource: "all",
    environment: "all",
    actor: "all",
    sort: "newest"
  };
  const raw = sessionStorage.getItem(getGatherHistoryViewStorageKey());
  if (!raw) return fallback;
  try {
    const parsed = JSON.parse(raw);
    return {
      search: normalizeGatherHistorySearch(parsed?.search),
      result: normalizeGatherHistoryResultFilter(parsed?.result),
      resource: normalizeGatherHistoryResourceFilter(parsed?.resource),
      environment: normalizeGatherHistoryEnvironmentFilter(parsed?.environment),
      actor: normalizeGatherHistoryActorFilter(parsed?.actor),
      sort: normalizeGatherHistorySort(parsed?.sort)
    };
  } catch (_error) {
    return fallback;
  }
}

function setGatherHistoryViewState(patch = {}) {
  const previous = getGatherHistoryViewState();
  const next = {
    search: patch?.search === undefined ? previous.search : normalizeGatherHistorySearch(patch.search),
    result: patch?.result === undefined ? previous.result : normalizeGatherHistoryResultFilter(patch.result),
    resource: patch?.resource === undefined ? previous.resource : normalizeGatherHistoryResourceFilter(patch.resource),
    environment: patch?.environment === undefined ? previous.environment : normalizeGatherHistoryEnvironmentFilter(patch.environment),
    actor: patch?.actor === undefined ? previous.actor : normalizeGatherHistoryActorFilter(patch.actor),
    sort: patch?.sort === undefined ? previous.sort : normalizeGatherHistorySort(patch.sort)
  };
  sessionStorage.setItem(getGatherHistoryViewStorageKey(), JSON.stringify(next));
  return next;
}

function getReputationFilterState() {
  const defaults = { keyword: "", standing: "all" };
  const raw = sessionStorage.getItem(getReputationFilterStorageKey());
  if (!raw) return defaults;
  try {
    const parsed = JSON.parse(raw);
    return {
      keyword: String(parsed?.keyword ?? ""),
      standing: String(parsed?.standing ?? "all")
    };
  } catch (_error) {
    return defaults;
  }
}

function setReputationFilterState(patch = {}) {
  const previous = getReputationFilterState();
  const next = {
    keyword: String(patch.keyword ?? previous.keyword ?? ""),
    standing: String(patch.standing ?? previous.standing ?? "all")
  };
  sessionStorage.setItem(getReputationFilterStorageKey(), JSON.stringify(next));
}

function getLootPackSourcesUiStorageKey() {
  return `po-loot-pack-sources-ui-${game.user?.id ?? "anon"}`;
}

function normalizeLootPackSourcesFilter(value) {
  return String(value ?? "").replace(/\s+/g, " ").trim().slice(0, 120);
}

function getLootPackSourcesUiState() {
  const defaults = { collapsed: false, filter: "" };
  const raw = sessionStorage.getItem(getLootPackSourcesUiStorageKey());
  if (!raw) return defaults;
  try {
    const parsed = JSON.parse(raw);
    return {
      collapsed: Boolean(parsed?.collapsed),
      filter: normalizeLootPackSourcesFilter(parsed?.filter)
    };
  } catch (_error) {
    return defaults;
  }
}

function setLootPackSourcesUiState(patch = {}) {
  const previous = getLootPackSourcesUiState();
  const next = {
    collapsed: (patch?.collapsed === undefined) ? previous.collapsed : Boolean(patch.collapsed),
    filter: (patch?.filter === undefined) ? previous.filter : normalizeLootPackSourcesFilter(patch.filter)
  };
  sessionStorage.setItem(getLootPackSourcesUiStorageKey(), JSON.stringify(next));
}

function getLootClaimActorStorageKey() {
  return `po-loot-claim-actor-${game.user?.id ?? "anon"}`;
}

function getLootClaimRunStorageKey() {
  return `po-loot-claim-run-${game.user?.id ?? "anon"}`;
}

function getLootClaimsArchiveSortStorageKey() {
  return `po-loot-claim-archive-sort-${game.user?.id ?? "anon"}`;
}

function normalizeLootClaimActorId(value) {
  return String(value ?? "").trim();
}

function normalizeLootClaimRunId(value) {
  return String(value ?? "").trim();
}

function normalizeLootClaimsArchiveSort(value) {
  const normalized = String(value ?? "").trim().toLowerCase();
  const allowed = new Set(LOOT_CLAIMS_ARCHIVE_SORT_OPTIONS.map((entry) => entry.value));
  return allowed.has(normalized) ? normalized : "archived-desc";
}

function getLootClaimActorSelection() {
  return normalizeLootClaimActorId(sessionStorage.getItem(getLootClaimActorStorageKey()));
}

function getLootClaimRunSelection() {
  return normalizeLootClaimRunId(sessionStorage.getItem(getLootClaimRunStorageKey()));
}

function getLootClaimsArchiveSort() {
  return normalizeLootClaimsArchiveSort(sessionStorage.getItem(getLootClaimsArchiveSortStorageKey()));
}

function setLootClaimActorSelection(actorIdInput) {
  const actorId = normalizeLootClaimActorId(actorIdInput);
  if (!actorId) {
    sessionStorage.removeItem(getLootClaimActorStorageKey());
    return "";
  }
  sessionStorage.setItem(getLootClaimActorStorageKey(), actorId);
  return actorId;
}

function setLootClaimRunSelection(runIdInput) {
  const runId = normalizeLootClaimRunId(runIdInput);
  if (!runId) {
    sessionStorage.removeItem(getLootClaimRunStorageKey());
    return "";
  }
  sessionStorage.setItem(getLootClaimRunStorageKey(), runId);
  return runId;
}

function setLootClaimsArchiveSort(sortInput) {
  const sort = normalizeLootClaimsArchiveSort(sortInput);
  sessionStorage.setItem(getLootClaimsArchiveSortStorageKey(), sort);
  return sort;
}

function setLootClaimActorSelectionFromElement(element) {
  const nextActorId = normalizeLootClaimActorId(element?.value);
  const currentActorId = getLootClaimActorSelection();
  if (nextActorId === currentActorId) return false;
  setLootClaimActorSelection(nextActorId);
  return true;
}

function getMerchantActorStorageKey() {
  return `po-merchant-actor-${game.user?.id ?? "anon"}`;
}

function normalizeMerchantActorId(value) {
  return String(value ?? "").trim();
}

function getSelectedMerchantActorId() {
  return normalizeMerchantActorId(sessionStorage.getItem(getMerchantActorStorageKey()));
}

function setSelectedMerchantActorId(actorIdInput) {
  const actorId = normalizeMerchantActorId(actorIdInput);
  if (!actorId) {
    sessionStorage.removeItem(getMerchantActorStorageKey());
    return "";
  }
  sessionStorage.setItem(getMerchantActorStorageKey(), actorId);
  return actorId;
}

function setSelectedMerchantActorFromElement(element) {
  const nextActorId = normalizeMerchantActorId(element?.value);
  const currentActorId = getSelectedMerchantActorId();
  if (nextActorId === currentActorId) return false;
  setSelectedMerchantActorId(nextActorId);
  return true;
}

function getMerchantSettlementStorageKey() {
  return `po-merchant-settlement-${game.user?.id ?? "anon"}`;
}

function getMerchantSettlementAllValue() {
  return "__all__";
}

function normalizeMerchantSettlementSelection(value) {
  const settlement = String(value ?? "").trim().slice(0, 120);
  if (!settlement) return "";
  return settlement.toLowerCase() === "global" ? "" : settlement;
}

function hasSelectedMerchantSettlementPreference() {
  return sessionStorage.getItem(getMerchantSettlementStorageKey()) !== null;
}

function getSelectedMerchantSettlement() {
  const stored = sessionStorage.getItem(getMerchantSettlementStorageKey());
  if (stored === getMerchantSettlementAllValue()) return "";
  return normalizeMerchantSettlementSelection(stored);
}

function setSelectedMerchantSettlement(settlementInput) {
  const settlement = normalizeMerchantSettlementSelection(settlementInput);
  if (!settlement) {
    sessionStorage.setItem(getMerchantSettlementStorageKey(), getMerchantSettlementAllValue());
    return "";
  }
  sessionStorage.setItem(getMerchantSettlementStorageKey(), settlement);
  return settlement;
}

function setSelectedMerchantSettlementFromElement(element) {
  const nextSettlement = normalizeMerchantSettlementSelection(element?.value);
  const currentSettlement = hasSelectedMerchantSettlementPreference()
    ? getSelectedMerchantSettlement()
    : normalizeMerchantSettlementSelection(getOperationsLedger()?.merchants?.currentSettlement ?? "");
  if (nextSettlement === currentSettlement) return false;
  setSelectedMerchantSettlement(nextSettlement);
  return true;
}

function getMerchantTabStorageKey() {
  return `po-merchant-tab-${game.user?.id ?? "anon"}`;
}

function normalizeMerchantTabId(value) {
  return String(value ?? "").trim();
}

function getSelectedMerchantTabId() {
  return normalizeMerchantTabId(sessionStorage.getItem(getMerchantTabStorageKey()));
}

function setSelectedMerchantTabId(merchantIdInput) {
  const merchantId = normalizeMerchantTabId(merchantIdInput);
  if (!merchantId) {
    sessionStorage.removeItem(getMerchantTabStorageKey());
    return "";
  }
  sessionStorage.setItem(getMerchantTabStorageKey(), merchantId);
  return merchantId;
}

function setSelectedMerchantTabIdFromElement(element) {
  const nextMerchantId = normalizeMerchantTabId(element?.dataset?.merchantId ?? element?.value);
  const currentMerchantId = getSelectedMerchantTabId();
  if (nextMerchantId === currentMerchantId) return false;
  setSelectedMerchantTabId(nextMerchantId);
  return true;
}

function getMerchantEditorStorageKey() {
  return `po-merchant-editor-${game.user?.id ?? "anon"}`;
}

function getMerchantEditorSelection() {
  return String(sessionStorage.getItem(getMerchantEditorStorageKey()) ?? "").trim();
}

function setMerchantEditorSelection(merchantIdInput) {
  const merchantId = String(merchantIdInput ?? "").trim();
  const previous = getMerchantEditorSelection();
  if (!merchantId) {
    sessionStorage.removeItem(getMerchantEditorStorageKey());
    clearMerchantEditorDraftState();
    return "";
  }
  sessionStorage.setItem(getMerchantEditorStorageKey(), merchantId);
  if (merchantId !== previous) clearMerchantEditorDraftState();
  return merchantId;
}

function getMerchantEditorDraftStorageKey() {
  return `po-merchant-editor-draft-${game.user?.id ?? "anon"}`;
}

function normalizeMerchantEditorSelectionKey(value) {
  const normalized = String(value ?? "").trim();
  return normalized || "__new__";
}

function getMerchantEditorDraftState() {
  const raw = sessionStorage.getItem(getMerchantEditorDraftStorageKey());
  if (!raw) return null;
  try {
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") return null;
    const selectionKey = normalizeMerchantEditorSelectionKey(parsed.selectionKey);
    const draft = getMerchantDefinitionDraftSource(parsed.draft ?? {});
    if (selectionKey === "__new__") draft.id = "";
    return { selectionKey, draft };
  } catch (_error) {
    return null;
  }
}

function setMerchantEditorDraftState(selectionKeyInput, draftInput = {}) {
  const selectionKey = normalizeMerchantEditorSelectionKey(selectionKeyInput);
  const draft = getMerchantDefinitionDraftSource(draftInput ?? {});
  if (selectionKey === "__new__") draft.id = "";
  sessionStorage.setItem(getMerchantEditorDraftStorageKey(), JSON.stringify({
    selectionKey,
    draft
  }));
  return { selectionKey, draft };
}

function clearMerchantEditorDraftState() {
  sessionStorage.removeItem(getMerchantEditorDraftStorageKey());
}

function getMerchantEditorViewTabStorageKey() {
  return `po-merchant-editor-view-tab-${game.user?.id ?? "anon"}`;
}

function normalizeMerchantEditorViewTab(value, fallback = "editor") {
  const normalized = String(value ?? "").trim().toLowerCase();
  if (normalized === "settings") return "settings";
  if (normalized === "editor") return "editor";
  return normalizeMerchantEditorViewTab(fallback, "editor");
}

function getMerchantEditorViewTab() {
  return normalizeMerchantEditorViewTab(sessionStorage.getItem(getMerchantEditorViewTabStorageKey()), "editor");
}

function setMerchantEditorViewTab(value) {
  const next = normalizeMerchantEditorViewTab(value, "editor");
  sessionStorage.setItem(getMerchantEditorViewTabStorageKey(), next);
  return next;
}

function setMerchantEditorViewTabFromElement(element) {
  const next = normalizeMerchantEditorViewTab(element?.dataset?.tab ?? element?.value, "editor");
  const current = getMerchantEditorViewTab();
  if (next === current) return false;
  setMerchantEditorViewTab(next);
  return true;
}

function getMerchantEditorPackFilterStorageKey() {
  return `po-merchant-pack-filter-${game.user?.id ?? "anon"}`;
}

function getMerchantEditorItemFilterStorageKey() {
  return `po-merchant-item-filter-${game.user?.id ?? "anon"}`;
}

function normalizeMerchantEditorFilter(value) {
  return String(value ?? "").replace(/\s+/g, " ").trim().slice(0, 120);
}

function getMerchantEditorPackFilter() {
  return normalizeMerchantEditorFilter(sessionStorage.getItem(getMerchantEditorPackFilterStorageKey()));
}

function setMerchantEditorPackFilter(value) {
  const normalized = normalizeMerchantEditorFilter(value);
  sessionStorage.setItem(getMerchantEditorPackFilterStorageKey(), normalized);
  return normalized;
}

function getMerchantEditorItemFilter() {
  return normalizeMerchantEditorFilter(sessionStorage.getItem(getMerchantEditorItemFilterStorageKey()));
}

function setMerchantEditorItemFilter(value) {
  const normalized = normalizeMerchantEditorFilter(value);
  sessionStorage.setItem(getMerchantEditorItemFilterStorageKey(), normalized);
  return normalized;
}

function setLootClaimRunSelectionFromElement(element) {
  const nextRunId = normalizeLootClaimRunId(element?.value);
  const currentRunId = getLootClaimRunSelection();
  if (nextRunId === currentRunId) return false;
  setLootClaimRunSelection(nextRunId);
  return true;
}

function getLootRegistryTabStorageKey() {
  return `po-loot-registry-tab-${game.user?.id ?? "anon"}`;
}

function getActiveLootRegistryTab() {
  const stored = String(sessionStorage.getItem(getLootRegistryTabStorageKey()) ?? "preview").trim().toLowerCase();
  return stored === "settings" ? "settings" : "preview";
}

function setActiveLootRegistryTab(tab) {
  const value = String(tab ?? "preview").trim().toLowerCase();
  sessionStorage.setItem(getLootRegistryTabStorageKey(), value === "settings" ? "settings" : "preview");
}

function getGmDowntimeViewStorageKey() {
  return `po-gm-downtime-view-${game.user?.id ?? "anon"}`;
}

function normalizeDowntimeEntriesSort(value) {
  const normalized = String(value ?? "").trim().toLowerCase();
  const allowed = new Set(DOWNTIME_ENTRY_SORT_OPTIONS.map((entry) => entry.value));
  return allowed.has(normalized) ? normalized : "pending";
}

function normalizeDowntimeLogsSort(value) {
  const normalized = String(value ?? "").trim().toLowerCase();
  const allowed = new Set(DOWNTIME_LOG_SORT_OPTIONS.map((entry) => entry.value));
  return allowed.has(normalized) ? normalized : "resolved-desc";
}

function getGmDowntimeViewState() {
  const fallback = { entriesSort: "pending", logsSort: "resolved-desc" };
  const raw = sessionStorage.getItem(getGmDowntimeViewStorageKey());
  if (!raw) return fallback;
  try {
    const parsed = JSON.parse(raw);
    return {
      entriesSort: normalizeDowntimeEntriesSort(parsed?.entriesSort),
      logsSort: normalizeDowntimeLogsSort(parsed?.logsSort)
    };
  } catch {
    return fallback;
  }
}

function setGmDowntimeViewState(patch = {}) {
  const previous = getGmDowntimeViewState();
  const next = {
    entriesSort: patch?.entriesSort === undefined
      ? previous.entriesSort
      : normalizeDowntimeEntriesSort(patch.entriesSort),
    logsSort: patch?.logsSort === undefined
      ? previous.logsSort
      : normalizeDowntimeLogsSort(patch.logsSort)
  };
  sessionStorage.setItem(getGmDowntimeViewStorageKey(), JSON.stringify(next));
  return next;
}

function getNonPartySyncFilterStorageKey() {
  return `po-non-party-sync-filter-${game.user?.id ?? "anon"}`;
}

function normalizeNonPartySyncFilterKeyword(value) {
  return String(value ?? "").slice(0, 120);
}

function getNonPartySyncFilterKeyword() {
  return normalizeNonPartySyncFilterKeyword(sessionStorage.getItem(getNonPartySyncFilterStorageKey()));
}

function getActiveSyncEffectsTabStorageKey() {
  return `po-active-sync-effects-tab-${game.user?.id ?? "anon"}`;
}

function getActiveSyncEffectsTab() {
  const stored = String(sessionStorage.getItem(getActiveSyncEffectsTabStorageKey()) ?? "active").trim().toLowerCase();
  return stored === "archived" ? "archived" : "active";
}

function getGmQuickPanelStorageKey() {
  return `po-gm-quick-panel-${game.user?.id ?? "anon"}`;
}

function getGmQuickWeatherDraftStorageKey() {
  return `po-gm-quick-weather-draft-${game.user?.id ?? "anon"}`;
}

function getLootPreviewDraftStorageKey() {
  return `po-loot-preview-draft-${game.user?.id ?? "anon"}`;
}

function getLootPreviewResultStorageKey() {
  return `po-loot-preview-result-${game.user?.id ?? "anon"}`;
}

function getOperationsJournalViewStorageKey() {
  return `po-operations-journal-view-${game.user?.id ?? "anon"}`;
}

function getOperationsJournalViewState() {
  const fallback = { filter: "", sort: "newest", category: "all" };
  const raw = sessionStorage.getItem(getOperationsJournalViewStorageKey());
  if (!raw) return fallback;
  try {
    const parsed = JSON.parse(raw);
    const filter = String(parsed?.filter ?? "").trim();
    const sortRaw = String(parsed?.sort ?? "newest").trim().toLowerCase();
    const categoryRaw = String(parsed?.category ?? "all").trim().toLowerCase();
    const sortAllowed = new Set(["newest", "oldest", "title", "folder"]);
    const categoryAllowed = new Set(["all", ...Object.keys(OPERATIONS_JOURNAL_CATEGORIES)]);
    return {
      filter,
      sort: sortAllowed.has(sortRaw) ? sortRaw : "newest",
      category: categoryAllowed.has(categoryRaw) ? categoryRaw : "all"
    };
  } catch {
    return fallback;
  }
}

function setOperationsJournalViewState(patch = {}) {
  const prev = getOperationsJournalViewState();
  const next = {
    ...prev,
    ...patch
  };
  const sortAllowed = new Set(["newest", "oldest", "title", "folder"]);
  const categoryAllowed = new Set(["all", ...Object.keys(OPERATIONS_JOURNAL_CATEGORIES)]);
  next.filter = String(next.filter ?? "").trim();
  next.sort = sortAllowed.has(String(next.sort ?? "").trim().toLowerCase()) ? String(next.sort).trim().toLowerCase() : "newest";
  next.category = categoryAllowed.has(String(next.category ?? "").trim().toLowerCase()) ? String(next.category).trim().toLowerCase() : "all";
  sessionStorage.setItem(getOperationsJournalViewStorageKey(), JSON.stringify(next));
}

function getJournalVisibilityMode() {
  const raw = String(game.settings.get(MODULE_ID, SETTINGS.JOURNAL_ENTRY_VISIBILITY) ?? JOURNAL_VISIBILITY_MODES.PUBLIC)
    .trim()
    .toLowerCase();
  if (raw === JOURNAL_VISIBILITY_MODES.GM_PRIVATE) return JOURNAL_VISIBILITY_MODES.GM_PRIVATE;
  if (raw === JOURNAL_VISIBILITY_MODES.REDACTED) return JOURNAL_VISIBILITY_MODES.REDACTED;
  return JOURNAL_VISIBILITY_MODES.PUBLIC;
}

function getJournalFilterDebounceMs() {
  const raw = Number(game.settings.get(MODULE_ID, SETTINGS.JOURNAL_FILTER_DEBOUNCE_MS) ?? 180);
  if (!Number.isFinite(raw)) return 180;
  return Math.max(0, Math.min(1000, Math.floor(raw)));
}

function getSessionSummaryRangeSetting() {
  const raw = String(game.settings.get(MODULE_ID, SETTINGS.SESSION_SUMMARY_RANGE) ?? "last-24h").trim().toLowerCase();
  return Object.prototype.hasOwnProperty.call(SESSION_SUMMARY_RANGE_OPTIONS, raw) ? raw : "last-24h";
}

function getSessionSummaryWindowBounds() {
  const mode = getSessionSummaryRangeSetting();
  const now = Date.now();
  if (mode === "last-7d") {
    return { mode, start: now - (7 * 86400000), end: now, label: SESSION_SUMMARY_RANGE_OPTIONS[mode] };
  }
  if (mode === "today") {
    const startDate = new Date();
    startDate.setHours(0, 0, 0, 0);
    return { mode, start: Number(startDate.getTime()), end: now, label: SESSION_SUMMARY_RANGE_OPTIONS[mode] };
  }
  return { mode: "last-24h", start: now - 86400000, end: now, label: SESSION_SUMMARY_RANGE_OPTIONS["last-24h"] };
}

function scheduleOperationsJournalFilterUpdate(app, value, rerender) {
  const existing = journalFilterDebounceTimers.get(app);
  if (existing) window.clearTimeout(existing);
  const delay = getJournalFilterDebounceMs();
  const timer = window.setTimeout(() => {
    setOperationsJournalViewState({ filter: String(value ?? "") });
    try {
      rerender?.();
    } finally {
      journalFilterDebounceTimers.delete(app);
    }
  }, delay);
  journalFilterDebounceTimers.set(app, timer);
}

function clearScheduledSopNoteSave(app, sopKey) {
  if (!app || !sopKey) return;
  const timersByKey = sopNoteDebounceTimers.get(app);
  if (!timersByKey) return;
  const existing = timersByKey.get(sopKey);
  if (existing) window.clearTimeout(existing);
  timersByKey.delete(sopKey);
  if (timersByKey.size === 0) sopNoteDebounceTimers.delete(app);
}

function scheduleOperationalSopNoteSave(app, element) {
  if (!app || !element) return;
  const sopKey = String(element?.dataset?.sop ?? "").trim();
  if (!sopKey || !SOP_KEYS.includes(sopKey)) return;
  let timersByKey = sopNoteDebounceTimers.get(app);
  if (!timersByKey) {
    timersByKey = new Map();
    sopNoteDebounceTimers.set(app, timersByKey);
  }
  const existing = timersByKey.get(sopKey);
  if (existing) window.clearTimeout(existing);
  const timer = window.setTimeout(async () => {
    try {
      await setOperationalSopNote(element, { suppressUiWarning: true });
    } finally {
      clearScheduledSopNoteSave(app, sopKey);
    }
  }, 300);
  timersByKey.set(sopKey, timer);
}

function cacheOperationalSopNoteDraftFromElement(element) {
  const sopKey = String(element?.dataset?.sop ?? "").trim();
  if (!sopKey || !SOP_KEYS.includes(sopKey)) return;
  const note = clampSocketText(element?.value, SOCKET_NOTE_MAX_LENGTH);
  writeSopCachedNoteEntry(sopKey, note, { pendingSync: false });
}

function getSopNoteTextareaFromElement(element) {
  const directTextarea = element?.matches?.("textarea[data-action='set-sop-note']") ? element : null;
  if (directTextarea) return directTextarea;
  const sopKey = String(element?.dataset?.sop ?? "").trim();
  if (!sopKey) return null;
  const noteBlock = element?.closest?.(".po-sop-note-block");
  if (noteBlock) {
    const scoped = noteBlock.querySelector(`textarea[data-action='set-sop-note'][data-sop='${sopKey}']`)
      ?? noteBlock.querySelector("textarea[data-action='set-sop-note']");
    if (scoped) return scoped;
  }
  const root = element?.closest?.("#po-ops-sops, .po-window, .window-content, form") ?? document;
  return root?.querySelector?.(`textarea[data-action='set-sop-note'][data-sop='${sopKey}']`) ?? null;
}

function buildRestWatchNoteTimerKey(slotId, actorId) {
  return `${String(slotId ?? "").trim()}::${String(actorId ?? "").trim()}`;
}

function getNoteDraftCacheStorageKey() {
  const worldId = String(game.world?.id ?? "world").trim() || "world";
  const userId = String(game.user?.id ?? "user").trim() || "user";
  return `${MODULE_ID}.noteDraftCache.${worldId}.${userId}`;
}

function readNoteDraftCacheStore() {
  try {
    const raw = localStorage.getItem(getNoteDraftCacheStorageKey());
    if (!raw) return {};
    const parsed = JSON.parse(raw);
    return parsed && typeof parsed === "object" && !Array.isArray(parsed) ? parsed : {};
  } catch {
    return {};
  }
}

function writeNoteDraftCacheStore(store = {}) {
  try {
    localStorage.setItem(getNoteDraftCacheStorageKey(), JSON.stringify(store));
  } catch {
    // Ignore storage errors silently.
  }
}

function getNoteDraftCacheValue(cacheKeyInput) {
  const cacheKey = String(cacheKeyInput ?? "").trim();
  if (!cacheKey) return "";
  const store = readNoteDraftCacheStore();
  const entry = store[cacheKey];
  if (entry && typeof entry === "object" && typeof entry.text === "string") return entry.text;
  return "";
}

function setNoteDraftCacheValue(cacheKeyInput, textInput) {
  const cacheKey = String(cacheKeyInput ?? "").trim();
  if (!cacheKey) return;
  const text = String(textInput ?? "");
  const store = readNoteDraftCacheStore();
  if (!text.trim()) {
    delete store[cacheKey];
    writeNoteDraftCacheStore(store);
    return;
  }
  store[cacheKey] = {
    text,
    updatedAt: Date.now()
  };
  const entries = Object.entries(store);
  if (entries.length > 300) {
    entries
      .sort((a, b) => Number(a?.[1]?.updatedAt ?? 0) - Number(b?.[1]?.updatedAt ?? 0))
      .slice(0, entries.length - 300)
      .forEach(([key]) => delete store[key]);
  }
  writeNoteDraftCacheStore(store);
}

function clearNoteDraftCacheValue(cacheKeyInput) {
  const cacheKey = String(cacheKeyInput ?? "").trim();
  if (!cacheKey) return;
  const store = readNoteDraftCacheStore();
  if (!Object.prototype.hasOwnProperty.call(store, cacheKey)) return;
  delete store[cacheKey];
  writeNoteDraftCacheStore(store);
}

function getRestWatchNoteCacheKey(slotIdInput, actorIdInput) {
  const slotId = String(slotIdInput ?? "").trim();
  const actorId = String(actorIdInput ?? "").trim();
  if (!slotId || !actorId) return "";
  return `rest:${slotId}:${actorId}`;
}

function getMarchingNoteCacheKey(actorIdInput) {
  const actorId = String(actorIdInput ?? "").trim();
  if (!actorId) return "";
  return `march:${actorId}`;
}

function getSopNoteCacheKey(sopKeyInput) {
  const sopKey = String(sopKeyInput ?? "").trim();
  if (!sopKey || !SOP_KEYS.includes(sopKey)) return "";
  return `sop:${sopKey}`;
}

function readSopCachedNoteEntry(sopKeyInput) {
  const cacheKey = getSopNoteCacheKey(sopKeyInput);
  if (!cacheKey) return null;
  const store = readNoteDraftCacheStore();
  const entry = store[cacheKey];
  if (!entry || typeof entry !== "object") return null;
  const text = clampSocketText(entry.text ?? "", SOCKET_NOTE_MAX_LENGTH);
  const pendingSync = Boolean(entry.pendingSync);
  if (!String(text ?? "").trim() && !pendingSync) return null;
  return {
    sopKey: String(sopKeyInput ?? "").trim(),
    text,
    pendingSync,
    updatedAt: Math.max(0, Number(entry.updatedAt ?? 0) || 0)
  };
}

function writeSopCachedNoteEntry(sopKeyInput, textInput, options = {}) {
  const cacheKey = getSopNoteCacheKey(sopKeyInput);
  if (!cacheKey) return;
  const text = clampSocketText(textInput ?? "", SOCKET_NOTE_MAX_LENGTH);
  const pendingSync = options?.pendingSync !== false;
  if (!String(text ?? "").trim() && !pendingSync) {
    clearNoteDraftCacheValue(cacheKey);
    return;
  }
  const store = readNoteDraftCacheStore();
  store[cacheKey] = {
    text,
    pendingSync,
    updatedAt: Date.now()
  };
  const entries = Object.entries(store);
  if (entries.length > 300) {
    entries
      .sort((a, b) => Number(a?.[1]?.updatedAt ?? 0) - Number(b?.[1]?.updatedAt ?? 0))
      .slice(0, entries.length - 300)
      .forEach(([key]) => delete store[key]);
  }
  writeNoteDraftCacheStore(store);
}

function clearSopCachedNoteEntry(sopKeyInput) {
  const cacheKey = getSopNoteCacheKey(sopKeyInput);
  if (!cacheKey) return;
  clearNoteDraftCacheValue(cacheKey);
}

function resolveSopNoteForView(sopKeyInput, worldNoteInput) {
  const sopKey = String(sopKeyInput ?? "").trim();
  const worldNote = clampSocketText(worldNoteInput ?? "", SOCKET_NOTE_MAX_LENGTH);
  const cached = readSopCachedNoteEntry(sopKey);
  if (!cached) return { note: worldNote, pendingSync: false };
  if (cached.text === worldNote) {
    clearSopCachedNoteEntry(sopKey);
    return { note: worldNote, pendingSync: false };
  }
  return { note: cached.text, pendingSync: cached.pendingSync };
}

function getPendingSopCachedNotes() {
  return SOP_KEYS
    .map((sopKey) => readSopCachedNoteEntry(sopKey))
    .filter((entry) => Boolean(entry?.pendingSync));
}

function schedulePendingSopNoteSync(reason = "context") {
  if (game.user?.isGM) return;
  if (sopPendingSyncScheduled || sopPendingSyncInFlight) return;
  if (!hasActiveGmClient()) return;
  if (getPendingSopCachedNotes().length === 0) return;
  sopPendingSyncScheduled = true;
  window.setTimeout(async () => {
    sopPendingSyncScheduled = false;
    await flushPendingSopNoteSync(reason);
  }, 120);
}

async function flushPendingSopNoteSync(reason = "manual") {
  if (game.user?.isGM) return 0;
  if (sopPendingSyncInFlight) return 0;
  if (!hasActiveGmClient()) return 0;
  const pending = getPendingSopCachedNotes();
  if (pending.length === 0) return 0;
  sopPendingSyncInFlight = true;
  let synced = 0;
  try {
    for (const entry of pending) {
      const sopKey = String(entry?.sopKey ?? "").trim();
      if (!sopKey || !SOP_KEYS.includes(sopKey)) continue;
      const note = clampSocketText(entry?.text ?? "", SOCKET_NOTE_MAX_LENGTH);
      game.socket.emit(SOCKET_CHANNEL, {
        type: "ops:setSopNote",
        userId: game.user.id,
        sopKey,
        note
      });
      writeSopCachedNoteEntry(sopKey, note, { pendingSync: false });
      synced += 1;
    }
    if (synced > 0) {
      logUiDebug("operations-sop", "flushed pending SOP notes to GM socket bridge", {
        reason: String(reason ?? "manual"),
        synced,
        userId: String(game.user?.id ?? ""),
        userName: String(game.user?.name ?? "Unknown")
      });
    }
  } finally {
    sopPendingSyncInFlight = false;
  }
  return synced;
}

function clearScheduledRestWatchNoteSave(app, slotId, actorId) {
  if (!app) return;
  const key = buildRestWatchNoteTimerKey(slotId, actorId);
  if (!key || key === "::") return;
  const timersByKey = restWatchNoteDebounceTimers.get(app);
  if (!timersByKey) return;
  const existing = timersByKey.get(key);
  if (existing) window.clearTimeout(existing);
  timersByKey.delete(key);
  if (timersByKey.size === 0) restWatchNoteDebounceTimers.delete(app);
}

function getRestWatchNoteContextFromElement(element) {
  const noteInput = element?.matches?.("textarea.po-notes-input")
    ? element
    : element?.closest?.(".po-notes")?.querySelector?.("textarea.po-notes-input");
  const watchEntry = noteInput?.closest?.(".po-watch-entry");
  const slotCard = noteInput?.closest?.(".po-card");
  const slotId = String(slotCard?.dataset?.slotId ?? "").trim();
  const actorId = String(watchEntry?.dataset?.actorId ?? "").trim();
  return {
    slotId,
    actorId,
    text: String(noteInput?.value ?? ""),
    noteInput
  };
}

function cacheRestWatchNoteDraftFromElement(element) {
  const context = getRestWatchNoteContextFromElement(element);
  if (!context?.slotId || !context?.actorId) return;
  const cacheKey = getRestWatchNoteCacheKey(context.slotId, context.actorId);
  setNoteDraftCacheValue(cacheKey, context.text);
}

function appendRestWatchNoteAudit(state, payload = {}) {
  if (!state || typeof state !== "object") return;
  if (!Array.isArray(state.noteAudit)) state.noteAudit = [];
  const slotId = String(payload.slotId ?? "").trim();
  const actorId = String(payload.actorId ?? "").trim();
  if (!slotId || !actorId) return;
  state.noteAudit.unshift({
    id: foundry.utils.randomID(),
    slotId,
    actorId,
    source: normalizeRestNoteSaveSource(payload.source),
    textPreview: clampSocketText(payload.textPreview ?? payload.text ?? "", 200),
    savedAt: Number(payload.savedAt ?? Date.now()) || Date.now(),
    savedBy: String(payload.savedBy ?? game.user?.name ?? "Unknown")
  });
  if (state.noteAudit.length > 200) state.noteAudit = state.noteAudit.slice(0, 200);
}

async function saveRestWatchEntryNoteByContext(context = {}, options = {}) {
  const slotId = String(context?.slotId ?? "").trim();
  const actorId = String(context?.actorId ?? "").trim();
  if (!slotId || !actorId) return false;
  const source = normalizeRestNoteSaveSource(options?.source ?? "autosave");
  const text = clampSocketText(context?.text ?? "", SOCKET_NOTE_MAX_LENGTH);
  const cacheKey = getRestWatchNoteCacheKey(slotId, actorId);
  setNoteDraftCacheValue(cacheKey, text);

  if (!canAccessAllPlayerOps()) {
    const actor = game.actors.get(actorId);
    if (!actor || !canUserControlActor(actor, game.user)) {
      logUiDebug("rest-watch-notes", "blocked note save (client permission check failed)", {
        slotId,
        actorId,
        userId: String(game.user?.id ?? ""),
        userName: String(game.user?.name ?? "Unknown")
      });
      ui.notifications?.warn("You can only save notes for characters you can access.");
      return false;
    }
    await updateRestWatchState({ op: "setEntryNotes", slotId, actorId, text, source });
    if (options?.notify) ui.notifications?.info("Note saved.");
    return true;
  }

  let changed = false;
  await updateRestWatchState((state) => {
    const slot = state.slots.find((entry) => entry.id === slotId);
    if (!slot) return;
    if (!slot.entries && slot.actorId) {
      slot.entries = [{ actorId: slot.actorId, notes: slot.notes ?? "" }];
      slot.actorId = null;
      slot.notes = "";
    }
    if (!slot.entries) slot.entries = [];
    const entry = slot.entries.find((row) => String(row?.actorId ?? "") === actorId);
    if (!entry) return;
    const previous = String(entry.notes ?? "");
    if (previous === text) return;
    entry.notes = text;
    appendRestWatchNoteAudit(state, {
      slotId,
      actorId,
      source,
      textPreview: text,
      savedBy: String(game.user?.name ?? "GM")
    });
    changed = true;
  });

  if (options?.notify) {
    ui.notifications?.info(changed ? "Note saved." : "No note changes to save.");
  }
  return changed;
}

async function saveRestWatchEntryNoteFromElement(element, options = {}) {
  const context = getRestWatchNoteContextFromElement(element);
  if (!context?.slotId || !context?.actorId) return false;
  return saveRestWatchEntryNoteByContext(context, options);
}

function scheduleRestWatchNoteSave(app, element, options = {}) {
  if (!app || !element) return;
  const context = getRestWatchNoteContextFromElement(element);
  if (!context?.slotId || !context?.actorId) return;
  let timersByKey = restWatchNoteDebounceTimers.get(app);
  if (!timersByKey) {
    timersByKey = new Map();
    restWatchNoteDebounceTimers.set(app, timersByKey);
  }
  const key = buildRestWatchNoteTimerKey(context.slotId, context.actorId);
  const existing = timersByKey.get(key);
  if (existing) window.clearTimeout(existing);
  const timer = window.setTimeout(async () => {
    try {
      await saveRestWatchEntryNoteByContext(context, {
        source: options?.source ?? "autosave",
        notify: false
      });
    } finally {
      clearScheduledRestWatchNoteSave(app, context.slotId, context.actorId);
    }
  }, 300);
  timersByKey.set(key, timer);
}

function getMarchingNoteContextFromElement(element) {
  const noteInput = element?.matches?.("textarea.po-entry-notes-input")
    ? element
    : element?.closest?.(".po-entry-notes")?.querySelector?.("textarea.po-entry-notes-input");
  const actorId = String(noteInput?.closest?.("[data-actor-id]")?.dataset?.actorId ?? "").trim();
  return {
    actorId,
    text: String(noteInput?.value ?? ""),
    noteInput
  };
}

function cacheMarchingNoteDraftFromElement(element) {
  const context = getMarchingNoteContextFromElement(element);
  if (!context?.actorId) return;
  const cacheKey = getMarchingNoteCacheKey(context.actorId);
  setNoteDraftCacheValue(cacheKey, context.text);
}

async function saveMarchingNoteByContext(context = {}, options = {}) {
  const actorId = String(context?.actorId ?? "").trim();
  if (!actorId) return false;
  const text = clampSocketText(context?.text ?? "", SOCKET_NOTE_MAX_LENGTH);
  const cacheKey = getMarchingNoteCacheKey(actorId);
  setNoteDraftCacheValue(cacheKey, text);

  if (!canAccessAllPlayerOps()) {
    const actor = game.actors.get(actorId);
    if (!actor || !canUserControlActor(actor, game.user)) {
      logUiDebug("march-notes", "blocked note save (client permission check failed)", {
        actorId,
        userId: String(game.user?.id ?? ""),
        userName: String(game.user?.name ?? "Unknown")
      });
      ui.notifications?.warn("You can only save notes for characters you can access.");
      return false;
    }
    await updateMarchingOrderState({ op: "setNote", actorId, text });
    if (options?.notify) ui.notifications?.info("Note saved.");
    return true;
  }

  let changed = false;
  await updateMarchingOrderState((state) => {
    if (!state.notes) state.notes = {};
    const previous = String(state.notes[actorId] ?? "");
    if (previous === text) return;
    state.notes[actorId] = text;
    changed = true;
  });
  if (options?.notify) {
    ui.notifications?.info(changed ? "Note saved." : "No note changes to save.");
  }
  return changed;
}

async function saveMarchingNoteFromElement(element, options = {}) {
  const context = getMarchingNoteContextFromElement(element);
  if (!context?.actorId) return false;
  return saveMarchingNoteByContext(context, options);
}

function clearScheduledMarchingNoteSave(app, actorIdInput) {
  if (!app) return;
  const actorId = String(actorIdInput ?? "").trim();
  if (!actorId) return;
  const timersByActor = marchingNoteDebounceTimers.get(app);
  if (!timersByActor) return;
  const existing = timersByActor.get(actorId);
  if (existing) window.clearTimeout(existing);
  timersByActor.delete(actorId);
  if (timersByActor.size === 0) marchingNoteDebounceTimers.delete(app);
}

function scheduleMarchingNoteSave(app, element, options = {}) {
  if (!app || !element) return;
  const context = getMarchingNoteContextFromElement(element);
  if (!context?.actorId) return;
  let timersByActor = marchingNoteDebounceTimers.get(app);
  if (!timersByActor) {
    timersByActor = new Map();
    marchingNoteDebounceTimers.set(app, timersByActor);
  }
  const existing = timersByActor.get(context.actorId);
  if (existing) window.clearTimeout(existing);
  const timer = window.setTimeout(async () => {
    try {
      await saveMarchingNoteByContext(context, {
        source: options?.source ?? "autosave",
        notify: false
      });
    } finally {
      clearScheduledMarchingNoteSave(app, context.actorId);
    }
  }, 300);
  timersByActor.set(context.actorId, timer);
}

function hydrateCachedNoteDraftInputs(root) {
  if (!root?.querySelectorAll) return;

  root.querySelectorAll(".po-watch-entry .po-notes-input").forEach((input) => {
    const context = getRestWatchNoteContextFromElement(input);
    if (!context?.slotId || !context?.actorId) return;
    const cacheKey = getRestWatchNoteCacheKey(context.slotId, context.actorId);
    const cached = getNoteDraftCacheValue(cacheKey);
    if (cached === "") return;
    if (String(input.value ?? "") !== cached) input.value = cached;
  });

  root.querySelectorAll(".po-entry-notes .po-entry-notes-input").forEach((input) => {
    const context = getMarchingNoteContextFromElement(input);
    if (!context?.actorId) return;
    const cacheKey = getMarchingNoteCacheKey(context.actorId);
    const cached = getNoteDraftCacheValue(cacheKey);
    if (cached === "") return;
    if (String(input.value ?? "") !== cached) input.value = cached;
  });
}

function buildJournalSortOptions(selectedSort = "newest") {
  const selected = String(selectedSort ?? "newest").trim().toLowerCase();
  return JOURNAL_SORT_OPTIONS.map((entry) => ({
    value: entry.value,
    label: entry.label,
    selected: entry.value === selected
  }));
}

function buildJournalCategoryOptions(selectedCategory = "all") {
  const selected = String(selectedCategory ?? "all").trim().toLowerCase();
  return [
    { value: "all", label: "All Categories", selected: selected === "all" },
    ...Object.entries(OPERATIONS_JOURNAL_CATEGORIES).map(([value, label]) => ({
      value,
      label,
      selected: selected === value
    }))
  ];
}

async function handleOperationsJournalAction(action, element, rerender) {
  const actionKey = String(action ?? "").trim();
  if (!actionKey) return false;
  if (actionKey === "set-journal-filter") {
    setOperationsJournalViewState({ filter: String(element?.value ?? "") });
    rerender?.();
    return true;
  }
  if (actionKey === "set-journal-sort") {
    setOperationsJournalViewState({ sort: String(element?.value ?? "newest") });
    rerender?.();
    return true;
  }
  if (actionKey === "set-journal-category") {
    setOperationsJournalViewState({ category: String(element?.value ?? "all") });
    rerender?.();
    return true;
  }
  if (actionKey === "open-journal-entry") {
    await openJournalEntryFromElement(element);
    return true;
  }
  return false;
}

function buildOperationsJournalContext() {
  const view = getOperationsJournalViewState();
  const root = findOperationsJournalRootFolder();
  const rootFolderId = String(root?.id ?? "").trim();
  const rootFolderName = String(root?.name ?? OPERATIONS_JOURNAL_ROOT_NAME).trim() || OPERATIONS_JOURNAL_ROOT_NAME;
  const selectedCategory = String(view?.category ?? "all").trim().toLowerCase() || "all";
  const filterNeedle = String(view?.filter ?? "").trim().toLowerCase();
  const selectedSort = String(view?.sort ?? "newest").trim().toLowerCase() || "newest";

  const resolveEntryFolder = (entry) => {
    const folderId = String(entry?.folder?.id ?? entry?.folder ?? "").trim();
    return folderId ? game.folders?.get(folderId) ?? null : null;
  };

  const resolveCategoryForEntry = (entryFolder) => {
    const folder = entryFolder;
    if (!folder) return { key: "session", label: OPERATIONS_JOURNAL_CATEGORIES.session };

    let current = folder;
    let guard = 0;
    while (current && guard < 40) {
      const parentId = getJournalFolderParentId(current);
      if (parentId === rootFolderId) {
        const label = String(current.name ?? "").trim();
        const key = Object.entries(OPERATIONS_JOURNAL_CATEGORIES).find(([, value]) => String(value ?? "").trim().toLowerCase() === label.toLowerCase())?.[0] ?? "session";
        return { key, label: label || OPERATIONS_JOURNAL_CATEGORIES[key] || OPERATIONS_JOURNAL_CATEGORIES.session };
      }
      current = parentId ? game.folders?.get(parentId) ?? null : null;
      guard += 1;
    }

    return { key: "session", label: OPERATIONS_JOURNAL_CATEGORIES.session };
  };

  const rows = (game.journal?.contents ?? [])
    .filter((entry) => {
      if (!entry) return false;
      if (!rootFolderId) return false;
      const entryFolder = resolveEntryFolder(entry);
      const entryFolderId = String(entryFolder?.id ?? "").trim();
      return journalFolderIsUnderRoot(entryFolderId, rootFolderId);
    })
    .map((entry) => {
      const name = String(entry?.name ?? "Untitled").trim() || "Untitled";
      const entryFolder = resolveEntryFolder(entry);
      const folderLabel = String(entryFolder?.name ?? "Unfiled").trim() || "Unfiled";
      const category = resolveCategoryForEntry(entryFolder);
      const updatedAtRaw = Number(entry?._stats?.modifiedTime ?? entry?._stats?.createdTime ?? Date.now());
      const updatedAt = Number.isFinite(updatedAtRaw) ? updatedAtRaw : Date.now();
      const updatedAtDate = new Date(updatedAt);
      const searchBlob = [name, folderLabel, category.label, category.key].join(" ").toLowerCase();
      return {
        id: String(entry?.id ?? "").trim(),
        name,
        folderLabel,
        categoryKey: category.key,
        categoryLabel: category.label,
        updatedAt,
        updatedAtLabel: Number.isFinite(updatedAtDate.getTime()) ? updatedAtDate.toLocaleString() : "Unknown",
        searchBlob
      };
    })
    .filter((row) => {
      if (selectedCategory !== "all" && row.categoryKey !== selectedCategory) return false;
      if (filterNeedle && !row.searchBlob.includes(filterNeedle)) return false;
      return true;
    });

  const sortedRows = [...rows].sort((a, b) => {
    if (selectedSort === "oldest") return Number(a.updatedAt) - Number(b.updatedAt);
    if (selectedSort === "title") return String(a.name ?? "").localeCompare(String(b.name ?? ""));
    if (selectedSort === "folder") {
      const folderCompare = String(a.folderLabel ?? "").localeCompare(String(b.folderLabel ?? ""));
      if (folderCompare !== 0) return folderCompare;
      return String(a.name ?? "").localeCompare(String(b.name ?? ""));
    }
    return Number(b.updatedAt) - Number(a.updatedAt);
  });

  return {
    rootFolderName,
    hasRootFolder: Boolean(rootFolderId),
    selectedFilter: String(view?.filter ?? ""),
    selectedSort,
    selectedCategory,
    sortOptions: buildJournalSortOptions(selectedSort),
    categoryOptions: buildJournalCategoryOptions(selectedCategory),
    rows: sortedRows,
    visibleCount: sortedRows.length,
    totalCount: rows.length,
    hasRows: sortedRows.length > 0,
    hasFilter: Boolean(filterNeedle)
  };
}

function normalizeLootPreviewDraft(input = {}) {
  const mode = String(input?.mode ?? "horde").trim().toLowerCase();
  const profile = String(input?.profile ?? "standard").trim().toLowerCase();
  const challenge = String(input?.challenge ?? "mid").trim().toLowerCase();
  const scale = String(input?.scale ?? "medium").trim().toLowerCase();
  const creaturesRaw = Number(input?.creatures ?? input?.actorCount ?? 1);
  const creatures = Number.isFinite(creaturesRaw) ? Math.max(1, Math.min(100, Math.floor(creaturesRaw))) : 1;
  const currencyScalarRaw = Number(input?.currencyScalar ?? 100);
  const itemScalarRaw = Number(input?.itemScalar ?? 100);
  const tableScalarRaw = Number(input?.tableScalar ?? 100);
  const valueBudgetScalarRaw = Number(input?.valueBudgetScalar ?? LOOT_PREVIEW_DEFAULT_VALUE_BUDGET_SCALAR);
  const valueStrictnessRaw = Number(input?.valueStrictness ?? LOOT_PREVIEW_DEFAULT_VALUE_STRICTNESS);
  const maxItemValueGpRaw = Number(input?.maxItemValueGp ?? 0);
  const targetItemsValueGpRaw = Number(input?.targetItemsValueGp ?? 0);
  const deterministic = shouldUseDeterministicLootRng(input);
  const seed = String(input?.seed ?? "").trim();
  const dateBucket = String(input?.dateBucket ?? "").trim();
  const currencyScalar = Number.isFinite(currencyScalarRaw) ? Math.max(25, Math.min(300, Math.floor(currencyScalarRaw))) : 100;
  const itemScalar = Number.isFinite(itemScalarRaw) ? Math.max(25, Math.min(300, Math.floor(itemScalarRaw))) : 100;
  const tableScalar = Number.isFinite(tableScalarRaw) ? Math.max(25, Math.min(300, Math.floor(tableScalarRaw))) : 100;
  const valueBudgetScalar = Number.isFinite(valueBudgetScalarRaw)
    ? Math.max(25, Math.min(300, Math.floor(valueBudgetScalarRaw)))
    : LOOT_PREVIEW_DEFAULT_VALUE_BUDGET_SCALAR;
  const valueStrictness = Number.isFinite(valueStrictnessRaw)
    ? Math.max(50, Math.min(300, Math.floor(valueStrictnessRaw)))
    : LOOT_PREVIEW_DEFAULT_VALUE_STRICTNESS;
  const maxItemValueGp = Number.isFinite(maxItemValueGpRaw)
    ? Math.max(0, Math.min(LOOT_PREVIEW_MAX_ITEM_VALUE_GP_LIMIT, Math.floor(maxItemValueGpRaw)))
    : 0;
  const targetItemsValueGp = Number.isFinite(targetItemsValueGpRaw)
    ? Math.max(0, Math.min(LOOT_PREVIEW_MAX_TOTAL_TARGET_VALUE_GP_LIMIT, Math.floor(targetItemsValueGpRaw)))
    : 0;
  const modeAllowed = new Set(LOOT_PREVIEW_MODE_OPTIONS.map((entry) => entry.value));
  const profileAllowed = new Set(LOOT_PREVIEW_PROFILE_OPTIONS.map((entry) => entry.value));
  const challengeAllowed = new Set(LOOT_PREVIEW_CHALLENGE_OPTIONS.map((entry) => entry.value));
  const scaleAllowed = new Set(LOOT_PREVIEW_SCALE_OPTIONS.map((entry) => entry.value));
  return {
    mode: modeAllowed.has(mode) ? mode : "horde",
    profile: profileAllowed.has(profile) ? profile : "standard",
    challenge: challengeAllowed.has(challenge) ? challenge : "mid",
    scale: scaleAllowed.has(scale) ? scale : "medium",
    creatures,
    actorCount: creatures,
    currencyScalar,
    itemScalar,
    tableScalar,
    valueBudgetScalar,
    valueStrictness,
    maxItemValueGp,
    targetItemsValueGp,
    deterministic,
    seed,
    dateBucket
  };
}

function getLootPreviewDraft() {
  const raw = sessionStorage.getItem(getLootPreviewDraftStorageKey());
  if (!raw) return normalizeLootPreviewDraft({});
  try {
    return normalizeLootPreviewDraft(JSON.parse(raw));
  } catch {
    return normalizeLootPreviewDraft({});
  }
}

function setLootPreviewDraft(draft = {}) {
  const normalized = normalizeLootPreviewDraft(draft);
  sessionStorage.setItem(getLootPreviewDraftStorageKey(), JSON.stringify(normalized));
}

function getLootPreviewResult() {
  const raw = sessionStorage.getItem(getLootPreviewResultStorageKey());
  if (!raw) return null;
  try {
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") return null;
    return parsed;
  } catch {
    return null;
  }
}

function setLootPreviewResult(result = null) {
  if (!result) {
    sessionStorage.removeItem(getLootPreviewResultStorageKey());
    return;
  }
  sessionStorage.setItem(getLootPreviewResultStorageKey(), JSON.stringify(result));
}

function getGmQuickWeatherDraft() {
  const raw = sessionStorage.getItem(getGmQuickWeatherDraftStorageKey());
  if (!raw) return null;
  try {
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") return null;
    return {
      selectedKey: String(parsed.selectedKey ?? "").trim(),
      darkness: Number(parsed.darkness ?? 0),
      visibilityModifier: Number(parsed.visibilityModifier ?? 0),
      note: String(parsed.note ?? ""),
      presetName: String(parsed.presetName ?? ""),
      daeChanges: Array.isArray(parsed.daeChanges) ? parsed.daeChanges : []
    };
  } catch (_error) {
    return null;
  }
}

function setGmQuickWeatherDraft(draft = null) {
  if (!draft || typeof draft !== "object") {
    sessionStorage.removeItem(getGmQuickWeatherDraftStorageKey());
    return;
  }
  sessionStorage.setItem(getGmQuickWeatherDraftStorageKey(), JSON.stringify({
    selectedKey: String(draft.selectedKey ?? "").trim(),
    darkness: Number(draft.darkness ?? 0),
    visibilityModifier: Number(draft.visibilityModifier ?? 0),
    note: String(draft.note ?? ""),
    presetName: String(draft.presetName ?? ""),
    daeChanges: Array.isArray(draft.daeChanges) ? draft.daeChanges : []
  }));
}

function getActiveGmQuickPanel() {
  const stored = String(sessionStorage.getItem(getGmQuickPanelStorageKey()) ?? "none").trim().toLowerCase();
  const allowed = new Set(["none", "faction", "modifier", "weather"]);
  return allowed.has(stored) ? stored : "none";
}

function setActiveGmQuickPanel(panel) {
  const value = String(panel ?? "none").trim().toLowerCase();
  const allowed = new Set(["none", "faction", "modifier", "weather"]);
  sessionStorage.setItem(getGmQuickPanelStorageKey(), allowed.has(value) ? value : "none");
}

function getGmOperationsTabStorageKey() {
  return `po-gm-ops-tab-${game.user?.id ?? "anon"}`;
}

function getActiveGmOperationsTab() {
  const stored = String(sessionStorage.getItem(getGmOperationsTabStorageKey()) ?? "environment").trim().toLowerCase();
  const allowed = new Set(["environment", "loot-sources"]);
  return allowed.has(stored) ? stored : "environment";
}

function setActiveGmOperationsTab(tab) {
  const value = String(tab ?? "environment").trim().toLowerCase();
  const allowed = new Set(["environment", "loot-sources"]);
  sessionStorage.setItem(getGmOperationsTabStorageKey(), allowed.has(value) ? value : "environment");
}

function normalizeGmOperationsTab(tab, fallback = "environment") {
  const value = String(tab ?? fallback).trim().toLowerCase();
  const allowed = new Set(["environment", "loot-sources"]);
  return allowed.has(value) ? value : fallback;
}

function normalizeLootRegistryTab(tab, fallback = "preview") {
  const value = String(tab ?? fallback).trim().toLowerCase();
  return value === "settings" ? "settings" : "preview";
}

function getActiveOperationsPlanningTab() {
  const allowed = new Set(["roles", "sops", "resources", "loot", "bonuses"]);
  const stored = String(sessionStorage.getItem(getOperationsPlanningTabStorageKey()) ?? "roles").trim().toLowerCase();
  return allowed.has(stored) ? stored : "roles";
}

function setActiveOperationsPlanningTab(tab) {
  const allowed = new Set(["roles", "sops", "resources", "loot", "bonuses"]);
  const normalized = String(tab ?? "").trim().toLowerCase();
  const value = allowed.has(normalized) ? normalized : "roles";
  sessionStorage.setItem(getOperationsPlanningTabStorageKey(), value);
}

function getMiniVizStorageKey() {
  return `po-mini-viz-collapsed-${game.user?.id ?? "anon"}`;
}

function isMiniVizCollapsed() {
  return sessionStorage.getItem(getMiniVizStorageKey()) === "1";
}

function setMiniVizCollapsed(collapsed) {
  sessionStorage.setItem(getMiniVizStorageKey(), collapsed ? "1" : "0");
}

function getMarchSectionsStorageKey() {
  return `po-march-sections-${game.user?.id ?? "anon"}`;
}

function getMarchSectionState() {
  const raw = sessionStorage.getItem(getMarchSectionsStorageKey());
  if (!raw) return {};
  try {
    const parsed = JSON.parse(raw);
    return parsed && typeof parsed === "object" ? parsed : {};
  } catch (_err) {
    return {};
  }
}

function setMarchSectionState(state) {
  sessionStorage.setItem(getMarchSectionsStorageKey(), JSON.stringify(state ?? {}));
}

function isMarchSectionCollapsed(sectionId) {
  if (!sectionId) return false;
  const state = getMarchSectionState();
  return Boolean(state[sectionId]);
}

function setMarchSectionCollapsed(sectionId, collapsed) {
  if (!sectionId) return;
  const state = getMarchSectionState();
  state[sectionId] = Boolean(collapsed);
  setMarchSectionState(state);
}

function buildMarchSectionUi(sectionId) {
  const collapsed = isMarchSectionCollapsed(sectionId);
  return {
    collapsed,
    toggleLabel: collapsed ? "Expand" : "Collapse",
    toggleIcon: collapsed ? "fa-chevron-down" : "fa-chevron-up"
  };
}

function buildMiniVizUiContext() {
  const collapsed = isMiniVizCollapsed();
  return {
    miniVizCollapsed: collapsed,
    miniVizToggleLabel: collapsed ? "Expand" : "Collapse",
    miniVizToggleIcon: collapsed ? "fa-chevron-down" : "fa-chevron-up"
  };
}

function getWatchEntryStateKey(entry) {
  const slotId = entry?.closest(".po-card")?.dataset?.slotId ?? "";
  const actorId = entry?.dataset?.actorId ?? "";
  if (!slotId || !actorId) return "";
  return `${slotId}:${actorId}`;
}

function getElementStatePath(node, root) {
  if (!node || !root || !(node instanceof HTMLElement)) return "";
  const segments = [];
  let cursor = node;
  while (cursor && cursor !== root && cursor instanceof HTMLElement) {
    const parent = cursor.parentElement;
    let siblingIndex = 0;
    if (parent) {
      const siblings = Array.from(parent.children).filter((entry) => entry.tagName === cursor.tagName);
      const found = siblings.indexOf(cursor);
      siblingIndex = found >= 0 ? found : 0;
    }
    const tag = cursor.tagName.toLowerCase();
    const idPart = cursor.id ? `#${cursor.id}` : "";
    const actionPart = cursor.dataset?.action ? `[a=${cursor.dataset.action}]` : "";
    const pagePart = cursor.dataset?.page ? `[p=${cursor.dataset.page}]` : "";
    const tabPart = cursor.dataset?.tab ? `[t=${cursor.dataset.tab}]` : "";
    segments.unshift(`${tag}:${siblingIndex}${idPart}${actionPart}${pagePart}${tabPart}`);
    cursor = parent;
  }
  return segments.join(">");
}

function captureDisclosureState(root) {
  if (!root) return [];
  return Array.from(root.querySelectorAll("details"))
    .map((details) => {
      const key = getElementStatePath(details, root);
      if (!key) return null;
      return {
        key,
        open: details.open === true
      };
    })
    .filter(Boolean);
}

function applyDisclosureState(root, disclosureState) {
  if (!root || !Array.isArray(disclosureState) || disclosureState.length === 0) return;
  const map = new Map(
    disclosureState
      .filter((entry) => entry && typeof entry.key === "string")
      .map((entry) => [entry.key, entry.open === true])
  );
  if (map.size === 0) return;
  root.querySelectorAll("details").forEach((details) => {
    const key = getElementStatePath(details, root);
    if (!key || !map.has(key)) return;
    const shouldOpen = map.get(key) === true;
    if (details.open !== shouldOpen) details.open = shouldOpen;
  });
}

function captureUiState(app) {
  const root = getAppRootElement(app);
  if (!root) return null;

  const captureFocusedInputState = () => {
    const active = document?.activeElement;
    if (!active || !(active instanceof HTMLElement)) return null;
    if (!root.contains(active)) return null;
    const tag = String(active.tagName ?? "").toUpperCase();
    if (!(["INPUT", "TEXTAREA", "SELECT"].includes(tag))) return null;
    const action = String(active.dataset?.action ?? "").trim();
    const name = String(active.getAttribute?.("name") ?? "").trim();
    if (!action && !name) return null;
    const statePath = getElementStatePath(active, root);
    const value = "value" in active ? String(active.value ?? "") : "";
    const selectionStart = typeof active.selectionStart === "number" ? active.selectionStart : null;
    const selectionEnd = typeof active.selectionEnd === "number" ? active.selectionEnd : null;
    return { action, name, statePath, value, selectionStart, selectionEnd };
  };

  if (app instanceof RestWatchApp || app instanceof RestWatchPlayerApp) {
    const openNotes = Array.from(root.querySelectorAll(".po-watch-entry .po-notes.is-active"))
      .map((notes) => getWatchEntryStateKey(notes.closest(".po-watch-entry")))
      .filter(Boolean);
    return {
      type: "rest",
      openNotes,
      disclosures: captureDisclosureState(root),
      focusedInput: captureFocusedInputState()
    };
  }

  if (app instanceof MarchingOrderApp) {
    return {
      type: "march",
      disclosures: captureDisclosureState(root),
      focusedInput: captureFocusedInputState()
    };
  }

  return {
    type: "generic",
    disclosures: captureDisclosureState(root),
    focusedInput: captureFocusedInputState()
  };
}

function applyUiState(app, state) {
  if (!state) return;
  const root = getAppRootElement(app);
  if (!root) return;

  const escapeCssValue = (value) => {
    const text = String(value ?? "");
    if (globalThis.CSS?.escape) return CSS.escape(text);
    return text.replace(/[^A-Za-z0-9_-]/g, "");
  };

  const findElementByStatePath = (statePath) => {
    const key = String(statePath ?? "").trim();
    if (!key) return null;
    const inputs = Array.from(root.querySelectorAll("input, textarea, select"));
    return inputs.find((element) => getElementStatePath(element, root) === key) ?? null;
  };

  const restoreFocusedInputState = (focusedInput) => {
    if (!focusedInput || typeof focusedInput !== "object") return;
    const action = String(focusedInput.action ?? "").trim();
    const name = String(focusedInput.name ?? "").trim();
    let target = findElementByStatePath(focusedInput.statePath);
    if (!(target instanceof HTMLElement)) {
      const selectors = [];
      if (action) selectors.push(`[data-action='${escapeCssValue(action)}']`);
      if (name) selectors.push(`[name='${escapeCssValue(name)}']`);
      if (!selectors.length) return;
      const matches = root.querySelectorAll(selectors.join(", "));
      if (matches.length !== 1) return;
      target = matches[0];
    }
    if (!(target instanceof HTMLElement)) return;
    try {
      target.focus({ preventScroll: true });
    } catch {
      target.focus();
    }
    const start = Number.isFinite(Number(focusedInput.selectionStart)) ? Number(focusedInput.selectionStart) : null;
    const end = Number.isFinite(Number(focusedInput.selectionEnd)) ? Number(focusedInput.selectionEnd) : null;
    if (typeof target.setSelectionRange === "function" && start !== null) {
      target.setSelectionRange(start, end ?? start);
    }
  };

  applyDisclosureState(root, state.disclosures);

  if (state.type === "rest") {
    const openSet = new Set(state.openNotes ?? []);
    root.querySelectorAll(".po-watch-entry").forEach((entry) => {
      const key = getWatchEntryStateKey(entry);
      const notes = entry.querySelector(".po-notes");
      if (!notes) return;
      notes.classList.toggle("is-active", Boolean(key && openSet.has(key)));
    });
    restoreFocusedInputState(state.focusedInput);
    return;
  }

  if (state.type === "march") {
    restoreFocusedInputState(state.focusedInput);
    return;
  }

  if (state.type === "generic") {
    restoreFocusedInputState(state.focusedInput);
    return;
  }
}

function restorePendingUiState(app) {
  const state = pendingUiRestore.get(app);
  if (!state) return;
  pendingUiRestore.delete(app);
  applyUiState(app, state);
}

function captureScrollState(app) {
  const root = getAppRootElement(app);
  if (!root) return [];
  const states = [];

  const getNodeStateKey = (node) => {
    if (node === root) return "root";
    const key = getElementStatePath(node, root);
    return key || "";
  };

  const collectNodes = () => {
    const nodes = [];
    const seen = new Set();
    for (const selector of SCROLL_STATE_SELECTORS) {
      const matched = Array.from(root.querySelectorAll(selector));
      if (root.matches?.(selector)) matched.unshift(root);
      for (const node of matched) {
        if (!(node instanceof HTMLElement) || seen.has(node)) continue;
        seen.add(node);
        nodes.push(node);
      }
    }
    return nodes;
  };

  for (const node of collectNodes()) {
    const canScrollY = node.scrollHeight > node.clientHeight;
    const canScrollX = node.scrollWidth > node.clientWidth;
    if (!canScrollY && !canScrollX) continue;
    const key = getNodeStateKey(node);
    if (!key) continue;
    states.push({ key, top: node.scrollTop, left: node.scrollLeft });
  }
  return states;
}

function applyScrollState(root, states) {
  if (!root || !Array.isArray(states)) return;

  const getNodeStateKey = (node) => {
    if (node === root) return "root";
    const key = getElementStatePath(node, root);
    return key || "";
  };

  const lookup = new Map();
  for (const selector of SCROLL_STATE_SELECTORS) {
    const matched = Array.from(root.querySelectorAll(selector));
    if (root.matches?.(selector)) matched.unshift(root);
    for (const node of matched) {
      if (!(node instanceof HTMLElement)) continue;
      const key = getNodeStateKey(node);
      if (!key || lookup.has(key)) continue;
      lookup.set(key, node);
    }
  }

  for (const state of states) {
    const key = String(state?.key ?? "").trim();
    if (!key) continue;
    const node = lookup.get(key);
    if (!node) continue;
    node.scrollTop = state.top ?? 0;
    node.scrollLeft = state.left ?? 0;
  }
}

function restorePendingScrollState(app) {
  const states = pendingScrollRestore.get(app);
  if (!states?.length) return;
  pendingScrollRestore.delete(app);
  const root = getAppRootElement(app);
  if (!root) return;
  const apply = () => applyScrollState(root, states);
  apply();
  requestAnimationFrame(apply);
}

function parseInlinePixelValue(value) {
  if (value === null || value === undefined) return NaN;
  const parsed = Number.parseFloat(String(value).replace("px", "").trim());
  return Number.isFinite(parsed) ? parsed : NaN;
}

function normalizeWindowStateLike(state) {
  if (!state || typeof state !== "object") return null;
  const left = Number(state.left);
  const top = Number(state.top);
  const width = Number(state.width);
  const height = Number(state.height);
  if (!Number.isFinite(left) || !Number.isFinite(top) || !Number.isFinite(width) || !Number.isFinite(height)) return null;
  if (width < 120 || height < 120) return null;
  return {
    left,
    top,
    width,
    height
  };
}

function captureWindowState(app) {
  const frame = getAppRootElement(app)?.closest?.(".window-app, .application");
  if (frame instanceof HTMLElement && frame.isConnected) {
    const rect = frame.getBoundingClientRect();
    const stateFromRect = normalizeWindowStateLike({
      left: Number.isFinite(parseInlinePixelValue(frame.style.left)) ? parseInlinePixelValue(frame.style.left) : Number(rect.left),
      top: Number.isFinite(parseInlinePixelValue(frame.style.top)) ? parseInlinePixelValue(frame.style.top) : Number(rect.top),
      width: Number(rect.width),
      height: Number(rect.height)
    });
    if (stateFromRect) return stateFromRect;
  }
  const pos = app?.position;
  return normalizeWindowStateLike({
    left: Number(pos?.left),
    top: Number(pos?.top),
    width: Number(pos?.width),
    height: Number(pos?.height)
  });
}

function areWindowStatesEquivalent(leftState, rightState, options = {}) {
  const a = normalizeWindowStateLike(leftState);
  const b = normalizeWindowStateLike(rightState);
  if (!a || !b) return false;
  const tolerance = Math.max(0.5, Number(options.tolerance ?? 1.25));
  return Math.abs(a.left - b.left) <= tolerance
    && Math.abs(a.top - b.top) <= tolerance
    && Math.abs(a.width - b.width) <= tolerance
    && Math.abs(a.height - b.height) <= tolerance;
}

function restorePendingWindowState(app) {
  const state = pendingWindowRestore.get(app);
  if (!state) return;
  pendingWindowRestore.delete(app);
  const normalizedState = normalizeWindowStateLike(state);
  if (!normalizedState || typeof app?.setPosition !== "function") return;
  const profileId = normalizeWindowProfileId(app);
  const restoredSize = getResponsiveWindowPosition(profileId, {
    width: normalizedState.width,
    height: normalizedState.height
  });
  const clampedPlacement = clampWindowPositionToViewport({
    left: normalizedState.left,
    top: normalizedState.top,
    width: restoredSize.width,
    height: restoredSize.height
  });
  if (!Number.isFinite(clampedPlacement.left) || !Number.isFinite(clampedPlacement.top)) return;
  const position = {
    left: clampedPlacement.left,
    top: clampedPlacement.top,
    width: restoredSize.width,
    height: restoredSize.height
  };
  const currentState = captureWindowState(app);
  if (areWindowStatesEquivalent(currentState, position)) return;
  const apply = () => app.setPosition(position);
  apply();
  requestAnimationFrame(apply);
}

function buildOperationsContextFallback() {
  const ledger = getOperationsLedger();
  const lootRegistryTab = getActiveLootRegistryTab();
  const gmQuickPanel = getActiveGmQuickPanel();
  let fallbackModifierKeyOptions = [];
  let fallbackModifierModeOptions = [];
  try {
    fallbackModifierKeyOptions = buildPartyHealthModifierKeyCatalog().map((entry) => ({
      value: entry.key,
      label: entry.label,
      hint: entry.hint
    }));
    fallbackModifierModeOptions = Object.entries(CONST.ACTIVE_EFFECT_MODES ?? {})
      .map(([label, value]) => ({ label, value: Number(value) }))
      .sort((a, b) => a.label.localeCompare(b.label));
  } catch (_error) {
    fallbackModifierKeyOptions = [];
    fallbackModifierModeOptions = [];
  }
  const fallbackPreviewDraft = normalizeLootPreviewDraft(getLootPreviewDraft());
  const fallbackMode = String(fallbackPreviewDraft.mode ?? "horde");
  const fallbackProfile = String(fallbackPreviewDraft.profile ?? "standard");
  const fallbackChallenge = String(fallbackPreviewDraft.challenge ?? "mid");
  const fallbackScale = String(fallbackPreviewDraft.scale ?? "medium");
  let fallbackWeather = {
    currentLabel: "-",
    currentVisibilityModifier: "0",
    currentDarkness: "0.00"
  };
  let fallbackWeatherSceneSnapshot = {
    label: "-",
    darkness: "0.00",
    visibilityModifier: "0"
  };
  let fallbackWeatherOptions = [];
  let fallbackWeatherDraft = {
    selectedKey: "",
    darkness: 0,
    visibilityModifier: 0,
    note: "",
    presetName: "",
    daeChanges: []
  };
  let fallbackWeatherDaeModeOptions = [];
  try {
    const weatherState = ensureWeatherState(ledger);
    const currentWeather = weatherState.current ?? null;
    fallbackWeather = {
      currentLabel: String(currentWeather?.label ?? "-"),
      currentVisibilityModifier: Number(currentWeather?.visibilityModifier ?? 0),
      currentDarkness: Number(currentWeather?.darkness ?? 0)
    };
    const weatherSceneSnapshot = resolveCurrentSceneWeatherSnapshot();
    fallbackWeatherSceneSnapshot = {
      label: String(weatherSceneSnapshot?.label ?? "-") || "-",
      darkness: Number.isFinite(Number(weatherSceneSnapshot?.darkness))
        ? Number(weatherSceneSnapshot.darkness)
        : 0,
      visibilityModifier: Number.isFinite(Number(weatherSceneSnapshot?.visibilityModifier))
        ? Number(weatherSceneSnapshot.visibilityModifier)
        : 0
    };
    const weatherQuickOptions = buildWeatherSelectionCatalog(weatherState, weatherSceneSnapshot);
    const storedWeatherDraft = getGmQuickWeatherDraft();
    const fallbackWeatherOption = weatherQuickOptions[0] ?? null;
    const selectedWeatherKey = String(storedWeatherDraft?.selectedKey ?? fallbackWeatherOption?.key ?? "").trim();
    const selectedWeatherOption = weatherQuickOptions.find((entry) => entry.key === selectedWeatherKey) ?? fallbackWeatherOption;
    fallbackWeatherDraft = {
      selectedKey: String(selectedWeatherOption?.key ?? ""),
      darkness: Number.isFinite(Number(storedWeatherDraft?.darkness))
        ? Math.max(0, Math.min(1, Number(storedWeatherDraft.darkness)))
        : Math.max(0, Math.min(1, Number(selectedWeatherOption?.darkness ?? weatherSceneSnapshot?.darkness ?? 0))),
      visibilityModifier: Number.isFinite(Number(storedWeatherDraft?.visibilityModifier))
        ? Math.max(-5, Math.min(5, Math.floor(Number(storedWeatherDraft.visibilityModifier))))
        : Math.max(-5, Math.min(5, Math.floor(Number(selectedWeatherOption?.visibilityModifier ?? 0) || 0))),
      note: String(storedWeatherDraft?.note ?? ""),
      presetName: String(storedWeatherDraft?.presetName ?? ""),
      daeChanges: Array.isArray(storedWeatherDraft?.daeChanges)
        ? storedWeatherDraft.daeChanges.map((entry) => normalizeWeatherDaeChange(entry)).filter((entry) => entry.key && entry.value)
        : (Array.isArray(selectedWeatherOption?.daeChanges)
          ? selectedWeatherOption.daeChanges.map((entry) => normalizeWeatherDaeChange(entry)).filter((entry) => entry.key && entry.value)
          : [])
    };
    fallbackWeatherOptions = weatherQuickOptions.map((option) => ({
      key: option.key,
      label: option.label,
      weatherId: option.weatherId,
      isBuiltIn: Boolean(option.isBuiltIn),
      visibilityModifier: Number(option.visibilityModifier ?? 0),
      visibilityLabel: formatSignedModifier(Number(option.visibilityModifier ?? 0)) || "0",
      effectSummary: getWeatherEffectSummary(Number(option.visibilityModifier ?? 0)),
      daeSummary: describeWeatherDaeChanges(option.daeChanges ?? []),
      selected: option.key === fallbackWeatherDraft.selectedKey
    }));
    fallbackWeatherDaeModeOptions = Object.entries(CONST.ACTIVE_EFFECT_MODES ?? {})
      .map(([label, value]) => ({ label, value: Number(value) }))
      .sort((a, b) => a.label.localeCompare(b.label));
  } catch (_error) {
    fallbackWeatherDaeModeOptions = [];
  }
  let fallbackLootSources;
  try {
    fallbackLootSources = buildLootSourceRegistryContext();
    fallbackLootSources.preview = buildLootPreviewContext();
  } catch (_error) {
    fallbackLootSources = {
      itemPackOptions: [],
      itemPackVisibleOptions: [],
      itemPackCollapsed: false,
      itemPackToggleLabel: "Collapse",
      itemPackToggleIcon: "fa-chevron-up",
      itemPackFilter: "",
      itemPackFilterActive: false,
      itemPackVisibleCount: 0,
      tableOptions: [],
      itemTypeOptions: [],
      rarityFloorOptions: [],
      rarityCeilingOptions: [],
      manifestPackOptions: [],
      manifestPackId: "",
      keywordIncludeTagsInput: "",
      keywordExcludeTagsInput: "",
      keywordIncludeTagCount: 0,
      keywordExcludeTagCount: 0,
      summary: {
        enabledItemPacks: 0,
        totalItemPacks: 0,
        enabledTables: 0,
        totalTables: 0,
        enabledItemTypes: 0,
        totalItemTypes: 0,
        updatedAtLabel: "-",
        updatedBy: "-"
      },
      preview: {
        modeOptions: LOOT_PREVIEW_MODE_OPTIONS.map((entry) => ({ ...entry, selected: entry.value === fallbackMode })),
        profileOptions: LOOT_PREVIEW_PROFILE_OPTIONS.map((entry) => ({ ...entry, selected: entry.value === fallbackProfile })),
        challengeOptions: LOOT_PREVIEW_CHALLENGE_OPTIONS.map((entry) => ({ ...entry, selected: entry.value === fallbackChallenge })),
        scaleOptions: LOOT_PREVIEW_SCALE_OPTIONS.map((entry) => ({ ...entry, selected: entry.value === fallbackScale })),
        draft: fallbackPreviewDraft,
        hasResult: false,
        generatedAtLabel: "-",
        generatedBy: "-",
        currency: {
          pp: 0,
          gp: 0,
          sp: 0,
          cp: 0,
          gpEquivalent: 0,
          formula: "-"
        },
        stats: {
          candidateCount: 0,
          itemCountGenerated: 0,
          itemCountTarget: 0,
          tableRollCount: 0
        },
        items: [],
        tableRolls: [],
        warnings: []
      }
    };
  }
  fallbackLootSources.registryTab = lootRegistryTab;
  fallbackLootSources.registryTabPreview = lootRegistryTab === "preview";
  fallbackLootSources.registryTabSettings = lootRegistryTab === "settings";
  let fallbackLootClaims;
  try {
    fallbackLootClaims = buildLootClaimsContext(game.user);
  } catch (_error) {
    fallbackLootClaims = {
      selectedRunId: "",
      selectedRunStatus: "open",
      selectedRunIsArchived: false,
      hasSelectedRun: false,
      selectedRunCard: null,
      hasOpenRuns: false,
      openRunCount: 0,
      openRuns: [],
      hasArchivedRuns: false,
      archivedRunCount: 0,
      archivedRuns: [],
      archiveSort: "archived-desc",
      archiveSortOptions: LOOT_CLAIMS_ARCHIVE_SORT_OPTIONS.map((entry) => ({
        value: entry.value,
        label: entry.label,
        selected: entry.value === "archived-desc"
      })),
      runOptions: [],
      publishedAtLabel: "-",
      publishedBy: "-",
      itemCount: 0,
      claimsLogCount: 0,
      currencyRemaining: { pp: 0, gp: 0, sp: 0, cp: 0 },
      currencyClaimedCount: 0,
      hasItems: false,
      items: []
    };
  }
  const roleMeta = [
    { key: "quartermaster", label: "Quartermaster", bonus: "+Supply discipline", penalty: "Missed ration/ammo tracking", hint: "Assign this role to keep supply usage, load tracking, and upkeep consistent." },
    { key: "cartographer", label: "Cartographer", bonus: "+Route clarity", penalty: "Navigation uncertainty", hint: "Assign this role to maintain route notes, landmarks, and navigation prep." },
    { key: "chronicler", label: "Chronicler", bonus: "+Operational recall", penalty: "Lost session intel", hint: "Assign this role to track key discoveries, risks, and mission outcomes." },
    { key: "steward", label: "Steward", bonus: "+Financial control", penalty: "Debt/coin drift", hint: "Assign this role to manage coin flow, contracts, and downtime costs." }
  ];
  const roles = roleMeta.map((role) => {
    const actorId = String(ledger.roles?.[role.key] ?? "");
    const actor = actorId ? game.actors.get(actorId) : null;
    return {
      key: role.key,
      label: role.label,
      actorId,
      actorName: actor?.name ?? "Unassigned",
      hasActor: Boolean(actor),
      bonus: role.bonus,
      penalty: role.penalty,
      hint: role.hint,
      actorOptions: buildRoleActorOptions(actorId)
    };
  });
  const sopMeta = [
    { key: "campSetup", label: "Camp setup" },
    { key: "watchRotation", label: "Watch rotation" },
    { key: "dungeonBreach", label: "Dungeon breach protocol" },
    { key: "urbanEntry", label: "Urban entry protocol" },
    { key: "prisonerHandling", label: "Prisoner handling" },
    { key: "retreatProtocol", label: "Retreat protocol" }
  ];
  const sops = sopMeta.map((sop) => {
    const worldNote = String(ledger.sopNotes?.[sop.key] ?? "");
    const resolved = resolveSopNoteForView(sop.key, worldNote);
    return {
      key: sop.key,
      label: sop.label,
      active: Boolean(ledger.sops?.[sop.key]),
      note: resolved.note,
      pendingLocalSync: resolved.pendingSync
    };
  });
  schedulePendingSopNoteSync("operations-fallback-context");
  const roleCoverage = roles.filter((role) => role.hasActor).length;
  const activeSops = sops.filter((sop) => sop.active).length;
  const fallbackEffects = (() => {
    try {
      return getOperationalEffects(ledger, roles, sops);
    } catch {
      return {
        riskTier: "unknown",
        bonuses: [],
        globalMinorBonuses: [],
        globalModifiers: {
          initiative: 0,
          abilityChecks: 0,
          perceptionChecks: 0,
          savingThrows: 0
        },
        worldGlobalModifiers: {
          initiative: 0,
          abilityChecks: 0,
          perceptionChecks: 0,
          savingThrows: 0
        },
        globalModifierRows: [],
        derivedModifierRows: [],
        customModifierRows: [],
        hasGlobalModifiers: false,
        hasCustomModifiers: false,
        customDaeChanges: [],
        worldDaeChanges: [],
        hasGlobalMinorBonuses: false,
        hasRisks: false,
        risks: []
      };
    }
  })();
  const fallbackResourcesState = foundry.utils.deepClone(ledger.resources ?? {});
  ensureOperationalResourceConfig(fallbackResourcesState);
  const fallbackStewardPools = {
    food: buildStewardPoolContext(fallbackResourcesState, "food"),
    water: buildStewardPoolContext(fallbackResourcesState, "water"),
    torches: buildStewardPoolContext(fallbackResourcesState, "torches")
  };
  const fallbackUpkeep = {
    partySize: Number(ledger.resources?.upkeep?.partySize ?? 4),
    foodPerMember: Number(ledger.resources?.upkeep?.foodPerMember ?? 1),
    waterPerMember: Number(ledger.resources?.upkeep?.waterPerMember ?? 1),
    foodMultiplier: Number(ledger.resources?.upkeep?.foodMultiplier ?? 1),
    waterMultiplier: Number(ledger.resources?.upkeep?.waterMultiplier ?? 1),
    torchPerRest: Number(ledger.resources?.upkeep?.torchPerRest ?? 0)
  };
  const fallbackFoodDrainPerDay = Math.max(0, Math.ceil(fallbackUpkeep.partySize * fallbackUpkeep.foodPerMember * fallbackUpkeep.foodMultiplier));
  const fallbackWaterDrainPerDay = Math.max(0, Math.ceil(fallbackUpkeep.partySize * fallbackUpkeep.waterPerMember * fallbackUpkeep.waterMultiplier));
  const fallbackTorchDrainPerDay = Math.max(0, Math.ceil(fallbackUpkeep.torchPerRest));
  const fallbackUpkeepDaysPending = getUpkeepDaysFromCalendar(fallbackResourcesState.upkeepLastAppliedTs, getCurrentWorldTimestamp());
  const fallbackResourcesNumeric = {
    food: Number(fallbackResourcesState.food ?? 0),
    partyFoodRations: getStewardPoolFiniteAmount(fallbackStewardPools.food),
    partyWaterRations: getStewardPoolFiniteAmount(fallbackStewardPools.water),
    water: Number(fallbackResourcesState.water ?? 0),
    torches: getStewardPoolFiniteAmount(fallbackStewardPools.torches)
  };
  const fallbackInfiniteFoodSteward = isStewardPoolInfinite(fallbackStewardPools.food);
  const fallbackInfiniteWaterSteward = isStewardPoolInfinite(fallbackStewardPools.water);
  const fallbackLinkedFoodStock = getSelectedResourceItemQuantity(fallbackResourcesState, "food");
  const fallbackLinkedWaterStock = getSelectedResourceItemQuantity(fallbackResourcesState, "water");
  const fallbackTotalFoodReserve = Math.max(0, fallbackResourcesNumeric.partyFoodRations) + fallbackLinkedFoodStock;
  const fallbackTotalWaterReserve = Math.max(0, fallbackResourcesNumeric.partyWaterRations) + fallbackLinkedWaterStock;
  const fallbackFormatCyclesLeft = (stock, drain, infinite = false) => {
    if (infinite) return "infinite";
    if (drain <= 0) return "infinite";
    return (Math.max(0, stock) / drain).toFixed(1);
  };
  const fallbackSelectedBindingCount = RESOURCE_TRACK_KEYS.filter((key) => {
    const selected = fallbackResourcesState.itemSelections?.[key] ?? {};
    return Boolean(String(selected.actorId ?? "").trim() && String(selected.itemId ?? "").trim());
  }).length;
  const fallbackNextDueKey = getNextUpkeepDueKey(getCurrentWorldTimestamp());
  const fallbackGatherFoodCoveredNextUpkeep = Number(fallbackResourcesState.gather?.foodCoverageDueKey) === fallbackNextDueKey;
  const fallbackGatherWaterCoveredNextUpkeep = Number(fallbackResourcesState.gather?.waterCoverageDueKey) === fallbackNextDueKey;
  let fallbackGatherWeatherOptions = [];
  try {
    fallbackGatherWeatherOptions = getGatherWeatherOptions(fallbackResourcesState);
  } catch {
    fallbackGatherWeatherOptions = [];
  }
  const fallbackGatherHistoryView = getGatherHistoryViewState();
  const fallbackGatherPresets = buildGatherPresetContext();
  const fallbackGatherHistory = buildGatherHistoryContext(fallbackResourcesState, { viewState: fallbackGatherHistoryView });
  const fallbackEnvironmentPreset = getEnvironmentPresetByKey(String(ledger.environment?.presetKey ?? "none"));
  const fallbackEnvironmentCheck = getEnvironmentCheckMeta(fallbackEnvironmentPreset);
  let fallbackMerchants;
  try {
    fallbackMerchants = buildMerchantsContext(ledger, { user: game.user });
  } catch {
    fallbackMerchants = {
      currentSettlement: "",
      currentSettlementLabel: "Global",
      settlementOptions: [{ value: "", label: "All Cities", selected: true }],
      selectedSettlement: "",
      selectedSettlementLabel: "All Cities",
      actorOptions: [],
      hasActorOptions: false,
      activeActorId: "",
      activeActorName: "",
      hasActiveActor: false,
      activeActorSocialScore: 0,
      availableMerchants: [],
      hasAvailableMerchants: false,
      activeMerchantId: "",
      hasActiveMerchant: false,
      activeMerchantName: "No Merchant Selected",
      activeMerchantTitle: "",
      activeMerchantRace: "",
      activeMerchantImg: "icons/svg/mystery-man.svg",
      activeMerchantStockCount: 0,
      activeMerchantBuyMarkupLabel: "1.00",
      activeMerchantCanOpenShop: false,
      inventoryRows: [],
      hasInventoryRows: false,
      inventoryItemCount: 0,
      viewerName: String(game.user?.name ?? "Player").trim() || "Player",
      viewerLastAccessLabel: "-",
      shouldLogAccess: false,
      accessLogPayload: {},
      gm: {
        definitions: [],
        hasDefinitions: false,
        editorViewTab: "editor",
        editorViewTabEditor: true,
        editorViewTabSettings: false,
        cityCatalogInput: "",
        editor: {
          id: "",
          name: "",
          title: "",
          race: "",
          img: "icons/svg/item-bag.svg",
          settlement: "",
          accessMode: MERCHANT_ACCESS_MODES.ALL,
          isHidden: false,
          requiresContract: false,
          contractKey: "",
          socialGateEnabled: false,
          minSocialScore: 0,
          buyMarkup: MERCHANT_DEFAULTS.pricing.buyMarkup,
          buyMarkupPercent: Number((MERCHANT_DEFAULTS.pricing.buyMarkup * 100).toFixed(2)),
          buyMarkupMultiplierLabel: (1 + Number(MERCHANT_DEFAULTS.pricing.buyMarkup)).toFixed(2),
          sellRate: MERCHANT_DEFAULTS.pricing.sellRate,
          sellRatePercent: Number((Number(MERCHANT_DEFAULTS.pricing.sellRate) * 100).toFixed(2)),
          sellEnabled: MERCHANT_DEFAULTS.pricing.sellEnabled !== false,
          cashOnHandGp: Number(MERCHANT_DEFAULTS.pricing.cashOnHandGp ?? 500),
          buybackAllowedTypes: normalizeMerchantAllowedItemTypes(
            MERCHANT_DEFAULTS.pricing.buybackAllowedTypes
            ?? MERCHANT_ALLOWED_ITEM_TYPE_LIST
          ),
          barterEnabled: MERCHANT_DEFAULTS.pricing.barterEnabled !== false,
          barterDc: Number(MERCHANT_DEFAULTS.pricing.barterDc ?? 15),
          barterAbility: normalizeMerchantBarterAbility(MERCHANT_DEFAULTS.pricing.barterAbility ?? "cha"),
          sourceType: MERCHANT_SOURCE_TYPES.WORLD_FOLDER,
          sourceRef: "",
          sourcePackIds: [],
          includeTagsInput: "",
          excludeTagsInput: "",
          keywordIncludeInput: "",
          keywordExcludeInput: "",
          allowedTypes: [...MERCHANT_ALLOWED_ITEM_TYPE_LIST],
          curatedItemUuidsInput: "",
          maxItems: MERCHANT_DEFAULTS.stock.maxItems,
          stockCount: MERCHANT_DEFAULTS.stock.maxItems,
          targetValueGp: MERCHANT_DEFAULTS.stock.targetValueGp,
          scarcity: MERCHANT_DEFAULTS.stock.scarcity,
          scarcityLabel: String(getMerchantScarcityProfile(MERCHANT_DEFAULTS.stock.scarcity)?.label ?? "6 - Normal"),
          duplicateChance: MERCHANT_DEFAULTS.stock.duplicateChance,
          maxStackSize: MERCHANT_DEFAULTS.stock.maxStackSize,
          rarityWeightCommon: Number(MERCHANT_DEFAULTS.stock.rarityWeights?.common ?? 100),
          rarityWeightUncommon: Number(MERCHANT_DEFAULTS.stock.rarityWeights?.uncommon ?? 45),
          rarityWeightRare: Number(MERCHANT_DEFAULTS.stock.rarityWeights?.rare ?? 16),
          rarityWeightVeryRare: Number(MERCHANT_DEFAULTS.stock.rarityWeights?.["very-rare"] ?? 5),
          rarityWeightLegendary: Number(MERCHANT_DEFAULTS.stock.rarityWeights?.legendary ?? 1),
          actorId: ""
        },
        sourceTypeOptions: getMerchantEditorSourceTypeOptions(MERCHANT_SOURCE_TYPES.WORLD_FOLDER),
        accessModeOptions: getMerchantAccessModeOptions(MERCHANT_ACCESS_MODES.ALL),
        barterAbilityOptions: getMerchantBarterAbilityOptions(MERCHANT_DEFAULTS.pricing.barterAbility ?? "cha"),
        raceOptions: getMerchantEditorRaceOptions(""),
        cityOptions: [{ value: "", label: "Global", selected: true }],
        offerTagOptions: buildMerchantOfferTagOptions(MERCHANT_DEFAULTS.stock.allowedTypes),
        scarcityOptions: getMerchantScarcityOptions(MERCHANT_DEFAULTS.stock.scarcity),
        actorOptions: [{ id: "", name: "Create on refresh", selected: true }],
        sourceRefOptions: [{ value: "", label: "Select one or more item folders", selected: true, disabled: true }],
        sourceRefSelectableOptions: [],
        hasSourceRefSelectableOptions: false,
        sourceRefOptionCount: 0,
        sourceRefSelectedCount: 0,
        sourceRefHintLabel: "Select one or more item folders",
        sourcePackFilter: "",
        sourcePackOptions: [],
        sourcePackVisibleOptions: [],
        sourcePackVisibleCount: 0,
        sourcePackFilterActive: false,
        tagCatalogCount: 0,
        hasTagCatalog: false,
        includeTagOptions: [],
        excludeTagOptions: [],
        keywordCatalogCount: 0,
        hasKeywordCatalog: false,
        keywordIncludeOptions: [],
        keywordExcludeOptions: [],
        allowedTypeOptions: getMerchantAllowedTypeOptionsForEditor(MERCHANT_DEFAULTS.stock.allowedTypes),
        buybackTypeOptions: getMerchantAllowedTypeOptionsForEditor(
          MERCHANT_DEFAULTS.pricing.buybackAllowedTypes
          ?? MERCHANT_ALLOWED_ITEM_TYPE_LIST
        ),
        curatedRows: [],
        hasCuratedRows: false,
        itemFilter: "",
        candidateRows: [],
        hasCandidateRows: false,
        assignmentRows: [],
        hasAssignmentRows: false
      }
    };
  }
  return {
    summary: {
      roleCoverage,
      roleTotal: roles.length,
      activeSops,
      sopTotal: sops.length,
      effects: fallbackEffects
    },
    roles,
    sops,
    resources: {
      food: fallbackResourcesNumeric.food,
      linkedFoodStock: fallbackLinkedFoodStock,
      linkedWaterStock: fallbackLinkedWaterStock,
      partyFoodRations: fallbackResourcesNumeric.partyFoodRations,
      partyWaterRations: fallbackResourcesNumeric.partyWaterRations,
      water: fallbackResourcesNumeric.water,
      torches: fallbackResourcesNumeric.torches,
      stewardPools: fallbackStewardPools,
      itemSelections: {
        food: buildResourceSelectionContext(fallbackResourcesState, "food"),
        water: buildResourceSelectionContext(fallbackResourcesState, "water"),
        torches: buildResourceSelectionContext(fallbackResourcesState, "torches")
      },
      gatherWeatherOptions: fallbackGatherWeatherOptions,
      gatherFoodCoveredNextUpkeep: fallbackGatherFoodCoveredNextUpkeep,
      gatherWaterCoveredNextUpkeep: fallbackGatherWaterCoveredNextUpkeep,
      gatherPresets: fallbackGatherPresets,
      hasGatherPresets: fallbackGatherPresets.length > 0,
      gatherHistory: fallbackGatherHistory,
      hasGatherHistory: fallbackGatherHistory.hasRows,
      summary: {
        foodDrainPerDay: fallbackFoodDrainPerDay,
        waterDrainPerDay: fallbackWaterDrainPerDay,
        torchDrainPerDay: fallbackTorchDrainPerDay,
        upkeepDaysPending: fallbackUpkeepDaysPending,
        foodDrainPending: fallbackFoodDrainPerDay * fallbackUpkeepDaysPending,
        waterDrainPending: fallbackWaterDrainPerDay * fallbackUpkeepDaysPending,
        foodStewardPoolDisplay: fallbackStewardPools.food.amountDisplay,
        waterStewardPoolDisplay: fallbackStewardPools.water.amountDisplay,
        torchStewardPoolDisplay: fallbackStewardPools.torches.amountDisplay,
        foodCyclesLeft: fallbackFormatCyclesLeft(fallbackTotalFoodReserve, fallbackFoodDrainPerDay, fallbackInfiniteFoodSteward),
        foodRationCyclesLeft: fallbackFormatCyclesLeft(fallbackTotalFoodReserve, fallbackFoodDrainPerDay, fallbackInfiniteFoodSteward),
        waterCyclesLeft: fallbackFormatCyclesLeft(fallbackTotalWaterReserve, fallbackWaterDrainPerDay, fallbackInfiniteWaterSteward),
        waterRationCyclesLeft: fallbackFormatCyclesLeft(fallbackTotalWaterReserve, fallbackWaterDrainPerDay, fallbackInfiniteWaterSteward),
        selectedBindingCount: fallbackSelectedBindingCount
      },
      upkeep: fallbackUpkeep,
      encumbranceOptions: [
        { value: "light", label: "Light", selected: (fallbackResourcesState.encumbrance ?? "light") === "light" },
        { value: "moderate", label: "Moderate", selected: (fallbackResourcesState.encumbrance ?? "light") === "moderate" },
        { value: "heavy", label: "Heavy", selected: (fallbackResourcesState.encumbrance ?? "light") === "heavy" },
        { value: "overloaded", label: "Overloaded", selected: (fallbackResourcesState.encumbrance ?? "light") === "overloaded" }
      ]
    },
    weather: fallbackWeather,
    gmQuickTools: {
      activePanel: gmQuickPanel,
      showFactionPanel: gmQuickPanel === "faction",
      showModifierPanel: gmQuickPanel === "modifier",
      showWeatherPanel: gmQuickPanel === "weather",
      modifierKeyOptions: fallbackModifierKeyOptions,
      modifierModeOptions: fallbackModifierModeOptions,
      stagedModifierQueue: [],
      hasStagedModifierQueue: false,
      hasModifierAddLog: false,
      modifierAddLog: [],
      weatherSceneSnapshot: fallbackWeatherSceneSnapshot,
      weatherOptions: fallbackWeatherOptions,
      weatherDaeModeOptions: fallbackWeatherDaeModeOptions,
      weatherDraft: fallbackWeatherDraft
    },
    lootSources: fallbackLootSources,
    lootClaims: fallbackLootClaims,
    merchants: fallbackMerchants,
    environment: {
      preset: fallbackEnvironmentPreset,
      targetCount: 0,
      movementCheckActive: Boolean(fallbackEnvironmentPreset?.movementCheck),
      checkLabel: String(fallbackEnvironmentCheck?.checkLabel ?? "").trim() || "-",
      movementDc: Math.max(1, Number(ledger.environment?.movementDc ?? 12) || 12),
      outcomes: {
        onSuccess: "-",
        onFail: "-",
        onFailBy5: "-",
        onSuccessiveFail: "-",
        alwaysOn: "-"
      },
      syncToSceneNonParty: Boolean(ledger.environment?.syncToSceneNonParty ?? true),
      note: String(ledger.environment?.note ?? ""),
      presetOptions: ENVIRONMENT_PRESETS.map((preset) => ({
        key: preset.key,
        label: preset.label,
        selected: preset.key === fallbackEnvironmentPreset.key
      })),
      successiveConfig: {
        statusOptions: [],
        slideFeet: 0,
        exhaustion: 0,
        damageFormula: "",
        damageTypeOptions: [],
        damageType: "",
        maxHpReductionFormula: "",
        daeChangeKey: "",
        daeKeyOptions: [],
        daeKeyHint: "-",
        daeModeOptions: [],
        daeChangeMode: 0,
        daeChangeValue: "",
        daeAvailable: true
      },
      targets: []
    }
  };
}

export class RestWatchApp extends HandlebarsApplicationMixin(ApplicationV2) {
  static DEFAULT_OPTIONS = foundry.utils.mergeObject(super.DEFAULT_OPTIONS, {
    id: "rest-watch-app",
    classes: ["party-operations"],
    window: { title: "Party Operations - Rest Watch" },
    position: getResponsiveWindowPosition("rest-watch"),
    resizable: true
  });

  static PARTS = {
    main: { template: "modules/party-operations/templates/rest-watch.hbs" }
  };

  async _prepareContext() {
    try {
      const isGM = canAccessAllPlayerOps();
      const state = getRestWatchState();
      const visibility = state.visibility ?? "names-passives";
      const slots = buildWatchSlotsView(state, isGM, visibility);
      const lockBannerText = state.locked ? (isGM ? "Players locked" : "Locked by GM") : "";
      const lockBannerTooltip = state.locked ? (isGM ? "Players cannot edit while locked." : "Edits are disabled while the GM lock is active.") : "";
      const playerCharacters = isGM ? [] : buildPlayerCharacterSelector(slots);
      const quickNotes = isGM ? buildQuickNotes(state) : [];
      const light = calculateLightSources(state.slots, state.campfire);
      let operations;
      try {
        operations = buildOperationsContext();
        this._lastGoodOperationsContext = operations;
      } catch (operationsError) {
        console.error(`${MODULE_ID}: buildOperationsContext failed`, operationsError);
        operations = this._lastGoodOperationsContext ?? buildOperationsContextFallback();
      }
      let injuryRecovery;
      try {
        injuryRecovery = buildInjuryRecoveryContext();
        this._lastGoodInjuryRecoveryContext = injuryRecovery;
      } catch (injuryRecoveryError) {
        console.error(`${MODULE_ID}: buildInjuryRecoveryContext failed`, injuryRecoveryError);
        injuryRecovery = this._lastGoodInjuryRecoveryContext ?? {};
      }
      const mainTab = normalizeMainTabId(this._activePanel ?? getActiveRestMainTab(), "rest-watch");
      const operationsTabActive = mainTab === "operations" || mainTab === "gm";
      const operationsPageValue = mainTab === "gm"
        ? "gm"
        : (() => {
          const active = getActiveOperationsPage();
          return active === "gm" ? "planning" : active;
        })();
      if (operationsPageValue === "merchants" && operations?.merchants?.shouldLogAccess === true && operations?.merchants?.accessLogPayload) {
        void logMerchantUiAccess(operations.merchants.accessLogPayload).catch((error) => {
          logUiFailure("merchant-access", "failed to record merchant UI access", error, {
            userId: operations?.merchants?.accessLogPayload?.userId,
            actorId: operations?.merchants?.accessLogPayload?.actorId
          });
        });
      }
      const operationsPlanningTab = getActiveOperationsPlanningTab();
      const gmOperationsTab = normalizeGmOperationsTab(this._gmOperationsTab ?? getActiveGmOperationsTab());
      this._gmOperationsTab = gmOperationsTab;
      const lootRegistryTab = normalizeLootRegistryTab(this._lootRegistryTab ?? operations?.lootSources?.registryTab ?? getActiveLootRegistryTab());
      this._lootRegistryTab = lootRegistryTab;
      if (operations?.lootSources) {
        operations.lootSources.registryTab = lootRegistryTab;
        operations.lootSources.registryTabPreview = lootRegistryTab === "preview";
        operations.lootSources.registryTabSettings = lootRegistryTab === "settings";
      }
      const moduleVersion = getCurrentModuleVersion();
      const miniViz = buildMiniVisualizationContext({ visibility });
      const miniVizUi = buildMiniVizUiContext();
      const totalSlots = slots.length;
      const occupiedSlots = slots.filter((slot) => (slot.entries?.length ?? 0) > 0).length;
      const assignedEntries = slots.reduce((count, slot) => count + (slot.entries?.length ?? 0), 0);
      const lowDarkvisionSlots = slots.filter((slot) => Number(slot.slotNoDarkvision ?? 0) > 0).length;
      const lockState = state.locked ? (isGM ? "Locked for players" : "Locked by GM") : "Open";
      const campfireState = state.campfire ? "Lit" : "Out";

      const context = {
        isGM,
        locked: state.locked,
        lockBannerText,
        lockBannerTooltip,
        lockBannerClass: isGM ? "is-gm" : "",
        showPopout: false,
        lastUpdatedAt: state.lastUpdatedAt ?? "-",
        lastUpdatedBy: state.lastUpdatedBy ?? "-",
        moduleVersion,
        mainContextLabel: mainTab === "gm" ? "GM" : (mainTab === "operations" ? "Operations" : "Rest Watch"),
        mainSubtitleLabel: mainTab === "gm" ? "GM" : (mainTab === "operations" ? "Operations" : "Rest Watch"),
        visibilityOptions: buildVisibilityOptions(visibility),
        highestPP: isGM ? computeHighestPP(slots) : "-",
        noDarkvision: isGM ? computeNoDarkvision(slots) : "",
        quickNotes,
        hasQuickNotes: quickNotes.length > 0,
        playerCharacters,
        slots,
        campfire: state.campfire ?? false,
        light,
        operations,
        injuryRecovery,
        miniViz,
        ...miniVizUi,
        mainTab,
        activeTab: getSwitchTabIdFromMainTabId(mainTab),
        mainTabRestWatch: mainTab === "rest-watch",
        mainTabOperations: mainTab === "operations",
        mainTabGm: mainTab === "gm",
        mainTabOperationsOrGm: operationsTabActive,
        gmPanelTabCore: mainTab === "rest-watch",
        gmPanelTabOperations: operationsTabActive,
        operationsPagePlanning: operationsPageValue === "planning",
        operationsPageReadiness: operationsPageValue === "readiness",
        operationsPageComms: operationsPageValue === "comms",
        operationsPageReputation: operationsPageValue === "reputation",
        operationsPageSupply: false,
        operationsPageBase: operationsPageValue === "base",
        operationsPageMerchants: operationsPageValue === "merchants",
        operationsPageDowntime: operationsPageValue === "downtime",
        operationsPageRecovery: operationsPageValue === "recovery",
        operationsPageGm: operationsPageValue === "gm",
        gmOpsTabEnvironment: gmOperationsTab === "environment",
        gmOpsTabLootSources: gmOperationsTab === "loot-sources",
        operationsPlanningRoles: operationsPlanningTab === "roles",
        operationsPlanningSops: operationsPlanningTab === "sops",
        operationsPlanningResources: operationsPlanningTab === "resources",
        operationsPlanningLoot: operationsPlanningTab === "loot",
        operationsPlanningBonuses: operationsPlanningTab === "bonuses",
        overview: {
          totalSlots,
          occupiedSlots,
          assignedEntries,
          lowDarkvisionSlots,
          hasLowDarkvisionCoverage: lowDarkvisionSlots > 0,
          lockState,
          campfireState
        }
      };

      logUiDebug("rest-watch", "prepared rest context", {
        mainTab,
        gmOperationsTab,
        lootRegistryTab,
        template: getTemplateForMainTab(mainTab),
        slots: slots.length,
        isGM
      });
      return context;
    } catch (error) {
      console.error(`${MODULE_ID}: RestWatchApp _prepareContext failed`, error);
      const mainTab = normalizeMainTabId(getActiveRestMainTab(), "rest-watch");
      const operationsTabActive = mainTab === "operations" || mainTab === "gm";
      const isGM = Boolean(canAccessAllPlayerOps());
      const fallbackState = getRestWatchState();
      const fallbackVisibility = fallbackState.visibility ?? "names-passives";
      const fallbackSlots = buildWatchSlotsView(fallbackState, isGM, fallbackVisibility);
      const fallbackTotalSlots = fallbackSlots.length;
      const fallbackOccupiedSlots = fallbackSlots.filter((slot) => (slot.entries?.length ?? 0) > 0).length;
      const fallbackAssignedEntries = fallbackSlots.reduce((count, slot) => count + (slot.entries?.length ?? 0), 0);
      const fallbackLowDarkvisionSlots = fallbackSlots.filter((slot) => Number(slot.slotNoDarkvision ?? 0) > 0).length;
      const fallbackCampfire = Boolean(fallbackState.campfire);
      const fallbackGmOpsTab = normalizeGmOperationsTab(this._gmOperationsTab ?? getActiveGmOperationsTab());
      const fallbackOpsPage = mainTab === "gm"
        ? "gm"
        : (() => {
          const active = getActiveOperationsPage();
          return active === "gm" ? "planning" : active;
        })();
      const fallbackPlanningTab = getActiveOperationsPlanningTab();
      logUiDebug("rest-watch", "falling back to safe context", { mainTab, error: String(error?.message ?? error) });
      return {
        isGM,
        locked: Boolean(fallbackState.locked),
        lockBannerText: fallbackState.locked ? (isGM ? "Players locked" : "Locked by GM") : "",
        lockBannerTooltip: fallbackState.locked ? (isGM ? "Players cannot edit while locked." : "Edits are disabled while the GM lock is active.") : "",
        lockBannerClass: isGM ? "is-gm" : "",
        showPopout: false,
        lastUpdatedAt: fallbackState.lastUpdatedAt ?? "-",
        lastUpdatedBy: fallbackState.lastUpdatedBy ?? "-",
        moduleVersion: getCurrentModuleVersion(),
        mainContextLabel: mainTab === "gm" ? "GM" : (mainTab === "operations" ? "Operations" : "Rest Watch"),
        mainSubtitleLabel: mainTab === "gm" ? "GM" : (mainTab === "operations" ? "Operations" : "Rest Watch"),
        visibilityOptions: buildVisibilityOptions(fallbackVisibility),
        highestPP: isGM ? computeHighestPP(fallbackSlots) : "-",
        noDarkvision: isGM ? computeNoDarkvision(fallbackSlots) : "",
        quickNotes: [],
        hasQuickNotes: false,
        playerCharacters: [],
        slots: fallbackSlots,
        campfire: fallbackCampfire,
        light: calculateLightSources(fallbackState.slots, fallbackCampfire),
        operations: this._lastGoodOperationsContext ?? buildOperationsContextFallback(),
        injuryRecovery: this._lastGoodInjuryRecoveryContext ?? {},
        miniViz: {},
        ...buildMiniVizUiContext(),
        mainTab,
        activeTab: getSwitchTabIdFromMainTabId(mainTab),
        mainTabRestWatch: mainTab === "rest-watch",
        mainTabOperations: mainTab === "operations",
        mainTabGm: mainTab === "gm",
        mainTabOperationsOrGm: operationsTabActive,
        gmPanelTabCore: mainTab === "rest-watch",
        gmPanelTabOperations: operationsTabActive,
        operationsPagePlanning: fallbackOpsPage === "planning",
        operationsPageReadiness: fallbackOpsPage === "readiness",
        operationsPageComms: fallbackOpsPage === "comms",
        operationsPageReputation: fallbackOpsPage === "reputation",
        operationsPageSupply: false,
        operationsPageBase: fallbackOpsPage === "base",
        operationsPageMerchants: fallbackOpsPage === "merchants",
        operationsPageDowntime: fallbackOpsPage === "downtime",
        operationsPageRecovery: fallbackOpsPage === "recovery",
        operationsPageGm: fallbackOpsPage === "gm",
        gmOpsTabEnvironment: fallbackGmOpsTab === "environment",
        gmOpsTabLootSources: fallbackGmOpsTab === "loot-sources",
        operationsPlanningRoles: fallbackPlanningTab === "roles",
        operationsPlanningSops: fallbackPlanningTab === "sops",
        operationsPlanningResources: fallbackPlanningTab === "resources",
        operationsPlanningLoot: fallbackPlanningTab === "loot",
        operationsPlanningBonuses: fallbackPlanningTab === "bonuses",
        overview: {
          totalSlots: fallbackTotalSlots,
          occupiedSlots: fallbackOccupiedSlots,
          assignedEntries: fallbackAssignedEntries,
          lowDarkvisionSlots: fallbackLowDarkvisionSlots,
          hasLowDarkvisionCoverage: fallbackLowDarkvisionSlots > 0,
          lockState: fallbackState.locked ? (isGM ? "Locked for players" : "Locked by GM") : "Open",
          campfireState: fallbackCampfire ? "Lit" : "Out"
        }
      };
    }
  }

  async _onRender(context, options) {
    await super._onRender(context, options);
    if (DEBUG_LOG) console.log("RestWatchApp: _onRender called");
    restWatchAppInstance = this;
    ensurePartyOperationsClass(this);
    syncApplicationWindowTitle(this, getRestMainWindowTitle(getActiveRestMainTab()));
    
    if (this.element && !this.element.dataset.poBoundRest) {
      this.element.dataset.poBoundRest = "1";

      // Use event delegation on the app element
      this.element.addEventListener("click", (event) => {
        const tabSwitch = event.target?.closest('[data-action="switch-tab"][data-tab]');
        if (tabSwitch) return this.#onSwitchTabClick(event, tabSwitch);

        const actionElement = event.target?.closest("[data-action]");
        if (isFormActionElement(actionElement)) return;
        const action = actionElement?.dataset?.action;
        if (action) {
          logUiDebug("rest-watch", "click action", {
            action,
            target: summarizeClickTarget(event.target)
          });
        }
        if (action) this.#onAction(event);
      });

      if (isModuleDebugEnabled()) {
        this.element.addEventListener("click", (event) => {
          const target = event.target instanceof Element ? event.target : null;
          if (!target) return;
          if (target.closest('[data-action="switch-tab"]')) return;
          const computed = getComputedStyle(target);
          const zIndexValue = Number.parseInt(computed.zIndex ?? "0", 10);
          const suspicious = (computed.position === "fixed" || computed.position === "absolute") && Number.isFinite(zIndexValue) && zIndexValue >= 900;
          if (!suspicious) return;
          logUiDebug("rest-watch", "capture-click suspicious overlay", {
            target: summarizeClickTarget(target),
            zIndex: computed.zIndex,
            position: computed.position,
            pointerEvents: computed.pointerEvents
          });
        }, true);
      }
      
      this.element.addEventListener("change", (event) => {
        if (event.target?.matches("select[data-action], input[data-action], textarea[data-action]")) {
          this.#onAction(event);
        } else if (event.target?.matches("textarea.po-notes-input")) {
          cacheRestWatchNoteDraftFromElement(event.target);
          scheduleRestWatchNoteSave(this, event.target, { source: "autosave" });
        }
      });

      this.element.addEventListener("input", (event) => {
        if (event.target?.matches("input[data-merchant-pack-filter]")) {
          setMerchantEditorPackFilter(event.target?.value ?? "");
          applyMerchantEditorFilters(this.element);
          return;
        }
        if (event.target?.matches("input[data-merchant-item-filter]")) {
          setMerchantEditorItemFilter(event.target?.value ?? "");
          applyMerchantEditorFilters(this.element);
          return;
        }
        if (event.target?.matches("input[data-action='set-loot-pack-filter']")) {
          this.#onAction(event);
          return;
        }
        if (event.target?.matches("textarea[data-action='set-sop-note']")) {
          cacheOperationalSopNoteDraftFromElement(event.target);
          scheduleOperationalSopNoteSave(this, event.target);
          return;
        }
        if (event.target?.matches("input[data-action='set-journal-filter']")) {
          scheduleOperationsJournalFilterUpdate(this, event.target?.value ?? "", () => {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          });
          return;
        }
        if (event.target?.matches("textarea.po-notes-input")) {
          cacheRestWatchNoteDraftFromElement(event.target);
          return;
        }
      });

      this.element.addEventListener("dblclick", (event) => {
        const portrait = event.target?.closest(".po-portrait");
        if (portrait) openActorSheetFromElement(portrait);
      });

      this.element.addEventListener("dragstart", (event) => {
        const curatedRow = event.target?.closest?.("[data-merchant-curated-row]");
        if (curatedRow) {
          const itemUuid = String(curatedRow?.dataset?.itemUuid ?? "").trim();
          if (!itemUuid || !event.dataTransfer) return;
          event.dataTransfer.effectAllowed = "move";
          event.dataTransfer.setData("application/x-po-merchant-curated", itemUuid);
          event.dataTransfer.setData("text/plain", itemUuid);
          return;
        }

        const candidateRow = event.target?.closest?.("[data-merchant-candidate-row]");
        if (!candidateRow) return;
        const candidateUuid = String(candidateRow?.dataset?.itemUuid ?? "").trim();
        if (!candidateUuid || !event.dataTransfer) return;
        event.dataTransfer.effectAllowed = "copy";
        event.dataTransfer.setData("application/x-po-merchant-candidate", candidateUuid);
        event.dataTransfer.setData("text/plain", candidateUuid);
      });

      this.element.addEventListener("dragover", (event) => {
        const merchantDropTarget = event.target?.closest?.("[data-merchant-curated-dropzone], [data-merchant-curated-list], [data-merchant-curated-row]");
        if (merchantDropTarget) {
          event.preventDefault();
          if (merchantDropTarget.classList?.contains("po-merchant-curated-row")) merchantDropTarget.classList.add("is-drop-target");
          return;
        }
        const dropZone = event.target?.closest?.("[data-loot-preview-dropzone]");
        if (!dropZone) return;
        event.preventDefault();
      });

      this.element.addEventListener("dragleave", (event) => {
        const merchantDropRow = event.target?.closest?.("[data-merchant-curated-row]");
        if (!merchantDropRow) return;
        merchantDropRow.classList.remove("is-drop-target");
      });

      this.element.addEventListener("drop", async (event) => {
        this.element.querySelectorAll?.("[data-merchant-curated-row].is-drop-target").forEach((node) => node.classList.remove("is-drop-target"));
        const merchantDropZone = event.target?.closest?.("[data-merchant-curated-dropzone]");
        if (merchantDropZone) {
          event.preventDefault();
          const draggedCuratedUuid = getMerchantCuratedDragUuidFromEvent(event);
          if (draggedCuratedUuid) {
            const moved = await reorderMerchantCuratedItemsFromElement(merchantDropZone, draggedCuratedUuid, "");
            if (moved) this.#renderWithPreservedState({ force: true, parts: ["main"] });
            return;
          }
          const draggedCandidateUuid = getMerchantCandidateDragUuidFromEvent(event);
          if (draggedCandidateUuid) {
            const added = await addMerchantCuratedItemFromElement(merchantDropZone, draggedCandidateUuid);
            if (added) this.#renderWithPreservedState({ force: true, parts: ["main"] });
            return;
          }
          const added = await addMerchantCuratedItemFromDropEvent(event);
          if (added) this.#renderWithPreservedState({ force: true, parts: ["main"] });
          return;
        }
        const merchantDropRow = event.target?.closest?.("[data-merchant-curated-row]");
        if (merchantDropRow) {
          event.preventDefault();
          const draggedUuid = getMerchantCuratedDragUuidFromEvent(event);
          const targetUuid = String(merchantDropRow?.dataset?.itemUuid ?? "").trim();
          if (draggedUuid) {
            const moved = await reorderMerchantCuratedItemsFromElement(merchantDropRow, draggedUuid, targetUuid);
            if (moved) this.#renderWithPreservedState({ force: true, parts: ["main"] });
            return;
          }
          const draggedCandidateUuid = getMerchantCandidateDragUuidFromEvent(event);
          if (draggedCandidateUuid) {
            const added = await addMerchantCuratedItemFromElement(merchantDropRow, draggedCandidateUuid);
            if (added) this.#renderWithPreservedState({ force: true, parts: ["main"] });
            return;
          }
          const added = await addMerchantCuratedItemFromDropEvent(event);
          if (added) this.#renderWithPreservedState({ force: true, parts: ["main"] });
          return;
        }
        const dropZone = event.target?.closest?.("[data-loot-preview-dropzone]");
        if (!dropZone) return;
        event.preventDefault();
        const added = await addLootPreviewItemFromDropEvent(event);
        if (added) this.#renderWithPreservedState({ force: true, parts: ["main"] });
      });
    }

    // Update activity UI state
    this.#updateActivityUI();
    this.#applyOperationsHoverHints();
    applyNonGmOperationsReadonly(this);
    applyMerchantEditorFilters(this.element);
    refreshTabAccessibility(this.element);
    diagnoseRenderedMainTabs(this.element, "rest-watch");
    this._activePanel = normalizeMainTabId(this.element?.dataset?.mainTab ?? this._activePanel ?? getActiveRestMainTab(), "rest-watch");
    if (isModuleDebugEnabled()) {
      const activeTab = getSwitchTabIdFromMainTabId(this._activePanel);
      const activeButton = this.element?.querySelector?.(`.po-tabs-main [data-action="switch-tab"][data-tab="${activeTab}"]`);
      const panelTarget = this._activePanel === "rest-watch" ? "#po-panel-rest-watch" : "#po-panel-operations";
      const panelExists = Boolean(this.element?.querySelector?.(panelTarget));
      logUiDebug("rest-watch", "after render active tab", {
        activeTab,
        activePanel: this._activePanel,
        activeButtonFound: Boolean(activeButton),
        panelTarget,
        panelExists
      });
    }

    // Setup drag-and-drop for rest watch entries
    setupRestWatchDragAndDrop(this.element);
    
    if (game.user?.isGM && canAccessAllPlayerOps() && !this._openedPlayers) {
      emitOpenRestPlayers();
      this._openedPlayers = true;
    }

    restorePendingWindowState(this);
    restorePendingUiState(this);
    hydrateCachedNoteDraftInputs(this.element);
    syncNotesDisclosureState(this.element);
    restorePendingScrollState(this);

    if (DEBUG_LOG) console.log("RestWatchApp: event delegation attached", this.element);
  }

  #updateActivityUI() {
    const root = getAppRootElement(this);
    if (!root) return;
    root.querySelectorAll(".po-exhaustion-controls").forEach((container) => {
      const current = Number(container.dataset.exhaustion ?? 0);
      container.querySelectorAll(".po-exh-btn").forEach((button) => {
        const level = Number(button.dataset.level ?? 0);
        button.classList.toggle("is-active", level === current);
      });
    });
  }

  #applyOperationsHoverHints() {
    const root = getAppRootElement(this);
    if (!root || (root.dataset.mainTab !== "operations" && root.dataset.mainTab !== "gm")) return;

    root.querySelectorAll(".po-gm-panel label.po-resource-row").forEach((label) => {
      const hintText = label.querySelector("span")?.textContent?.trim();
      if (hintText && !label.getAttribute("title")) {
        label.setAttribute("title", `${hintText}: configure this operations setting.`);
      }
      label.querySelectorAll("input, select, textarea").forEach((control) => {
        if (control.getAttribute("title") || !hintText) return;
        control.setAttribute("title", hintText);
      });
    });

    root.querySelectorAll(".po-gm-panel .po-btn, .po-gm-panel .po-switch").forEach((element) => {
      if (element.getAttribute("title")) return;
      const text = element.textContent?.trim().replace(/\s+/g, " ");
      if (!text) return;
      element.setAttribute("title", text);
    });
  }

  #renderWithPreservedState(renderOptions = { force: true, parts: ["main"], focus: false }) {
    renderAppWithPreservedState(this, renderOptions);
  }

  setActivePanel(panelId, options = {}) {
    const normalized = normalizeMainTabId(panelId, "rest-watch");
    if (normalized === "gm" && !canAccessAllPlayerOps()) {
      ui.notifications?.warn("GM permissions are required for the GM section.");
      return;
    }
    this._activePanel = normalized;
    setActiveRestMainTab(normalized);
    if (options?.rerender !== false) {
      this.#renderWithPreservedState({ force: true, parts: ["main"] });
    }
  }

  setActiveTab(tabId) {
    const requested = String(tabId ?? "").trim().toLowerCase();
    if (!PO_SWITCH_TAB_IDS.has(requested)) {
      logUiDebug("rest-watch", "setActiveTab ignored unknown tab", { tabId: requested });
      return;
    }
    const normalizedSwitchTab = normalizeSwitchTabId(requested, "rest");
    const normalizedMainTab = normalizeMainTabId(normalizedSwitchTab, "rest-watch");
    const previousMainTab = normalizeMainTabId(this._activePanel ?? getActiveRestMainTab(), "rest-watch");
    if (normalizedMainTab === previousMainTab) return;

    const windowContent = this.element?.closest?.(".window-content") ?? this.element?.querySelector?.(".window-content") ?? null;
    const previousScrollTop = windowContent?.scrollTop ?? 0;

    this._activePanel = normalizedMainTab;
    setActiveRestMainTab(normalizedMainTab);

    if (normalizedMainTab === "marching-order") {
      openMainTab("marching-order", { force: true });
    } else {
      this.#renderWithPreservedState({ force: true, parts: ["main"] });
      requestAnimationFrame(() => {
        const nextWindowContent = this.element?.closest?.(".window-content") ?? this.element?.querySelector?.(".window-content") ?? null;
        if (nextWindowContent) nextWindowContent.scrollTop = previousScrollTop;
      });
    }
  }

  #onSwitchTabClick(event, tabButton) {
    event.preventDefault();
    event.stopPropagation();
    const tabId = String(tabButton?.dataset?.tab ?? "").trim().toLowerCase();
    logUiDebug("rest-watch", "switch-tab click", {
      tabId,
      target: summarizeClickTarget(event.target)
    });
    this.setActiveTab(tabId);
  }


  #onTabClick(tabElement, html, event = null) {
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
    const tabName = normalizeMainTabId(getRequestedPanelIdFromElement(tabElement), "rest-watch");
    logUiDebug("rest-watch", "main tab click", {
      tabName,
      target: summarizeClickTarget(event?.target ?? tabElement)
    });
    if (tabName === "rest-watch" || tabName === "operations" || tabName === "gm") {
      this.setActivePanel(tabName);
      return;
    }
    if (tabName === "marching-order") {
      this.setActiveTab("march");
    }
  }

  async #onAction(event) {
    const element = event.target?.closest("[data-action]");
    const action = element?.dataset?.action;
    const preserveCanvas = shouldPreserveCanvasForUiEvent(event, element, action);
    const canvasSnapshot = preserveCanvas ? captureCanvasViewState() : null;
    try {
      const isFormAction = isFormActionElement(element);
      if (event?.type === "click" && !isFormAction) {
        event.preventDefault();
        event.stopPropagation();
      }
      if (DEBUG_LOG) console.log("RestWatchApp #onAction:", { action, element, event });
      if (!action) return;
      if (element?.tagName === "SELECT" && event?.type !== "change") return;

      const handledJournalAction = await handleOperationsJournalAction(action, element, () => {
        this.#renderWithPreservedState({ force: true, parts: ["main"] });
      });
      if (handledJournalAction) return;

      try {
        const actionHandlers = {
        "switch-tab": async () => {
          this.#onSwitchTabClick(event, element);
        },
        "refresh": async () => {
          emitSocketRefresh();
        },
        "popout": async () => {
          this.render({ force: true, popOut: true });
        },
        "assign": async () => {
          await assignSlotByPicker(element, { source: "pc" });
        },
        "assign-character": async () => {
          await assignSlotByPicker(element, { source: "pc" });
        },
        "assign-actor": async () => {
          await assignSlotByPicker(element, { source: "neutral-friendly" });
        },
        "assign-actor-global": async () => {
          await assignSlotByPicker(element, { source: "all" });
        },
        "assign-me": async () => {
          await assignSlotToUser(element);
        },
        "clear": async () => {
          await clearSlotEntry(element);
        },
        "swap": async () => {
          await swapSlots(element);
        },
        "toggle-notes": async () => {
          toggleCardNotes(element);
        },
        "save-entry-notes": async () => {
          {
            const context = getRestWatchNoteContextFromElement(element);
            if (context?.slotId && context?.actorId) {
              clearScheduledRestWatchNoteSave(this, context.slotId, context.actorId);
            }
          }
          await saveRestWatchEntryNoteFromElement(element, { source: "manual", notify: true });
        },
        "visibility": async () => {
          await updateVisibility(element);
        },
        "autofill-party": async () => {
          await autofillFromParty();
        },
        "autofill-last": async () => {
          await restoreRestCommitted();
        },
        "commit-plan": async () => {
          await commitRestWatchState();
        },
        "copy-text": async () => {
          await copyRestWatchText(false);
        },
        "copy-md": async () => {
          await copyRestWatchText(true);
        },
        "clear-all": async () => {
          await clearRestWatchAll();
        },
        "ping": async () => {
          await pingActorFromElement(element);
        },
        "time-range": async () => {
          await updateTimeRange(element);
        },
        "switch-character": async () => {
          await switchActiveCharacter(element);
        },
        "set-exhaustion": async () => {
          await updateExhaustion(element);
        },
        "set-activity": async () => {
          await updateActivity(element, { skipLocalRefresh: true });
        },
        "reset-activities": async () => {
          await resetAllActivities();
        },
        "toggle-campfire": async () => {
          await toggleCampfire(element);
        },
        "toggle-mini-viz": async () => {
          setMiniVizCollapsed(!isMiniVizCollapsed());
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "gm-panel-tab": async () => {
          setActiveGmPanelTab(element?.dataset?.tab);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "operations-page": async () => {
          setActiveOperationsPage(element?.dataset?.page);
          if (String(element?.dataset?.page ?? "").trim() === "gm" && canAccessAllPlayerOps()) setActiveRestMainTab("gm");
          else if (getActiveRestMainTab() === "gm") setActiveRestMainTab("operations");
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "merchant-select-actor": async () => {
          if (setMerchantActorSelectionFromElement(element)) {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          }
        },
        "merchant-select-city": async () => {
          if (setMerchantSettlementSelectionFromElement(element)) {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          }
        },
        "merchant-save-city-catalog": async () => {
          if (await saveMerchantCityCatalogFromElement(element)) {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          }
        },
        "merchant-assign-city": async () => {
          if (await assignMerchantCityFromElement(element)) {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          }
        },
        "merchant-select-tab": async () => {
          if (setSelectedMerchantTabIdFromElement(element)) {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          }
        },
        "merchant-open-shop": async () => {
          await openMerchantShopFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "merchant-settlement": async () => {
          await setMerchantSettlementFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "merchant-editor-draft-change": async () => {
          if (cacheMerchantEditorDraftFromElement(element, { suppressMissingFormWarning: true })) {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          }
        },
        "merchant-editor-view-tab": async () => {
          if (setMerchantEditorViewTabFromElement(element)) {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          }
        },
        "merchant-new": async () => {
          resetMerchantEditorSelection();
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "merchant-randomize-name": async () => {
          if (randomizeMerchantNameFromElement(element)) {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          }
        },
        "merchant-randomize-race": async () => {
          if (randomizeMerchantRaceFromElement(element)) {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          }
        },
        "merchant-edit": async () => {
          if (setMerchantEditorSelectionFromElement(element)) {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          }
        },
        "merchant-save": async () => {
          await saveMerchantFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "merchant-delete": async () => {
          await deleteMerchantFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "merchant-refresh-stock": async () => {
          await refreshMerchantStockFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "merchant-refresh-all-stock": async () => {
          await refreshAllMerchantStocksFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "merchant-assign-by-contract-key": async () => {
          await assignMerchantByContractKeyFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "merchant-assign-toggle": async () => {
          await setMerchantAssignmentFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "merchant-assign-all": async () => {
          await setMerchantAssignmentAllEnabledFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "merchant-assign-none": async () => {
          await setMerchantAssignmentAllDisabledFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "merchant-set-access-mode": async () => {
          await setMerchantAccessModeFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "merchant-open-actor": async () => {
          await openMerchantActorFromElement(element);
        },
        "toggle-merchant-pack-source": async () => {
          await toggleMerchantPackSourceFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "toggle-merchant-allowed-type": async () => {
          await toggleMerchantAllowedTypeFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "merchant-add-curated-item": async () => {
          await addMerchantCuratedItemFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "merchant-remove-curated-item": async () => {
          await removeMerchantCuratedItemFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "merchant-clear-curated-items": async () => {
          await clearMerchantCuratedItemsFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "operations-planning-tab": async () => {
          setActiveOperationsPlanningTab(element?.dataset?.planningTab);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "gm-ops-tab": async () => {
          if (isModuleDebugEnabled()) {
            logUiDebug("loot", "gm ops tab click", {
              requestedTab: String(element?.dataset?.gmTab ?? ""),
              beforeGmOpsTab: normalizeGmOperationsTab(this._gmOperationsTab ?? getActiveGmOperationsTab()),
              beforeLootRegistryTab: normalizeLootRegistryTab(this._lootRegistryTab ?? getActiveLootRegistryTab())
            });
          }
          this._gmOperationsTab = normalizeGmOperationsTab(element?.dataset?.gmTab);
          setActiveGmOperationsTab(this._gmOperationsTab);
          if (isModuleDebugEnabled()) {
            logUiDebug("loot", "gm ops tab applied", {
              afterGmOpsTab: this._gmOperationsTab,
              storedGmOpsTab: getActiveGmOperationsTab()
            });
          }
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "set-role": async () => {
          await setOperationalRole(element);
        },
        "clear-role": async () => {
          await clearOperationalRole(element);
        },
        "toggle-sop": async () => {
          await toggleOperationalSOP(element, { skipLocalRefresh: true });
        },
        "set-sop-note": async () => {
          clearScheduledSopNoteSave(this, String(element?.dataset?.sop ?? "").trim());
          await setOperationalSopNote(element, { suppressUiWarning: true });
        },
        "save-sop-note": async () => {
          const sopKey = String(element?.dataset?.sop ?? "").trim();
          clearScheduledSopNoteSave(this, sopKey);
          const noteInput = getSopNoteTextareaFromElement(element);
          if (!noteInput) {
            logUiDebug("operations-sop", "save-sop-note could not resolve textarea", {
              sopKey,
              target: summarizeClickTarget(event?.target ?? element)
            });
            ui.notifications?.warn("Could not find the SOP note input to save.");
            return;
          }
          await setOperationalSopNote(noteInput, {
            suppressUiWarning: false,
            notify: true
          });
        },
        "set-resource": async () => {
          await setOperationalResource(element);
        },
        "set-downtime-hours": async () => {
          await setDowntimeHoursGranted(element);
        },
        "set-downtime-tuning": async () => {
          await setDowntimeTuningField(element);
        },
        "set-downtime-resolve-target": async () => {
          applyDowntimeResolverBaseToUi(element, { force: true });
        },
        "prefill-downtime-resolution": async () => {
          applyDowntimeResolverBaseToUi(element, { force: true });
        },
        "pre-resolve-selected-downtime-entry": async () => {
          await preResolveSelectedDowntimeEntry(element);
        },
        "submit-downtime-action": async () => {
          await submitDowntimeAction(element);
        },
        "clear-downtime-entry": async () => {
          await clearDowntimeEntry(element);
        },
        "resolve-selected-downtime-entry": async () => {
          await resolveSelectedDowntimeEntry(element);
        },
        "edit-downtime-result": async () => {
          await editDowntimeResult(element);
        },
        "clear-downtime-results": async () => {
          await clearDowntimeResults();
        },
        "unarchive-downtime-log": async () => {
          await unarchiveDowntimeLogEntry(element);
        },
        "clear-downtime-log": async () => {
          await clearDowntimeLogEntry(element);
        },
        "post-downtime-log": async () => {
          await postDowntimeLogOutcome(element);
        },
        "collect-downtime-result": async () => {
          await collectDowntimeResult(element);
        },
        "set-environment-preset": async () => {
          await setOperationalEnvironmentPreset(element);
        },
        "set-environment-dc": async () => {
          await setOperationalEnvironmentDc(element);
        },
        "set-environment-note": async () => {
          await setOperationalEnvironmentNote(element);
        },
        "set-environment-sync-non-party": async () => {
          await setOperationalEnvironmentSyncNonParty(element);
        },
        "set-environment-successive": async () => {
          await setOperationalEnvironmentSuccessive(element);
        },
        "reset-environment-successive-defaults": async () => {
          await resetOperationalEnvironmentSuccessiveDefaults();
        },
        "toggle-environment-actor": async () => {
          await toggleOperationalEnvironmentActor(element);
        },
        "add-environment-log": async () => {
          await addOperationalEnvironmentLog();
        },
        "edit-environment-log": async () => {
          await editOperationalEnvironmentLog(element);
        },
        "remove-environment-log": async () => {
          await removeOperationalEnvironmentLog(element);
        },
        "clear-environment-effects": async () => {
          await clearOperationalEnvironmentEffects();
        },
        "show-environment-brief": async () => {
          await showOperationalEnvironmentBrief();
        },
        "apply-upkeep": async () => {
          await applyOperationalUpkeep();
        },
        "gather-resource-check": async () => {
          triggerGatherResourceButtonAnimation(element);
          await runGatherResourceCheck();
        },
        "run-gather-preset": async () => {
          await runGatherPresetAction(element);
        },
        "set-gather-history-filter": async () => {
          setGatherHistoryViewFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "clear-gather-history-filters": async () => {
          clearGatherHistoryFilters();
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "clear-gather-history": async () => {
          await clearGatherHistoryAction();
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "remove-gather-history-entry": async () => {
          await removeGatherHistoryEntryAction(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "show-operational-brief": async () => {
          await showOperationalBrief();
        },
        "set-comm-toggle": async () => {
          await setCommunicationToggle(element);
        },
        "set-comm-text": async () => {
          await setCommunicationText(element);
        },
        "set-recon-field": async () => {
          await setReconField(element);
        },
        "run-recon-check": async () => {
          await runReconCheck();
        },
        "show-recon-brief": async () => {
          await showReconBrief();
        },
        "show-communication-brief": async () => {
          await showCommunicationBrief();
        },
        "set-reputation-score": async () => {
          await setReputationScore(element);
        },
        "adjust-reputation-score": async () => {
          await adjustReputationScore(element);
        },
        "set-reputation-note": async () => {
          await setReputationNote(element);
        },
        "log-reputation-note": async () => {
          await logReputationNote(element);
        },
        "load-reputation-note-log": async () => {
          await loadReputationNoteLog(element);
        },
        "post-reputation-note-log": async () => {
          await postReputationNoteLog(element);
        },
        "clear-reputation-note": async () => {
          await clearReputationNote(element);
        },
        "remove-reputation-note-log": async () => {
          await removeReputationNoteLog(element);
        },
        "set-reputation-label": async () => {
          await setReputationLabel(element);
        },
        "add-reputation-faction": async () => {
          await addReputationFaction(element);
        },
        "remove-reputation-faction": async () => {
          await removeReputationFaction(element);
        },
        "set-reputation-filter-keyword": async () => {
          setReputationFilterState({ keyword: String(element?.value ?? "") });
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "set-reputation-filter-standing": async () => {
          setReputationFilterState({ standing: String(element?.value ?? "all") });
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "clear-reputation-filters": async () => {
          setReputationFilterState({ keyword: "", standing: "all" });
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "show-reputation-brief": async () => {
          await showReputationBrief();
        },
        "toggle-loot-pack-sources-collapsed": async () => {
          const current = getLootPackSourcesUiState();
          setLootPackSourcesUiState({ collapsed: !current.collapsed });
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "set-loot-registry-tab": async () => {
          if (isModuleDebugEnabled()) {
            logUiDebug("loot", "loot registry tab click", {
              requestedTab: String(element?.dataset?.tab ?? ""),
              beforeGmOpsTab: normalizeGmOperationsTab(this._gmOperationsTab ?? getActiveGmOperationsTab()),
              beforeLootRegistryTab: normalizeLootRegistryTab(this._lootRegistryTab ?? getActiveLootRegistryTab())
            });
          }
          this._lootRegistryTab = normalizeLootRegistryTab(String(element?.dataset?.tab ?? "preview"));
          setActiveLootRegistryTab(this._lootRegistryTab);
          logUiDebug("loot", "set loot registry tab", {
            tab: this._lootRegistryTab,
            storedLootRegistryTab: getActiveLootRegistryTab()
          });
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "set-loot-pack-filter": async () => {
          setLootPackSourcesUiState({ filter: String(element?.value ?? "") });
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "clear-loot-pack-filter": async () => {
          setLootPackSourcesUiState({ filter: "" });
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "toggle-loot-pack-source": async () => {
          await toggleLootPackSource(element);
        },
        "set-loot-pack-weight": async () => {
          await setLootPackWeight(element);
        },
        "toggle-loot-table-source": async () => {
          await toggleLootTableSource(element);
        },
        "set-loot-table-type": async () => {
          await setLootTableType(element);
        },
        "toggle-loot-item-type": async () => {
          await toggleLootItemType(element);
        },
        "set-loot-rarity-floor": async () => {
          await setLootRarityFloor(element);
        },
        "set-loot-rarity-ceiling": async () => {
          await setLootRarityCeiling(element);
        },
        "set-loot-manifest-pack": async () => {
          await setLootManifestPack(element);
        },
        "set-loot-keyword-include-tags": async () => {
          await setLootKeywordIncludeTags(element);
        },
        "set-loot-keyword-exclude-tags": async () => {
          await setLootKeywordExcludeTags(element);
        },
        "reset-loot-source-config": async () => {
          await resetLootSourceConfig();
        },
        "set-loot-preview-field": async () => {
          setLootPreviewField(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "roll-loot-preview": async () => {
          await rollLootPreview(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "add-loot-preview-item": async () => {
          const added = await addLootPreviewItemByPicker();
          if (added) this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "remove-loot-preview-item": async () => {
          const removed = await removeLootPreviewItem(element);
          if (removed) this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "adjust-loot-preview-currency": async () => {
          const adjusted = adjustLootPreviewCurrency(element);
          if (adjusted) this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "clear-loot-preview": async () => {
          clearLootPreviewResult();
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "publish-loot-claims": async () => {
          await publishLootPreviewToClaims();
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "clear-loot-claims": async () => {
          await clearLootClaimsPool();
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "set-loot-claim-run": async () => {
          if (setLootClaimRunSelectionFromElement(element)) {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          }
        },
        "set-loot-claims-archive-sort": async () => {
          setLootClaimsArchiveSort(element?.value);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "open-loot-item": async () => {
          await openLootItemFromElement(element);
        },
        "claim-loot-item": async () => {
          await claimLootItemForPlayer(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "toggle-loot-vouch": async () => {
          await toggleLootItemVouchForPlayer(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "set-loot-claim-actor": async () => {
          if (setLootClaimActorSelectionFromElement(element)) {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          }
        },
        "claim-loot-currency": async () => {
          await claimLootCurrencyForPlayer(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "set-loot-major-item": async () => {
          await setLootItemMajorFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "run-loot-rolloff": async () => {
          await runLootRollOffFromElement(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "open-gm-loot-claims-board": async () => {
          openGmLootClaimsBoard({
            force: true,
            runId: getLootClaimRunIdFromElement(element)
          });
        },
        "gm-quick-add-faction": async () => {
          await gmQuickAddFaction();
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "gm-quick-add-modifier": async () => {
          openGlobalModifierSummaryPage({ force: true });
        },
        "gm-quick-open-environment": async () => {
          openGmEnvironmentPage({ force: true });
        },
        "gm-quick-open-downtime": async () => {
          openGmDowntimePage({ force: true });
        },
        "gm-quick-open-merchants": async () => {
          openGmMerchantsPage({ force: true });
        },
        "gm-quick-open-loot": async () => {
          openGmLootPage({ force: true });
        },
        "gm-quick-cancel-panel": async () => {
          setActiveGmQuickPanel("none");
          setGmQuickWeatherDraft(null);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "gm-quick-submit-faction": async () => {
          await gmQuickSubmitFaction(element);
        },
        "gm-quick-submit-modifier": async () => {
          await gmQuickSubmitModifier(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "gm-quick-save-modifier": async () => {
          await gmQuickSaveModifier(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "gm-quick-set-staged-field": async () => {
          await gmQuickSetStagedModifierField(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "gm-quick-delete-staged-modifier": async () => {
          await gmQuickDeleteStagedModifier(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "gm-quick-delete-saved-modifier": async () => {
          await gmQuickDeleteSavedModifier(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "gm-quick-sync-integrations": async () => {
          scheduleIntegrationSync("gm-quick-action");
          ui.notifications?.info("Party Operations integration sync queued.");
        },
        "gm-quick-session-autopilot": async () => {
          await runSessionAutopilot();
        },
        "gm-quick-undo-autopilot": async () => {
          await undoLastSessionAutopilot();
        },
        "gm-quick-log-weather": async () => {
          await gmQuickLogCurrentWeather();
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "gm-quick-submit-weather": async () => {
          await gmQuickSubmitWeather(element);
        },
        "gm-quick-weather-select": async () => {
          await gmQuickSelectWeatherPreset(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "gm-quick-weather-set": async () => {
          gmQuickUpdateWeatherDraftField(element);
        },
        "gm-quick-modifier-key-preset": async () => {
          gmQuickApplyModifierKeyPreset(element);
        },
        "gm-quick-modifier-key-filter": async () => {
          filterModifierPresetSelect(element, "quickGlobalModifierKey");
        },
        "gm-quick-weather-dae-key-preset": async () => {
          gmQuickApplyWeatherDaeKeyPreset(element);
        },
        "gm-quick-weather-add-dae": async () => {
          await gmQuickAddWeatherDaeChange(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "gm-quick-weather-remove-dae": async () => {
          await gmQuickRemoveWeatherDaeChange(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "gm-quick-weather-save-preset": async () => {
          await gmQuickSaveWeatherPreset(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "gm-quick-weather-delete-preset": async () => {
          await gmQuickDeleteWeatherPreset(element);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        },
        "set-base-ops-config": async () => {
          await setBaseOperationsConfig(element);
        },
        "upsert-base-site": async () => {
          await upsertBaseOperationsSite(element);
        },
        "clear-base-site": async () => {
          await clearBaseOperationsSite(element);
        },
        "open-base-site-storage": async () => {
          await showBaseSiteStorageManager(element);
        },
        "show-base-ops-brief": async () => {
          await showBaseOperationsBrief();
        },
        "set-injury-config": async () => {
          await setInjuryRecoveryConfig(element);
        },
        "upsert-injury": async () => {
          await upsertInjuryEntry(element);
        },
        "roll-injury-table": async () => {
          await rollInjuryTableForEditor(element);
        },
        "set-injury-result": async () => {
          syncInjuryEditorFromSelection(element);
        },
        "stabilize-injury": async () => {
          await stabilizeInjuryEntry(element);
        },
        "clear-injury": async () => {
          await clearInjuryEntry(element);
        },
        "show-injury-table": async () => {
          await showInjuryTable();
        },
        "apply-recovery-cycle": async () => {
          await applyRecoveryCycle();
        },
        "show-recovery-brief": async () => {
          await showRecoveryBrief();
        },
      };
        const handler = actionHandlers[action];
        if (typeof handler === "function") {
          await handler();
        }
      } catch (error) {
        logUiFailure("rest-watch", "action handler failed", error, {
          action,
          eventType: String(event?.type ?? ""),
          target: summarizeClickTarget(event?.target)
        });
        ui.notifications?.error("Party Operations action failed. Check the console for details.");
      }
    } finally {
      if (preserveCanvas) {
        queueCanvasViewRestore(canvasSnapshot, {
          action: String(action ?? ""),
          eventType: String(event?.type ?? "")
        });
      }
    }
  }

  async #onNotesChange(event) {
    if (event?.type === "input") return;
    const state = getRestWatchState();
    if (isLockedForUser(state, canAccessAllPlayerOps())) {
      ui.notifications?.warn("Rest watch is locked by the GM.");
      return;
    }
    const slotId = event.target?.closest(".po-card")?.dataset?.slotId;
    if (!slotId) return;
    const text = event.target.value ?? "";

    if (!canAccessAllPlayerOps()) {
      const actor = getActiveActorForUser();
      if (!actor) return;
      await updateRestWatchState({ op: "setEntryNotes", slotId, actorId: actor.id, text });
      return;
    }

    await updateRestWatchState((state) => {
      const slot = state.slots.find((entry) => entry.id === slotId);
      if (slot) slot.notes = text;
    });
  }

  async close(options = {}) {
    if (isModuleDebugEnabled()) {
      console.trace(`[${MODULE_ID}] RestWatchApp.close`, {
        options,
        activePanel: this._activePanel ?? getActiveRestMainTab()
      });
    }
    return super.close(options);
  }
}

function buildGlobalModifierSummaryContext() {
  const ledger = getOperationsLedger();
  const roleKeys = ["quartermaster", "cartographer", "chronicler", "steward"];
  const sopKeys = ["campSetup", "watchRotation", "dungeonBreach", "urbanEntry", "prisonerHandling", "retreatProtocol"];
  const roles = roleKeys.map((key) => {
    const actorId = String(ledger.roles?.[key] ?? "").trim();
    return {
      hasActor: Boolean(actorId && game.actors?.get(actorId))
    };
  });
  const sops = sopKeys.map((key) => ({
    active: Boolean(ledger.sops?.[key])
  }));
  const effects = getOperationalEffects(ledger, roles, sops);
  const partyHealth = ensurePartyHealthState(ledger);
  const customModifierById = new Map((partyHealth.customModifiers ?? []).map((entry) => [String(entry?.id ?? ""), entry]));

  const globalRows = (effects.derivedModifierRows ?? [])
    .filter((row) => row?.enabled)
    .map((row) => ({
      label: String(row?.label ?? "Modifier").trim() || "Modifier",
      appliesTo: String(row?.appliesTo ?? "All player actors").trim() || "All player actors",
      key: String(row?.key ?? "").trim() || "-",
      value: String(row?.effectiveFormatted ?? row?.formatted ?? row?.value ?? "-").trim() || "-",
      note: String(row?.note ?? "").trim()
    }));

  const partyRows = (effects.customModifierRows ?? [])
    .filter((row) => row?.enabled)
    .map((row) => {
      const modifierId = String(row?.modifierId ?? "");
      const customId = modifierId.startsWith("custom:") ? modifierId.slice("custom:".length) : "";
      const customEntry = customModifierById.get(customId);
      const modeLabel = String(row?.modeLabel ?? "").trim() || (customEntry ? getActiveEffectModeLabel(customEntry.mode) : "-");
      return {
        label: String(row?.label ?? "Modifier").trim() || "Modifier",
        modeLabel,
        key: String(row?.key ?? "").trim() || "-",
        value: String(row?.effectiveFormatted ?? row?.formatted ?? row?.value ?? "-").trim() || "-",
        appliesTo: String(row?.appliesTo ?? "All player actors").trim() || "All player actors",
        note: String(row?.note ?? "").trim()
      };
    });

  const exclusionRows = (effects.globalModifierRows ?? []).map((row) => {
    const modifierId = String(row?.modifierId ?? "").trim();
    const source = String(row?.source ?? "derived").trim() || "derived";
    const customId = modifierId.startsWith("custom:") ? modifierId.slice("custom:".length) : "";
    const customEntry = customModifierById.get(customId);
    const excluded = source === "custom"
      ? !(customEntry?.enabled !== false)
      : row?.enabled === false;
    return {
      modifierId,
      label: String(row?.label ?? "Modifier").trim() || "Modifier",
      source,
      scopeLabel: String(row?.appliesTo ?? "All player actors").trim() || "All player actors",
      valueLabel: String(row?.formatted ?? row?.value ?? "-").trim() || "-",
      excluded
    };
  });

  return {
    moduleVersion: getCurrentModuleVersion(),
    generatedAtLabel: new Date().toLocaleString(),
    generatedBy: String(game.user?.name ?? "GM"),
    globalRows,
    partyRows,
    exclusionRows,
    hasGlobalRows: globalRows.length > 0,
    hasPartyRows: partyRows.length > 0,
    hasExclusionRows: exclusionRows.length > 0,
    hasAnyRows: globalRows.length > 0 || partyRows.length > 0
  };
}

async function setGlobalModifierExcluded(modifierId, excluded, options = {}) {
  const normalizedId = String(modifierId ?? "").trim();
  if (!normalizedId) return false;
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update modifier exclusions.");
    return false;
  }

  await updateOperationsLedger((ledger) => {
    const partyHealth = ensurePartyHealthState(ledger);
    if (normalizedId.startsWith("custom:")) {
      const customId = normalizedId.slice("custom:".length);
      const entry = (partyHealth.customModifiers ?? []).find((row) => String(row?.id ?? "") === customId);
      if (entry) entry.enabled = !excluded;
      return;
    }
    if (!partyHealth.modifierEnabled || typeof partyHealth.modifierEnabled !== "object") {
      partyHealth.modifierEnabled = {};
    }
    partyHealth.modifierEnabled[normalizedId] = !excluded;
  }, options);

  return true;
}

function openGlobalModifierSummaryPage(renderOptions = { force: true }) {
  const suppressHistory = Boolean(renderOptions?.suppressHistory);
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("GM permissions are required to view global modifiers.");
    return null;
  }
  const app = globalModifierSummaryAppInstance?.element?.isConnected
    ? globalModifierSummaryAppInstance
    : new GlobalModifierSummaryApp(getResponsiveWindowOptions("global-modifiers"));
  app.render(renderOptions);
  if (!suppressHistory) writePoBrowserHistoryEntry({ type: "window", id: "global-modifiers" });
  return app;
}

export class GlobalModifierSummaryApp extends HandlebarsApplicationMixin(ApplicationV2) {
  static DEFAULT_OPTIONS = foundry.utils.mergeObject(super.DEFAULT_OPTIONS, {
    id: "party-operations-global-modifier-summary",
    classes: ["party-operations"],
    window: { title: "Party Operations - Global Modifiers" },
    position: getResponsiveWindowPosition("global-modifiers"),
    resizable: true
  });

  static PARTS = {
    main: { template: "modules/party-operations/templates/global-modifiers.hbs" }
  };

  constructor(options = {}) {
    super(options);
    globalModifierSummaryAppInstance = this;
  }

  async _prepareContext() {
    try {
      return buildGlobalModifierSummaryContext();
    } catch (error) {
      console.warn(`${MODULE_ID}: failed to build global modifier summary context`, error);
      return {
        moduleVersion: getCurrentModuleVersion(),
        generatedAtLabel: new Date().toLocaleString(),
        generatedBy: String(game.user?.name ?? "GM"),
        globalRows: [],
        partyRows: [],
        hasGlobalRows: false,
        hasPartyRows: false,
        hasAnyRows: false
      };
    }
  }

  async close(options = {}) {
    if (globalModifierSummaryAppInstance === this) globalModifierSummaryAppInstance = null;
    return super.close(options);
  }

  #renderWithPreservedState(renderOptions = { force: true, parts: ["main"], focus: false }) {
    renderAppWithPreservedState(this, renderOptions);
  }

  async _onRender(context, options) {
    await super._onRender(context, options);
    ensurePartyOperationsClass(this);
    if (this.element && !this.element.dataset.poBoundGlobalModifiers) {
      this.element.dataset.poBoundGlobalModifiers = "1";
      this.element.addEventListener("click", (event) => {
        const actionElement = event.target?.closest?.("[data-action]");
        const action = String(actionElement?.dataset?.action ?? "").trim();
        if (!action) return;
        if (action === "global-modifier-set-excluded") {
          event.stopPropagation();
          return;
        }
        if (action === "global-modifiers-back") {
          event.preventDefault();
          event.stopPropagation();
          this.close();
          openMainTab("gm", { force: true });
          return;
        }
        if (action === "global-modifiers-refresh") {
          event.preventDefault();
          event.stopPropagation();
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
        }
      });
      this.element.addEventListener("change", async (event) => {
        const actionElement = event.target?.closest?.("[data-action]");
        const action = String(actionElement?.dataset?.action ?? "").trim();
        if (action !== "global-modifier-set-excluded") return;
        event.preventDefault();
        event.stopPropagation();
        const modifierId = String(actionElement?.dataset?.modifierId ?? "").trim();
        const excluded = Boolean(actionElement?.checked);
        await setGlobalModifierExcluded(modifierId, excluded, { skipLocalRefresh: true });
        this.#renderWithPreservedState({ force: true, parts: ["main"] });
      });
    }
    restorePendingWindowState(this);
    restorePendingUiState(this);
    restorePendingScrollState(this);
  }
}

function getStandaloneOpsContext() {
  try {
    return buildOperationsContext();
  } catch (error) {
    console.warn(`${MODULE_ID}: buildOperationsContext failed for standalone page`, error);
    return buildOperationsContextFallback();
  }
}

function buildGmEnvironmentPageContext() {
  const operations = getStandaloneOpsContext();
  const environment = operations?.environment ?? {};
  const weather = operations?.weather ?? {
    currentLabel: "Not logged",
    currentVisibilityModifier: 0,
    currentDarkness: 0
  };
  const gmQuickTools = operations?.gmQuickTools ?? {
    weatherSceneSnapshot: {
      label: "-",
      darkness: 0,
      visibilityModifier: 0
    },
    weatherOptions: [],
    weatherDaeModeOptions: [],
    modifierKeyOptions: [],
    weatherDraft: {
      selectedKey: "",
      darkness: 0,
      visibilityModifier: 0,
      note: "",
      presetName: "",
      daeChanges: []
    }
  };
  const logs = Array.isArray(environment.logs) ? environment.logs : [];
  const checkResults = Array.isArray(environment.checkResults) ? environment.checkResults : [];
  return {
    moduleVersion: getCurrentModuleVersion(),
    generatedAtLabel: new Date().toLocaleString(),
    generatedBy: String(game.user?.name ?? "GM"),
    environment,
    weather,
    gmQuickTools,
    logs,
    checkResults,
    hasLogs: logs.length > 0,
    hasCheckResults: checkResults.length > 0,
    hasWeatherOptions: Array.isArray(gmQuickTools?.weatherOptions) && gmQuickTools.weatherOptions.length > 0
  };
}

function buildGmDowntimePageContext() {
  const ledger = getOperationsLedger();
  const downtimeState = ensureDowntimeState(ledger);
  const viewState = getGmDowntimeViewState();
  const downtime = buildDowntimeContext(downtimeState, {
    user: game.user,
    entriesSort: viewState.entriesSort,
    logsSort: viewState.logsSort
  });
  return {
    moduleVersion: getCurrentModuleVersion(),
    generatedAtLabel: new Date().toLocaleString(),
    generatedBy: String(game.user?.name ?? "GM"),
    downtime
  };
}

function buildGmMerchantsPageContext() {
  const merchants = buildMerchantsContext(getOperationsLedger(), { user: game.user });
  return {
    moduleVersion: getCurrentModuleVersion(),
    generatedAtLabel: new Date().toLocaleString(),
    generatedBy: String(game.user?.name ?? "GM"),
    merchants
  };
}

function buildGmLootPageContext() {
  const operations = getStandaloneOpsContext();
  const lootSources = operations?.lootSources ?? {};
  const preview = lootSources.preview ?? {
    hasResult: false,
    generatedAtLabel: "-",
    generatedBy: "-",
    currency: { pp: 0, gp: 0, sp: 0, cp: 0, gpEquivalent: 0, formula: "-" },
    stats: { candidateCount: 0, itemCountGenerated: 0, itemCountTarget: 0, tableRollCount: 0 },
    items: [],
    tableRolls: [],
    warnings: []
  };
  const lootClaims = operations?.lootClaims ?? {
    publishedAtLabel: "-",
    publishedBy: "-",
    itemCount: 0,
    claimsLogCount: 0,
    currencyRemaining: { pp: 0, gp: 0, sp: 0, cp: 0 },
    currencyClaimedCount: 0,
    hasItems: false,
    items: []
  };
  const sourceSummary = lootSources.summary ?? {
    enabledItemPacks: 0,
    totalItemPacks: 0,
    enabledTables: 0,
    totalTables: 0,
    enabledItemTypes: 0,
    totalItemTypes: 0,
    updatedAtLabel: "-",
    updatedBy: "-"
  };
  return {
    moduleVersion: getCurrentModuleVersion(),
    generatedAtLabel: new Date().toLocaleString(),
    generatedBy: String(game.user?.name ?? "GM"),
    operations,
    sourceSummary,
    preview,
    lootClaims,
    hasPreviewResult: Boolean(preview?.hasResult),
    hasPreviewItems: Array.isArray(preview?.items) && preview.items.length > 0,
    hasPreviewWarnings: Array.isArray(preview?.warnings) && preview.warnings.length > 0,
    hasClaimsItems: Boolean(lootClaims?.hasItems),
    hasContestedItems: Number(lootClaims?.contestedItemCount ?? 0) > 0
  };
}

function buildGmLootClaimsBoardContext() {
  return {
    moduleVersion: getCurrentModuleVersion(),
    generatedAtLabel: new Date().toLocaleString(),
    generatedBy: String(game.user?.name ?? "GM"),
    lootClaims: buildLootClaimsContext(game.user),
    isGM: Boolean(canAccessAllPlayerOps()),
    canManageClaims: Boolean(canAccessAllPlayerOps())
  };
}

function openGmEnvironmentPage(renderOptions = { force: true }) {
  const suppressHistory = Boolean(renderOptions?.suppressHistory);
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("GM permissions are required to view environment controls.");
    return null;
  }
  const app = gmEnvironmentPageAppInstance?.element?.isConnected
    ? gmEnvironmentPageAppInstance
    : new GmEnvironmentPageApp(getResponsiveWindowOptions("gm-environment"));
  app.render(renderOptions);
  if (!suppressHistory) writePoBrowserHistoryEntry({ type: "window", id: "gm-environment" });
  return app;
}

function openGmDowntimePage(renderOptions = { force: true }) {
  const suppressHistory = Boolean(renderOptions?.suppressHistory);
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("GM permissions are required to view downtime controls.");
    return null;
  }
  const app = gmDowntimePageAppInstance?.element?.isConnected
    ? gmDowntimePageAppInstance
    : new GmDowntimePageApp(getResponsiveWindowOptions("gm-downtime"));
  app.render(renderOptions);
  if (!suppressHistory) writePoBrowserHistoryEntry({ type: "window", id: "gm-downtime" });
  return app;
}

function openGmMerchantsPage(renderOptions = { force: true }) {
  const suppressHistory = Boolean(renderOptions?.suppressHistory);
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("GM permissions are required to view merchant controls.");
    return null;
  }
  const app = gmMerchantsPageAppInstance?.element?.isConnected
    ? gmMerchantsPageAppInstance
    : new GmMerchantsPageApp(getResponsiveWindowOptions("gm-merchants"));
  app.render(renderOptions);
  if (!suppressHistory) writePoBrowserHistoryEntry({ type: "window", id: "gm-merchants" });
  return app;
}

function openGmLootPage(renderOptions = { force: true }) {
  const suppressHistory = Boolean(renderOptions?.suppressHistory);
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("GM permissions are required to view loot controls.");
    return null;
  }
  const app = gmLootPageAppInstance?.element?.isConnected
    ? gmLootPageAppInstance
    : new GmLootPageApp(getResponsiveWindowOptions("gm-loot"));
  app.render(renderOptions);
  if (!suppressHistory) writePoBrowserHistoryEntry({ type: "window", id: "gm-loot" });
  return app;
}

function openGmLootClaimsBoard(renderOptions = { force: true }) {
  const runId = normalizeLootClaimRunId(renderOptions?.runId);
  if (runId) setLootClaimRunSelection(runId);
  const suppressHistory = Boolean(renderOptions?.suppressHistory);
  const app = gmLootClaimsBoardAppInstance?.element?.isConnected
    ? gmLootClaimsBoardAppInstance
    : new GmLootClaimsBoardApp(getResponsiveWindowOptions("gm-loot-claims-board"));
  app.render(renderOptions);
  if (!suppressHistory) writePoBrowserHistoryEntry({ type: "window", id: "gm-loot-claims-board" });
  return app;
}

class BaseStatefulPageApp extends HandlebarsApplicationMixin(ApplicationV2) {
  constructor(options = {}) {
    super(options);
    this._setPageInstance(this);
  }

  _setPageInstance(_instance) {}

  _getBoundDatasetKey() {
    return "";
  }

  _getActionHandlers(_event = null) {
    return {};
  }

  _shouldHandleChangeAction(_action, _actionElement, _event) {
    return true;
  }

  _shouldHandleInputAction(_action, _actionElement, _event) {
    return false;
  }

  _bindAdditionalListeners(_root) {}

  async _onPostRender(_context, _options) {}

  _getActionErrorScope() {
    return "stateful-page";
  }

  _getActionErrorMessage() {
    return "Page action failed. Check console for details.";
  }

  _renderWithPreservedState(renderOptions = { force: true, parts: ["main"], focus: false }) {
    renderAppWithPreservedState(this, renderOptions);
  }

  async _dispatchActionEvent(event) {
    if (event?.type === "click") {
      event.preventDefault();
      event.stopPropagation();
    }
    const actionElement = event?.target?.closest?.("[data-action]");
    const action = String(actionElement?.dataset?.action ?? "").trim();
    if (!action) return;
    if (actionElement?.tagName === "SELECT" && event?.type !== "change") return;
    const preserveCanvas = shouldPreserveCanvasForUiEvent(event, actionElement, action);
    const canvasSnapshot = preserveCanvas ? captureCanvasViewState() : null;

    const actionHandlers = this._getActionHandlers(event);
    const handler = actionHandlers?.[action];
    if (typeof handler !== "function") return;

    try {
      await handler(actionElement, event);
    } catch (error) {
      logUiFailure(this._getActionErrorScope(), `action failed: ${action}`, error, {
        target: summarizeClickTarget(event?.target)
      });
      ui.notifications?.warn(this._getActionErrorMessage());
    } finally {
      if (preserveCanvas) {
        queueCanvasViewRestore(canvasSnapshot, {
          action,
          eventType: String(event?.type ?? "")
        });
      }
    }
  }

  async close(options = {}) {
    this._setPageInstance(null);
    return super.close(options);
  }

  async _onRender(context, options) {
    await super._onRender(context, options);
    ensurePartyOperationsClass(this);
    if (this.element) {
      const datasetKey = this._getBoundDatasetKey();
      if (datasetKey && !this.element.dataset[datasetKey]) {
        this.element.dataset[datasetKey] = "1";
        this.element.addEventListener("click", (event) => {
          const actionElement = event.target?.closest?.("[data-action]");
          if (isFormActionElement(actionElement)) return;
          if (!actionElement) return;
          void this._dispatchActionEvent(event);
        });
        this.element.addEventListener("change", (event) => {
          const actionElement = event.target?.closest?.("[data-action]");
          const action = String(actionElement?.dataset?.action ?? "").trim();
          if (!action) return;
          if (!this._shouldHandleChangeAction(action, actionElement, event)) return;
          void this._dispatchActionEvent(event);
        });
        this.element.addEventListener("input", (event) => {
          const actionElement = event.target?.closest?.("[data-action]");
          const action = String(actionElement?.dataset?.action ?? "").trim();
          if (!action) return;
          if (!this._shouldHandleInputAction(action, actionElement, event)) return;
          void this._dispatchActionEvent(event);
        });
        this._bindAdditionalListeners(this.element);
      }
    }
    await this._onPostRender(context, options);
    restorePendingWindowState(this);
    restorePendingUiState(this);
    restorePendingScrollState(this);
  }
}

export const GmEnvironmentPageApp = createGmEnvironmentPageApp({
  BaseStatefulPageApp,
  getResponsiveWindowPosition,
  setPageInstance: (instance) => {
    gmEnvironmentPageAppInstance = instance;
  },
  buildContext: buildGmEnvironmentPageContext,
  openMainTab,
  setOperationalEnvironmentSyncNonParty,
  setOperationalEnvironmentPreset,
  setOperationalEnvironmentDc,
  setOperationalEnvironmentSuccessive,
  setOperationalEnvironmentNote,
  toggleOperationalEnvironmentActor,
  resetOperationalEnvironmentSuccessiveDefaults,
  addOperationalEnvironmentLog,
  clearOperationalEnvironmentEffects,
  showOperationalEnvironmentBrief,
  gmQuickLogCurrentWeather,
  gmQuickAddWeatherDaeChange,
  gmQuickRemoveWeatherDaeChange,
  gmQuickSaveWeatherPreset,
  gmQuickDeleteWeatherPreset,
  gmQuickSubmitWeather,
  gmQuickSelectWeatherPreset,
  gmQuickUpdateWeatherDraftField,
  gmQuickApplyWeatherDaeKeyPreset
});

export const GmDowntimePageApp = createGmDowntimePageApp({
  BaseStatefulPageApp,
  getResponsiveWindowPosition,
  setPageInstance: (instance) => {
    gmDowntimePageAppInstance = instance;
  },
  buildContext: buildGmDowntimePageContext,
  openMainTab,
  setGmDowntimeViewState,
  setDowntimeHoursGranted,
  setDowntimeTuningField,
  applyDowntimeResolverBaseToUi,
  preResolveSelectedDowntimeEntry,
  resolveSelectedDowntimeEntry,
  editDowntimeResult,
  submitDowntimeAction,
  clearDowntimeEntry,
  clearDowntimeResults,
  unarchiveDowntimeLogEntry,
  clearDowntimeLogEntry,
  postDowntimeLogOutcome,
  collectDowntimeResult,
  removeDowntimeResolverItemDropFromUi,
  addDowntimeResolverCraftingItemDropFromDropEvent,
  addDowntimeResolverItemRewardFromDropEvent,
  renderDowntimeResolverItemDropList
});

export const GmMerchantsPageApp = createGmMerchantsPageApp({
  BaseStatefulPageApp,
  getResponsiveWindowPosition,
  setPageInstance: (instance) => {
    gmMerchantsPageAppInstance = instance;
  },
  buildContext: buildGmMerchantsPageContext,
  openMainTab,
  cacheMerchantEditorDraftFromElement,
  setMerchantEditorViewTabFromElement,
  resetMerchantEditorSelection,
  createStarterMerchants,
  randomizeMerchantNameFromElement,
  randomizeMerchantRaceFromElement,
  saveMerchantCityCatalogFromElement,
  assignMerchantCityFromElement,
  setMerchantEditorSelectionFromElement,
  saveMerchantFromElement,
  deleteMerchantFromElement,
  refreshMerchantStockFromElement,
  refreshAllMerchantStocksFromElement,
  setMerchantAccessModeFromElement,
  setMerchantAssignmentFromElement,
  setMerchantAssignmentAllEnabledFromElement,
  setMerchantAssignmentAllDisabledFromElement,
  openMerchantActorFromElement
});

export const GmLootPageApp = createGmLootPageApp({
  BaseStatefulPageApp,
  getResponsiveWindowPosition,
  setPageInstance: (instance) => {
    gmLootPageAppInstance = instance;
  },
  buildContext: buildGmLootPageContext,
  openMainTab,
  openGmLootClaimsBoard,
  getLootClaimRunIdFromElement,
  setActiveLootRegistryTab,
  setLootPackSourcesUiState,
  toggleLootPackSource,
  setLootPackWeight,
  toggleLootTableSource,
  setLootTableType,
  toggleLootItemType,
  setLootRarityFloor,
  setLootRarityCeiling,
  setLootManifestPack,
  setLootKeywordIncludeTags,
  setLootKeywordExcludeTags,
  resetLootSourceConfig,
  setLootPreviewField,
  rollLootPreview,
  addLootPreviewItemByPicker,
  removeLootPreviewItem,
  adjustLootPreviewCurrency,
  clearLootPreviewResult,
  publishLootPreviewToClaims,
  clearLootClaimsPool,
  openLootItemFromElement,
  addLootPreviewItemFromDropEvent
});

export class GmLootClaimsBoardApp extends HandlebarsApplicationMixin(ApplicationV2) {
  static DEFAULT_OPTIONS = foundry.utils.mergeObject(super.DEFAULT_OPTIONS, {
    id: "party-operations-gm-loot-claims-board",
    classes: ["party-operations"],
    window: { title: "Party Operations - Live Loot Claims" },
    position: getResponsiveWindowPosition("gm-loot-claims-board"),
    resizable: true
  });

  static PARTS = {
    main: { template: "modules/party-operations/templates/gm-loot-claims-board.hbs" }
  };

  constructor(options = {}) {
    super(options);
    gmLootClaimsBoardAppInstance = this;
  }

  async _prepareContext() {
    return buildGmLootClaimsBoardContext();
  }

  async close(options = {}) {
    if (gmLootClaimsBoardAppInstance === this) gmLootClaimsBoardAppInstance = null;
    return super.close(options);
  }

  #renderWithPreservedState(renderOptions = { force: true, parts: ["main"], focus: false }) {
    renderAppWithPreservedState(this, renderOptions);
  }

  async #onAction(event) {
    const actionElement = event?.target?.closest?.("[data-action]");
    const action = String(actionElement?.dataset?.action ?? "").trim();
    const preserveCanvas = shouldPreserveCanvasForUiEvent(event, actionElement, action);
    const canvasSnapshot = preserveCanvas ? captureCanvasViewState() : null;
    try {
      if (event?.type === "click") {
        event.preventDefault();
        event.stopPropagation();
      }
      if (!action) return;
      if (actionElement?.tagName === "SELECT" && event?.type !== "change") return;

      try {
        if (action === "gm-loot-claims-board-back") {
          this.close();
          if (canAccessAllPlayerOps()) openMainTab("gm", { force: true });
          else openOperationsLootClaimsTabForPlayer({ force: true });
          return;
        }
        if (action === "gm-loot-claims-board-refresh") {
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
          return;
        }
        if (action === "set-loot-claim-run") {
          if (setLootClaimRunSelectionFromElement(actionElement)) {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          }
          return;
        }
        if (action === "claim-loot-item") {
          await claimLootItemForPlayer(actionElement);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
          return;
        }
        if (action === "toggle-loot-vouch") {
          await toggleLootItemVouchForPlayer(actionElement);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
          return;
        }
        if (action === "run-loot-rolloff") {
          await runLootRollOffFromElement(actionElement);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
          return;
        }
        if (action === "open-loot-item") {
          await openLootItemFromElement(actionElement);
          return;
        }
        if (action === "set-loot-major-item") {
          await setLootItemMajorFromElement(actionElement);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
          return;
        }
        if (action === "claim-loot-currency") {
          await claimLootCurrencyForPlayer(actionElement);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
          return;
        }
        if (action === "archive-loot-claim-run") {
          const runId = getLootClaimRunIdFromElement(actionElement);
          await clearLootClaimsPool(runId);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
          return;
        }
        if (action === "set-loot-claim-actor") {
          if (setLootClaimActorSelectionFromElement(actionElement)) {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          }
        }
      } catch (error) {
        logUiFailure("gm-loot-claims-board", `action failed: ${action}`, error, {
          target: summarizeClickTarget(event?.target)
        });
        ui.notifications?.warn("Loot claims action failed. Check console for details.");
      }
    } finally {
      if (preserveCanvas) {
        queueCanvasViewRestore(canvasSnapshot, {
          action,
          eventType: String(event?.type ?? "")
        });
      }
    }
  }

  async _onRender(context, options) {
    await super._onRender(context, options);
    ensurePartyOperationsClass(this);
    if (this.element && !this.element.dataset.poBoundGmLootClaimsBoard) {
      this.element.dataset.poBoundGmLootClaimsBoard = "1";
      this.element.addEventListener("click", (event) => {
        const actionElement = event.target?.closest?.("[data-action]");
        if (isFormActionElement(actionElement)) return;
        if (!actionElement) return;
        this.#onAction(event);
      });
      this.element.addEventListener("change", (event) => {
        if (!event.target?.matches("select[data-action], input[data-action], textarea[data-action]")) return;
        this.#onAction(event);
      });
    }
    restorePendingWindowState(this);
    restorePendingUiState(this);
    restorePendingScrollState(this);
  }
}

export class RestWatchPlayerApp extends HandlebarsApplicationMixin(ApplicationV2) {
  static DEFAULT_OPTIONS = foundry.utils.mergeObject(super.DEFAULT_OPTIONS, {
    id: "rest-watch-player-app",
    classes: ["party-operations"],
    window: { title: "Party Operations - Rest Watch" },
    position: getResponsiveWindowPosition("rest-watch-player"),
    resizable: true
  });

  static PARTS = {
    main: { template: "modules/party-operations/templates/rest-watch-player.hbs" }
  };

  async _prepareContext() {
    try {
      const state = getRestWatchState();
      const visibility = state.visibility ?? "names-passives";
      const slots = buildWatchSlotsView(state, false, visibility);
      const lockBannerText = state.locked ? "Locked by GM" : "";
      const lockBannerTooltip = state.locked ? "Edits are disabled while the GM lock is active." : "";
      const miniViz = buildMiniVisualizationContext({ visibility });
      const miniVizUi = buildMiniVizUiContext();
      const totalSlots = slots.length;
      const occupiedSlots = slots.filter((slot) => (slot.entries?.length ?? 0) > 0).length;
      const assignedEntries = slots.reduce((count, slot) => count + (slot.entries?.length ?? 0), 0);
      const lowDarkvisionSlots = slots.filter((slot) => Number(slot.slotNoDarkvision ?? 0) > 0).length;
      const lootClaims = buildLootClaimsContext(game.user);
      const operationsJournal = buildOperationsJournalContext();
      const context = {
        isGM: false,
        locked: state.locked,
        lockBannerText,
        lockBannerTooltip,
        lockBannerClass: "",
        showPopout: false,
        lastUpdatedAt: state.lastUpdatedAt ?? "-",
        lastUpdatedBy: state.lastUpdatedBy ?? "-",
        moduleVersion: getCurrentModuleVersion(),
        activeTab: "rest",
        slots,
        miniViz,
        lootClaims,
        operationsJournal,
        ...miniVizUi,
        overview: {
          totalSlots,
          occupiedSlots,
          assignedEntries,
          lowDarkvisionSlots,
          hasLowDarkvisionCoverage: lowDarkvisionSlots > 0,
          lockState: state.locked ? "Locked by GM" : "Open"
        }
      };
      logUiDebug("rest-watch-player", "prepared player context", {
        template: PO_TEMPLATE_MAP["rest-watch-player"],
        slots: slots.length
      });
      return context;
    } catch (error) {
      console.error(`${MODULE_ID}: RestWatchPlayerApp _prepareContext failed`, error);
      logUiDebug("rest-watch-player", "falling back to safe player context", { error: String(error?.message ?? error) });
      return {
        isGM: false,
        locked: false,
        lockBannerText: "",
        lockBannerTooltip: "",
        lockBannerClass: "",
        showPopout: false,
        lastUpdatedAt: "-",
        lastUpdatedBy: "-",
        moduleVersion: getCurrentModuleVersion(),
        activeTab: "rest",
        slots: [],
        miniViz: {},
        lootClaims: {},
        operationsJournal: {},
        ...buildMiniVizUiContext(),
        overview: {
          totalSlots: 0,
          occupiedSlots: 0,
          assignedEntries: 0,
          lowDarkvisionSlots: 0,
          hasLowDarkvisionCoverage: false,
          lockState: "Open"
        }
      };
    }
  }

  async _onRender(context, options) {
    await super._onRender(context, options);

    restWatchPlayerAppInstance = this;
    ensurePartyOperationsClass(this);

    if (this.element && !this.element.dataset.poBoundRestPlayer) {
      this.element.dataset.poBoundRestPlayer = "1";

      this.element.addEventListener("click", (event) => {
        const tabSwitch = event.target?.closest('[data-action="switch-tab"][data-tab]');
        if (tabSwitch) return this.#onSwitchTabClick(event, tabSwitch);
        const actionElement = event.target?.closest("[data-action]");
        if (isFormActionElement(actionElement)) return;
        const action = actionElement?.dataset?.action;
        if (action) {
          logUiDebug("rest-watch-player", "click action", {
            action,
            target: summarizeClickTarget(event.target)
          });
        }
        if (action) this.#onAction(event);
      });

      if (isModuleDebugEnabled()) {
        this.element.addEventListener("click", (event) => {
          const target = event.target instanceof Element ? event.target : null;
          if (!target) return;
          if (target.closest('[data-action="switch-tab"]')) return;
          const computed = getComputedStyle(target);
          const zIndexValue = Number.parseInt(computed.zIndex ?? "0", 10);
          const suspicious = (computed.position === "fixed" || computed.position === "absolute") && Number.isFinite(zIndexValue) && zIndexValue >= 900;
          if (!suspicious) return;
          logUiDebug("rest-watch-player", "capture-click suspicious overlay", {
            target: summarizeClickTarget(target),
            zIndex: computed.zIndex,
            position: computed.position,
            pointerEvents: computed.pointerEvents
          });
        }, true);
      }

      this.element.addEventListener("change", (event) => {
        if (event.target?.matches("select[data-action], input[data-action], textarea[data-action]")) {
          this.#onAction(event);
        } else if (event.target?.matches("textarea.po-notes-input")) {
          cacheRestWatchNoteDraftFromElement(event.target);
          scheduleRestWatchNoteSave(this, event.target, { source: "autosave" });
        }
      });

      this.element.addEventListener("input", (event) => {
        if (event.target?.matches("input[data-action='set-journal-filter']")) {
          scheduleOperationsJournalFilterUpdate(this, event.target?.value ?? "", () => {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          });
          return;
        }
        if (event.target?.matches("textarea.po-notes-input")) {
          cacheRestWatchNoteDraftFromElement(event.target);
          return;
        }
      });

      this.element.addEventListener("dblclick", (event) => {
        const portrait = event.target?.closest(".po-portrait");
        if (portrait) openActorSheetFromElement(portrait);
      });
    }

    this.#updateActivityUI();
    diagnoseRenderedMainTabs(this.element, "rest-watch-player");
    restorePendingWindowState(this);
    restorePendingUiState(this);
    hydrateCachedNoteDraftInputs(this.element);
    syncNotesDisclosureState(this.element);
    restorePendingScrollState(this);
  }

  #updateActivityUI() {
    const root = getAppRootElement(this);
    if (!root) return;
    root.querySelectorAll(".po-exhaustion-controls").forEach((container) => {
      const current = Number(container.dataset.exhaustion ?? 0);
      container.querySelectorAll(".po-exh-btn").forEach((button) => {
        const level = Number(button.dataset.level ?? 0);
        button.classList.toggle("is-active", level === current);
      });
    });
  }

  #renderWithPreservedState(renderOptions = { force: true, parts: ["main"], focus: false }) {
    renderAppWithPreservedState(this, renderOptions);
  }

  #onTabClick(tabElement, html, event = null) {
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
    const tabName = normalizeMainTabId(getRequestedPanelIdFromElement(tabElement), "rest-watch");
    logUiDebug("rest-watch-player", "main tab click", {
      tabName,
      target: summarizeClickTarget(event?.target ?? tabElement)
    });
    openMainTab(tabName, { force: true });
  }

  #onSwitchTabClick(event, tabButton) {
    event.preventDefault();
    event.stopPropagation();
    const tabId = String(tabButton?.dataset?.tab ?? "").trim().toLowerCase();
    logUiDebug("rest-watch-player", "switch-tab click", {
      tabId,
      target: summarizeClickTarget(event.target)
    });
    openMainTab(normalizeMainTabId(tabId, "rest-watch"), { force: true });
  }

  async #onAction(event) {
    const element = event.target?.closest("[data-action]");
    const action = element?.dataset?.action;
    const preserveCanvas = shouldPreserveCanvasForUiEvent(event, element, action);
    const canvasSnapshot = preserveCanvas ? captureCanvasViewState() : null;
    try {
      if (event?.type === "click") {
        event.preventDefault();
        event.stopPropagation();
      }
      if (!action) return;
      if (element?.tagName === "SELECT" && event?.type !== "change") return;

      const handledJournalAction = await handleOperationsJournalAction(action, element, () => {
        this.#renderWithPreservedState({ force: true, parts: ["main"] });
      });
      if (handledJournalAction) return;

      switch (action) {
        case "refresh":
          emitSocketRefresh();
          break;
        case "switch-tab":
          this.#onSwitchTabClick(event, element);
          break;
        case "main-tab":
        case "set-panel":
          this.#onTabClick(element, this.element);
          break;
        case "toggle-mini-viz":
          setMiniVizCollapsed(!isMiniVizCollapsed());
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
          break;
        case "assign-me":
          await assignSlotToUser(element);
          break;
        case "set-activity":
          await updateActivity(element, { skipLocalRefresh: true });
          break;
        case "clear":
          await clearSlotEntry(element);
          break;
        case "toggle-notes":
          toggleCardNotes(element);
          break;
        case "save-entry-notes":
          {
            const context = getRestWatchNoteContextFromElement(element);
            if (context?.slotId && context?.actorId) {
              clearScheduledRestWatchNoteSave(this, context.slotId, context.actorId);
            }
          }
          await saveRestWatchEntryNoteFromElement(element, { source: "manual", notify: true });
          break;
        case "ping":
          await pingActorFromElement(element);
          break;
        case "claim-loot-item":
          await claimLootItemForPlayer(element);
          break;
        case "toggle-loot-vouch":
          await toggleLootItemVouchForPlayer(element);
          break;
        case "set-loot-claim-run":
          if (setLootClaimRunSelectionFromElement(element)) {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          }
          break;
        case "set-loot-claims-archive-sort":
          setLootClaimsArchiveSort(element?.value);
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
          break;
        case "set-loot-claim-actor":
          if (setLootClaimActorSelectionFromElement(element)) {
            this.#renderWithPreservedState({ force: true, parts: ["main"] });
          }
          break;
        case "claim-loot-currency":
          await claimLootCurrencyForPlayer(element);
          break;
        case "open-gm-loot-claims-board":
          openGmLootClaimsBoard({
            force: true,
            runId: getLootClaimRunIdFromElement(element)
          });
          break;
        case "open-loot-item":
          await openLootItemFromElement(element);
          break;
        default:
          break;
      }
    } finally {
      if (preserveCanvas) {
        queueCanvasViewRestore(canvasSnapshot, {
          action: String(action ?? ""),
          eventType: String(event?.type ?? "")
        });
      }
    }
  }

  async #onNotesChange(event) {
    if (event?.type === "input") return;
    const state = getRestWatchState();
    if (isLockedForUser(state, canAccessAllPlayerOps())) {
      ui.notifications?.warn("Rest watch is locked by the GM.");
      return;
    }
    const slotId = event.target?.closest(".po-card")?.dataset?.slotId;
    if (!slotId) return;
    const text = event.target.value ?? "";
    const actorId = event.target?.closest(".po-watch-entry")?.dataset?.actorId || getActiveActorForUser()?.id;
    if (!actorId) return;
    const actor = game.actors.get(actorId);
    if (!actor || !canUserControlActor(actor, game.user)) return;
    await updateRestWatchState({ op: "setEntryNotes", slotId, actorId, text });
  }

  async close(options = {}) {
    if (isModuleDebugEnabled()) {
      console.trace(`[${MODULE_ID}] RestWatchPlayerApp.close`, {
        options
      });
    }
    return super.close(options);
  }
}

export class MarchingOrderApp extends HandlebarsApplicationMixin(ApplicationV2) {
  static DEFAULT_OPTIONS = foundry.utils.mergeObject(super.DEFAULT_OPTIONS, {
    id: "marching-order-app",
    classes: ["party-operations"],
    window: { title: "Party Operations - Marching Order" },
    position: getResponsiveWindowPosition("marching-order"),
    resizable: true
  });

  static PARTS = {
    main: { template: "modules/party-operations/templates/marching-order.hbs" }
  };

  async _prepareContext() {
    const isGM = canAccessAllPlayerOps();
    const state = getMarchingOrderState();
    const ranks = buildRanksView(state, isGM);
    const lockBannerText = state.locked ? (isGM ? "Players locked" : "Locked by GM") : "";
    const lockBannerTooltip = state.locked ? (isGM ? "Players cannot edit while locked." : "Edits are disabled while the GM lock is active.") : "";
    const formation = normalizeMarchingFormation(state.formation ?? "default");
    const formationLabels = {
      default: "Default Formation (2 front, 3 middle)",
      "combat-ready": "Combat-Ready Formation (2 front, 2 middle)",
      "tight-corridor": "Tight Corridor Formation (2 front, 2 middle)",
      "low-visibility": "Low-Visibility Formation (1 front, 1 middle)"
    };
    const doctrineEffects = getDoctrineEffects(formation);
    const tracker = ensureDoctrineTracker(state);
    const miniViz = buildMiniVisualizationContext({ visibility: "names-passives" });
    const miniVizUi = buildMiniVizUiContext();
    const lightToggles = buildLightToggles(state, ranks, isGM);
    const frontCount = (ranks.find((rank) => rank.id === "front")?.entries?.length ?? 0);
    const middleCount = (ranks.find((rank) => rank.id === "middle")?.entries?.length ?? 0);
    const rearCount = (ranks.find((rank) => rank.id === "rear")?.entries?.length ?? 0);
    const totalAssigned = frontCount + middleCount + rearCount;
    const lightSources = lightToggles.filter((entry) => entry.hasLight).length;
    const lockState = state.locked ? (isGM ? "Locked for players" : "Locked by GM") : "Open";
    return {
      isGM,
      locked: state.locked,
      lockBannerText,
      lockBannerTooltip,
      lockBannerClass: isGM ? "is-gm" : "",
      showPopout: false,
      lastUpdatedAt: state.lastUpdatedAt ?? "-",
      lastUpdatedBy: state.lastUpdatedBy ?? "-",
      moduleVersion: getCurrentModuleVersion(),
      activeTab: "march",
      usageCollapsed: false,
      usageToggleLabel: "Collapse",
      usageToggleIcon: "fa-chevron-up",
      ranks,
      gmNotes: state.gmNotes ?? "",
      lightToggles,
      gmSections: {
        formationsCollapsed: false,
        formationsToggleLabel: "Collapse",
        formationsToggleIcon: "fa-chevron-up",
        lightCollapsed: false,
        lightToggleLabel: "Collapse",
        lightToggleIcon: "fa-chevron-up",
        exportCollapsed: false,
        exportToggleLabel: "Collapse",
        exportToggleIcon: "fa-chevron-up",
        snapshotCollapsed: false,
        snapshotToggleLabel: "Collapse",
        snapshotToggleIcon: "fa-chevron-up",
        clearCollapsed: false,
        clearToggleLabel: "Collapse",
        clearToggleIcon: "fa-chevron-up",
        gmNotesCollapsed: false,
        gmNotesToggleLabel: "Collapse",
        gmNotesToggleIcon: "fa-chevron-up"
      },
      formation,
      formationLabel: formationLabels[formation] ?? formationLabels.default,
      doctrineEffects,
      doctrineTracker: {
        lastCheckAt: tracker.lastCheckAt ?? "-",
        lastCheckNote: tracker.lastCheckNote ?? "-"
      },
      miniViz,
      ...miniVizUi,
      activateFormation: {
        default: formation === "default",
        combatReady: formation === "combat-ready",
        tightCorridor: formation === "tight-corridor",
        lowVisibility: formation === "low-visibility"
      },
      overview: {
        totalAssigned,
        frontCount,
        middleCount,
        rearCount,
        formationLabel: formationLabels[formation] ?? formationLabels.default,
        lightSources,
        lockState
      }
    };
  }

  async _onRender(context, options) {
    await super._onRender(context, options);
    marchingOrderAppInstance = this;
    if (DEBUG_LOG) console.log("MarchingOrderApp: _onRender called");
    ensurePartyOperationsClass(this);
    
    if (this.element && !this.element.dataset.poBoundMarch) {
      this.element.dataset.poBoundMarch = "1";

      // Use event delegation on the app element
      this.element.addEventListener("click", (event) => {
        const tabSwitch = event.target?.closest('[data-action="switch-tab"][data-tab]');
        if (tabSwitch) return this.#onSwitchTabClick(event, tabSwitch);

        const actionElement = event.target?.closest("[data-action]");
        if (isFormActionElement(actionElement)) return;
        const action = actionElement?.dataset?.action;
        if (action) {
          logUiDebug("marching-order", "click action", {
            action,
            target: summarizeClickTarget(event.target)
          });
        }
        if (action) this.#onAction(event);
      });

      if (isModuleDebugEnabled()) {
        this.element.addEventListener("click", (event) => {
          const target = event.target instanceof Element ? event.target : null;
          if (!target) return;
          if (target.closest('[data-action="switch-tab"]')) return;
          const computed = getComputedStyle(target);
          const zIndexValue = Number.parseInt(computed.zIndex ?? "0", 10);
          const suspicious = (computed.position === "fixed" || computed.position === "absolute") && Number.isFinite(zIndexValue) && zIndexValue >= 900;
          if (!suspicious) return;
          logUiDebug("marching-order", "capture-click suspicious overlay", {
            target: summarizeClickTarget(target),
            zIndex: computed.zIndex,
            position: computed.position,
            pointerEvents: computed.pointerEvents
          });
        }, true);
      }
      
      this.element.addEventListener("change", (event) => {
        if (event.target?.matches("select[data-action], input[data-action], textarea[data-action]")) {
          this.#onAction(event);
        } else if (event.target?.matches("textarea.po-notes-input")) {
          cacheMarchingNoteDraftFromElement(event.target);
          scheduleMarchingNoteSave(this, event.target, { source: "autosave" });
        } else if (event.target?.matches("textarea.po-gm-notes")) {
          this.#onGMNotesChange(event);
        }
      });

      this.element.addEventListener("dblclick", (event) => {
        const portrait = event.target?.closest(".po-portrait");
        if (portrait) openActorSheetFromElement(portrait);
      });

      this.element.addEventListener("input", (event) => {
        if (event.target?.matches("textarea.po-notes-input")) {
          cacheMarchingNoteDraftFromElement(event.target);
          return;
        } else if (event.target?.matches("textarea.po-gm-notes")) {
          // Save on change/blur only to avoid typing jitter.
          return;
        }
      });
    }
    
    setupMarchingDragAndDrop(this.element);
    refreshTabAccessibility(this.element);
    diagnoseRenderedMainTabs(this.element, "marching-order");
    if (isModuleDebugEnabled()) {
      const activeTab = "march";
      const activeButton = this.element?.querySelector?.(`.po-tabs-main [data-action="switch-tab"][data-tab="${activeTab}"]`);
      const panelExists = Boolean(this.element?.querySelector?.("#po-march-overview"));
      logUiDebug("marching-order", "after render active tab", {
        activeTab,
        activePanel: "marching-order",
        activeButtonFound: Boolean(activeButton),
        panelTarget: "#po-march-overview",
        panelExists
      });
    }
    restorePendingWindowState(this);
    restorePendingUiState(this);
    hydrateCachedNoteDraftInputs(this.element);
    restorePendingScrollState(this);
    
    if (DEBUG_LOG) console.log("MarchingOrderApp: event delegation attached", this.element);
  }

  #onTabClick(tabElement, html, event = null) {
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
    const tabName = normalizeMainTabId(getRequestedPanelIdFromElement(tabElement), "rest-watch");
    logUiDebug("marching-order", "main tab click", {
      tabName,
      target: summarizeClickTarget(event?.target ?? tabElement)
    });
    openMainTab(tabName, { force: true });
  }

  setActiveTab(tabId) {
    const requested = String(tabId ?? "").trim().toLowerCase();
    if (!PO_SWITCH_TAB_IDS.has(requested)) {
      logUiDebug("marching-order", "setActiveTab ignored unknown tab", { tabId: requested });
      return;
    }
    const normalizedSwitchTab = normalizeSwitchTabId(requested, "march");
    if (normalizedSwitchTab === "march") return;
    openMainTab(normalizeMainTabId(normalizedSwitchTab, "rest-watch"), { force: true });
  }

  #onSwitchTabClick(event, tabButton) {
    event.preventDefault();
    event.stopPropagation();
    const tabId = String(tabButton?.dataset?.tab ?? "").trim().toLowerCase();
    logUiDebug("marching-order", "switch-tab click", {
      tabId,
      target: summarizeClickTarget(event.target)
    });
    this.setActiveTab(tabId);
  }

  #renderWithPreservedState(renderOptions = { force: true, parts: ["main"], focus: false }) {
    renderAppWithPreservedState(this, renderOptions);
  }

  async #onAction(event) {
    const element = event.target?.closest("[data-action]");
    const action = element?.dataset?.action;
    const preserveCanvas = shouldPreserveCanvasForUiEvent(event, element, action);
    const canvasSnapshot = preserveCanvas ? captureCanvasViewState() : null;
    try {
      if (event?.type === "click") {
        event.preventDefault();
        event.stopPropagation();
      }
      if (DEBUG_LOG) console.log("MarchingOrderApp #onAction:", { action, element, event });
      if (!action) return;
      if (element?.tagName === "SELECT" && event?.type !== "change") return;

      switch (action) {
        case "refresh":
          emitSocketRefresh();
          break;
        case "switch-tab":
          this.#onSwitchTabClick(event, element);
          break;
        case "main-tab":
        case "set-panel":
          this.#onTabClick(element, this.element);
          break;
        case "popout":
          this.render({ force: true, popOut: true });
          break;
        case "toggle-mini-viz":
          setMiniVizCollapsed(!isMiniVizCollapsed());
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
          break;
        case "toggle-section": {
          const sectionId = element?.dataset?.sectionId;
          if (!sectionId) break;
          setMarchSectionCollapsed(sectionId, !isMarchSectionCollapsed(sectionId));
          this.#renderWithPreservedState({ force: true, parts: ["main"] });
          break;
        }
        case "assign-rank":
          await assignActorToRank(element);
          break;
        case "remove-from-rank":
          await removeActorFromRanks(element);
          break;
        case "toggle-light":
          await toggleLight(element);
          break;
        case "set-light-range":
          await setLightRange(element);
          break;
        case "copy-text":
          await copyMarchingText(false);
          break;
        case "copy-md":
          await copyMarchingText(true);
          break;
        case "commit-plan":
          await commitMarchingOrderState();
          break;
        case "clear-all":
          await clearMarchingAll();
          break;
        case "ping":
          await pingActorFromElement(element);
          break;
        case "formation-standard":
          await applyMarchingFormation({ front: 2, middle: 3, type: "default" });
          break;
        case "formation-combat-ready":
          await applyMarchingFormation({ front: 2, middle: 2, type: "combat-ready" });
          break;
        case "formation-tight-corridor":
          await applyMarchingFormation({ front: 2, middle: 2, type: "tight-corridor" });
          break;
        case "formation-low-visibility":
          await applyMarchingFormation({ front: 1, middle: 1, type: "low-visibility" });
          break;
        case "doctrine-check":
          await runDoctrineCheckPrompt();
          break;
        case "toggle-notes":
            toggleNotesDrawer(element);
          break;
        case "save-entry-notes":
          {
            const context = getMarchingNoteContextFromElement(element);
            if (context?.actorId) clearScheduledMarchingNoteSave(this, context.actorId);
          }
          await saveMarchingNoteFromElement(element, { notify: true });
          break;
        default:
          break;
      }
    } finally {
      if (preserveCanvas) {
        queueCanvasViewRestore(canvasSnapshot, {
          action: String(action ?? ""),
          eventType: String(event?.type ?? "")
        });
      }
    }
  }

  async #onNotesChange(event) {
    if (event?.type === "input") return;
    const state = getMarchingOrderState();
    if (isLockedForUser(state, canAccessAllPlayerOps())) {
      ui.notifications?.warn("Marching order is locked by the GM.");
      return;
    }
    const text = event.target.value ?? "";

    // Players: only allowed to edit notes for characters they own
    if (!canAccessAllPlayerOps()) {
      const actorId = event.target?.closest("[data-actor-id]")?.dataset?.actorId || getActiveActorForUser()?.id;
      if (!actorId) return;
      const actor = game.actors.get(actorId);
      if (!actor || !userOwnsActor(actor)) return;
      await updateMarchingOrderState({ op: "setNote", actorId, text });
      return;
    }

    // GM: apply per-actor notes directly
    const actorId = event.target?.closest("[data-actor-id]")?.dataset?.actorId;
    if (!actorId) return;
    await updateMarchingOrderState((state) => {
      if (!state.notes) state.notes = {};
      state.notes[actorId] = text;
    });
  }

  async #onGMNotesChange(event) {
    if (event?.type === "input") return;
    const state = getMarchingOrderState();
    if (isLockedForUser(state, canAccessAllPlayerOps())) {
      ui.notifications?.warn("Marching order is locked by the GM.");
      return;
    }
    if (!canAccessAllPlayerOps()) return; // GM notes are GM-only
    const text = event.target.value ?? "";
    await updateMarchingOrderState((state) => {
      state.gmNotes = text;
    });
  }

  async close(options = {}) {
    if (isModuleDebugEnabled()) {
      console.trace(`[${MODULE_ID}] MarchingOrderApp.close`, {
        options
      });
    }
    return super.close(options);
  }
}

function buildEmptyWatchSlots(isGM) {
  return [1, 2, 3, 4].map((index) => ({
    id: `watch-${index}`,
    label: `Watch ${index}`,
    timeRange: "",
    actor: null,
    notes: "",
    canAssign: isGM,
    canAssignMe: !isGM,
    canClear: false,
    canEditNotes: isGM
  }));
}

function buildEmptyRanks(isGM) {
  return [
    { id: "front", label: "Front Rank", entries: [], capacity: null, canJoin: false },
    { id: "middle", label: "Middle Rank", entries: [], capacity: null, canJoin: false },
    { id: "rear", label: "Rear Rank", entries: [], capacity: null, canJoin: false }
  ];
}

function buildStoredWatchSlots() {
  return [1, 2, 3, 4].map((index) => ({
    id: `watch-${index}`,
    timeRange: "",
    entries: [] // each entry: { actorId, notes }
  }));
}

function buildDefaultRestWatchState() {
  return {
    locked: false,
    lockedBy: "",
    visibility: "names-passives",
    campfire: false,
    lastUpdatedAt: "-",
    lastUpdatedBy: "-",
    slots: buildStoredWatchSlots()
  };
}

function buildDefaultActivityState() {
  return {
    dateCreated: new Date().toDateString(),
    activities: {} // actorId => { exhaustion, activity, spellSlots: {...}, hitDice: {...} }
  };
}

function buildDefaultLootSourceConfig() {
  return {
    packs: [
      {
        id: LOOT_WORLD_ITEMS_SOURCE_ID,
        label: "World Item Directory",
        sourceKind: "world-items",
        enabled: true,
        weight: 1
      }
    ],
    tables: [],
    filters: {
      allowedTypes: [...LOOT_DEFAULT_ITEM_TYPES],
      rarityFloor: "",
      rarityCeiling: "",
      manifestPackId: "",
      keywordIncludeTags: [],
      keywordExcludeTags: []
    },
    updatedAt: 0,
    updatedBy: ""
  };
}

function normalizeLootKeywordTag(value) {
  return String(value ?? "")
    .trim()
    .toLowerCase();
}

function normalizeLootKeywordTagList(values = []) {
  const source = Array.isArray(values) ? values : [values];
  return source
    .flatMap((entry) => String(entry ?? "").split(/[\n,;]+/))
    .map((entry) => normalizeLootKeywordTag(entry))
    .filter((entry, index, rows) => entry.length > 0 && rows.indexOf(entry) === index);
}

function parseLootKeywordTagListFromInput(value) {
  return normalizeLootKeywordTagList(String(value ?? "").split(/[\s,;\n]+/));
}

function formatLootKeywordTagListForInput(values = []) {
  return normalizeLootKeywordTagList(values).join(", ");
}

function normalizeLootRarityValue(value) {
  const raw = String(value ?? "").trim().toLowerCase();
  const allowed = new Set(LOOT_RARITY_OPTIONS.map((entry) => String(entry.value ?? "").trim().toLowerCase()));
  return allowed.has(raw) ? raw : "";
}

function buildLootItemTypeCatalog() {
  const labels = CONFIG?.Item?.typeLabels && typeof CONFIG.Item.typeLabels === "object"
    ? CONFIG.Item.typeLabels
    : {};
  const merged = new Map();
  for (const [key, label] of Object.entries(LOOT_ITEM_TYPE_LABELS)) {
    merged.set(String(key).trim(), String(label).trim() || String(key).trim());
  }
  for (const [key, label] of Object.entries(labels)) {
    const id = String(key ?? "").trim();
    if (!id) continue;
    if (!merged.has(id)) merged.set(id, String(label ?? id).trim() || id);
  }
  return Array.from(merged.entries())
    .map(([value, label]) => ({ value, label }))
    .filter((entry) => entry.value)
    .sort((a, b) => a.label.localeCompare(b.label));
}

function normalizeLootSourcePackEntry(entry = {}) {
  const id = String(entry?.id ?? entry?.pack ?? "").trim();
  if (!id) return null;
  const weightRaw = Number(entry?.weight ?? 1);
  const weight = Number.isFinite(weightRaw) ? Math.max(1, Math.floor(weightRaw)) : 1;
  const sourceKindRaw = String(entry?.sourceKind ?? (id === LOOT_WORLD_ITEMS_SOURCE_ID ? "world-items" : "compendium-pack")).trim().toLowerCase();
  const sourceKind = sourceKindRaw === "world-items" ? "world-items" : "compendium-pack";
  return {
    id,
    label: String(entry?.label ?? "").trim(),
    sourceKind,
    enabled: entry?.enabled !== false,
    weight
  };
}

function normalizeLootSourceTableEntry(entry = {}) {
  const id = String(entry?.id ?? entry?.tableRef ?? entry?.tableUuid ?? "").trim();
  if (!id) return null;
  const typeRaw = String(entry?.tableType ?? entry?.type ?? "currency").trim().toLowerCase();
  const validTypes = new Set(LOOT_TABLE_TYPE_OPTIONS.map((option) => option.value));
  const tableType = validTypes.has(typeRaw) ? typeRaw : "currency";
  const sourceKindRaw = String(entry?.sourceKind ?? (id.startsWith("world-table:") ? "world-table" : "table-pack")).trim().toLowerCase();
  const sourceKind = sourceKindRaw === "world-table" ? "world-table" : "table-pack";
  return {
    id,
    label: String(entry?.label ?? "").trim(),
    sourceKind,
    enabled: entry?.enabled !== false,
    tableType
  };
}

function normalizeLootSourceConfig(config = {}) {
  const fallback = buildDefaultLootSourceConfig();
  const rawPacks = Array.isArray(config?.packs) ? config.packs : fallback.packs;
  const rawTables = Array.isArray(config?.tables) ? config.tables : fallback.tables;
  const packs = rawPacks
    .map((entry) => normalizeLootSourcePackEntry(entry))
    .filter((entry, index, rows) => entry && rows.findIndex((candidate) => candidate.id === entry.id) === index);
  const tables = rawTables
    .map((entry) => normalizeLootSourceTableEntry(entry))
    .filter((entry, index, rows) => entry && rows.findIndex((candidate) => candidate.id === entry.id) === index);

  const itemTypeCatalog = new Set(buildLootItemTypeCatalog().map((entry) => entry.value));
  const validPackIds = new Set(getAvailableLootItemPackSources().map((entry) => String(entry?.id ?? "").trim()).filter(Boolean));
  const rawAllowedTypes = Array.isArray(config?.filters?.allowedTypes)
    ? config.filters.allowedTypes
    : fallback.filters.allowedTypes;
  const allowedTypes = rawAllowedTypes
    .map((entry) => String(entry ?? "").trim())
    .filter((entry, index, rows) => entry && itemTypeCatalog.has(entry) && rows.indexOf(entry) === index);

  const updatedAtRaw = Number(config?.updatedAt ?? 0);
  return {
    packs,
    tables,
    filters: {
      allowedTypes: allowedTypes.length > 0 ? allowedTypes : [...LOOT_DEFAULT_ITEM_TYPES],
      rarityFloor: normalizeLootRarityValue(config?.filters?.rarityFloor),
      rarityCeiling: normalizeLootRarityValue(config?.filters?.rarityCeiling),
      manifestPackId: (() => {
        const id = String(config?.filters?.manifestPackId ?? "").trim();
        if (!id) return "";
        return validPackIds.has(id) ? id : "";
      })(),
      keywordIncludeTags: normalizeLootKeywordTagList(config?.filters?.keywordIncludeTags ?? []),
      keywordExcludeTags: normalizeLootKeywordTagList(config?.filters?.keywordExcludeTags ?? [])
    },
    updatedAt: Number.isFinite(updatedAtRaw) ? updatedAtRaw : 0,
    updatedBy: String(config?.updatedBy ?? "")
  };
}

function getLootSourceConfig() {
  const stored = game.settings.get(MODULE_ID, SETTINGS.LOOT_SOURCE_CONFIG);
  return normalizeLootSourceConfig(stored ?? buildDefaultLootSourceConfig());
}

async function updateLootSourceConfig(mutator, options = {}) {
  if (typeof mutator !== "function") return;
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can configure loot sources.");
    return;
  }
  const config = getLootSourceConfig();
  mutator(config);
  const next = normalizeLootSourceConfig(config);
  next.updatedAt = Date.now();
  next.updatedBy = String(game.user?.name ?? "GM");
  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.LOOT_SOURCE_CONFIG, next);
  if (!options.skipLocalRefresh) refreshOpenApps();
  emitSocketRefresh();
}

function getAllCompendiumPacks() {
  if (!game?.packs) return [];
  if (typeof game.packs.values === "function") return Array.from(game.packs.values());
  const rows = [];
  for (const entry of game.packs) {
    if (Array.isArray(entry) && entry.length > 1) rows.push(entry[1]);
    else rows.push(entry);
  }
  return rows;
}

function normalizeLootManifestItemType(value) {
  return String(value ?? "")
    .trim()
    .toLowerCase();
}

function getLootManifestFolderNameKey(value) {
  return String(value ?? "")
    .trim()
    .toLowerCase();
}

function getLootManifestFolderLabelForType(itemType = "") {
  const normalizedType = normalizeLootManifestItemType(itemType);
  if (!normalizedType) return LOOT_MANIFEST_FOLDER_LABELS.other;
  const explicit = String(LOOT_MANIFEST_FOLDER_LABELS[normalizedType] ?? "").trim();
  if (explicit) return explicit;
  const fallback = String(LOOT_ITEM_TYPE_LABELS[normalizedType] ?? "").trim();
  if (fallback) return fallback;
  return normalizedType
    .split(/[-_\s]+/)
    .filter(Boolean)
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
    .join(" ");
}

function getLootManifestFolderSortPriority(itemType = "") {
  const normalizedType = normalizeLootManifestItemType(itemType) || "other";
  const index = LOOT_MANIFEST_FOLDER_TYPE_PRIORITY.indexOf(normalizedType);
  if (index >= 0) return index;
  return LOOT_MANIFEST_FOLDER_TYPE_PRIORITY.length + 100;
}

function getLootManifestCompendiumPack() {
  const allowedPackages = new Set([String(PRIMARY_MODULE_ID).trim().toLowerCase(), String(PREMIUM_MODULE_ID).trim().toLowerCase()]);
  const targetName = String(LOOT_MANIFEST_PACK_NAME).trim().toLowerCase();
  const targetLabel = String(LOOT_MANIFEST_PACK_LABEL).trim().toLowerCase();

  const candidates = getAllCompendiumPacks().filter((pack) => {
    const documentName = String(pack?.documentName ?? pack?.metadata?.type ?? "").trim().toLowerCase();
    if (documentName !== "item") return false;
    const metadataName = String(pack?.metadata?.name ?? "").trim().toLowerCase();
    return metadataName === targetName;
  });

  if (candidates.length > 0) {
    const packageMatched = candidates.find((pack) => {
      const packageName = String(pack?.metadata?.packageName ?? pack?.metadata?.package ?? "").trim().toLowerCase();
      if (!packageName) return false;
      return allowedPackages.has(packageName);
    });
    if (packageMatched) return packageMatched;
    return candidates[0];
  }

  const collectionMatched = getAllCompendiumPacks().find((pack) => {
    const documentName = String(pack?.documentName ?? pack?.metadata?.type ?? "").trim().toLowerCase();
    if (documentName !== "item") return false;
    const collection = String(pack?.collection ?? "").trim().toLowerCase();
    return collection.endsWith(`.${targetName}`);
  });
  if (collectionMatched) return collectionMatched;

  return getAllCompendiumPacks().find((pack) => {
    const documentName = String(pack?.documentName ?? pack?.metadata?.type ?? "").trim().toLowerCase();
    if (documentName !== "item") return false;
    const label = String(pack?.metadata?.label ?? pack?.title ?? "").trim().toLowerCase();
    return label === targetLabel;
  }) ?? null;
}

function getCompendiumFolderRows(pack) {
  const folders = pack?.folders;
  if (!folders) return [];
  if (Array.isArray(folders?.contents)) return folders.contents;
  if (typeof folders.values === "function") return Array.from(folders.values());
  if (Array.isArray(folders)) return folders;
  return [];
}

async function getLootManifestPackItemRows(pack) {
  try {
    if (typeof pack?.getIndex === "function") {
      const index = await pack.getIndex({ fields: ["type", "folder", "name"] });
      const rows = [];
      if (Array.isArray(index)) rows.push(...index);
      else if (Array.isArray(index?.contents)) rows.push(...index.contents);
      else if (typeof index?.values === "function") rows.push(...Array.from(index.values()));
      if (rows.length > 0) {
        return rows.map((entry) => ({
          id: String(entry?._id ?? entry?.id ?? "").trim(),
          type: normalizeLootManifestItemType(entry?.type),
          name: String(entry?.name ?? "").trim(),
          folderId: String(entry?.folder?.id ?? entry?.folder ?? "").trim()
        })).filter((entry) => entry.id);
      }
    }
  } catch (error) {
    console.warn(`${MODULE_ID}: failed to read loot manifest compendium index`, error);
  }

  try {
    const docs = typeof pack?.getDocuments === "function" ? await pack.getDocuments() : [];
    return (Array.isArray(docs) ? docs : []).map((entry) => ({
      id: String(entry?.id ?? entry?._id ?? "").trim(),
      type: normalizeLootManifestItemType(entry?.type),
      name: String(entry?.name ?? "").trim(),
      folderId: String(entry?.folder?.id ?? entry?.folder ?? "").trim()
    })).filter((entry) => entry.id);
  } catch (error) {
    console.warn(`${MODULE_ID}: failed to read loot manifest compendium documents`, error);
  }

  return [];
}

async function updateLootManifestPackItemFolders(pack, updates = []) {
  const normalizedUpdates = (Array.isArray(updates) ? updates : [])
    .map((entry) => {
      const id = String(entry?._id ?? entry?.id ?? "").trim();
      const folderId = String(entry?.folder ?? "").trim();
      if (!id) return null;
      return { _id: id, folder: folderId || null };
    })
    .filter(Boolean);
  if (normalizedUpdates.length <= 0) return 0;

  if (typeof Item?.updateDocuments === "function") {
    await Item.updateDocuments(normalizedUpdates, { pack: pack.collection });
    return normalizedUpdates.length;
  }

  let applied = 0;
  for (const entry of normalizedUpdates) {
    try {
      const document = typeof pack?.getDocument === "function" ? await pack.getDocument(entry._id) : null;
      if (!document || typeof document.update !== "function") continue;
      await document.update({ folder: entry.folder });
      applied += 1;
    } catch (error) {
      console.warn(`${MODULE_ID}: failed to update loot manifest item folder`, entry?._id, error);
    }
  }
  return applied;
}

async function ensureLootManifestCompendiumTypeFolders(options = {}) {
  if (!game.user?.isGM) return { ok: false, reason: "not-gm" };
  const pack = getLootManifestCompendiumPack();
  if (!pack) return { ok: false, reason: "pack-missing" };

  const report = {
    ok: true,
    packId: String(pack?.collection ?? ""),
    createdFolders: 0,
    updatedItems: 0
  };

  const originalLocked = Boolean(pack?.locked);
  const mustUnlock = originalLocked && typeof pack?.configure === "function";
  try {
    if (mustUnlock) await pack.configure({ locked: false });
  } catch (error) {
    report.ok = false;
    report.reason = "unlock-failed";
    console.warn(`${MODULE_ID}: unable to unlock loot manifest compendium for folder sync`, error);
    return report;
  }

  try {
    const items = await getLootManifestPackItemRows(pack);
    if (items.length <= 0) return report;

    const folderRequestsByType = new Map();
    for (const item of items) {
      const normalizedType = normalizeLootManifestItemType(item?.type) || "other";
      if (!folderRequestsByType.has(normalizedType)) {
        folderRequestsByType.set(normalizedType, {
          type: normalizedType,
          label: getLootManifestFolderLabelForType(normalizedType),
          priority: getLootManifestFolderSortPriority(normalizedType)
        });
      }
    }

    if (typeof pack?.getFolders === "function") {
      await pack.getFolders();
    }
    let folders = getCompendiumFolderRows(pack);
    const folderByName = new Map(
      folders.map((folder) => [getLootManifestFolderNameKey(folder?.name), folder]).filter(([key]) => key)
    );

    const foldersToCreate = Array.from(folderRequestsByType.values())
      .filter((entry) => !folderByName.has(getLootManifestFolderNameKey(entry.label)))
      .sort((left, right) => {
        const byPriority = Number(left?.priority ?? 0) - Number(right?.priority ?? 0);
        if (byPriority !== 0) return byPriority;
        return String(left?.label ?? "").localeCompare(String(right?.label ?? ""));
      })
      .map((entry, index) => ({
        name: String(entry.label ?? "Other"),
        type: "Item",
        folder: null,
        sorting: "a",
        color: null,
        sort: (index + 1) * 1000
      }));

    if (foldersToCreate.length > 0) {
      if (typeof Folder?.createDocuments === "function") {
        await Folder.createDocuments(foldersToCreate, { pack: pack.collection });
        report.createdFolders = foldersToCreate.length;
      } else if (typeof pack?.createFolder === "function") {
        for (const folderData of foldersToCreate) {
          await pack.createFolder(folderData);
          report.createdFolders += 1;
        }
      }
      if (typeof pack?.getFolders === "function") {
        await pack.getFolders();
      }
      folders = getCompendiumFolderRows(pack);
      folderByName.clear();
      for (const folder of folders) {
        const key = getLootManifestFolderNameKey(folder?.name);
        if (!key) continue;
        folderByName.set(key, folder);
      }
    }

    const itemUpdates = [];
    for (const item of items) {
      const normalizedType = normalizeLootManifestItemType(item?.type) || "other";
      const folderLabel = getLootManifestFolderLabelForType(normalizedType);
      const folder = folderByName.get(getLootManifestFolderNameKey(folderLabel));
      const folderId = String(folder?.id ?? "").trim();
      if (!folderId) continue;
      if (String(item.folderId ?? "").trim() === folderId) continue;
      itemUpdates.push({
        _id: item.id,
        folder: folderId
      });
    }

    report.updatedItems = await updateLootManifestPackItemFolders(pack, itemUpdates);

    if (isModuleDebugEnabled()) {
      console.log(`${MODULE_ID}: loot manifest compendium folder sync`, {
        reason: String(options?.reason ?? ""),
        ...report
      });
    }

    return report;
  } catch (error) {
    report.ok = false;
    report.reason = "sync-failed";
    console.warn(`${MODULE_ID}: failed to sync loot manifest compendium folders`, error);
    return report;
  } finally {
    if (mustUnlock) {
      try {
        await pack.configure({ locked: true });
      } catch (error) {
        console.warn(`${MODULE_ID}: failed to restore loot manifest compendium lock`, error);
      }
    }
  }
}

function scheduleLootManifestCompendiumTypeFolderSync(reason = "") {
  if (!game.user?.isGM) return Promise.resolve({ ok: false, reason: "not-gm" });
  if (lootManifestFolderSyncPromise) return lootManifestFolderSyncPromise;

  lootManifestFolderSyncPromise = ensureLootManifestCompendiumTypeFolders({ reason })
    .catch((error) => {
      console.warn(`${MODULE_ID}: unexpected loot manifest folder sync failure`, error);
      return { ok: false, reason: "unexpected-error" };
    })
    .finally(() => {
      lootManifestFolderSyncPromise = null;
    });
  return lootManifestFolderSyncPromise;
}

function getAvailableLootItemPackSources() {
  const rows = [{
    id: LOOT_WORLD_ITEMS_SOURCE_ID,
    label: "World Item Directory",
    sourceKind: "world-items"
  }];
  for (const pack of getAllCompendiumPacks()) {
    const documentName = String(pack?.documentName ?? pack?.metadata?.type ?? "").trim().toLowerCase();
    if (documentName !== "item") continue;
    const id = String(pack?.collection ?? "").trim();
    if (!id) continue;
    const packageLabel = String(pack?.metadata?.packageName ?? pack?.metadata?.package ?? "").trim();
    const baseLabel = String(pack?.metadata?.label ?? pack?.title ?? id).trim() || id;
    rows.push({
      id,
      label: packageLabel ? `${baseLabel} (${packageLabel})` : baseLabel,
      sourceKind: "compendium-pack"
    });
  }
  return rows
    .filter((entry, index, list) => entry.id && list.findIndex((candidate) => candidate.id === entry.id) === index)
    .sort((a, b) => a.label.localeCompare(b.label));
}

function getAvailableLootTableSources() {
  const rows = [];

  for (const table of game.tables?.contents ?? []) {
    const uuid = String(table?.uuid ?? "").trim();
    if (!uuid) continue;
    const name = String(table?.name ?? "World Roll Table").trim() || "World Roll Table";
    rows.push({
      id: `world-table:${uuid}`,
      label: `${name} (World Table)`,
      sourceKind: "world-table"
    });
  }

  for (const pack of getAllCompendiumPacks()) {
    const documentName = String(pack?.documentName ?? pack?.metadata?.type ?? "").trim().toLowerCase();
    if (documentName !== "rolltable") continue;
    const id = String(pack?.collection ?? "").trim();
    if (!id) continue;
    const packageLabel = String(pack?.metadata?.packageName ?? pack?.metadata?.package ?? "").trim();
    const baseLabel = String(pack?.metadata?.label ?? pack?.title ?? id).trim() || id;
    rows.push({
      id: `table-pack:${id}`,
      label: packageLabel ? `${baseLabel} (${packageLabel})` : baseLabel,
      sourceKind: "table-pack"
    });
  }

  return rows
    .filter((entry, index, list) => entry.id && list.findIndex((candidate) => candidate.id === entry.id) === index)
    .sort((a, b) => a.label.localeCompare(b.label));
}

function normalizeLootSourceSearchText(value) {
  return String(value ?? "")
    .normalize("NFKD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function tokenizeLootSourceSearchText(value) {
  const normalized = normalizeLootSourceSearchText(value);
  return normalized ? normalized.split(" ") : [];
}

function hasEditDistanceWithin(sourceToken, queryToken, maxDistance = 1) {
  if (sourceToken === queryToken) return true;
  const sourceLength = sourceToken.length;
  const queryLength = queryToken.length;
  if (!sourceLength || !queryLength) return false;
  if (Math.abs(sourceLength - queryLength) > maxDistance) return false;

  let previousRow = Array.from({ length: queryLength + 1 }, (_entry, index) => index);
  for (let rowIndex = 1; rowIndex <= sourceLength; rowIndex += 1) {
    const currentRow = [rowIndex];
    let rowMin = currentRow[0];
    for (let colIndex = 1; colIndex <= queryLength; colIndex += 1) {
      const substitutionCost = sourceToken[rowIndex - 1] === queryToken[colIndex - 1] ? 0 : 1;
      const value = Math.min(
        previousRow[colIndex] + 1,
        currentRow[colIndex - 1] + 1,
        previousRow[colIndex - 1] + substitutionCost
      );
      currentRow[colIndex] = value;
      if (value < rowMin) rowMin = value;
    }
    if (rowMin > maxDistance) return false;
    previousRow = currentRow;
  }
  return previousRow[queryLength] <= maxDistance;
}

function doesLootSourceTokenMatch(queryToken, candidateToken) {
  if (!queryToken || !candidateToken) return false;
  if (candidateToken.includes(queryToken) || queryToken.includes(candidateToken)) return true;

  const queryStem = queryToken.length > 4 && queryToken.endsWith("s") ? queryToken.slice(0, -1) : queryToken;
  const candidateStem = candidateToken.length > 4 && candidateToken.endsWith("s") ? candidateToken.slice(0, -1) : candidateToken;
  if (candidateStem.includes(queryStem) || queryStem.includes(candidateStem)) return true;

  const queryPrefix = queryStem.slice(0, Math.min(4, queryStem.length));
  const candidatePrefix = candidateStem.slice(0, Math.min(4, candidateStem.length));
  if (queryPrefix.length >= 3 && candidateStem.startsWith(queryPrefix)) return true;
  if (candidatePrefix.length >= 3 && queryStem.startsWith(candidatePrefix)) return true;

  const maxDistance = queryStem.length >= 6 ? 2 : 1;
  return hasEditDistanceWithin(candidateStem, queryStem, maxDistance);
}

function matchesLootSourceSearchQuery(query, source = {}) {
  const normalizedQuery = normalizeLootSourceSearchText(query);
  if (!normalizedQuery) return true;
  const queryTokens = tokenizeLootSourceSearchText(normalizedQuery);
  if (queryTokens.length === 0) return true;

  const searchableText = normalizeLootSourceSearchText([
    source.label,
    source.id,
    source.sourceKind,
    source.available ? "available" : "unavailable",
    source.enabled ? "enabled" : "disabled"
  ].join(" "));

  if (!searchableText) return false;
  if (searchableText.includes(normalizedQuery)) return true;

  const searchableTokens = tokenizeLootSourceSearchText(searchableText);
  return queryTokens.every((queryToken) => {
    if (searchableText.includes(queryToken)) return true;
    return searchableTokens.some((candidateToken) => doesLootSourceTokenMatch(queryToken, candidateToken));
  });
}

function buildLootSourceRegistryContext() {
  const config = getLootSourceConfig();
  const availablePacks = getAvailableLootItemPackSources();
  const availableTables = getAvailableLootTableSources();
  const packLookup = new Map((config.packs ?? []).map((entry) => [entry.id, entry]));
  const tableLookup = new Map((config.tables ?? []).map((entry) => [entry.id, entry]));

  const itemPackOptions = availablePacks.map((source) => {
    const stored = packLookup.get(source.id);
    const weightRaw = Number(stored?.weight ?? 1);
    return {
      id: source.id,
      label: source.label,
      sourceKind: source.sourceKind,
      available: true,
      enabled: Boolean(stored?.enabled),
      weight: Number.isFinite(weightRaw) ? Math.max(1, Math.floor(weightRaw)) : 1
    };
  });

  for (const stored of config.packs ?? []) {
    if (itemPackOptions.some((entry) => entry.id === stored.id)) continue;
    const weightRaw = Number(stored?.weight ?? 1);
    itemPackOptions.push({
      id: stored.id,
      label: stored.label || `${stored.id} (Unavailable)`,
      sourceKind: stored.sourceKind,
      available: false,
      enabled: Boolean(stored.enabled),
      weight: Number.isFinite(weightRaw) ? Math.max(1, Math.floor(weightRaw)) : 1
    });
  }

  const tableOptions = availableTables.map((source) => {
    const stored = tableLookup.get(source.id);
    const currentType = String(stored?.tableType ?? "currency");
    return {
      id: source.id,
      label: source.label,
      sourceKind: source.sourceKind,
      available: true,
      enabled: Boolean(stored?.enabled),
      tableType: currentType,
      typeOptions: LOOT_TABLE_TYPE_OPTIONS.map((option) => ({
        value: option.value,
        label: option.label,
        selected: option.value === currentType
      }))
    };
  });

  for (const stored of config.tables ?? []) {
    if (tableOptions.some((entry) => entry.id === stored.id)) continue;
    const currentType = String(stored?.tableType ?? "currency");
    tableOptions.push({
      id: stored.id,
      label: stored.label || `${stored.id} (Unavailable)`,
      sourceKind: stored.sourceKind,
      available: false,
      enabled: Boolean(stored.enabled),
      tableType: currentType,
      typeOptions: LOOT_TABLE_TYPE_OPTIONS.map((option) => ({
        value: option.value,
        label: option.label,
        selected: option.value === currentType
      }))
    });
  }

  itemPackOptions.sort((a, b) => {
    const enabledDelta = Number(Boolean(b.enabled)) - Number(Boolean(a.enabled));
    if (enabledDelta !== 0) return enabledDelta;
    return a.label.localeCompare(b.label);
  });
  tableOptions.sort((a, b) => {
    const enabledDelta = Number(Boolean(b.enabled)) - Number(Boolean(a.enabled));
    if (enabledDelta !== 0) return enabledDelta;
    return a.label.localeCompare(b.label);
  });

  const itemPackUi = getLootPackSourcesUiState();
  const itemPackFilter = normalizeLootPackSourcesFilter(itemPackUi.filter);
  const itemPackVisibleOptions = itemPackOptions.filter((entry) => matchesLootSourceSearchQuery(itemPackFilter, entry));
  const itemPackCollapsed = Boolean(itemPackUi.collapsed);

  const selectedTypes = new Set(config.filters?.allowedTypes ?? []);
  const itemTypeOptions = buildLootItemTypeCatalog().map((entry) => ({
    value: entry.value,
    label: entry.label,
    selected: selectedTypes.has(entry.value)
  }));

  const rarityFloor = normalizeLootRarityValue(config.filters?.rarityFloor);
  const rarityCeiling = normalizeLootRarityValue(config.filters?.rarityCeiling);
  const manifestPackId = String(config.filters?.manifestPackId ?? "").trim();
  const manifestPackOptions = [{ value: "", label: "Any enabled item source", selected: !manifestPackId }]
    .concat(itemPackOptions.map((entry) => ({
      value: entry.id,
      label: entry.label,
      selected: entry.id === manifestPackId
    })));
  const keywordIncludeTagsInput = formatLootKeywordTagListForInput(config.filters?.keywordIncludeTags ?? []);
  const keywordExcludeTagsInput = formatLootKeywordTagListForInput(config.filters?.keywordExcludeTags ?? []);
  const updatedAt = Number(config.updatedAt ?? 0);
  const updatedAtLabel = updatedAt > 0 ? new Date(updatedAt).toLocaleString() : "Not set";
  return {
    itemPackOptions,
    itemPackVisibleOptions,
    itemPackCollapsed,
    itemPackToggleLabel: itemPackCollapsed ? "Expand" : "Collapse",
    itemPackToggleIcon: itemPackCollapsed ? "fa-chevron-down" : "fa-chevron-up",
    itemPackFilter,
    itemPackFilterActive: itemPackFilter.length > 0,
    itemPackVisibleCount: itemPackVisibleOptions.length,
    tableOptions,
    itemTypeOptions,
    rarityFloorOptions: LOOT_RARITY_OPTIONS.map((entry) => ({
      value: entry.value,
      label: entry.label,
      selected: entry.value === rarityFloor
    })),
    rarityCeilingOptions: LOOT_RARITY_OPTIONS.map((entry) => ({
      value: entry.value,
      label: entry.label,
      selected: entry.value === rarityCeiling
    })),
    manifestPackOptions,
    manifestPackId,
    keywordIncludeTagsInput,
    keywordExcludeTagsInput,
    keywordIncludeTagCount: normalizeLootKeywordTagList(config.filters?.keywordIncludeTags ?? []).length,
    keywordExcludeTagCount: normalizeLootKeywordTagList(config.filters?.keywordExcludeTags ?? []).length,
    summary: {
      enabledItemPacks: itemPackOptions.filter((entry) => entry.enabled).length,
      totalItemPacks: itemPackOptions.length,
      enabledTables: tableOptions.filter((entry) => entry.enabled).length,
      totalTables: tableOptions.length,
      enabledItemTypes: itemTypeOptions.filter((entry) => entry.selected).length,
      totalItemTypes: itemTypeOptions.length,
      updatedAtLabel,
      updatedBy: String(config.updatedBy ?? "").trim() || "GM"
    }
  };
}

function getCollectionValues(collectionLike) {
  if (!collectionLike) return [];
  if (Array.isArray(collectionLike)) return collectionLike;
  if (typeof collectionLike.values === "function") return Array.from(collectionLike.values());
  if (Array.isArray(collectionLike.contents)) return collectionLike.contents;
  return [];
}

function logAutoInventoryDebug(message, details = null) {
  if (!isModuleDebugEnabled()) return;
  if (details === null) {
    console.debug(`[${MODULE_ID}][auto-inv] ${message}`);
    return;
  }
  console.debug(`[${MODULE_ID}][auto-inv] ${message}`, details);
}

function normalizeAutoInventoryName(value) {
  return String(value ?? "")
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9\s]+/g, " ")
    .replace(/\s+/g, " ");
}

function parseAutoInventoryCrValue(rawValue) {
  if (rawValue === null || rawValue === undefined) return 0;
  if (typeof rawValue === "number") return Number.isFinite(rawValue) ? Math.max(0, rawValue) : 0;

  const raw = String(rawValue).trim().toLowerCase();
  if (!raw) return 0;
  if (raw.includes("/")) {
    const [leftRaw, rightRaw] = raw.split("/", 2);
    const left = Number(leftRaw);
    const right = Number(rightRaw);
    if (Number.isFinite(left) && Number.isFinite(right) && right !== 0) {
      return Math.max(0, left / right);
    }
  }

  const parsed = Number(raw);
  if (Number.isFinite(parsed)) return Math.max(0, parsed);
  return 0;
}

function getActorCrForAutoInventory(actor) {
  if (!actor) return 0;
  const details = actor.system?.details ?? {};
  const candidates = [
    details?.cr,
    details?.cr?.value,
    details?.challengeRating,
    details?.challenge?.rating
  ];
  for (const candidate of candidates) {
    const parsed = parseAutoInventoryCrValue(candidate);
    if (parsed > 0) return parsed;
  }
  return 0;
}

function normalizeAutoInventoryCreatureType(rawType) {
  const normalized = normalizeAutoInventoryName(rawType);
  if (!normalized) return "unknown";
  const rules = [
    ["humanoid", "humanoid"],
    ["beast", "beast"],
    ["undead", "undead"],
    ["construct", "construct"],
    ["elemental", "elemental"],
    ["ooze", "ooze"],
    ["dragon", "dragon"],
    ["fiend", "fiend"],
    ["celestial", "celestial"],
    ["aberration", "aberration"],
    ["fey", "fey"],
    ["giant", "giant"],
    ["monstrosity", "monstrosity"],
    ["plant", "plant"],
    ["swarm", "swarm"]
  ];
  for (const [needle, value] of rules) {
    if (normalized.includes(needle)) return value;
  }
  return "unknown";
}

function getActorCreatureTypeForAutoInventory(actor) {
  if (!actor) return "unknown";
  const detailsType = actor.system?.details?.type;
  if (detailsType && typeof detailsType === "object") {
    const fromObject = normalizeAutoInventoryCreatureType(
      detailsType?.value
      ?? detailsType?.subtype
      ?? detailsType?.custom
      ?? detailsType?.type
      ?? detailsType?.label
      ?? ""
    );
    if (fromObject !== "unknown") return fromObject;
  }
  const fromDirect = normalizeAutoInventoryCreatureType(detailsType);
  if (fromDirect !== "unknown") return fromDirect;
  return normalizeAutoInventoryCreatureType(actor.system?.details?.race ?? "");
}

function getActorAbilityScore(actor, abilityKey) {
  const key = String(abilityKey ?? "").trim().toLowerCase();
  if (!key) return 0;
  const node = actor?.system?.abilities?.[key];
  const value = Number(node?.value ?? node?.mod ?? 0);
  return Number.isFinite(value) ? value : 0;
}

function actorHasFeatureName(actor, pattern) {
  const regex = pattern instanceof RegExp ? pattern : null;
  if (!regex || !actor?.items) return false;
  for (const item of actor.items) {
    const name = String(item?.name ?? "").trim();
    if (!name) continue;
    if (regex.test(name)) return true;
  }
  return false;
}

function inferRole(actor) {
  if (!actor) return "none";
  const hasSpellItems = actor.items?.some((item) => String(item?.type ?? "").trim().toLowerCase() === "spell") ?? false;
  const spellSlots = actor.system?.spells ?? {};
  const hasSpellSlots = Object.values(spellSlots).some((slot) => {
    const max = Number(slot?.max ?? 0);
    return Number.isFinite(max) && max > 0;
  });
  const hasSpellcastingFeature = actorHasFeatureName(actor, /(spellcasting|innate spellcasting)/i);
  if (hasSpellItems || hasSpellSlots || hasSpellcastingFeature) return "caster";

  if (actorHasFeatureName(actor, /(sneak|stealth|cunning|scout|skirmish)/i)) return "scout";
  if (actorHasFeatureName(actor, /(rage|frenzy|brutal|reckless|berserk)/i)) return "brute";

  const str = getActorAbilityScore(actor, "str");
  const dex = getActorAbilityScore(actor, "dex");
  const con = getActorAbilityScore(actor, "con");
  const int = getActorAbilityScore(actor, "int");
  const wis = getActorAbilityScore(actor, "wis");
  const cha = getActorAbilityScore(actor, "cha");
  const martialTop = Math.max(str, dex);
  const casterTop = Math.max(int, wis, cha);

  if (str >= 16 && con >= 14) return "brute";
  if (dex >= 15 && dex > str + 1) return "scout";
  if (martialTop >= casterTop) return "martial";
  return "none";
}

function isLikelyIntelligentCreature(actor) {
  const intScore = getActorAbilityScore(actor, "int");
  if (intScore >= 8) return true;
  const languages = actor?.system?.traits?.languages;
  const languageValue = String(languages?.value ?? "").trim();
  if (languageValue.length > 0) return true;
  return actorHasFeatureName(actor, /(speak|spellcasting|command|tactics)/i);
}

function getAutoInventoryCrBand(crValue = 0) {
  const cr = Math.max(0, Number(crValue) || 0);
  if (cr <= 1) return "cr-0-1";
  if (cr <= 4) return "cr-2-4";
  if (cr <= 8) return "cr-5-8";
  if (cr <= 12) return "cr-9-12";
  return "cr-13+";
}

function getAutoInventoryChallengeFromCr(crValue = 0) {
  const cr = Math.max(0, Number(crValue) || 0);
  if (cr <= 4) return "low";
  if (cr <= 10) return "mid";
  if (cr <= 16) return "high";
  return "epic";
}

function shiftAutoInventoryCrBand(crBand = "cr-0-1", shift = 0) {
  const current = String(crBand ?? "cr-0-1").trim();
  const currentIndex = UNLINKED_TOKEN_AUTO_INV_BAND_ORDER.indexOf(current);
  const baseIndex = currentIndex >= 0 ? currentIndex : 0;
  const delta = Math.max(-2, Math.min(2, Math.floor(Number(shift) || 0)));
  const targetIndex = Math.max(0, Math.min(UNLINKED_TOKEN_AUTO_INV_BAND_ORDER.length - 1, baseIndex + delta));
  return UNLINKED_TOKEN_AUTO_INV_BAND_ORDER[targetIndex] ?? "cr-0-1";
}

function rollChance(probability = 0) {
  const chance = Math.max(0, Math.min(1, Number(probability) || 0));
  return Math.random() < chance;
}

function autoInventoryPercentSettingToScale(value, fallback = 100) {
  const resolved = Number.isFinite(Number(value)) ? Number(value) : Number(fallback);
  return Math.max(0, Math.min(3, resolved / 100));
}

function scaleAutoInventoryChance(baseChance, scalarPercent = 100) {
  const base = Math.max(0, Math.min(1, Number(baseChance) || 0));
  const scale = autoInventoryPercentSettingToScale(scalarPercent, 100);
  return Math.max(0, Math.min(1, base * scale));
}

function rollIntRange(min, max) {
  const low = Math.ceil(Math.min(min, max));
  const high = Math.floor(Math.max(min, max));
  if (low === high) return low;
  return Math.floor(Math.random() * (high - low + 1)) + low;
}

function pickWeightedEntryName(entries = []) {
  if (!Array.isArray(entries) || entries.length === 0) return "";
  const pool = entries
    .map((entry) => ({
      name: String(entry?.name ?? "").trim(),
      weight: Math.max(0, Number(entry?.weight ?? 0) || 0)
    }))
    .filter((entry) => entry.name.length > 0 && entry.weight > 0);
  if (pool.length === 0) return "";
  const totalWeight = pool.reduce((sum, entry) => sum + entry.weight, 0);
  if (totalWeight <= 0) return pool[0].name;
  let cursor = Math.random() * totalWeight;
  for (const row of pool) {
    cursor -= row.weight;
    if (cursor <= 0) return row.name;
  }
  return pool[pool.length - 1]?.name ?? "";
}

function getDefaultAutoInventoryPackId() {
  const packs = getAllCompendiumPacks();
  const dnd5eItems = packs.find((pack) => {
    const id = String(pack?.collection ?? "").trim();
    const documentName = String(pack?.documentName ?? pack?.metadata?.type ?? "").trim().toLowerCase();
    return documentName === "item" && id === "dnd5e.items";
  });
  if (dnd5eItems) return "dnd5e.items";

  const fallback = packs.find((pack) => String(pack?.documentName ?? pack?.metadata?.type ?? "").trim().toLowerCase() === "item");
  return String(fallback?.collection ?? "").trim();
}

function resolveAutoInventoryPackId(packIdValue) {
  const requested = String(packIdValue ?? "").trim();
  if (requested && game.packs?.get(requested)) return requested;
  const fallback = getDefaultAutoInventoryPackId();
  return fallback || requested;
}

function getAutoInventorySettingsSnapshot() {
  return {
    enabled: Boolean(game.settings.get(MODULE_ID, SETTINGS.AUTO_INV_ENABLED) ?? true),
    currencyEnabled: Boolean(game.settings.get(MODULE_ID, SETTINGS.AUTO_INV_CURRENCY_ENABLED) ?? true),
    weaponPackId: resolveAutoInventoryPackId(game.settings.get(MODULE_ID, SETTINGS.AUTO_INV_WEAPON_PACK)),
    armorPackId: resolveAutoInventoryPackId(game.settings.get(MODULE_ID, SETTINGS.AUTO_INV_ARMOR_PACK)),
    gearPackId: resolveAutoInventoryPackId(game.settings.get(MODULE_ID, SETTINGS.AUTO_INV_GEAR_PACK)),
    consumablesPackId: resolveAutoInventoryPackId(game.settings.get(MODULE_ID, SETTINGS.AUTO_INV_CONSUMABLES_PACK)),
    itemChanceScalar: Number(game.settings.get(MODULE_ID, SETTINGS.AUTO_INV_ITEM_CHANCE_SCALAR) ?? AUTO_INV_DEFAULT_ITEM_CHANCE_SCALAR),
    consumableChanceScalar: Number(game.settings.get(MODULE_ID, SETTINGS.AUTO_INV_CONSUMABLE_CHANCE_SCALAR) ?? AUTO_INV_DEFAULT_CONSUMABLE_CHANCE_SCALAR),
    currencyScalar: Number(game.settings.get(MODULE_ID, SETTINGS.AUTO_INV_CURRENCY_SCALAR) ?? AUTO_INV_DEFAULT_CURRENCY_SCALAR),
    qualityShift: Math.max(-2, Math.min(2, Math.floor(Number(game.settings.get(MODULE_ID, SETTINGS.AUTO_INV_QUALITY_SHIFT) ?? AUTO_INV_DEFAULT_QUALITY_SHIFT) || 0)))
  };
}

function isAutoInventoryArmorIndexRow(row) {
  const type = String(row?.type ?? "").trim().toLowerCase();
  if (type !== "equipment") return false;
  const subtype = String(row?.subtype ?? "").trim().toLowerCase();
  if (["light", "medium", "heavy", "shield"].includes(subtype)) return true;
  const name = normalizeAutoInventoryName(row?.name ?? "");
  return name.includes("armor") || name.includes("mail") || name.includes("plate") || name.includes("shield");
}

function matchesAutoInventoryCategory(row, category = "gear") {
  const normalizedCategory = String(category ?? "gear").trim().toLowerCase();
  const type = String(row?.type ?? "").trim().toLowerCase();
  if (normalizedCategory === "weapon") return type === "weapon";
  if (normalizedCategory === "armor") return isAutoInventoryArmorIndexRow(row);
  if (normalizedCategory === "consumable") return type === "consumable";
  if (normalizedCategory === "gear") {
    if (type === "weapon" || type === "spell") return false;
    if (isAutoInventoryArmorIndexRow(row)) return false;
    return UNLINKED_TOKEN_AUTO_LOOT_ITEM_TYPES.has(type);
  }
  return true;
}

async function getAutoInventoryPackIndexRows(packId) {
  const id = String(packId ?? "").trim();
  if (!id) return [];
  if (autoInventoryPackIndexCache.has(id)) return autoInventoryPackIndexCache.get(id) ?? [];

  const pack = game.packs?.get(id);
  if (!pack) return [];
  try {
    const index = await pack.getIndex({ fields: ["name", "type", "system.type.value"] });
    const rows = getCollectionValues(index)
      .map((entry) => Array.isArray(entry) ? entry[1] : entry)
      .map((entry) => {
        const rowId = String(entry?._id ?? entry?.id ?? "").trim();
        const rowName = String(entry?.name ?? "").trim();
        if (!rowId || !rowName) return null;
        return {
          id: rowId,
          name: rowName,
          type: String(entry?.type ?? "").trim().toLowerCase(),
          subtype: String(foundry.utils.getProperty(entry, "system.type.value") ?? "").trim().toLowerCase(),
          search: normalizeAutoInventoryName(rowName)
        };
      })
      .filter(Boolean);
    autoInventoryPackIndexCache.set(id, rows);
    return rows;
  } catch (error) {
    console.warn(`${MODULE_ID}: failed to read auto-inventory pack index`, { packId: id, error });
    return [];
  }
}

function findAutoInventoryIndexRowByName(indexRows = [], targetName = "", category = "gear") {
  const needle = normalizeAutoInventoryName(targetName);
  if (!needle) return null;
  const categoryRows = (Array.isArray(indexRows) ? indexRows : []).filter((row) => matchesAutoInventoryCategory(row, category));
  const needsEnhancedItem = /\+\s*[123]/i.test(String(targetName ?? ""));
  const nonEnhancedRows = categoryRows.filter((row) => !/\+\s*[123]/i.test(String(row?.name ?? "")));
  const rows = !needsEnhancedItem && nonEnhancedRows.length > 0 ? nonEnhancedRows : categoryRows;
  const exact = rows.find((row) => row.search === needle);
  if (exact) return exact;

  const needleTokens = needle.split(" ").filter(Boolean);
  const startsWith = rows.find((row) => row.search.startsWith(needle));
  if (startsWith) return startsWith;
  const containsTokens = rows.find((row) => needleTokens.every((token) => row.search.includes(token)));
  if (containsTokens) return containsTokens;
  return rows.find((row) => row.search.includes(needle)) ?? null;
}

async function resolveAutoInventoryItemData(packId, itemName, category = "gear") {
  const id = String(packId ?? "").trim();
  if (!id) return null;
  const pack = game.packs?.get(id);
  if (!pack) return null;
  const rows = await getAutoInventoryPackIndexRows(id);
  const match = findAutoInventoryIndexRowByName(rows, itemName, category);
  if (!match) return null;
  try {
    const document = await pack.getDocument(match.id);
    if (!document || document.documentName !== "Item") return null;
    const data = document.toObject();
    if (data && typeof data === "object" && Object.prototype.hasOwnProperty.call(data, "_id")) delete data._id;
    return data;
  } catch (error) {
    console.warn(`${MODULE_ID}: failed loading auto-inventory item`, { packId: id, itemName, error });
    return null;
  }
}

function setAutoInventoryItemQuantity(itemData, quantity = 1) {
  const qty = Math.max(1, Math.floor(Number(quantity) || 1));
  if (!itemData || typeof itemData !== "object") return itemData;
  if (!itemData.system || typeof itemData.system !== "object") itemData.system = {};
  const quantityNode = itemData.system.quantity;
  if (quantityNode && typeof quantityNode === "object") {
    quantityNode.value = qty;
  } else {
    itemData.system.quantity = qty;
  }
  return itemData;
}

async function resolveTokenActorForAutoInventory(tokenDoc) {
  if (!tokenDoc) return null;
  const sleep = foundry.utils?.sleep
    ? (ms) => foundry.utils.sleep(ms)
    : (ms) => new Promise((resolve) => setTimeout(resolve, ms));
  for (let attempt = 0; attempt < 10; attempt += 1) {
    const actor = tokenDoc?.actor ?? tokenDoc?.object?.actor ?? tokenDoc?.getActor?.();
    if (actor?.documentName === "Actor") return actor;
    if (attempt < 9) await sleep(75);
  }
  return null;
}

function isPrimaryActiveGmForAutoInventory() {
  const activeGms = (game.users ?? [])
    .filter((user) => Boolean(user?.active) && Boolean(user?.isGM))
    .sort((left, right) => String(left?.id ?? "").localeCompare(String(right?.id ?? "")));
  if (activeGms.length === 0) return Boolean(canAccessAllPlayerOps());
  return String(activeGms[0]?.id ?? "") === String(game.user?.id ?? "");
}

function actorHasUsableInventory(actor) {
  if (!actor?.items) return false;
  return actor.items.some((item) => UNLINKED_TOKEN_AUTO_LOOT_ITEM_TYPES.has(String(item?.type ?? "").trim().toLowerCase()));
}

function shouldAutoInventoryApplyForCreature(actor, creatureType, role) {
  const type = String(creatureType ?? "unknown");
  if (["construct", "elemental", "ooze"].includes(type)) return false;
  if (type === "beast") return false;
  if (type === "undead") {
    if (!isLikelyIntelligentCreature(actor) && role === "none") return false;
  }
  return true;
}

function buildAutoInventoryTypeWeights(creatureType, role) {
  const type = String(creatureType ?? "unknown").trim().toLowerCase();
  const roleValue = String(role ?? "none").trim().toLowerCase();
  const base = {
    ...(UNLINKED_TOKEN_AUTO_LOOT_TYPE_WEIGHTS.default ?? {})
  };
  const creatureWeights = UNLINKED_TOKEN_AUTO_LOOT_TYPE_WEIGHTS[type] ?? {};
  const merged = { ...base, ...creatureWeights };
  if (roleValue === "caster") {
    merged.weapon = Math.max(0, Number(merged.weapon ?? 1) * 0.72);
    merged.consumable = Math.max(0, Number(merged.consumable ?? 1) * 1.35);
    merged.tool = Math.max(0, Number(merged.tool ?? 1) * 1.2);
  } else if (roleValue === "scout") {
    merged.weapon = Math.max(0, Number(merged.weapon ?? 1) * 1.1);
    merged.armor = Math.max(0, Number(merged.armor ?? 1) * 0.75);
    merged.consumable = Math.max(0, Number(merged.consumable ?? 1) * 1.2);
  } else if (roleValue === "brute") {
    merged.weapon = Math.max(0, Number(merged.weapon ?? 1) * 1.2);
    merged.armor = Math.max(0, Number(merged.armor ?? 1) * 1.25);
    merged.consumable = Math.max(0, Number(merged.consumable ?? 1) * 0.8);
  }
  merged.default = Math.max(0.01, Number(merged.default ?? 1) || 1);
  return merged;
}

function getLootBuilderItemTypeWeight(draft = {}, itemType = "") {
  const normalizedType = String(itemType ?? "").trim().toLowerCase();
  const map = (draft?.itemTypeWeights && typeof draft.itemTypeWeights === "object" && !Array.isArray(draft.itemTypeWeights))
    ? draft.itemTypeWeights
    : null;
  if (!map || !normalizedType) return 1;
  const raw = Number(map[normalizedType] ?? map.default ?? 1);
  if (!Number.isFinite(raw)) return 1;
  return Math.max(0, raw);
}

function buildAutoInventoryCurrencyBundle(crBand = "cr-0-1", scalarPercent = 100) {
  const table = {
    "cr-0-1": () => ({ gp: rollIntRange(0, 4), sp: rollIntRange(1, 10), cp: rollIntRange(0, 20) }),
    "cr-2-4": () => ({ gp: rollIntRange(2, 12), sp: rollIntRange(2, 18), cp: rollIntRange(0, 15) }),
    "cr-5-8": () => ({ gp: rollIntRange(8, 35), sp: rollIntRange(0, 20), cp: rollIntRange(0, 10) }),
    "cr-9-12": () => ({ pp: rollIntRange(0, 4), gp: rollIntRange(18, 65), sp: rollIntRange(0, 12), cp: 0 }),
    "cr-13+": () => ({ pp: rollIntRange(2, 12), gp: rollIntRange(45, 180), sp: rollIntRange(0, 10), cp: 0 })
  };
  const rolled = (table[crBand] ?? table["cr-0-1"])();
  const scale = autoInventoryPercentSettingToScale(scalarPercent, AUTO_INV_DEFAULT_CURRENCY_SCALAR);
  const apply = (value) => Math.max(0, Math.floor((Number(value) || 0) * scale));
  return {
    pp: apply(rolled.pp),
    gp: apply(rolled.gp),
    sp: apply(rolled.sp),
    cp: apply(rolled.cp)
  };
}

function buildAutoInventoryDraftForActor(actor, crValue, creatureType, role) {
  const cr = Math.max(0, Number(crValue) || 0);
  const challenge = getAutoInventoryChallengeFromCr(cr);
  const scale = cr >= 13 ? "major" : cr >= 6 ? "medium" : "small";
  const type = String(creatureType ?? "unknown").trim().toLowerCase();
  const roleValue = String(role ?? "none").trim().toLowerCase();

  let profile = "standard";
  if (["beast", "ooze", "plant", "construct", "elemental"].includes(type)) profile = "poor";
  if (["dragon", "fiend", "celestial"].includes(type) || roleValue === "caster") profile = "well";

  let itemScalar = cr >= 13 ? 135 : cr >= 9 ? 120 : cr >= 5 ? 105 : 88;
  let valueBudgetScalar = cr >= 13 ? 145 : cr >= 9 ? 120 : cr >= 5 ? 102 : 78;
  let valueStrictness = cr <= 1 ? 255 : cr <= 4 ? 235 : cr <= 8 ? 205 : cr <= 12 ? 180 : 150;

  if (roleValue === "caster") {
    itemScalar += 6;
    valueBudgetScalar += 8;
    valueStrictness -= 10;
  }
  if (roleValue === "brute") {
    itemScalar += 6;
    valueBudgetScalar += 4;
  }
  if (["beast", "ooze", "plant", "elemental", "construct"].includes(type)) {
    itemScalar = Math.max(60, itemScalar - 25);
    valueBudgetScalar = Math.max(45, valueBudgetScalar - 22);
    valueStrictness = Math.min(300, valueStrictness + 22);
  }

  const baseMaxItemValue = (() => {
    if (cr <= 0.125) return 30;
    if (cr <= 0.5) return 55;
    if (cr <= 1) return 90;
    if (cr <= 2) return 160;
    if (cr <= 4) return 280;
    if (cr <= 6) return 500;
    if (cr <= 8) return 750;
    if (cr <= 10) return 1000;
    if (cr <= 12) return 1600;
    if (cr <= 16) return 3000;
    return 8500;
  })();

  const maxItemValueGp = (() => {
    if (["dragon", "fiend", "celestial"].includes(type)) return Math.floor(baseMaxItemValue * 1.2);
    if (["beast", "ooze", "plant", "construct", "elemental"].includes(type)) return Math.floor(baseMaxItemValue * 0.65);
    return baseMaxItemValue;
  })();

  return {
    mode: "encounter",
    profile,
    challenge,
    scale,
    creatures: 1,
    actorCount: 1,
    currencyScalar: 100,
    itemScalar: Math.max(25, Math.min(300, Math.floor(itemScalar))),
    tableScalar: 25,
    valueBudgetScalar: Math.max(25, Math.min(300, Math.floor(valueBudgetScalar))),
    valueStrictness: Math.max(50, Math.min(300, Math.floor(valueStrictness))),
    maxItemValueGp: Math.max(0, Math.min(LOOT_PREVIEW_MAX_ITEM_VALUE_GP_LIMIT, Math.floor(maxItemValueGp))),
    itemTypeWeights: buildAutoInventoryTypeWeights(creatureType, role)
  };
}

async function buildAutoInventorySelectionPlan(actor, settings, context) {
  const plan = [];
  const existingNames = new Set((actor.items ?? []).map((item) => normalizeAutoInventoryName(item?.name ?? "")).filter(Boolean));
  const selectedNames = new Set();
  const crBand = context.crBand;
  const qualityBand = shiftAutoInventoryCrBand(crBand, settings?.qualityShift ?? AUTO_INV_DEFAULT_QUALITY_SHIFT);
  const creatureType = context.creatureType;
  const role = context.role;
  const itemChanceScalar = Number(settings?.itemChanceScalar ?? AUTO_INV_DEFAULT_ITEM_CHANCE_SCALAR);
  const consumableChanceScalar = Number(settings?.consumableChanceScalar ?? AUTO_INV_DEFAULT_CONSUMABLE_CHANCE_SCALAR);
  const rollItemChance = (baseChance) => rollChance(scaleAutoInventoryChance(baseChance, itemChanceScalar));
  const rollConsumableChance = (baseChance) => rollChance(scaleAutoInventoryChance(baseChance, consumableChanceScalar));
  const isHumanoidLike = ["humanoid", "fey", "giant", "fiend", "celestial", "monstrosity"].includes(creatureType)
    || (creatureType === "undead" && context.intelligent);

  const addPick = (packId, category, weightedChoices, quantity = 1) => {
    const targetName = pickWeightedEntryName(weightedChoices);
    if (!targetName) return;
    const normalized = normalizeAutoInventoryName(targetName);
    if (!normalized || existingNames.has(normalized) || selectedNames.has(normalized)) return;
    selectedNames.add(normalized);
    plan.push({ packId, category, name: targetName, quantity: Math.max(1, Math.floor(Number(quantity) || 1)) });
  };

  if (isHumanoidLike) {
    addPick(settings.weaponPackId, "weapon", UNLINKED_TOKEN_AUTO_INV_CURATED.weapon[qualityBand] ?? []);

    const armorChanceByBand = {
      "cr-0-1": role === "caster" ? 0.25 : 0.45,
      "cr-2-4": role === "caster" ? 0.42 : 0.62,
      "cr-5-8": role === "caster" ? 0.56 : 0.76,
      "cr-9-12": role === "caster" ? 0.62 : 0.82,
      "cr-13+": role === "caster" ? 0.68 : 0.86
    };
    if (rollItemChance(Number(armorChanceByBand[crBand] ?? 0.6))) {
      addPick(settings.armorPackId, "armor", UNLINKED_TOKEN_AUTO_INV_CURATED.armor[qualityBand] ?? []);
    }

    if (["cr-5-8", "cr-9-12", "cr-13+"].includes(crBand) && (role === "martial" || role === "brute") && rollItemChance(0.35)) {
      addPick(settings.armorPackId, "armor", [{ name: "Shield", weight: 100 }], 1);
    }

    if (rollItemChance(0.65)) addPick(settings.gearPackId, "gear", [{ name: "Rations", weight: 100 }], rollIntRange(1, 3));
    if (rollItemChance(0.7)) addPick(settings.gearPackId, "gear", [{ name: "Waterskin", weight: 100 }], 1);
    if (rollItemChance(0.6)) addPick(settings.gearPackId, "gear", [{ name: "Torch", weight: 100 }], rollIntRange(1, 4));
    if (rollItemChance(0.35)) addPick(settings.gearPackId, "gear", [{ name: "Lantern, Hooded", weight: 100 }], 1);
    if (rollItemChance(0.45)) addPick(settings.gearPackId, "gear", [{ name: "Rope, Hempen (50 feet)", weight: 100 }], 1);

    const healChance = Number(UNLINKED_TOKEN_AUTO_INV_HEALING_CHANCE_BY_BAND[crBand] ?? 0.1);
    if (rollConsumableChance(healChance)) {
      addPick(settings.consumablesPackId, "consumable", UNLINKED_TOKEN_AUTO_INV_CURATED.healingByBand[qualityBand] ?? [], 1);
    }

    const utilityChance = crBand === "cr-0-1" ? 0.05 : crBand === "cr-2-4" ? 0.1 : crBand === "cr-5-8" ? 0.18 : 0.24;
    if (rollConsumableChance(utilityChance)) {
      addPick(settings.consumablesPackId, "consumable", UNLINKED_TOKEN_AUTO_INV_CURATED.utilityConsumables ?? [], 1);
    }
  } else if (creatureType === "undead" && context.intelligent) {
    if (rollItemChance(0.55)) addPick(settings.weaponPackId, "weapon", UNLINKED_TOKEN_AUTO_INV_CURATED.weapon[qualityBand] ?? []);
    if (rollItemChance(0.25)) addPick(settings.armorPackId, "armor", UNLINKED_TOKEN_AUTO_INV_CURATED.armor[qualityBand] ?? []);
  }

  return plan;
}

async function resolveAutoInventoryPlanToItemData(plan = []) {
  const merged = new Map();
  for (const entry of Array.isArray(plan) ? plan : []) {
    const packId = String(entry?.packId ?? "").trim();
    const category = String(entry?.category ?? "gear").trim().toLowerCase();
    const name = String(entry?.name ?? "").trim();
    const quantity = Math.max(1, Math.floor(Number(entry?.quantity ?? 1) || 1));
    if (!packId || !name) continue;
    const key = `${packId}::${normalizeAutoInventoryName(name)}::${category}`;
    if (!merged.has(key)) merged.set(key, { packId, category, name, quantity });
    else merged.get(key).quantity += quantity;
  }

  const itemDataRows = [];
  for (const entry of merged.values()) {
    const itemData = await resolveAutoInventoryItemData(entry.packId, entry.name, entry.category);
    if (!itemData) continue;
    setAutoInventoryItemQuantity(itemData, entry.quantity);
    itemDataRows.push(itemData);
  }
  return itemDataRows;
}

async function applyAutoInventoryToUnlinkedToken(tokenDoc, options = {}, userId = null) {
  if (!canAccessAllPlayerOps()) return;
  if (!isPrimaryActiveGmForAutoInventory()) return;
  const settings = getAutoInventorySettingsSnapshot();
  if (!settings.enabled) return;

  const actorLinkState = tokenDoc?.actorLink ?? tokenDoc?.document?.actorLink ?? tokenDoc?._source?.actorLink;
  const isLinkedToken = actorLinkState === true;
  if (isLinkedToken) return;
  const alreadyApplied = Boolean(tokenDoc?.getFlag?.(MODULE_ID, "autoInvApplied"));
  if (alreadyApplied) return;

  const actor = await resolveTokenActorForAutoInventory(tokenDoc);
  if (!actor || actor.documentName !== "Actor" || !actor.isToken) {
    logAutoInventoryDebug("skipped: synthetic token actor not available", {
      tokenId: tokenDoc?.id,
      actorId: tokenDoc?.actorId
    });
    return;
  }
  if (String(actor.type ?? "").trim().toLowerCase() !== "npc") {
    await tokenDoc.setFlag(MODULE_ID, "autoInvApplied", true);
    return;
  }

  if (actorHasUsableInventory(actor)) {
    logAutoInventoryDebug("skipped: token actor already has usable inventory", { actor: actor.name, tokenId: tokenDoc.id });
    await tokenDoc.setFlag(MODULE_ID, "autoInvApplied", true);
    return;
  }

  const crValue = getActorCrForAutoInventory(actor);
  const creatureType = getActorCreatureTypeForAutoInventory(actor);
  const role = inferRole(actor);
  const intelligent = isLikelyIntelligentCreature(actor);
  const shouldApply = shouldAutoInventoryApplyForCreature(actor, creatureType, role);

  if (!shouldApply) {
    logAutoInventoryDebug("skipped: creature type does not receive auto inventory", {
      actor: actor.name,
      creatureType,
      role,
      crValue
    });
    await tokenDoc.setFlag(MODULE_ID, "autoInvApplied", true);
    return;
  }

  const crBand = getAutoInventoryCrBand(crValue);
  const draft = buildAutoInventoryDraftForActor(actor, crValue, creatureType, role);
  const plan = await buildAutoInventorySelectionPlan(actor, settings, {
    crValue,
    crBand,
    creatureType,
    role,
    intelligent,
    draft
  });
  const itemData = await resolveAutoInventoryPlanToItemData(plan);

  if (itemData.length > 0) {
    try {
      await actor.createEmbeddedDocuments("Item", itemData);
    } catch (error) {
      console.warn(`${MODULE_ID}: failed applying auto inventory to token actor`, {
        actor: actor.name,
        tokenId: tokenDoc.id,
        error
      });
    }
  }

  if (settings.currencyEnabled && (creatureType === "humanoid" || (creatureType === "undead" && intelligent))) {
    try {
      const currency = buildAutoInventoryCurrencyBundle(crBand, settings.currencyScalar);
      await awardCurrencyBundleToActor(actor, currency);
    } catch (error) {
      console.warn(`${MODULE_ID}: failed applying auto inventory currency`, {
        actor: actor.name,
        tokenId: tokenDoc.id,
        error
      });
    }
  }

  await tokenDoc.setFlag(MODULE_ID, "autoInvApplied", true);
  logAutoInventoryDebug("auto inventory applied", {
    actor: actor.name,
    tokenId: tokenDoc.id,
    crValue,
    crBand,
    creatureType,
    role,
    itemsApplied: itemData.map((entry) => entry.name).filter(Boolean)
  });
}

function normalizeLootRarity(value) {
  const raw = String(value ?? "").trim().toLowerCase();
  if (!raw) return "";
  if (["artifact", "artifacts", "artefact", "artefacts", "superrare", "super-rare", "super rare"].includes(raw)) return "very-rare";
  if (["veryrare", "very rare", "very_rare", "very-rare"].includes(raw)) return "very-rare";
  if (["legend", "legendary"].includes(raw)) return "legendary";
  if (["rare"].includes(raw)) return "rare";
  if (["uncommon"].includes(raw)) return "uncommon";
  if (["common"].includes(raw)) return "common";
  return "";
}

function getLootRarityFromData(data = {}) {
  const candidates = [
    data?.rarity,
    data?.system?.rarity,
    data?.system?.details?.rarity,
    data?.system?.traits?.rarity,
    data?.system?.properties?.rarity
  ];
  for (const candidate of candidates) {
    if (candidate === null || candidate === undefined) continue;
    if (typeof candidate === "object") {
      const nested = normalizeLootRarity(candidate.value ?? candidate.label ?? candidate.name ?? "");
      if (nested) return nested;
      continue;
    }
    const normalized = normalizeLootRarity(candidate);
    if (normalized) return normalized;
  }
  return "";
}

function getLootKeywordsFromData(data = {}) {
  const keywordCandidates = [
    data?.flags?.[MODULE_ID]?.keywords,
    data?.flags?.["party-operations"]?.keywords
  ];
  for (const candidate of keywordCandidates) {
    const normalized = normalizeLootKeywordTagList(candidate ?? []);
    if (normalized.length > 0) return normalized;
  }
  return [];
}

function isLootKeywordMatch(itemKeywords = [], includeTags = [], excludeTags = []) {
  const keywords = new Set(normalizeLootKeywordTagList(itemKeywords));
  const include = normalizeLootKeywordTagList(includeTags);
  const exclude = normalizeLootKeywordTagList(excludeTags);
  if (include.some((tag) => !keywords.has(tag))) return false;
  if (exclude.some((tag) => keywords.has(tag))) return false;
  return true;
}

function isLootRarityAllowed(rarity, floor, ceiling) {
  const rankMap = {
    common: 1,
    uncommon: 2,
    rare: 3,
    "very-rare": 4,
    legendary: 5
  };
  const normalized = normalizeLootRarity(rarity);
  if (!normalized) return true;
  const value = Number(rankMap[normalized] ?? 0);
  if (!value) return true;
  const floorValue = Number(rankMap[normalizeLootRarity(floor)] ?? 0);
  const ceilingValue = Number(rankMap[normalizeLootRarity(ceiling)] ?? 0);
  if (floorValue > 0 && value < floorValue) return false;
  if (ceilingValue > 0 && value > ceilingValue) return false;
  return true;
}

async function loadItemsFromPack(packId, options = {}) {
  const resolvedPackId = String(packId ?? "").trim();
  if (!resolvedPackId) return [];
  const pack = game.packs?.get(resolvedPackId);
  if (!pack) {
    if (Array.isArray(options.warnings)) {
      options.warnings.push(`Item source missing: ${String(options.sourceLabel ?? resolvedPackId)}.`);
    }
    if (isModuleDebugEnabled()) {
      console.warn(`${MODULE_ID}: loadItemsFromPack missing pack`, { packId: resolvedPackId });
    }
    return [];
  }

  try {
    if (typeof pack.getDocuments === "function") {
      const docs = await pack.getDocuments();
      return Array.isArray(docs) ? docs : [];
    }
    const index = await pack.getIndex({
      fields: ["type", "name", "img", "system.description.value", "system.rarity", "system.details.rarity", "system.traits.rarity", "rarity", "flags.party-operations.keywords", "flags"]
    });
    return getCollectionValues(index);
  } catch (error) {
    if (Array.isArray(options.warnings)) {
      options.warnings.push(`Could not read item source: ${String(options.sourceLabel ?? resolvedPackId)}.`);
    }
    if (isModuleDebugEnabled()) {
      console.warn(`${MODULE_ID}: loadItemsFromPack failed`, { packId: resolvedPackId, error });
    }
    return [];
  }
}

function filterItems(items, options = {}) {
  const rows = Array.isArray(items) ? items : [];
  const typeWhitelist = Array.isArray(options?.typeWhitelist)
    ? options.typeWhitelist.map((entry) => String(entry ?? "").trim()).filter(Boolean)
    : [];
  const nameIncludes = Array.isArray(options?.nameIncludes)
    ? options.nameIncludes.map((entry) => String(entry ?? "").trim().toLowerCase()).filter(Boolean)
    : [];
  const rarityKeywords = Array.isArray(options?.rarityKeywords)
    ? options.rarityKeywords.map((entry) => String(entry ?? "").trim().toLowerCase()).filter(Boolean)
    : [];

  return rows.filter((item) => {
    const data = (item && typeof item?.toObject === "function") ? item.toObject() : item;
    const itemType = String(data?.type ?? "").trim();
    const itemName = String(data?.name ?? "").trim().toLowerCase();
    const description = String(data?.system?.description?.value ?? "")
      .replace(/<[^>]+>/g, " ")
      .replace(/\s+/g, " ")
      .trim()
      .toLowerCase();

    if (typeWhitelist.length > 0 && !typeWhitelist.includes(itemType)) return false;
    if (nameIncludes.length > 0 && !nameIncludes.some((term) => itemName.includes(term))) return false;
    if (rarityKeywords.length > 0 && !rarityKeywords.some((term) => itemName.includes(term) || description.includes(term))) return false;
    return true;
  });
}

function buildWeightedPool(items, weightFn) {
  const rows = Array.isArray(items) ? items : [];
  const compute = typeof weightFn === "function" ? weightFn : ((entry) => Number(entry?.weight ?? 1));
  const pool = [];
  for (const item of rows) {
    const raw = Number(compute(item));
    const weight = Number.isFinite(raw) ? Math.max(0, raw) : 0;
    if (weight <= 0) continue;
    pool.push({ item, weight });
  }
  return pool;
}

function getLootItemGpValueFromData(data = {}) {
  const toNumber = (value) => {
    const parsed = Number(value);
    if (!Number.isFinite(parsed)) return 0;
    return Math.max(0, parsed);
  };
  const priceNode = data?.system?.price;
  if (priceNode && typeof priceNode === "object") {
    const amount = toNumber(priceNode.value ?? priceNode.amount ?? 0);
    const denomRaw = String(priceNode.denomination ?? priceNode.currency ?? "gp").trim().toLowerCase();
    const denomMap = { pp: 10, gp: 1, ep: 0.5, sp: 0.1, cp: 0.01 };
    const mult = Number(denomMap[denomRaw] ?? 1);
    return Math.max(0, amount * mult);
  }
  if (priceNode !== null && priceNode !== undefined) return toNumber(priceNode);
  if (data?.price && typeof data.price === "object") {
    const amount = toNumber(data.price.value ?? data.price.amount ?? 0);
    const denomRaw = String(data.price.denomination ?? data.price.currency ?? "gp").trim().toLowerCase();
    const denomMap = { pp: 10, gp: 1, ep: 0.5, sp: 0.1, cp: 0.01 };
    const mult = Number(denomMap[denomRaw] ?? 1);
    return Math.max(0, amount * mult);
  }
  return toNumber(data?.price ?? 0);
}

function summarizeLootCandidateValueStats(candidates = []) {
  const values = (Array.isArray(candidates) ? candidates : [])
    .map((entry) => Math.max(0, Number(entry?.itemValueGp ?? 0) || 0))
    .filter((value) => value > 0)
    .sort((a, b) => a - b);
  if (!values.length) {
    return {
      hasValues: false,
      targetValuePerItem: 0,
      spread: 1
    };
  }
  const middleIndex = Math.floor(values.length / 2);
  const median = values.length % 2 === 0
    ? (values[middleIndex - 1] + values[middleIndex]) / 2
    : values[middleIndex];
  const minValue = values[0];
  const maxValue = values[values.length - 1];
  const spread = Math.max(1, ((maxValue - minValue) * 0.6) + 1);
  return {
    hasValues: true,
    targetValuePerItem: Math.max(0.01, Number(median) || 0.01),
    spread
  };
}

function logLootBuilderDebug(message, details = null) {
  if (!isModuleDebugEnabled()) return;
  if (details === null) {
    console.debug(`[${MODULE_ID}][loot-builder] ${message}`);
    return;
  }
  console.debug(`[${MODULE_ID}][loot-builder] ${message}`, details);
}

function getLootBuilderErrorSummary(error) {
  if (!error) return { message: "Unknown error" };
  const message = String(error?.message ?? error ?? "Unknown error");
  const name = String(error?.name ?? "Error");
  const stack = String(error?.stack ?? "").trim();
  const stackTop = stack.split("\n").map((line) => line.trim()).filter(Boolean).slice(0, 4);
  return { name, message, stackTop };
}

function logLootBuilderFailure(functionName = "unknown", error = null, context = null) {
  const errorSummary = getLootBuilderErrorSummary(error);
  if (context && typeof context === "object") {
    console.error(`${MODULE_ID}: loot-builder failure in ${functionName}`, {
      functionName,
      ...errorSummary,
      context
    });
  } else {
    console.error(`${MODULE_ID}: loot-builder failure in ${functionName}`, {
      functionName,
      ...errorSummary
    });
  }
}

function normalizeLootSeedInput(value) {
  return String(value ?? "").trim();
}

function shouldUseDeterministicLootRng(input = {}) {
  if (input?.deterministic === true) return true;
  if (input?.deterministic === false) return false;
  const explicitSeed = normalizeLootSeedInput(input?.seed ?? "");
  if (explicitSeed) return true;
  const explicitDateBucket = normalizeLootSeedInput(input?.dateBucket ?? "");
  if (explicitDateBucket) return true;
  return false;
}

function hashLootSeedToUint32(seedInput = "") {
  const seed = normalizeLootSeedInput(seedInput);
  let hash = 0x811c9dc5;
  for (let index = 0; index < seed.length; index += 1) {
    hash ^= seed.charCodeAt(index);
    hash = Math.imul(hash, 0x01000193);
  }
  return hash >>> 0;
}

function createLootSeededRandom(seedInput = "") {
  let state = hashLootSeedToUint32(seedInput);
  if (!state) state = 0x9e3779b9;
  return () => {
    state += 0x6d2b79f5;
    let value = state;
    value = Math.imul(value ^ (value >>> 15), value | 1);
    value ^= value + Math.imul(value ^ (value >>> 7), value | 61);
    return ((value ^ (value >>> 14)) >>> 0) / 4294967296;
  };
}

function resolveTargetGP(draft = {}) {
  try {
    const mode = String(draft?.mode ?? "horde").trim().toLowerCase();
    const challenge = String(draft?.challenge ?? "mid").trim().toLowerCase();
    const profile = String(draft?.profile ?? "standard").trim().toLowerCase();
    const scale = String(draft?.scale ?? "medium").trim().toLowerCase();
    const budgetScalarRaw = Number(draft?.valueBudgetScalar ?? LOOT_PREVIEW_DEFAULT_VALUE_BUDGET_SCALAR);
    const manualTotalTargetRaw = Number(draft?.targetItemsValueGp ?? 0);
    const budgetScalar = Number.isFinite(budgetScalarRaw)
      ? Math.max(0.25, Math.min(3, budgetScalarRaw / 100))
      : (LOOT_PREVIEW_DEFAULT_VALUE_BUDGET_SCALAR / 100);
    const manualTotalTargetGp = Number.isFinite(manualTotalTargetRaw)
      ? Math.max(0, Math.min(LOOT_PREVIEW_MAX_TOTAL_TARGET_VALUE_GP_LIMIT, Math.floor(manualTotalTargetRaw)))
      : 0;

    const baseTargetTable = {
      defeated: { low: 24, mid: 90, high: 320, epic: 980 },
      encounter: { low: 45, mid: 180, high: 700, epic: 2200 },
      horde: { low: 90, mid: 340, high: 1250, epic: 3800 }
    };
    const modeKey = (mode === "defeated" || mode === "encounter" || mode === "horde") ? mode : "horde";
    const byMode = baseTargetTable[modeKey] ?? baseTargetTable.horde;
    const base = Math.max(1, Number(byMode[challenge] ?? byMode.mid) || byMode.mid);
    const profileMultiplier = profile === "poor" ? 0.68 : profile === "well" ? 1.32 : 1;
    const scaleMultiplier = getLootScaleMultiplier(scale);
    const autoTotalTargetGp = Math.max(
      1,
      Number((base * profileMultiplier * scaleMultiplier * budgetScalar).toFixed(2))
    );
    const effectiveTotalTargetGp = manualTotalTargetGp > 0 ? manualTotalTargetGp : autoTotalTargetGp;
    return {
      mode: modeKey,
      challenge,
      profile,
      scale,
      budgetScalar,
      autoTotalTargetGp,
      manualTotalTargetGp,
      effectiveTotalTargetGp,
      usingManualTotalTarget: manualTotalTargetGp > 0
    };
  } catch (error) {
    logLootBuilderFailure("resolveTargetGP", error, {
      mode: draft?.mode,
      challenge: draft?.challenge,
      profile: draft?.profile,
      scale: draft?.scale,
      valueBudgetScalar: draft?.valueBudgetScalar,
      targetItemsValueGp: draft?.targetItemsValueGp
    });
    return {
      mode: "horde",
      challenge: "mid",
      profile: "standard",
      scale: "medium",
      budgetScalar: 1,
      autoTotalTargetGp: 1,
      manualTotalTargetGp: 0,
      effectiveTotalTargetGp: 1,
      usingManualTotalTarget: false
    };
  }
}

function resolveTolerance(encounterTargetGp = 0, strictnessInput = LOOT_PREVIEW_DEFAULT_VALUE_STRICTNESS) {
  try {
    const strictnessRaw = Number(strictnessInput);
    const strictness = Number.isFinite(strictnessRaw)
      ? Math.max(50, Math.min(300, Math.round(strictnessRaw)))
      : LOOT_PREVIEW_DEFAULT_VALUE_STRICTNESS;
    const band = LOOT_PREVIEW_STRICTNESS_BANDS.find((row) => strictness >= row.min)
      ?? LOOT_PREVIEW_STRICTNESS_BANDS[LOOT_PREVIEW_STRICTNESS_BANDS.length - 1];
    const target = Math.max(1, Number(encounterTargetGp) || 1);
    const toleranceGp = Math.max(1, Number((target * Number(band.ratio ?? 0.2)).toFixed(2)));
    const minGp = Math.max(0, Number((target - toleranceGp).toFixed(2)));
    const maxGp = Math.max(minGp, Number((target + toleranceGp).toFixed(2)));
    return {
      strictness,
      bandKey: String(band?.key ?? "normal"),
      bandLabel: String(band?.label ?? "Normal"),
      ratio: Math.max(0.01, Number(band?.ratio ?? 0.2) || 0.2),
      percent: Math.max(1, Math.round((Number(band?.ratio ?? 0.2) || 0.2) * 100)),
      toleranceGp,
      minGp,
      maxGp
    };
  } catch (error) {
    logLootBuilderFailure("resolveTolerance", error, {
      encounterTargetGp,
      strictnessInput
    });
    return {
      strictness: LOOT_PREVIEW_DEFAULT_VALUE_STRICTNESS,
      bandKey: "normal",
      bandLabel: "Normal",
      ratio: 0.2,
      percent: 20,
      toleranceGp: 1,
      minGp: 0,
      maxGp: Math.max(1, Number(encounterTargetGp) || 1)
    };
  }
}

function resolveDesiredItemCount(draft = {}, encounterTargetGp = 0, targetCountOverride = 0) {
  try {
    const manualTargetCount = Math.max(0, Math.floor(Number(targetCountOverride) || 0));
    if (manualTargetCount > 0) return manualTargetCount;

    const mode = String(draft?.mode ?? "horde").trim().toLowerCase();
    const challenge = String(draft?.challenge ?? "mid").trim().toLowerCase();
    const profile = String(draft?.profile ?? "standard").trim().toLowerCase();
    const scale = String(draft?.scale ?? "medium").trim().toLowerCase();
    const creatures = Math.max(1, Number(draft?.creatures ?? draft?.actorCount ?? 1) || 1);
    const itemScale = Math.max(0.5, Math.min(2.5, Number(draft?.itemScalar ?? 100) / 100));
    const scaleModifier = scale === "small" ? 0.9 : scale === "major" ? 1.2 : 1;
    const profileModifier = profile === "poor" ? 0.88 : profile === "well" ? 1.12 : 1;
    const challengeBonus = challenge === "low" ? 0 : challenge === "mid" ? 1 : challenge === "high" ? 2 : 3;

    if (mode === "encounter") {
      const baseItems = Math.max(1, Math.min(8, Math.round(creatures * 0.6)));
      const adjusted = Math.round((baseItems + challengeBonus) * scaleModifier * profileModifier * itemScale);
      const budgetSafetyCap = Math.max(1, Math.round(Math.max(1, Number(encounterTargetGp) || 1) / 15));
      return Math.max(1, Math.min(24, Math.max(1, Math.min(adjusted, budgetSafetyCap))));
    }

    if (mode === "defeated") {
      const base = challenge === "low" ? 0 : challenge === "mid" ? 1 : challenge === "high" ? 2 : 3;
      return Math.max(0, Math.min(16, Math.round(base * scaleModifier * profileModifier * itemScale)));
    }

    const base = challenge === "low" ? 3 : challenge === "mid" ? 5 : challenge === "high" ? 8 : 12;
    const adjusted = Math.round(base * scaleModifier * profileModifier * itemScale);
    return Math.max(1, Math.min(60, adjusted));
  } catch (error) {
    logLootBuilderFailure("resolveDesiredItemCount", error, {
      mode: draft?.mode,
      challenge: draft?.challenge,
      profile: draft?.profile,
      scale: draft?.scale,
      creatures: draft?.creatures ?? draft?.actorCount,
      encounterTargetGp,
      targetCountOverride
    });
    return 1;
  }
}

function resolveLootSelectionSeed(draft = {}, budgetContext = {}) {
  const explicitSeed = normalizeLootSeedInput(draft?.seed ?? "");
  if (explicitSeed) return explicitSeed;
  const dateBucket = normalizeLootSeedInput(draft?.dateBucket ?? "");
  const parts = [
    String(draft?.mode ?? "horde"),
    String(draft?.profile ?? "standard"),
    String(draft?.challenge ?? "mid"),
    String(draft?.scale ?? "medium"),
    String(draft?.valueBudgetScalar ?? LOOT_PREVIEW_DEFAULT_VALUE_BUDGET_SCALAR),
    String(draft?.valueStrictness ?? LOOT_PREVIEW_DEFAULT_VALUE_STRICTNESS),
    String(draft?.itemScalar ?? 100),
    String(draft?.tableScalar ?? 100),
    String(draft?.currencyScalar ?? 100),
    String(draft?.targetItemsValueGp ?? 0),
    String(draft?.maxItemValueGp ?? 0),
    String(draft?.creatures ?? draft?.actorCount ?? 1),
    String(budgetContext?.effectiveTotalTargetGp ?? 0)
  ];
  if (dateBucket) parts.push(dateBucket);
  return parts.join("|");
}

function buildLootRandomContext(draft = {}, budgetContext = {}) {
  try {
    const deterministic = Boolean(draft?.deterministic);
    if (!deterministic) return { deterministic: false, seed: "", random: Math.random };
    const seed = resolveLootSelectionSeed(draft, budgetContext);
    return {
      deterministic: true,
      seed,
      random: createLootSeededRandom(seed)
    };
  } catch (error) {
    logLootBuilderFailure("buildLootRandomContext", error, {
      deterministic: draft?.deterministic,
      seed: draft?.seed,
      dateBucket: draft?.dateBucket
    });
    return { deterministic: false, seed: "", random: Math.random };
  }
}

function buildLootValueBudgetContext(draft = {}, targetCount = 0) {
  try {
    const target = resolveTargetGP(draft);
    const tolerance = resolveTolerance(target.effectiveTotalTargetGp, draft?.valueStrictness ?? LOOT_PREVIEW_DEFAULT_VALUE_STRICTNESS);
    const desiredItemCount = Math.max(1, resolveDesiredItemCount(draft, target.effectiveTotalTargetGp, targetCount));
    const challenge = String(target.challenge ?? "mid").trim().toLowerCase();
    const profile = String(target.profile ?? "standard").trim().toLowerCase();
    const scale = String(target.scale ?? "medium").trim().toLowerCase();
    const combatants = getLootCombatantCount(draft, target.mode);
    const manualCapRaw = Number(draft?.maxItemValueGp ?? 0);
    const manualMaxItemValueGp = Number.isFinite(manualCapRaw)
      ? Math.max(0, Math.min(LOOT_PREVIEW_MAX_ITEM_VALUE_GP_LIMIT, Math.floor(manualCapRaw)))
      : 0;

    const autoCapBaseTable = { low: 150, mid: 650, high: 2400, epic: 8500 };
    const autoCapBase = Number(autoCapBaseTable[challenge] ?? autoCapBaseTable.mid);
    const profileCapMod = profile === "poor" ? 0.75 : profile === "well" ? 1.2 : 1;
    const scaleCapMod = scale === "small" ? 0.85 : scale === "major" ? 1.3 : 1;
    const targetCapFloor = Math.max(25, target.effectiveTotalTargetGp * (0.8 + tolerance.ratio));
    const autoMaxItemValueGp = Math.max(
      targetCapFloor,
      Number((autoCapBase * profileCapMod * scaleCapMod * Math.sqrt(Math.max(0.25, target.budgetScalar))).toFixed(2))
    );
    const effectiveMaxItemValueGp = manualMaxItemValueGp > 0 ? manualMaxItemValueGp : autoMaxItemValueGp;
    const targetPerItemGp = Math.max(0.5, Number((target.effectiveTotalTargetGp / Math.max(1, desiredItemCount)).toFixed(2)));
    const maxItems = Math.max(desiredItemCount, Math.min(80, Math.ceil(desiredItemCount * (1.4 + tolerance.ratio))));
    const valueStrictnessRaw = Number(draft?.valueStrictness ?? LOOT_PREVIEW_DEFAULT_VALUE_STRICTNESS);
    const valueStrictness = Number.isFinite(valueStrictnessRaw)
      ? Math.max(0.5, Math.min(3, valueStrictnessRaw / 100))
      : (LOOT_PREVIEW_DEFAULT_VALUE_STRICTNESS / 100);
    return {
      mode: target.mode,
      challenge,
      combatants,
      targetCount: desiredItemCount,
      desiredItemCount,
      maxItems,
      targetPerItemGp,
      totalBudgetGp: target.effectiveTotalTargetGp,
      autoTotalTargetGp: target.autoTotalTargetGp,
      manualTotalTargetGp: target.manualTotalTargetGp,
      effectiveTotalTargetGp: target.effectiveTotalTargetGp,
      targetValueRangeMinGp: tolerance.minGp,
      targetValueRangeMaxGp: tolerance.maxGp,
      toleranceGp: tolerance.toleranceGp,
      tolerancePercent: tolerance.percent,
      strictnessBandKey: tolerance.bandKey,
      strictnessBandLabel: tolerance.bandLabel,
      autoMaxItemValueGp,
      manualMaxItemValueGp,
      effectiveMaxItemValueGp,
      overshootAllowanceRatio: tolerance.ratio,
      valueStrictness
    };
  } catch (error) {
    logLootBuilderFailure("buildLootValueBudgetContext", error, {
      mode: draft?.mode,
      challenge: draft?.challenge,
      profile: draft?.profile,
      scale: draft?.scale,
      targetCount
    });
    return {
      mode: "horde",
      challenge: "mid",
      combatants: 1,
      targetCount: 1,
      desiredItemCount: 1,
      maxItems: 1,
      targetPerItemGp: 1,
      totalBudgetGp: 1,
      autoTotalTargetGp: 1,
      manualTotalTargetGp: 0,
      effectiveTotalTargetGp: 1,
      targetValueRangeMinGp: 0,
      targetValueRangeMaxGp: 2,
      toleranceGp: 1,
      tolerancePercent: 20,
      strictnessBandKey: "normal",
      strictnessBandLabel: "Normal",
      autoMaxItemValueGp: 25,
      manualMaxItemValueGp: 0,
      effectiveMaxItemValueGp: 25,
      overshootAllowanceRatio: 0.2,
      valueStrictness: 1
    };
  }
}

function getLootBudgetDrivenValueWeight(itemValueGp = 0, selectedTotalValueGp = 0, selectedCount = 0, budgetContext = {}) {
  const value = Math.max(0, Number(itemValueGp) || 0);
  if (value <= 0) return 0.9;

  const targetCount = Math.max(1, Math.floor(Number(budgetContext?.targetCount ?? (selectedCount + 1)) || (selectedCount + 1)));
  const picksUsed = Math.max(0, Math.floor(Number(selectedCount) || 0));
  const remainingPicks = Math.max(1, targetCount - picksUsed);
  const totalBudgetGp = Math.max(0.5, Number(budgetContext?.totalBudgetGp ?? budgetContext?.targetPerItemGp ?? 0.5) || 0.5);
  const consumedBudgetGp = Math.max(0, Number(selectedTotalValueGp) || 0);
  const remainingBudgetGp = Math.max(0.5, totalBudgetGp - consumedBudgetGp);
  const mode = String(budgetContext?.mode ?? "horde").trim().toLowerCase();
  const combatants = Math.max(1, Number(budgetContext?.combatants ?? 1) || 1);
  const soloEncounter = mode === "encounter" && combatants <= 1;
  let desiredNextValueGp = Math.max(0.5, remainingBudgetGp / remainingPicks);
  const strictness = Math.max(0.5, Number(budgetContext?.valueStrictness ?? 1) || 1);

  const manualCapGp = Math.max(0, Number(budgetContext?.manualMaxItemValueGp ?? 0) || 0);
  if (manualCapGp > 0 && value > manualCapGp) return 0;
  const effectiveCapGp = Math.max(0, Number(budgetContext?.effectiveMaxItemValueGp ?? 0) || 0);
  const nearMaxReferenceGp = Math.max(0, manualCapGp > 0 ? manualCapGp : effectiveCapGp);
  if (soloEncounter && nearMaxReferenceGp > 0) {
    desiredNextValueGp = Math.max(desiredNextValueGp, nearMaxReferenceGp * 0.9);
  }

  let weight = 1;
  if (value <= desiredNextValueGp) {
    const savingsRatio = Math.max(0, 1 - (value / Math.max(0.01, desiredNextValueGp)));
    weight *= 1 + Math.min(0.2, savingsRatio * 0.2);
  } else {
    const overRatio = value / Math.max(0.01, desiredNextValueGp);
    weight *= Math.exp(-(overRatio - 1) * (2.2 * strictness));
  }

  if (effectiveCapGp > 0 && value > effectiveCapGp) {
    const capOverRatio = value / Math.max(0.01, effectiveCapGp);
    weight *= Math.exp(-(capOverRatio - 1) * (4.6 * strictness));
  }

  if (manualCapGp > 0 && value <= manualCapGp) {
    const capLiftRatio = Math.max(0, Math.min(1, (manualCapGp / Math.max(1, desiredNextValueGp)) - 1));
    if (capLiftRatio > 0) {
      const expensiveRatio = Math.max(0, Math.min(1, value / Math.max(0.01, manualCapGp)));
      const expensiveBias = Math.pow(expensiveRatio, 1.6);
      weight *= 1 + (capLiftRatio * 0.65 * expensiveBias);
    }
  }

  const rangeMinGp = Math.max(0, Number(budgetContext?.targetValueRangeMinGp ?? 0) || 0);
  const rangeMaxGp = Math.max(rangeMinGp, Number(budgetContext?.targetValueRangeMaxGp ?? 0) || 0);
  if (rangeMaxGp > 0) {
    const projectedTotalGp = consumedBudgetGp + value;
    if (projectedTotalGp < rangeMinGp) {
      const gapRatio = (rangeMinGp - projectedTotalGp) / Math.max(1, rangeMinGp);
      weight *= 1 + Math.min(0.45, gapRatio * 0.45);
    } else if (projectedTotalGp > rangeMaxGp) {
      const overRatio = (projectedTotalGp - rangeMaxGp) / Math.max(1, rangeMaxGp);
      weight *= Math.exp(-overRatio * (2.8 * strictness));
    }
  }

  if (soloEncounter && nearMaxReferenceGp > 0 && value <= nearMaxReferenceGp) {
    const normalized = value / Math.max(0.01, nearMaxReferenceGp);
    const nearCapCloseness = Math.max(0, 1 - (Math.abs(normalized - 0.9) / 0.9));
    weight *= 1 + (nearCapCloseness * 0.35);
  }

  return Math.max(0.000001, weight);
}

function getLootValueBalanceWeight(itemValueGp = 0, selectedTotalValueGp = 0, selectedCount = 0, valueStats = {}, draft = {}, budgetContext = null) {
  const value = Math.max(0, Number(itemValueGp) || 0);
  const hasLegacyStats = Boolean(valueStats?.hasValues);
  let legacyWeight = 1;
  if (hasLegacyStats) {
    const mode = String(draft?.mode ?? "horde").trim().toLowerCase();
    const encounterCreatures = getLootCombatantCount(draft, mode);
    let target = Math.max(0.01, Number(valueStats.targetValuePerItem ?? 0.01) || 0.01);
    if (mode === "encounter") {
      if (encounterCreatures <= 1) target *= 1.08;
      else if (encounterCreatures >= 5) target *= 0.9;
    }
    const spread = Math.max(1, Number(valueStats.spread ?? 1) || 1);
    const desiredNextValue = Math.max(0, (target * (Math.max(0, selectedCount) + 1)) - Math.max(0, Number(selectedTotalValueGp) || 0));
    if (value <= 0) {
      legacyWeight = 0.95;
    } else {
      const delta = Math.abs(value - desiredNextValue);
      const closeness = Math.max(0, 1 - (delta / spread));
      legacyWeight = 0.35 + (closeness * 1.25);
    }
  }

  if (!budgetContext) return Math.max(0.000001, legacyWeight);
  const budgetWeight = getLootBudgetDrivenValueWeight(value, selectedTotalValueGp, selectedCount, budgetContext);
  if (!hasLegacyStats) return budgetWeight;
  return Math.max(0.000001, (budgetWeight * 0.86) + (legacyWeight * 0.14));
}

function buildLootCandidateFromSourceItem(item, context = {}, draft = {}, filters = {}) {
  if (!item) return null;
  const data = (item && typeof item?.toObject === "function") ? item.toObject() : item;
  const itemType = String(data?.type ?? "").trim();
  if (!itemType) return null;

  const includeTags = filters.includeTags ?? [];
  const excludeTags = filters.excludeTags ?? [];
  const floor = String(filters.floor ?? "");
  const ceiling = String(filters.ceiling ?? "");

  const keywords = getLootKeywordsFromData(data);
  if (!isLootKeywordMatch(keywords, includeTags, excludeTags)) return null;
  const rarity = getLootRarityFromData(data);
  const rarityBucket = getLootRarityBucket(rarity);
  const itemValueGp = getLootItemGpValueFromData(data);
  if (!isLootRarityAllowed(rarity, floor, ceiling)) return null;

  const sourceId = String(context.sourceId ?? "").trim();
  const sourceLabel = String(context.sourceLabel ?? sourceId).trim() || sourceId;
  const sourceWeight = Math.max(1, Math.floor(Number(context.sourceWeight ?? 1) || 1));
  const fallbackKey = String(data?._id ?? data?.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID();
  const rawUuid = String(item?.uuid ?? data?.uuid ?? "").trim();
  const uuid = rawUuid || (context.fallbackUuidPrefix ? `${context.fallbackUuidPrefix}.${fallbackKey}` : "");
  const key = uuid || fallbackKey;

  return {
    key,
    name: String(data?.name ?? "Item").trim() || "Item",
    img: String(data?.img ?? "icons/svg/item-bag.svg"),
    itemType,
    rarity,
    rarityBucket,
    uuid,
    sourceId,
    sourceLabel,
    sourceWeight,
    itemValueGp,
    keywords,
    profileWeight: getLootProfileRarityWeight(draft.profile, rarityBucket),
    rarityWeight: getLootModeChallengeRarityWeight(draft, rarityBucket)
  };
}

function getLootProfileRarityWeight(profile, rarity) {
  const normalizedProfile = String(profile ?? "standard").trim().toLowerCase();
  const normalizedRarity = getLootRarityBucket(rarity);
  if (!normalizedRarity) return 1;
  if (normalizedProfile === "poor") {
    if (normalizedRarity === "common") return 1.15;
    if (normalizedRarity === "uncommon") return 0.75;
    if (normalizedRarity === "rare") return 0.4;
    if (normalizedRarity === "very-rare") return 0.2;
    if (normalizedRarity === "legendary") return 0.08;
    return 1;
  }
  if (normalizedProfile === "well") {
    if (normalizedRarity === "common") return 0.9;
    if (normalizedRarity === "uncommon") return 1.08;
    if (normalizedRarity === "rare") return 1.18;
    if (normalizedRarity === "very-rare") return 1.28;
    if (normalizedRarity === "legendary") return 1.38;
    return 1;
  }
  return 1;
}

function getLootRarityBucket(rarity) {
  return normalizeLootRarity(rarity) || "common";
}

function getLootModeChallengeRarityWeight(draft = {}, rarity = "") {
  const mode = String(draft?.mode ?? "horde").trim().toLowerCase();
  const challenge = String(draft?.challenge ?? "mid").trim().toLowerCase();
  const bucket = getLootRarityBucket(rarity);
  const table = {
    defeated: {
      low: { common: 24, uncommon: 2.2, rare: 0.15, "very-rare": 0.01, legendary: 0 },
      mid: { common: 22, uncommon: 3, rare: 0.35, "very-rare": 0.03, legendary: 0 },
      high: { common: 20, uncommon: 4.2, rare: 0.8, "very-rare": 0.1, legendary: 0.01 },
      epic: { common: 17, uncommon: 5.5, rare: 1.4, "very-rare": 0.25, legendary: 0.03 }
    },
    encounter: {
      low: { common: 20, uncommon: 3.5, rare: 0.4, "very-rare": 0.03, legendary: 0 },
      mid: { common: 18, uncommon: 4.5, rare: 0.8, "very-rare": 0.08, legendary: 0.01 },
      high: { common: 16, uncommon: 5.8, rare: 1.5, "very-rare": 0.22, legendary: 0.02 },
      epic: { common: 14, uncommon: 6.5, rare: 2.4, "very-rare": 0.4, legendary: 0.05 }
    },
    horde: {
      low: { common: 16, uncommon: 4.5, rare: 0.9, "very-rare": 0.08, legendary: 0 },
      mid: { common: 14, uncommon: 5.8, rare: 1.5, "very-rare": 0.18, legendary: 0.01 },
      high: { common: 12, uncommon: 6.8, rare: 2.6, "very-rare": 0.45, legendary: 0.03 },
      epic: { common: 10.5, uncommon: 7.2, rare: 3.8, "very-rare": 0.95, legendary: 0.08 }
    }
  };
  const byMode = table[mode] ?? table.horde;
  const byChallenge = byMode[challenge] ?? byMode.mid;
  const base = Number(byChallenge[bucket] ?? 1);
  return Number.isFinite(base) ? Math.max(0, base) : 1;
}

function getLootCombatantCount(draft = {}, mode = "horde") {
  const normalizedMode = String(mode ?? draft?.mode ?? "horde").trim().toLowerCase();
  if (normalizedMode !== "encounter") return 1;
  return Math.max(1, Number(draft?.creatures ?? draft?.actorCount ?? 1) || 1);
}

function getLootCombatantSpreadFactor(draft = {}, mode = "horde") {
  if (String(mode ?? "horde").trim().toLowerCase() !== "encounter") return 1;
  const challenge = String(draft?.challenge ?? "mid").trim().toLowerCase();
  const combatants = getLootCombatantCount(draft, mode);
  const baselineByMode = {
    defeated: { low: 2, mid: 4, high: 6, epic: 8 },
    encounter: { low: 2, mid: 4, high: 6, epic: 8 },
    horde: { low: 3, mid: 5, high: 7, epic: 9 }
  };
  const modeKey = mode === "defeated" || mode === "encounter" ? mode : "horde";
  const byChallenge = baselineByMode[modeKey] ?? baselineByMode.horde;
  const baseline = Math.max(1, Number(byChallenge[challenge] ?? byChallenge.mid) || 1);
  const raw = combatants / baseline;
  return Math.max(0.45, Math.min(1.9, raw));
}

function getLootCombatantLowTierBonusCount(draft = {}, mode = "horde") {
  if (String(mode ?? "horde").trim().toLowerCase() !== "encounter") return 0;
  const combatants = getLootCombatantCount(draft, mode);
  const extra = Math.max(0, combatants - 1);
  if (extra <= 0) return 0;
  return Math.min(16, Math.floor(extra * 0.75));
}

function getLootCombatantRarityWeightModifier(draft = {}, rarity = "") {
  const mode = String(draft?.mode ?? "horde").trim().toLowerCase();
  const combatants = getLootCombatantCount(draft, mode);
  const pressure = Math.max(0, combatants - 1);
  if (pressure <= 0) return 1;
  const bucket = getLootRarityBucket(rarity);
  if (bucket === "common") return Math.min(3.25, 1 + pressure * 0.16);
  if (bucket === "uncommon") return Math.min(2.2, 1 + pressure * 0.1);
  if (bucket === "rare") return Math.max(0.28, 1 - pressure * 0.085);
  if (bucket === "very-rare") return Math.max(0.12, 1 - pressure * 0.11);
  if (bucket === "legendary") return Math.max(0.06, 1 - pressure * 0.14);
  return 1;
}

function getLootRaritySelectionCaps(draft = {}, targetCount = 0) {
  const mode = String(draft?.mode ?? "horde").trim().toLowerCase();
  const challenge = String(draft?.challenge ?? "mid").trim().toLowerCase();
  const count = Math.max(0, Math.floor(Number(targetCount) || 0));
  const ratioTable = {
    defeated: {
      low: { uncommon: 0.12, rare: 0, "very-rare": 0, legendary: 0 },
      mid: { uncommon: 0.16, rare: 0.03, "very-rare": 0, legendary: 0 },
      high: { uncommon: 0.22, rare: 0.06, "very-rare": 0.01, legendary: 0 },
      epic: { uncommon: 0.28, rare: 0.1, "very-rare": 0.03, legendary: 0.005 }
    },
    encounter: {
      low: { uncommon: 0.2, rare: 0.03, "very-rare": 0, legendary: 0 },
      mid: { uncommon: 0.26, rare: 0.06, "very-rare": 0.01, legendary: 0 },
      high: { uncommon: 0.33, rare: 0.11, "very-rare": 0.03, legendary: 0.005 },
      epic: { uncommon: 0.38, rare: 0.15, "very-rare": 0.05, legendary: 0.01 }
    },
    horde: {
      low: { uncommon: 0.3, rare: 0.08, "very-rare": 0.01, legendary: 0 },
      mid: { uncommon: 0.36, rare: 0.12, "very-rare": 0.03, legendary: 0.002 },
      high: { uncommon: 0.42, rare: 0.18, "very-rare": 0.06, legendary: 0.01 },
      epic: { uncommon: 0.48, rare: 0.24, "very-rare": 0.1, legendary: 0.02 }
    }
  };
  const byMode = ratioTable[mode] ?? ratioTable.horde;
  const byChallenge = byMode[challenge] ?? byMode.mid;
  const pressure = Math.max(0, getLootCombatantCount(draft, mode) - 1);
  const uncommonRatioBoost = Math.min(1.8, 1 + pressure * 0.03);
  const rareRatioPenalty = Math.max(0.35, 1 - pressure * 0.05);
  const veryRareRatioPenalty = Math.max(0.18, 1 - pressure * 0.07);
  const legendaryRatioPenalty = Math.max(0.1, 1 - pressure * 0.08);
  const caps = {
    uncommon: Math.max(0, Math.min(count, Math.floor(count * Number(byChallenge.uncommon ?? 0) * uncommonRatioBoost))),
    rare: Math.max(0, Math.min(count, Math.floor(count * Number(byChallenge.rare ?? 0) * rareRatioPenalty))),
    "very-rare": Math.max(0, Math.min(count, Math.floor(count * Number(byChallenge["very-rare"] ?? 0) * veryRareRatioPenalty))),
    legendary: Math.max(0, Math.min(count, Math.floor(count * Number(byChallenge.legendary ?? 0) * legendaryRatioPenalty)))
  };

  if (mode === "horde") {
    if (count >= 4) caps.uncommon = Math.max(caps.uncommon, 1);
    if (challenge !== "low" && count >= 8) caps.rare = Math.max(caps.rare, 1);
    if ((challenge === "high" || challenge === "epic") && count >= 14) caps["very-rare"] = Math.max(caps["very-rare"], 1);
    if (challenge === "epic" && count >= 30) caps.legendary = Math.max(caps.legendary, 1);
  } else if (mode === "encounter") {
    if ((challenge === "high" || challenge === "epic") && count >= 14) caps.rare = Math.max(caps.rare, 1);
    if (challenge === "epic" && count >= 20) caps["very-rare"] = Math.max(caps["very-rare"], 1);
  }

  return caps;
}

function canSelectLootRarityWithCaps(rarity, selectedCounts = {}, caps = {}) {
  const bucket = getLootRarityBucket(rarity);
  if (bucket === "common") return true;
  const cap = Math.max(0, Number(caps?.[bucket] ?? 0) || 0);
  const current = Math.max(0, Number(selectedCounts?.[bucket] ?? 0) || 0);
  return current < cap;
}

function chooseWeightedEntry(entries, weightAccessor, randomFn = Math.random) {
  if (!Array.isArray(entries) || entries.length === 0) return null;
  const getWeight = typeof weightAccessor === "function"
    ? weightAccessor
    : (entry) => Number(entry?.weight ?? 1);
  const random = typeof randomFn === "function" ? randomFn : Math.random;
  let total = 0;
  const weighted = entries.map((entry) => {
    const raw = Number(getWeight(entry));
    const weight = Number.isFinite(raw) ? Math.max(0, raw) : 0;
    total += weight;
    return { entry, weight };
  });
  if (total <= 0) return entries[0] ?? null;
  let cursor = random() * total;
  for (const row of weighted) {
    cursor -= row.weight;
    if (cursor <= 0) return row.entry;
  }
  return weighted[weighted.length - 1]?.entry ?? null;
}

function shuffleArray(input = [], randomFn = Math.random) {
  const rows = [...input];
  const random = typeof randomFn === "function" ? randomFn : Math.random;
  for (let index = rows.length - 1; index > 0; index -= 1) {
    const swapIndex = Math.floor(random() * (index + 1));
    [rows[index], rows[swapIndex]] = [rows[swapIndex], rows[index]];
  }
  return rows;
}

function getLootCurrencyProfile(draft = {}) {
  const mode = String(draft.mode ?? "horde");
  const challenge = String(draft.challenge ?? "mid");
  const table = {
    horde: {
      low: { dice: "6d10", bonus: 60 },
      mid: { dice: "8d12", bonus: 180 },
      high: { dice: "10d20", bonus: 450 },
      epic: { dice: "12d30", bonus: 1200 }
    },
    defeated: {
      low: { dice: "1d8", bonus: 2 },
      mid: { dice: "2d10", bonus: 5 },
      high: { dice: "3d12", bonus: 12 },
      epic: { dice: "4d20", bonus: 30 }
    },
    encounter: {
      low: { dice: "3d10", bonus: 20 },
      mid: { dice: "5d12", bonus: 55 },
      high: { dice: "7d16", bonus: 180 },
      epic: { dice: "9d24", bonus: 500 }
    }
  };
  const modeRows = table[mode] ?? table.horde;
  return modeRows[challenge] ?? modeRows.mid;
}

function getLootScaleMultiplier(scale = "medium") {
  if (scale === "small") return 0.75;
  if (scale === "major") return 1.8;
  return 1;
}

function getLootProfileMultiplier(profile = "standard") {
  if (profile === "poor") return 0.75;
  if (profile === "well") return 1.35;
  return 1;
}

function convertGpToCurrency(gpValue = 0) {
  const gp = Math.max(0, Number(gpValue) || 0);
  let cpTotal = Math.max(0, Math.round(gp * 100));
  const pp = Math.floor(cpTotal / 1000);
  cpTotal -= (pp * 1000);
  const finalGp = Math.floor(cpTotal / 100);
  cpTotal -= (finalGp * 100);
  const sp = Math.floor(cpTotal / 10);
  cpTotal -= (sp * 10);
  const cp = cpTotal;
  return {
    pp,
    gp: finalGp,
    sp,
    cp,
    gpEquivalent: gp
  };
}

function rollSimpleDiceFormulaDeterministic(formula = "", randomFn = Math.random) {
  const text = String(formula ?? "").trim().toLowerCase();
  const match = /^(\d+)d(\d+)$/.exec(text);
  if (!match) return null;
  const count = Math.max(1, Math.min(200, Number(match[1]) || 1));
  const sides = Math.max(1, Math.min(1000, Number(match[2]) || 1));
  const random = typeof randomFn === "function" ? randomFn : Math.random;
  let total = 0;
  for (let index = 0; index < count; index += 1) {
    total += 1 + Math.floor(random() * sides);
  }
  return total;
}

async function rollLootCurrency(draft = {}, randomContext = null) {
  const profile = getLootCurrencyProfile(draft);
  const random = randomContext?.random ?? Math.random;
  let rollTotal = 0;
  if (randomContext?.deterministic) {
    const deterministicTotal = rollSimpleDiceFormulaDeterministic(String(profile.dice ?? "1d1"), random);
    if (deterministicTotal !== null) {
      rollTotal = deterministicTotal;
    } else {
      const roll = await (new Roll(String(profile.dice ?? "1d1"))).evaluate();
      rollTotal = Number(roll?.total ?? 0);
    }
  } else {
    const roll = await (new Roll(String(profile.dice ?? "1d1"))).evaluate();
    rollTotal = Number(roll?.total ?? 0);
  }
  const modeFactor = 1;
  const scaled = (Math.max(0, rollTotal) + Math.max(0, Number(profile.bonus ?? 0)))
    * getLootScaleMultiplier(String(draft.scale ?? "medium"))
    * getLootProfileMultiplier(String(draft.profile ?? "standard"))
    * modeFactor;
  const currencyScale = Math.max(0.25, Math.min(3, Number(draft.currencyScalar ?? 100) / 100));
  const gpEquivalent = Math.max(0, Number((scaled * currencyScale).toFixed(2)));
  return {
    formula: `${profile.dice} + ${profile.bonus}`,
    rolled: Math.max(0, Math.floor(rollTotal)),
    modeFactor,
    scaleMultiplier: getLootScaleMultiplier(String(draft.scale ?? "medium")),
    profileMultiplier: getLootProfileMultiplier(String(draft.profile ?? "standard")),
    ...convertGpToCurrency(gpEquivalent)
  };
}

function getLootItemCount(draft = {}) {
  const target = resolveTargetGP(draft);
  return resolveDesiredItemCount(draft, target.effectiveTotalTargetGp, 0);
}

async function buildLootItemCandidates(sourceConfig, draft, warnings = []) {
  const allowedTypes = new Set(sourceConfig?.filters?.allowedTypes ?? []);
  const floor = String(sourceConfig?.filters?.rarityFloor ?? "");
  const ceiling = String(sourceConfig?.filters?.rarityCeiling ?? "");
  const manifestPackId = String(sourceConfig?.filters?.manifestPackId ?? "").trim();
  const includeTags = normalizeLootKeywordTagList(sourceConfig?.filters?.keywordIncludeTags ?? []);
  const excludeTags = normalizeLootKeywordTagList(sourceConfig?.filters?.keywordExcludeTags ?? []);
  let enabledSources = (sourceConfig?.packs ?? []).filter((entry) => entry?.enabled !== false);
  if (manifestPackId) {
    const source = enabledSources.find((entry) => String(entry?.id ?? "").trim() === manifestPackId)
      ?? normalizeLootSourcePackEntry({ id: manifestPackId, label: manifestPackId, sourceKind: "compendium-pack", enabled: true, weight: 1 });
    enabledSources = source ? [source] : [];
  }
  const candidates = [];
  const baseFilterOptions = {
    typeWhitelist: [...allowedTypes]
  };
  for (const source of enabledSources) {
    try {
      const sourceId = String(source?.id ?? "").trim();
      const sourceLabel = String(source?.label ?? sourceId).trim() || sourceId;
      const sourceWeight = Math.max(1, Math.floor(Number(source?.weight ?? 1) || 1));
      if (!sourceId) continue;
      if (sourceId === LOOT_WORLD_ITEMS_SOURCE_ID) {
        const worldItems = filterItems(game.items?.contents ?? [], baseFilterOptions);
        for (const item of worldItems) {
          const candidate = buildLootCandidateFromSourceItem(item, {
            sourceId,
            sourceLabel,
            sourceWeight,
            fallbackUuidPrefix: "World.Item"
          }, draft, {
            includeTags,
            excludeTags,
            floor,
            ceiling
          });
          if (!candidate) continue;
          candidates.push(candidate);
        }
        continue;
      }

      const packItems = await loadItemsFromPack(sourceId, { sourceLabel, warnings });
      const filteredPackItems = filterItems(packItems, baseFilterOptions);
      for (const item of filteredPackItems) {
        const candidate = buildLootCandidateFromSourceItem(item, {
          sourceId,
          sourceLabel,
          sourceWeight,
          fallbackUuidPrefix: `Compendium.${sourceId}`
        }, draft, {
          includeTags,
          excludeTags,
          floor,
          ceiling
        });
        if (!candidate) continue;
        candidates.push(candidate);
      }
    } catch (error) {
      logLootBuilderFailure("buildLootItemCandidates.source", error, {
        sourceId: source?.id,
        sourceLabel: source?.label,
        mode: draft?.mode,
        challenge: draft?.challenge
      });
      warnings.push(`Failed item source: ${String(source?.label ?? source?.id ?? "Unknown source")}`);
    }
  }
  return candidates;
}

function getLootRarityKeepPriority(rarity = "") {
  const bucket = getLootRarityBucket(rarity);
  if (bucket === "legendary") return 10;
  if (bucket === "very-rare") return 8;
  if (bucket === "rare") return 5;
  if (bucket === "uncommon") return 2.5;
  return 1;
}

function getLootBudgetPhaseCandidateWeight(entry = {}, state = {}, phase = "spend") {
  const budgetContext = state?.budgetContext ?? {};
  const selectedTotalValueGp = Math.max(0, Number(state?.selectedTotalValueGp ?? 0) || 0);
  const selectedCount = Math.max(0, Number(state?.selected?.length ?? 0) || 0);
  const targetTotal = Math.max(1, Number(budgetContext?.effectiveTotalTargetGp ?? 1) || 1);
  const toleranceGp = Math.max(1, Number(budgetContext?.toleranceGp ?? 1) || 1);
  const remaining = Math.max(0, targetTotal - selectedTotalValueGp);
  const remainingSlots = Math.max(1, Number(budgetContext?.targetCount ?? 1) - selectedCount);
  const desiredNextValue = Math.max(0.5, remaining / remainingSlots);
  const value = Math.max(0, Number(entry?.itemValueGp ?? 0) || 0);
  const overshootAllowanceRatio = Math.max(0.05, Math.min(0.45, Number(budgetContext?.overshootAllowanceRatio ?? 0.2) || 0.2));
  const overshootLimit = Math.max(1, remaining * (1 + overshootAllowanceRatio));
  if (phase === "spend" && remaining > toleranceGp && value > overshootLimit) return 0;
  if (phase === "fill" && value > Math.max(1, remaining * (1 + Math.min(0.2, overshootAllowanceRatio)))) return 0;

  const sourceWeight = Math.max(1, Number(entry?.sourceWeight ?? 1) || 1);
  const profileWeight = Math.max(0.1, Number(entry?.profileWeight ?? 1) || 1);
  const rarityWeight = Math.max(0.01, Number(entry?.rarityWeight ?? 1) || 1);
  const combatantWeight = Math.max(0.01, Number(getLootCombatantRarityWeightModifier(state?.draft ?? {}, entry?.rarity) || 1));
  const typeWeight = Math.max(0, Number(getLootBuilderItemTypeWeight(state?.draft ?? {}, entry?.itemType) || 0));
  const distance = Math.abs(value - desiredNextValue) / Math.max(1, desiredNextValue);
  const closenessWeight = 1 / (1 + (phase === "fill" ? distance * 1.1 : distance * 1.85));
  const cheapFillBoost = phase === "fill" && value <= remaining
    ? 1 + Math.min(0.85, (remaining - value) / Math.max(1, remaining))
    : 1;
  const budgetWeight = Math.max(0.000001, closenessWeight * cheapFillBoost);
  return sourceWeight * profileWeight * rarityWeight * combatantWeight * typeWeight * budgetWeight;
}

function chooseLootBudgetCandidate(selectionPool = [], state = {}, phase = "spend") {
  const weightedPool = buildWeightedPool(selectionPool, (entry) => getLootBudgetPhaseCandidateWeight(entry, state, phase));
  const pickedRow = chooseWeightedEntry(weightedPool, (entry) => Number(entry?.weight ?? 0), state?.random ?? Math.random);
  return pickedRow?.item ?? null;
}

function commitLootBudgetPick(state = {}, picked = null) {
  if (!picked || !state) return false;
  const rarityBucket = getLootRarityBucket(picked.rarity);
  state.selectedByRarity[rarityBucket] = Math.max(0, Number(state.selectedByRarity[rarityBucket] ?? 0) || 0) + 1;
  state.selected.push({
    name: picked.name,
    img: picked.img,
    itemType: picked.itemType,
    rarity: picked.rarity || "",
    sourceLabel: picked.sourceLabel,
    uuid: picked.uuid,
    itemValueGp: Math.max(0, Number(picked?.itemValueGp ?? 0) || 0)
  });
  state.selectedTotalValueGp += Math.max(0, Number(picked?.itemValueGp ?? 0) || 0);
  const mode = String(state?.draft?.mode ?? "horde").trim().toLowerCase();
  const encounterCreatures = Math.max(1, Number(state?.budgetContext?.combatants ?? 1) || 1);
  const duplicateChance = Math.min(0.75, 0.2 + (Math.max(0, encounterCreatures - 1) * 0.1));
  const allowEncounterDuplicate = mode === "encounter"
    && encounterCreatures > 1
    && (rarityBucket === "common" || rarityBucket === "uncommon")
    && (state.random?.() ?? Math.random()) < duplicateChance;
  if (!allowEncounterDuplicate) {
    const index = state.pool.indexOf(picked);
    if (index >= 0) state.pool.splice(index, 1);
  }
  return true;
}

function buildLootPhaseSelectionPool(state = {}, phase = "spend") {
  const budgetContext = state?.budgetContext ?? {};
  const effectiveCapGp = Math.max(0, Number(budgetContext?.effectiveMaxItemValueGp ?? 0) || 0);
  const targetTotal = Math.max(1, Number(budgetContext?.effectiveTotalTargetGp ?? 1) || 1);
  const toleranceGp = Math.max(1, Number(budgetContext?.toleranceGp ?? 1) || 1);
  const selectedTotalValueGp = Math.max(0, Number(state?.selectedTotalValueGp ?? 0) || 0);
  const remaining = Math.max(0, targetTotal - selectedTotalValueGp);
  const overshootAllowanceRatio = Math.max(0.05, Math.min(0.45, Number(budgetContext?.overshootAllowanceRatio ?? 0.2) || 0.2));
  const overshootLimit = Math.max(1, remaining * (1 + overshootAllowanceRatio));
  const rawPool = (Array.isArray(state?.pool) ? state.pool : [])
    .filter((entry) => canSelectLootRarityWithCaps(entry?.rarity, state?.selectedByRarity ?? {}, state?.rarityCaps ?? {}))
    .filter((entry) => {
      if (effectiveCapGp <= 0) return true;
      const value = Math.max(0, Number(entry?.itemValueGp ?? 0) || 0);
      return value <= effectiveCapGp;
    });
  if (rawPool.length === 0) return [];
  if (phase === "spend" && remaining > toleranceGp) {
    const budgetPool = rawPool.filter((entry) => Math.max(0, Number(entry?.itemValueGp ?? 0) || 0) <= overshootLimit);
    if (budgetPool.length > 0) return budgetPool;
    return [...rawPool].sort((left, right) => Number(left?.itemValueGp ?? 0) - Number(right?.itemValueGp ?? 0)).slice(0, 18);
  }
  if (phase === "fill") {
    const fillLimit = Math.max(1, remaining * (1 + Math.min(0.2, overshootAllowanceRatio)));
    const fillPool = rawPool.filter((entry) => Math.max(0, Number(entry?.itemValueGp ?? 0) || 0) <= fillLimit);
    if (fillPool.length > 0) return fillPool;
    return [...rawPool].sort((left, right) => Number(left?.itemValueGp ?? 0) - Number(right?.itemValueGp ?? 0)).slice(0, 12);
  }
  return rawPool;
}

function spendBudgetLoop(state = {}) {
  try {
    const budgetContext = state?.budgetContext ?? {};
    const targetTotal = Math.max(1, Number(budgetContext?.effectiveTotalTargetGp ?? 1) || 1);
    const toleranceGp = Math.max(1, Number(budgetContext?.toleranceGp ?? 1) || 1);
    const maxItems = Math.max(1, Number(state?.maxItems ?? budgetContext?.maxItems ?? 1) || 1);
    let safety = 0;
    while (safety < 600) {
      safety += 1;
      const remaining = Math.max(0, targetTotal - Math.max(0, Number(state.selectedTotalValueGp ?? 0) || 0));
      if (remaining <= toleranceGp) return;
      if ((state.selected?.length ?? 0) >= maxItems) return;
      const selectionPool = buildLootPhaseSelectionPool(state, "spend");
      if (!selectionPool.length) {
        state.diagnostics.push("No spend-phase candidates in the current budget range.");
        logLootBuilderDebug("spendBudgetLoop stopped: no candidates", {
          remaining,
          toleranceGp,
          selectedCount: state.selected?.length ?? 0,
          maxItems
        });
        return;
      }
      const picked = chooseLootBudgetCandidate(selectionPool, state, "spend");
      if (!picked) {
        state.diagnostics.push("Weighted spend-phase pick returned no candidate.");
        logLootBuilderDebug("spendBudgetLoop stopped: weighted pick empty", {
          selectionPoolSize: selectionPool.length
        });
        return;
      }
      if (!commitLootBudgetPick(state, picked)) return;
    }
    state.diagnostics.push("Spend loop hit safety iteration cap.");
    logLootBuilderDebug("spendBudgetLoop safety cap reached", {
      selectedCount: state.selected?.length ?? 0,
      selectedTotalValueGp: state.selectedTotalValueGp
    });
  } catch (error) {
    state?.diagnostics?.push?.("Spend loop failed unexpectedly.");
    logLootBuilderFailure("spendBudgetLoop", error, {
      selectedCount: state?.selected?.length ?? 0,
      selectedTotalValueGp: state?.selectedTotalValueGp ?? 0,
      target: state?.budgetContext?.effectiveTotalTargetGp ?? 0,
      tolerance: state?.budgetContext?.toleranceGp ?? 0
    });
  }
}

function fillPass(state = {}) {
  try {
    const budgetContext = state?.budgetContext ?? {};
    const targetTotal = Math.max(1, Number(budgetContext?.effectiveTotalTargetGp ?? 1) || 1);
    const toleranceGp = Math.max(1, Number(budgetContext?.toleranceGp ?? 1) || 1);
    const maxItems = Math.max(1, Number(state?.maxItems ?? budgetContext?.maxItems ?? 1) || 1);
    let safety = 0;
    while (safety < 400) {
      safety += 1;
      const remaining = Math.max(0, targetTotal - Math.max(0, Number(state.selectedTotalValueGp ?? 0) || 0));
      if (remaining <= toleranceGp) return;
      if ((state.selected?.length ?? 0) >= maxItems) {
        state.diagnostics.push("Fill pass stopped at max item cap before target tolerance was reached.");
        logLootBuilderDebug("fillPass stopped at max items", {
          remaining,
          toleranceGp,
          maxItems
        });
        return;
      }
      const selectionPool = buildLootPhaseSelectionPool(state, "fill");
      if (!selectionPool.length) {
        state.diagnostics.push("Fill pass ended: no affordable low-value candidates remained.");
        logLootBuilderDebug("fillPass ended with no candidates", {
          remaining,
          toleranceGp
        });
        return;
      }
      const picked = chooseLootBudgetCandidate(selectionPool, state, "fill");
      if (!picked) return;
      if (!commitLootBudgetPick(state, picked)) return;
    }
    state.diagnostics.push("Fill pass hit safety iteration cap.");
    logLootBuilderDebug("fillPass safety cap reached", {
      selectedCount: state.selected?.length ?? 0,
      selectedTotalValueGp: state.selectedTotalValueGp
    });
  } catch (error) {
    state?.diagnostics?.push?.("Fill pass failed unexpectedly.");
    logLootBuilderFailure("fillPass", error, {
      selectedCount: state?.selected?.length ?? 0,
      selectedTotalValueGp: state?.selectedTotalValueGp ?? 0,
      target: state?.budgetContext?.effectiveTotalTargetGp ?? 0,
      tolerance: state?.budgetContext?.toleranceGp ?? 0
    });
  }
}

function trimPass(state = {}) {
  try {
    const budgetContext = state?.budgetContext ?? {};
    const targetTotal = Math.max(1, Number(budgetContext?.effectiveTotalTargetGp ?? 1) || 1);
    const toleranceGp = Math.max(1, Number(budgetContext?.toleranceGp ?? 1) || 1);
    let safety = 0;
    while (safety < 200) {
      safety += 1;
      const overspent = Math.max(0, Math.max(0, Number(state.selectedTotalValueGp ?? 0) || 0) - targetTotal);
      if (overspent <= toleranceGp) return;
      if (!Array.isArray(state.selected) || state.selected.length === 0) {
        state.diagnostics.push("Trim pass could not run: no selected items.");
        logLootBuilderDebug("trimPass stopped: nothing to trim", {
          overspent,
          toleranceGp
        });
        return;
      }
      const scored = state.selected.map((entry, index) => {
        const value = Math.max(0, Number(entry?.itemValueGp ?? 0) || 0);
        const keepPriority = getLootRarityKeepPriority(entry?.rarity);
        const rarityWeight = Number(1 / Math.max(1, keepPriority));
        const budgetWeight = Math.min(2, value / Math.max(1, overspent));
        return {
          index,
          score: (budgetWeight * 1.2) + rarityWeight
        };
      }).sort((left, right) => right.score - left.score);
      const pick = scored[0];
      if (!pick) return;
      const removed = state.selected[pick.index];
      const removedValue = Math.max(0, Number(removed?.itemValueGp ?? 0) || 0);
      const bucket = getLootRarityBucket(removed?.rarity);
      state.selected.splice(pick.index, 1);
      state.selectedTotalValueGp = Math.max(0, Math.max(0, Number(state.selectedTotalValueGp ?? 0) || 0) - removedValue);
      state.selectedByRarity[bucket] = Math.max(0, Math.max(0, Number(state.selectedByRarity[bucket] ?? 0) || 0) - 1);
    }
    state.diagnostics.push("Trim pass hit safety iteration cap.");
    logLootBuilderDebug("trimPass safety cap reached", {
      selectedCount: state.selected?.length ?? 0,
      selectedTotalValueGp: state.selectedTotalValueGp
    });
  } catch (error) {
    state?.diagnostics?.push?.("Trim pass failed unexpectedly.");
    logLootBuilderFailure("trimPass", error, {
      selectedCount: state?.selected?.length ?? 0,
      selectedTotalValueGp: state?.selectedTotalValueGp ?? 0,
      target: state?.budgetContext?.effectiveTotalTargetGp ?? 0,
      tolerance: state?.budgetContext?.toleranceGp ?? 0
    });
  }
}

function pickLootItemsFromCandidatesLegacy(candidates, count = 0, draft = {}) {
  const targetCount = Math.max(0, Math.floor(Number(count) || 0));
  if (!Array.isArray(candidates) || candidates.length === 0 || targetCount <= 0) return [];
  const pool = [...candidates];
  const selected = [];
  const mode = String(draft?.mode ?? "horde").trim().toLowerCase();
  const encounterCreatures = getLootCombatantCount(draft, mode);
  const valueStats = summarizeLootCandidateValueStats(pool);
  const valueBudgetContext = buildLootValueBudgetContext(draft, targetCount);
  const manualCapGp = Math.max(0, Number(valueBudgetContext?.manualMaxItemValueGp ?? 0) || 0);
  const rarityCaps = getLootRaritySelectionCaps(draft, targetCount);
  const selectedByRarity = {
    common: 0,
    uncommon: 0,
    rare: 0,
    "very-rare": 0,
    legendary: 0
  };
  let selectedTotalValueGp = 0;
  while (pool.length > 0 && selected.length < targetCount) {
    const cappedPool = pool.filter((entry) => canSelectLootRarityWithCaps(entry?.rarity, selectedByRarity, rarityCaps));
    const rarityPool = cappedPool.length > 0 ? cappedPool : pool;
    const selectionPool = manualCapGp > 0
      ? rarityPool.filter((entry) => Math.max(0, Number(entry?.itemValueGp ?? 0) || 0) <= manualCapGp)
      : rarityPool;
    if (!selectionPool.length) break;
    const weightedPool = buildWeightedPool(selectionPool, (entry) => {
      const sourceWeight = Math.max(1, Number(entry?.sourceWeight ?? 1) || 1);
      const profileWeight = Math.max(0.1, Number(entry?.profileWeight ?? 1) || 1);
      const rarityWeight = Math.max(0.01, Number(entry?.rarityWeight ?? 1) || 1);
      const combatantWeight = Math.max(0.01, Number(getLootCombatantRarityWeightModifier(draft, entry?.rarity) || 1));
      const typeWeight = Math.max(0, Number(getLootBuilderItemTypeWeight(draft, entry?.itemType) || 0));
      const valueWeight = Math.max(0, Number(getLootValueBalanceWeight(
        entry?.itemValueGp,
        selectedTotalValueGp,
        selected.length,
        valueStats,
        draft,
        valueBudgetContext
      ) || 0));
      return sourceWeight * profileWeight * rarityWeight * combatantWeight * typeWeight * valueWeight;
    });
    const pickedRow = chooseWeightedEntry(weightedPool, (entry) => Number(entry?.weight ?? 0));
    const picked = pickedRow?.item ?? null;
    if (!picked) break;
    const rarityBucket = getLootRarityBucket(picked.rarity);
    selectedByRarity[rarityBucket] = Math.max(0, Number(selectedByRarity[rarityBucket] ?? 0) || 0) + 1;
    selected.push({
      name: picked.name,
      img: picked.img,
      itemType: picked.itemType,
      rarity: picked.rarity || "",
      sourceLabel: picked.sourceLabel,
      uuid: picked.uuid,
      itemValueGp: Math.max(0, Number(picked?.itemValueGp ?? 0) || 0)
    });
    selectedTotalValueGp += Math.max(0, Number(picked?.itemValueGp ?? 0) || 0);
    const allowEncounterDuplicate = mode === "encounter"
      && encounterCreatures > 1
      && (rarityBucket === "common" || rarityBucket === "uncommon")
      && Math.random() < Math.min(0.75, 0.2 + (Math.max(0, encounterCreatures - 1) * 0.1));
    if (!allowEncounterDuplicate) {
      const index = pool.indexOf(picked);
      if (index >= 0) pool.splice(index, 1);
    }
  }
  return selected;
}

function pickLootItemsFromCandidates(candidates, count = 0, draft = {}, options = {}) {
  try {
    const targetCount = Math.max(0, Math.floor(Number(count) || 0));
    if (!Array.isArray(candidates) || candidates.length === 0 || targetCount <= 0) return [];
    const budgetContext = (options?.budgetContext && typeof options.budgetContext === "object")
      ? options.budgetContext
      : buildLootValueBudgetContext(draft, targetCount);
    const randomContext = (options?.randomContext && typeof options.randomContext === "object")
      ? options.randomContext
      : buildLootRandomContext(draft, budgetContext);
    const initialPool = [...candidates];
    const state = {
      pool: initialPool,
      selected: [],
      selectedTotalValueGp: 0,
      selectedByRarity: {
        common: 0,
        uncommon: 0,
        rare: 0,
        "very-rare": 0,
        legendary: 0
      },
      rarityCaps: getLootRaritySelectionCaps(draft, Math.max(targetCount, Number(budgetContext?.maxItems ?? targetCount) || targetCount)),
      budgetContext,
      targetCount: Math.max(1, Number(budgetContext?.targetCount ?? targetCount) || targetCount),
      maxItems: Math.max(targetCount, Number(budgetContext?.maxItems ?? targetCount) || targetCount),
      draft,
      random: randomContext?.random ?? Math.random,
      diagnostics: []
    };

    spendBudgetLoop(state);
    fillPass(state);
    trimPass(state);
    fillPass(state);
    trimPass(state);

    const finalTotalValueGp = Math.max(0, Number(state.selectedTotalValueGp ?? 0) || 0);
    const targetTotalValueGp = Math.max(0, Number(budgetContext?.effectiveTotalTargetGp ?? 0) || 0);
    const deltaGp = Number((finalTotalValueGp - targetTotalValueGp).toFixed(2));
    const meta = {
      deterministic: Boolean(randomContext?.deterministic),
      seed: String(randomContext?.seed ?? ""),
      desiredItemCount: Math.max(0, Number(budgetContext?.targetCount ?? targetCount) || 0),
      maxItems: Math.max(0, Number(state.maxItems ?? 0) || 0),
      encounterTargetGp: targetTotalValueGp,
      finalItemsValueGp: Number(finalTotalValueGp.toFixed(2)),
      deltaGp,
      toleranceGp: Math.max(0, Number(budgetContext?.toleranceGp ?? 0) || 0),
      tolerancePercent: Math.max(0, Number(budgetContext?.tolerancePercent ?? 0) || 0),
      strictnessBandLabel: String(budgetContext?.strictnessBandLabel ?? "Normal"),
      strictnessBandKey: String(budgetContext?.strictnessBandKey ?? "normal"),
      candidateCount: Math.max(0, Number(candidates.length || 0)),
      diagnostics: state.diagnostics
    };
    const selected = state.selected;
    try {
      Object.defineProperty(selected, "__meta", {
        value: meta,
        enumerable: false,
        configurable: true,
        writable: false
      });
    } catch {
      // Non-critical metadata attachment.
    }
    return selected;
  } catch (error) {
    logLootBuilderFailure("pickLootItemsFromCandidates", error, {
      count,
      mode: draft?.mode,
      challenge: draft?.challenge,
      profile: draft?.profile,
      scale: draft?.scale,
      creatures: draft?.creatures ?? draft?.actorCount,
      candidateCount: Array.isArray(candidates) ? candidates.length : 0,
      hasBudgetContext: Boolean(options?.budgetContext),
      hasRandomContext: Boolean(options?.randomContext)
    });
    logLootBuilderDebug("falling back to legacy picker after budget-first failure", {
      count,
      candidateCount: Array.isArray(candidates) ? candidates.length : 0
    });
    return pickLootItemsFromCandidatesLegacy(candidates, count, draft);
  }
}

async function resolveUuidDocument(uuid) {
  const ref = String(uuid ?? "").trim();
  if (!ref) return null;
  if (typeof fromUuid === "function") {
    try {
      const asyncDoc = await fromUuid(ref);
      if (asyncDoc) return asyncDoc;
    } catch {
      // Fall back to sync lookup.
    }
  }
  if (typeof fromUuidSync === "function") {
    try {
      const syncDoc = fromUuidSync(ref);
      if (syncDoc) return syncDoc;
    } catch {
      return null;
    }
  }
  return null;
}

function getLootTableRollBudget(draft = {}) {
  const mode = String(draft.mode ?? "horde");
  const challenge = String(draft.challenge ?? "mid");
  const scale = String(draft.scale ?? "medium");
  const modeBase = mode === "horde" ? 2 : 1;
  const challengeBonus = challenge === "high" ? 1 : challenge === "epic" ? 2 : 0;
  const scaleBonus = scale === "major" ? 1 : 0;
  const baseBudget = modeBase + challengeBonus + scaleBonus;
  const tableScale = Math.max(0.25, Math.min(3, Number(draft.tableScalar ?? 100) / 100));
  return Math.max(0, Math.min(6, Math.round(baseBudget * tableScale)));
}

async function resolveLootTableFromSource(source = {}, randomContext = null) {
  const sourceId = String(source?.id ?? "").trim();
  if (!sourceId) return null;
  const random = randomContext?.random ?? Math.random;

  if (sourceId.startsWith("world-table:")) {
    const uuid = sourceId.slice("world-table:".length);
    const document = await resolveUuidDocument(uuid);
    if (document?.documentName === "RollTable") return document;
    return null;
  }

  if (sourceId.startsWith("table-pack:")) {
    const collection = sourceId.slice("table-pack:".length);
    const pack = game.packs?.get(collection);
    if (!pack) return null;
    const index = await pack.getIndex();
    const rows = getCollectionValues(index);
    if (!rows.length) return null;
    const row = rows[Math.floor(random() * rows.length)];
    const entry = Array.isArray(row) ? row[1] : row;
    const docId = String(entry?._id ?? entry?.id ?? "").trim();
    if (!docId) return null;
    return pack.getDocument(docId);
  }

  return null;
}

function getRollTableResultLabel(result = {}) {
  const text = String(result?.text ?? "").trim();
  if (text) return text;
  const collection = String(result?.documentCollection ?? "").trim();
  const docId = String(result?.documentId ?? "").trim();
  if (collection && docId) return `${collection} (${docId})`;
  return "No result text";
}

async function rollLootTableDry(tableDoc, randomContext = null) {
  if (!tableDoc) return null;
  const random = randomContext?.random ?? Math.random;
  const formula = String(tableDoc.formula ?? "1d100").trim() || "1d100";
  let total = 0;
  if (randomContext?.deterministic) {
    const deterministicTotal = rollSimpleDiceFormulaDeterministic(formula, random);
    if (deterministicTotal !== null) total = deterministicTotal;
    else {
      const roll = await (new Roll(formula)).evaluate();
      total = Number(roll?.total ?? 0);
    }
  } else {
    const roll = await (new Roll(formula)).evaluate();
    total = Number(roll?.total ?? 0);
  }
  const results = getCollectionValues(tableDoc.results);
  const matches = results.filter((result) => {
    const range = Array.isArray(result?.range) ? result.range : [1, 1];
    const min = Number(range[0] ?? 1);
    const max = Number(range[1] ?? min);
    return total >= min && total <= max;
  });
  const picked = matches.length > 0
    ? matches[Math.floor(random() * matches.length)]
    : (results[0] ?? null);
  return {
    tableName: String(tableDoc.name ?? "Roll Table").trim() || "Roll Table",
    formula,
    total: Number.isFinite(total) ? Math.floor(total) : 0,
    result: picked ? getRollTableResultLabel(picked) : "No matching result",
    resultType: String(picked?.type ?? "").trim()
  };
}

async function buildLootTableRolls(sourceConfig, draft, warnings = [], randomContext = null) {
  const enabledSources = (sourceConfig?.tables ?? []).filter((entry) => entry?.enabled !== false);
  if (!enabledSources.length) return [];
  const budget = getLootTableRollBudget(draft);
  if (budget <= 0) return [];
  const sources = shuffleArray(enabledSources, randomContext?.random ?? Math.random).slice(0, budget);
  const rolls = [];
  for (const source of sources) {
    try {
      const tableDoc = await resolveLootTableFromSource(source, randomContext);
      if (!tableDoc) {
        warnings.push(`Table source unavailable: ${source.label || source.id}.`);
        continue;
      }
      const rolled = await rollLootTableDry(tableDoc, randomContext);
      if (!rolled) continue;
      rolls.push({
        sourceLabel: String(source.label ?? source.id ?? "Roll Table Source"),
        sourceType: String(source.tableType ?? "currency"),
        ...rolled
      });
    } catch (error) {
      logLootBuilderFailure("buildLootTableRolls.source", error, {
        sourceId: source?.id,
        sourceLabel: source?.label,
        mode: draft?.mode,
        challenge: draft?.challenge
      });
      warnings.push(`Failed to roll table source: ${source?.label || source?.id || "Unknown source"}.`);
    }
  }
  return rolls;
}

async function generateLootPreviewPayload(draftInput = {}) {
  try {
    const draft = normalizeLootPreviewDraft(draftInput);
    logLootBuilderDebug("generateLootPreviewPayload start", {
      mode: draft.mode,
      challenge: draft.challenge,
      profile: draft.profile,
      scale: draft.scale,
      creatures: draft.creatures,
      deterministic: draft.deterministic,
      seed: draft.seed
    });
    const sourceConfig = getLootSourceConfig();
    const warnings = [];
    const previewBudgetContext = buildLootValueBudgetContext(draft, 0);
    const randomContext = buildLootRandomContext(draft, previewBudgetContext);
    const currency = await rollLootCurrency(draft, randomContext);
    const candidates = await buildLootItemCandidates(sourceConfig, draft, warnings);
    const desiredItemCount = previewBudgetContext?.targetCount ?? getLootItemCount(draft) ?? 1;
    const itemCountTarget = Math.max(1, Number(desiredItemCount));
    const selectedItems = pickLootItemsFromCandidates(candidates, itemCountTarget, draft, {
      budgetContext: previewBudgetContext,
      randomContext
    });
    const selectionMeta = (Array.isArray(selectedItems) && selectedItems.__meta && typeof selectedItems.__meta === "object")
      ? selectedItems.__meta
      : null;
    const items = selectedItems.map((entry) => ({
      id: foundry.utils.randomID(),
      ...entry
    }));
    const resolvedSelectionMeta = selectionMeta ?? {
      deterministic: Boolean(randomContext?.deterministic),
      seed: String(randomContext?.seed ?? ""),
      desiredItemCount: itemCountTarget,
      maxItems: Math.max(itemCountTarget, Number(previewBudgetContext?.maxItems ?? itemCountTarget) || itemCountTarget),
      encounterTargetGp: Number(previewBudgetContext?.effectiveTotalTargetGp ?? 0),
      finalItemsValueGp: Number(items.reduce((sum, entry) => sum + Math.max(0, Number(entry?.itemValueGp ?? 0) || 0), 0).toFixed(2)),
      deltaGp: 0,
      toleranceGp: Number(previewBudgetContext?.toleranceGp ?? 0),
      tolerancePercent: Number(previewBudgetContext?.tolerancePercent ?? 0),
      strictnessBandLabel: String(previewBudgetContext?.strictnessBandLabel ?? "Normal"),
      strictnessBandKey: String(previewBudgetContext?.strictnessBandKey ?? "normal"),
      candidateCount: candidates.length,
      diagnostics: []
    };
    resolvedSelectionMeta.deltaGp = Number((resolvedSelectionMeta.finalItemsValueGp - resolvedSelectionMeta.encounterTargetGp).toFixed(2));
    const tableRolls = await buildLootTableRolls(sourceConfig, draft, warnings, randomContext);
    if (candidates.length === 0) warnings.push("No eligible item candidates were found for current source/filter settings.");
    const seenDiagnostics = new Set();
    for (const note of (resolvedSelectionMeta.diagnostics ?? [])) {
      const text = String(note ?? "").trim();
      if (!text) continue;
      const key = text.toLowerCase();
      if (seenDiagnostics.has(key)) continue;
      seenDiagnostics.add(key);
      warnings.push(`Budget note: ${text}`);
    }
    logLootBuilderDebug("builder generation summary", {
      encounterTargetGp: resolvedSelectionMeta.encounterTargetGp,
      creatureCount: draft.creatures,
      desiredItemCount: resolvedSelectionMeta.desiredItemCount,
      maxItems: resolvedSelectionMeta.maxItems,
      strictnessBand: resolvedSelectionMeta.strictnessBandLabel,
      strictnessToleranceGp: resolvedSelectionMeta.toleranceGp,
      candidateCount: candidates.length,
      finalItemsValueGp: resolvedSelectionMeta.finalItemsValueGp,
      deltaGp: resolvedSelectionMeta.deltaGp,
      deterministic: resolvedSelectionMeta.deterministic,
      seed: resolvedSelectionMeta.seed
    });
    return {
      generatedAt: Date.now(),
      generatedBy: String(game.user?.name ?? "GM"),
      draft,
      currency,
      items,
      tableRolls,
      stats: {
        candidateCount: candidates.length,
        itemCountTarget,
        itemCountGenerated: items.length,
        tableRollCount: tableRolls.length,
        creatureCount: Math.max(1, Number(draft?.creatures ?? draft?.actorCount ?? 1) || 1),
        enabledItemSources: (sourceConfig.packs ?? []).filter((entry) => entry?.enabled !== false).length,
        enabledTableSources: (sourceConfig.tables ?? []).filter((entry) => entry?.enabled !== false).length,
        desiredItemCount: Math.max(0, Number(resolvedSelectionMeta.desiredItemCount ?? itemCountTarget) || itemCountTarget),
        maxItems: Math.max(0, Number(resolvedSelectionMeta.maxItems ?? itemCountTarget) || itemCountTarget),
        encounterTargetGp: Number(resolvedSelectionMeta.encounterTargetGp ?? 0),
        finalItemsValueGp: Number(resolvedSelectionMeta.finalItemsValueGp ?? 0),
        deltaGp: Number(resolvedSelectionMeta.deltaGp ?? 0),
        strictnessToleranceGp: Number(resolvedSelectionMeta.toleranceGp ?? 0),
        strictnessTolerancePercent: Number(resolvedSelectionMeta.tolerancePercent ?? 0),
        strictnessBandLabel: String(resolvedSelectionMeta.strictnessBandLabel ?? "Normal"),
        deterministic: Boolean(resolvedSelectionMeta.deterministic),
        seed: String(resolvedSelectionMeta.seed ?? "")
      },
      warnings
    };
  } catch (error) {
    logLootBuilderFailure("generateLootPreviewPayload", error, {
      mode: draftInput?.mode,
      challenge: draftInput?.challenge,
      profile: draftInput?.profile,
      scale: draftInput?.scale,
      creatures: draftInput?.creatures ?? draftInput?.actorCount,
      deterministic: draftInput?.deterministic,
      seed: draftInput?.seed
    });
    return {
      generatedAt: Date.now(),
      generatedBy: String(game.user?.name ?? "GM"),
      draft: normalizeLootPreviewDraft(draftInput),
      currency: { pp: 0, gp: 0, sp: 0, cp: 0, gpEquivalent: 0, formula: "n/a" },
      items: [],
      tableRolls: [],
      stats: {
        candidateCount: 0,
        itemCountTarget: 0,
        itemCountGenerated: 0,
        tableRollCount: 0,
        creatureCount: Math.max(1, Number(draftInput?.creatures ?? draftInput?.actorCount ?? 1) || 1),
        enabledItemSources: 0,
        enabledTableSources: 0,
        desiredItemCount: 0,
        maxItems: 0,
        encounterTargetGp: 0,
        finalItemsValueGp: 0,
        deltaGp: 0,
        strictnessToleranceGp: 0,
        strictnessTolerancePercent: 0,
        strictnessBandLabel: "Normal",
        deterministic: true,
        seed: ""
      },
      warnings: ["Loot builder failed to generate. Check browser console for details."]
    };
  }
}

function getLootEngineRarityWeights() {
  const config = getPartyOpsConfigSetting();
  const rarityWeights = config?.rarityWeights ?? {};
  return {
    common: Math.max(0.01, Number(rarityWeights.common ?? 1) || 1),
    uncommon: Math.max(0.01, Number(rarityWeights.uncommon ?? 1) || 1),
    rare: Math.max(0.01, Number(rarityWeights.rare ?? 1) || 1),
    "very-rare": Math.max(0.01, Number(rarityWeights.veryRare ?? rarityWeights["very-rare"] ?? 1) || 1),
    legendary: Math.max(0.01, Number(rarityWeights.legendary ?? 1) || 1)
  };
}

function estimateSuggestedLootGold(cr = 1, target = "pocket", scarcity = LOOT_SCARCITY_LEVELS.NORMAL) {
  const safeCr = Math.max(0, Math.floor(Number(cr) || 0));
  const base = target === "horde"
    ? (35 + (safeCr * 42) + Math.floor((safeCr * safeCr) * 8.5))
    : (8 + (safeCr * 14) + Math.floor((safeCr * safeCr) * 1.8));
  const scarcityMultiplier = scarcity === LOOT_SCARCITY_LEVELS.ABUNDANT
    ? 1.25
    : scarcity === LOOT_SCARCITY_LEVELS.SCARCE
      ? 0.75
      : 1;
  const config = getPartyOpsConfigSetting();
  const configMultiplier = Math.max(0.1, Number(config?.crGoldMultiplier ?? 1) || 1);
  const variance = (target === "horde" ? (80 + Math.floor(Math.random() * 51)) : (85 + Math.floor(Math.random() * 36))) / 100;
  return Math.max(0, Math.round(base * scarcityMultiplier * configMultiplier * variance));
}

function estimateSuggestedLootItemCount(cr = 1, target = "pocket", scarcity = LOOT_SCARCITY_LEVELS.NORMAL) {
  const safeCr = Math.max(0, Math.floor(Number(cr) || 0));
  const base = target === "horde"
    ? Math.max(1, Math.floor(safeCr / 5) + 1)
    : Math.max(0, Math.floor((safeCr - 1) / 8));
  const variance = target === "horde" ? Math.floor(Math.random() * 3) : Math.floor(Math.random() * 2);
  const scarcityMultiplier = scarcity === LOOT_SCARCITY_LEVELS.ABUNDANT
    ? 1.25
    : scarcity === LOOT_SCARCITY_LEVELS.SCARCE
      ? 0.75
      : 1;
  return Math.max(0, Math.round((base + variance) * scarcityMultiplier));
}

async function generateLootFromPackIds(packIds = [], input = {}, options = {}) {
  try {
    const normalizedPackIds = [...new Set(
      (Array.isArray(packIds) ? packIds : [])
        .map((entry) => String(entry ?? "").trim())
        .filter(Boolean)
    )];

    const target = String(input?.target ?? "pocket").trim().toLowerCase() === "horde" ? "horde" : "pocket";
    const config = getPartyOpsConfigSetting();
    const scarcityRaw = String(input?.scarcity ?? config?.lootScarcity ?? LOOT_SCARCITY_LEVELS.NORMAL).trim().toLowerCase();
    const scarcity = scarcityRaw === LOOT_SCARCITY_LEVELS.ABUNDANT || scarcityRaw === LOOT_SCARCITY_LEVELS.SCARCE
      ? scarcityRaw
      : LOOT_SCARCITY_LEVELS.NORMAL;
    const cr = Math.max(0, Math.floor(Number(input?.cr ?? 1) || 1));

    logLootBuilderDebug("generateLootFromPackIds start", {
      packCount: normalizedPackIds.length,
      target,
      scarcity,
      cr,
      deterministic: input?.deterministic !== false,
      seed: String(input?.seed ?? "").trim()
    });

    const gold = estimateSuggestedLootGold(cr, target, scarcity);
    const desiredItemCount = estimateSuggestedLootItemCount(cr, target, scarcity);
    if (normalizedPackIds.length === 0 || desiredItemCount <= 0) {
      return { gold, items: [] };
    }

    const sourceFilter = {
      typeWhitelist: Array.isArray(options?.typeWhitelist) ? options.typeWhitelist : undefined,
      nameIncludes: Array.isArray(options?.nameIncludes) ? options.nameIncludes : undefined,
      rarityKeywords: Array.isArray(options?.rarityKeywords) ? options.rarityKeywords : undefined
    };

    const candidates = [];
    for (const packId of normalizedPackIds) {
      const sourceItems = await loadItemsFromPack(packId, {
        sourceLabel: packId,
        warnings: []
      });
      const filteredItems = filterItems(sourceItems, sourceFilter);
      for (const item of filteredItems) {
        const candidate = buildLootCandidateFromSourceItem(item, {
          sourceId: packId,
          sourceLabel: packId,
          sourceWeight: 1,
          fallbackUuidPrefix: `Compendium.${packId}`
        }, {
          profile: "standard",
          mode: target,
          challenge: cr <= 4 ? "low" : cr <= 10 ? "mid" : cr <= 16 ? "high" : "epic"
        }, {
          includeTags: [],
          excludeTags: [],
          floor: "",
          ceiling: ""
        });
        if (!candidate) continue;
        candidates.push(candidate);
      }
    }

    if (candidates.length === 0) return { gold, items: [] };

    const challengeBucket = cr <= 4 ? "low" : cr <= 10 ? "mid" : cr <= 16 ? "high" : "epic";
    const creatures = Math.max(1, Number(input?.creatures ?? input?.actorCount ?? 1) || 1);
    const selectionDraft = {
      mode: target === "horde" ? "horde" : "defeated",
      challenge: challengeBucket,
      profile: String(input?.profile ?? "standard"),
      scale: String(input?.scale ?? "medium"),
      creatures,
      valueBudgetScalar: Number(input?.valueBudgetScalar ?? LOOT_PREVIEW_DEFAULT_VALUE_BUDGET_SCALAR),
      valueStrictness: Number(input?.valueStrictness ?? LOOT_PREVIEW_DEFAULT_VALUE_STRICTNESS),
      maxItemValueGp: Number(input?.maxItemValueGp ?? 0),
      targetItemsValueGp: Number(input?.targetItemsValueGp ?? 0),
      itemScalar: Number(input?.itemScalar ?? 100),
      deterministic: shouldUseDeterministicLootRng(input),
      seed: String(input?.seed ?? "").trim(),
      dateBucket: String(input?.dateBucket ?? "").trim()
    };
    const valueBudgetContext = buildLootValueBudgetContext(selectionDraft, desiredItemCount);
    const randomContext = buildLootRandomContext(selectionDraft, valueBudgetContext);
    const manualCapGp = Math.max(0, Number(valueBudgetContext?.manualMaxItemValueGp ?? 0) || 0);
    const selectionCandidates = manualCapGp > 0
      ? candidates.filter((entry) => Math.max(0, Number(entry?.itemValueGp ?? 0) || 0) <= manualCapGp)
      : candidates;
    if (!selectionCandidates.length) return { gold, items: [] };
    const pickedItems = pickLootItemsFromCandidates(selectionCandidates, desiredItemCount, selectionDraft, {
      budgetContext: valueBudgetContext,
      randomContext
    });
    const selected = new Map();
    for (const picked of pickedItems) {
      const uuid = String(picked?.uuid ?? "").trim();
      const name = String(picked?.name ?? "Item").trim() || "Item";
      if (!uuid) continue;
      const current = selected.get(uuid);
      if (!current) selected.set(uuid, { uuid, name, qty: 1 });
      else {
        current.qty += 1;
        selected.set(uuid, current);
      }
    }

    return {
      gold,
      items: Array.from(selected.values())
    };
  } catch (error) {
    logLootBuilderFailure("generateLootFromPackIds", error, {
      packCount: Array.isArray(packIds) ? packIds.length : 0,
      target: input?.target,
      scarcity: input?.scarcity,
      cr: input?.cr,
      creatures: input?.creatures ?? input?.actorCount,
      deterministic: input?.deterministic,
      seed: input?.seed
    });
    return {
      gold: 0,
      items: []
    };
  }
}

function buildLootPreviewContext() {
  const draft = getLootPreviewDraft();
  const result = getLootPreviewResult();
  const hasResult = Boolean(result && typeof result === "object");
  const mode = String(draft.mode ?? "horde");
  const profile = String(draft.profile ?? "standard");
  const challenge = String(draft.challenge ?? "mid");
  const scale = String(draft.scale ?? "medium");
  const itemCountTarget = getLootItemCount(draft);
  const valueBudgetContext = buildLootValueBudgetContext(draft, itemCountTarget);
  const generatedAt = Number(result?.generatedAt ?? 0);
  const generatedAtLabel = generatedAt > 0 ? new Date(generatedAt).toLocaleString() : "-";
  return {
    draft,
    modeOptions: LOOT_PREVIEW_MODE_OPTIONS.map((entry) => ({ ...entry, selected: entry.value === mode })),
    profileOptions: LOOT_PREVIEW_PROFILE_OPTIONS.map((entry) => ({ ...entry, selected: entry.value === profile })),
    challengeOptions: LOOT_PREVIEW_CHALLENGE_OPTIONS.map((entry) => ({ ...entry, selected: entry.value === challenge })),
    scaleOptions: LOOT_PREVIEW_SCALE_OPTIONS.map((entry) => ({ ...entry, selected: entry.value === scale })),
    budget: {
      targetPerItemGp: Number(valueBudgetContext.targetPerItemGp ?? 0),
      totalBudgetGp: Number(valueBudgetContext.totalBudgetGp ?? 0),
      autoTotalTargetGp: Number(valueBudgetContext.autoTotalTargetGp ?? 0),
      manualTotalTargetGp: Number(valueBudgetContext.manualTotalTargetGp ?? 0),
      effectiveTotalTargetGp: Number(valueBudgetContext.effectiveTotalTargetGp ?? 0),
      targetValueRangeMinGp: Number(valueBudgetContext.targetValueRangeMinGp ?? 0),
      targetValueRangeMaxGp: Number(valueBudgetContext.targetValueRangeMaxGp ?? 0),
      toleranceGp: Number(valueBudgetContext.toleranceGp ?? 0),
      tolerancePercent: Number(valueBudgetContext.tolerancePercent ?? 0),
      strictnessBandLabel: String(valueBudgetContext.strictnessBandLabel ?? "Normal"),
      desiredItemCount: Math.max(0, Number(valueBudgetContext.targetCount ?? 0) || 0),
      maxItems: Math.max(0, Number(valueBudgetContext.maxItems ?? 0) || 0),
      usingManualTotalTarget: Number(valueBudgetContext.manualTotalTargetGp ?? 0) > 0,
      autoMaxItemValueGp: Number(valueBudgetContext.autoMaxItemValueGp ?? 0),
      manualMaxItemValueGp: Number(valueBudgetContext.manualMaxItemValueGp ?? 0),
      effectiveMaxItemValueGp: Number(valueBudgetContext.effectiveMaxItemValueGp ?? 0),
      usingManualCap: Number(valueBudgetContext.manualMaxItemValueGp ?? 0) > 0
    },
    hasResult,
    generatedAtLabel,
    generatedBy: String(result?.generatedBy ?? "GM"),
    currency: {
      pp: Math.max(0, Number(result?.currency?.pp ?? 0) || 0),
      gp: Math.max(0, Number(result?.currency?.gp ?? 0) || 0),
      sp: Math.max(0, Number(result?.currency?.sp ?? 0) || 0),
      cp: Math.max(0, Number(result?.currency?.cp ?? 0) || 0),
      gpEquivalent: Math.max(0, Number(result?.currency?.gpEquivalent ?? 0) || 0),
      formula: String(result?.currency?.formula ?? "")
    },
    stats: {
      candidateCount: Math.max(0, Number(result?.stats?.candidateCount ?? 0) || 0),
      itemCountTarget: Math.max(0, Number(result?.stats?.itemCountTarget ?? 0) || 0),
      itemCountGenerated: Math.max(0, Number(result?.stats?.itemCountGenerated ?? 0) || 0),
      tableRollCount: Math.max(0, Number(result?.stats?.tableRollCount ?? 0) || 0),
      enabledItemSources: Math.max(0, Number(result?.stats?.enabledItemSources ?? 0) || 0),
      enabledTableSources: Math.max(0, Number(result?.stats?.enabledTableSources ?? 0) || 0),
      desiredItemCount: Math.max(0, Number(result?.stats?.desiredItemCount ?? valueBudgetContext.targetCount ?? 0) || 0),
      maxItems: Math.max(0, Number(result?.stats?.maxItems ?? valueBudgetContext.maxItems ?? 0) || 0),
      encounterTargetGp: Number(result?.stats?.encounterTargetGp ?? valueBudgetContext.effectiveTotalTargetGp ?? 0),
      finalItemsValueGp: Number(result?.stats?.finalItemsValueGp ?? 0),
      deltaGp: Number(result?.stats?.deltaGp ?? 0),
      strictnessToleranceGp: Number(result?.stats?.strictnessToleranceGp ?? valueBudgetContext.toleranceGp ?? 0),
      strictnessTolerancePercent: Number(result?.stats?.strictnessTolerancePercent ?? valueBudgetContext.tolerancePercent ?? 0),
      strictnessBandLabel: String(result?.stats?.strictnessBandLabel ?? valueBudgetContext.strictnessBandLabel ?? "Normal"),
      deterministic: Boolean(result?.stats?.deterministic ?? draft?.deterministic !== false),
      seed: String(result?.stats?.seed ?? "")
    },
    items: Array.isArray(result?.items)
      ? result.items.map((entry, index) => ({
        id: String(entry?.id ?? `${String(entry?.uuid ?? "").trim() || String(entry?.name ?? "item").trim() || "item"}-${index}`),
        uuid: String(entry?.uuid ?? "").trim(),
        name: String(entry?.name ?? "Item"),
        itemType: String(entry?.itemType ?? ""),
        rarity: String(entry?.rarity ?? ""),
        sourceLabel: String(entry?.sourceLabel ?? ""),
        hasRarity: String(entry?.rarity ?? "").trim().length > 0,
        canOpen: String(entry?.uuid ?? "").trim().length > 0
      }))
      : [],
    tableRolls: Array.isArray(result?.tableRolls)
      ? result.tableRolls.map((entry) => ({
        sourceLabel: String(entry?.sourceLabel ?? "Source"),
        sourceType: String(entry?.sourceType ?? "currency"),
        tableName: String(entry?.tableName ?? "Roll Table"),
        formula: String(entry?.formula ?? ""),
        total: Math.max(0, Number(entry?.total ?? 0) || 0),
        result: String(entry?.result ?? "No result")
      }))
      : [],
    warnings: Array.isArray(result?.warnings)
      ? result.warnings.map((entry) => String(entry ?? "").trim()).filter(Boolean)
      : []
  };
}

function buildLootClaimsContext(user = game.user) {
  const ledger = getOperationsLedger();
  const claims = ensureLootClaimsState(ledger);
  const boards = Array.isArray(claims.boards) ? claims.boards : [];
  const openBoards = boards
    .filter((entry) => String(entry?.status ?? "open") !== "archived")
    .sort((a, b) => Number(b?.publishedAt ?? 0) - Number(a?.publishedAt ?? 0));
  const archivedBoards = boards
    .filter((entry) => String(entry?.status ?? "open") === "archived");
  const boardById = new Map(boards.map((entry) => [String(entry?.id ?? ""), entry]));
  const storedRunId = getLootClaimRunSelection();
  const fallbackRunId = normalizeLootClaimRunId(claims.activeBoardId) || String(openBoards[0]?.id ?? "") || String(archivedBoards[0]?.id ?? "");
  const selectedRunId = boardById.has(storedRunId) ? storedRunId : fallbackRunId;
  if (storedRunId !== selectedRunId) setLootClaimRunSelection(selectedRunId);
  const selectedRun = boardById.get(selectedRunId) ?? null;
  const displayRun = selectedRun ?? openBoards[0] ?? archivedBoards[0] ?? null;
  const displayRunId = normalizeLootClaimRunId(displayRun?.id);
  const displayRunStatus = String(displayRun?.status ?? "open");
  const displayRunIsArchived = displayRunStatus === "archived";
  if (displayRunId && displayRunId !== selectedRunId) setLootClaimRunSelection(displayRunId);

  const formatTimestampLabel = (timestampInput, fallbackLabel = "-") => {
    const timestamp = Math.max(0, Number(timestampInput ?? 0) || 0);
    return timestamp > 0 ? new Date(timestamp).toLocaleString() : fallbackLabel;
  };

  const mapRunCard = (run) => {
    const id = normalizeLootClaimRunId(run?.id);
    const status = String(run?.status ?? "open") === "archived" ? "archived" : "open";
    const currencyRemaining = run?.currencyRemaining ?? run?.currency ?? {};
    const hasCurrencyRemaining = ["pp", "gp", "sp", "cp"].some((denom) => {
      return Math.max(0, Math.floor(Number(currencyRemaining?.[denom] ?? 0) || 0)) > 0;
    });
    const itemCount = Array.isArray(run?.items) ? run.items.length : 0;
    const claimsLogCount = Array.isArray(run?.claimsLog) ? run.claimsLog.length : 0;
    const contestedItemCount = Array.isArray(run?.items)
      ? run.items.filter((item) => Array.isArray(item?.vouchedByActorIds) && item.vouchedByActorIds.length > 1).length
      : 0;
    const majorItemCount = Array.isArray(run?.items)
      ? run.items.filter((item) => Boolean(item?.majorItem)).length
      : 0;
    return {
      id,
      selected: id === displayRunId,
      status,
      isOpen: status === "open",
      isArchived: status === "archived",
      statusLabel: status === "archived" ? "Archived" : "Open",
      publishedAt: Math.max(0, Number(run?.publishedAt ?? 0) || 0),
      publishedAtLabel: formatTimestampLabel(run?.publishedAt),
      publishedBy: String(run?.publishedBy ?? "").trim() || "GM",
      archivedAt: Math.max(0, Number(run?.archivedAt ?? 0) || 0),
      archivedAtLabel: formatTimestampLabel(run?.archivedAt, "Not archived"),
      archivedBy: String(run?.archivedBy ?? "").trim() || "GM",
      itemCount,
      claimsLogCount,
      contestedItemCount,
      majorItemCount,
      hasContestedItems: contestedItemCount > 0,
      hasMajorItems: majorItemCount > 0,
      hasCurrencyRemaining,
      currencyRemaining: {
        pp: Math.max(0, Math.floor(Number(currencyRemaining?.pp ?? 0) || 0)),
        gp: Math.max(0, Math.floor(Number(currencyRemaining?.gp ?? 0) || 0)),
        sp: Math.max(0, Math.floor(Number(currencyRemaining?.sp ?? 0) || 0)),
        cp: Math.max(0, Math.floor(Number(currencyRemaining?.cp ?? 0) || 0))
      },
      currencyRemainingLabel: formatLootCurrencyRemainingLabel(currencyRemaining),
      tableRollCount: Array.isArray(run?.tableRolls) ? run.tableRolls.length : 0
    };
  };

  const archiveSort = getLootClaimsArchiveSort();
  const sortedArchivedBoards = [...archivedBoards].sort((left, right) => {
    const leftArchivedAt = Math.max(0, Number(left?.archivedAt ?? 0) || 0);
    const rightArchivedAt = Math.max(0, Number(right?.archivedAt ?? 0) || 0);
    const leftPublishedAt = Math.max(0, Number(left?.publishedAt ?? 0) || 0);
    const rightPublishedAt = Math.max(0, Number(right?.publishedAt ?? 0) || 0);
    const leftItemCount = Array.isArray(left?.items) ? left.items.length : 0;
    const rightItemCount = Array.isArray(right?.items) ? right.items.length : 0;
    switch (archiveSort) {
      case "archived-asc":
        return leftArchivedAt - rightArchivedAt;
      case "published-desc":
        return rightPublishedAt - leftPublishedAt;
      case "published-asc":
        return leftPublishedAt - rightPublishedAt;
      case "items-desc":
        return rightItemCount - leftItemCount;
      case "items-asc":
        return leftItemCount - rightItemCount;
      case "archived-desc":
      default:
        return rightArchivedAt - leftArchivedAt;
    }
  });

  const publishedAt = Number(displayRun?.publishedAt ?? claims.publishedAt ?? 0);
  const publishedAtLabel = publishedAt > 0 ? new Date(publishedAt).toLocaleString() : "-";
  const selectableActors = getDowntimeSelectableActorsForUser(user);
  const actorOptions = selectableActors.map((actor) => ({
    id: String(actor.id),
    name: String(actor.name ?? `Actor ${actor.id}`),
    selected: false
  }));
  const storedActorId = getLootClaimActorSelection();
  const preferredActorId = storedActorId || String(user?.character?.id ?? "").trim();
  const fallbackActorId = actorOptions[0]?.id ?? "";
  const selectedActorId = actorOptions.find((entry) => entry.id === preferredActorId)?.id ?? fallbackActorId;
  for (const option of actorOptions) option.selected = option.id === selectedActorId;
  if (!storedActorId || storedActorId !== selectedActorId) {
    setLootClaimActorSelection(selectedActorId);
  }
  const selectedActorName = actorOptions.find((entry) => entry.id === selectedActorId)?.name ?? "";
  const ownedPcActors = getOwnedPcActors();
  const eligibleActorIds = new Set(ownedPcActors.map((actor) => String(actor?.id ?? "").trim()).filter(Boolean));
  const actorNameById = new Map(ownedPcActors.map((actor) => [String(actor?.id ?? "").trim(), String(actor?.name ?? `Actor ${actor?.id ?? ""}`).trim() || `Actor ${actor?.id ?? ""}`]));
  const displayCurrencyClaimedActorIds = Array.isArray(displayRun?.currencyClaimedActorIds)
    ? displayRun.currencyClaimedActorIds
    : [];
  const claimedActorIds = new Set(displayCurrencyClaimedActorIds.map((entry) => String(entry ?? "").trim()).filter(Boolean));
  const selectedActorClaimedCurrency = claimedActorIds.has(selectedActorId);
  const displayCurrency = displayRun?.currency ?? { pp: 0, gp: 0, sp: 0, cp: 0, gpEquivalent: 0 };
  const displayCurrencyRemaining = displayRun?.currencyRemaining ?? displayCurrency;
  const currencyRemaining = {
    pp: Math.max(0, Math.floor(Number(displayCurrencyRemaining?.pp ?? displayCurrency?.pp ?? 0) || 0)),
    gp: Math.max(0, Math.floor(Number(displayCurrencyRemaining?.gp ?? displayCurrency?.gp ?? 0) || 0)),
    sp: Math.max(0, Math.floor(Number(displayCurrencyRemaining?.sp ?? displayCurrency?.sp ?? 0) || 0)),
    cp: Math.max(0, Math.floor(Number(displayCurrencyRemaining?.cp ?? displayCurrency?.cp ?? 0) || 0)),
    gpEquivalent: Math.max(0, Number(displayCurrencyRemaining?.gpEquivalent ?? displayCurrency?.gpEquivalent ?? 0) || 0)
  };
  const hasCurrencyRemaining = currencyRemaining.pp > 0 || currencyRemaining.gp > 0 || currencyRemaining.sp > 0 || currencyRemaining.cp > 0;
  const displayItems = Array.isArray(displayRun?.items) ? displayRun.items : [];
  const displayTableRolls = Array.isArray(displayRun?.tableRolls) ? displayRun.tableRolls : [];
  const displayClaimsLog = Array.isArray(displayRun?.claimsLog) ? displayRun.claimsLog : [];
  const openRunCards = openBoards.map((run) => mapRunCard(run));
  const archivedRunCards = sortedArchivedBoards.map((run) => mapRunCard(run));
  const selectedRunCard = displayRun ? mapRunCard(displayRun) : null;
  const runOptions = [...openBoards, ...sortedArchivedBoards].map((run) => {
    const status = String(run?.status ?? "open") === "archived" ? "archived" : "open";
    const statusLabel = status === "archived" ? "Archived" : "Open";
    const publishedLabel = formatTimestampLabel(run?.publishedAt);
    const itemCount = Array.isArray(run?.items) ? run.items.length : 0;
    return {
      id: String(run?.id ?? ""),
      label: `${publishedLabel} - ${itemCount} item(s) - ${statusLabel}`,
      selected: String(run?.id ?? "") === displayRunId,
      isArchived: status === "archived",
      isOpen: status === "open"
    };
  });
  const archiveSortOptions = LOOT_CLAIMS_ARCHIVE_SORT_OPTIONS.map((entry) => ({
    value: entry.value,
    label: entry.label,
    selected: entry.value === archiveSort
  }));
  const hasSelectedRun = Boolean(displayRun);
  const selectedRunHasItems = displayItems.length > 0;
  const selectedRunClaimsLogCount = displayClaimsLog.length;
  const selectedRunContestedItemCount = displayItems.filter((entry) => Array.isArray(entry?.vouchedByActorIds) && entry.vouchedByActorIds.length > 1).length;
  const canClaimCurrency = hasSelectedRun
    && !displayRunIsArchived
    && Boolean(selectedActorId)
    && eligibleActorIds.has(selectedActorId)
    && hasCurrencyRemaining
    && !selectedActorClaimedCurrency;
  return {
    selectedRunId: displayRunId,
    selectedRunStatus: displayRunStatus,
    selectedRunIsArchived: displayRunIsArchived,
    hasSelectedRun,
    selectedRunCard,
    canArchiveSelectedRun: hasSelectedRun && !displayRunIsArchived,
    hasOpenRuns: openRunCards.length > 0,
    openRunCount: openRunCards.length,
    openRuns: openRunCards,
    hasArchivedRuns: archivedRunCards.length > 0,
    archivedRunCount: archivedRunCards.length,
    archivedRuns: archivedRunCards,
    archiveSort,
    archiveSortOptions,
    runOptions,
    publishedAtLabel,
    publishedBy: String(displayRun?.publishedBy ?? claims.publishedBy ?? "").trim() || "GM",
    hasPublished: publishedAt > 0,
    hasItems: selectedRunHasItems,
    itemCount: displayItems.length,
    claimsLogCount: selectedRunClaimsLogCount,
    currency: foundry.utils.deepClone(displayCurrency),
    currencyRemaining,
    hasCurrencyRemaining,
    selectedActorClaimedCurrency,
    canClaimCurrency,
    currencyClaimedCount: claimedActorIds.size,
    tableRolls: foundry.utils.deepClone(displayTableRolls),
    actorOptions,
    selectedActorId,
    selectedActorName,
    items: displayItems.map((entry) => ({
      ...entry,
      claimRunId: displayRunId,
      hasRarity: entry.rarity.length > 0,
      canOpen: entry.uuid.length > 0,
      isMajorItem: Boolean(entry.majorItem),
      vouchedByActorIds: Array.isArray(entry.vouchedByActorIds) ? entry.vouchedByActorIds : [],
      vouchedByNames: (Array.isArray(entry.vouchedByActorIds) ? entry.vouchedByActorIds : [])
        .map((actorId) => actorNameById.get(String(actorId ?? "").trim()))
        .filter(Boolean),
      voucherCount: Array.isArray(entry.vouchedByActorIds) ? entry.vouchedByActorIds.length : 0,
      hasVouchers: Array.isArray(entry.vouchedByActorIds) && entry.vouchedByActorIds.length > 0,
      selectedActorVouched: Boolean(selectedActorId) && Array.isArray(entry.vouchedByActorIds)
        && entry.vouchedByActorIds.includes(selectedActorId),
      canVouch: !displayRunIsArchived && Boolean(selectedActorId) && eligibleActorIds.has(selectedActorId),
      requiresRollOff: Array.isArray(entry.vouchedByActorIds) && entry.vouchedByActorIds.length > 1,
      canRunRollOff: !displayRunIsArchived && Array.isArray(entry.vouchedByActorIds) && entry.vouchedByActorIds.length > 1,
      canClaimDirect: !displayRunIsArchived && !(Array.isArray(entry.vouchedByActorIds) && entry.vouchedByActorIds.length > 1),
      vouchedByNamesText: (Array.isArray(entry.vouchedByActorIds) ? entry.vouchedByActorIds : [])
        .map((actorId) => actorNameById.get(String(actorId ?? "").trim()))
        .filter(Boolean)
        .join(", ")
    })),
    contestedItemCount: selectedRunContestedItemCount
  };
}

function buildDefaultOperationsLedger() {
  return {
    roles: {
      quartermaster: "",
      cartographer: "",
      chronicler: "",
      steward: ""
    },
    sops: {
      campSetup: false,
      watchRotation: false,
      dungeonBreach: false,
      urbanEntry: false,
      prisonerHandling: false,
      retreatProtocol: false
    },
    sopNotes: {
      campSetup: "",
      watchRotation: "",
      dungeonBreach: "",
      urbanEntry: "",
      prisonerHandling: "",
      retreatProtocol: ""
    },
    communication: {
      silentSignals: "",
      codePhrase: "",
      signalFlare: false,
      signalBell: false,
      preCombatPlan: false
    },
    reputation: {
      factions: getDefaultReputationFactions()
    },
    supplyLines: {
      resupplyRisk: "moderate",
      caravanEscortPlanned: false,
      caches: [],
      safehouses: []
    },
    recon: {
      objective: "",
      region: "",
      intelSource: "",
      heatLevel: "moderate",
      network: "limited",
      rumorReliability: 50,
      bribeBudget: 0,
      spySlots: 0,
      recentFindings: "",
      lastBriefAt: "-",
      lastBriefBy: "-"
    },
    baseOperations: {
      maintenanceRisk: "moderate",
      sites: []
    },
    merchants: {
      currentSettlement: "",
      cityCatalog: [],
      definitions: [],
      stockStateById: {},
      accessLog: []
    },
    downtime: {
      hoursGranted: 4,
      tuning: {
        economy: "standard",
        risk: "standard",
        discovery: "standard"
      },
      entries: {},
      logs: []
    },
    lootClaims: {
      publishedAt: 0,
      publishedBy: "",
      activeBoardId: "",
      boards: [],
      currency: {
        pp: 0,
        gp: 0,
        sp: 0,
        cp: 0,
        gpEquivalent: 0
      },
      currencyRemaining: {
        pp: 0,
        gp: 0,
        sp: 0,
        cp: 0,
        gpEquivalent: 0
      },
      currencyClaimedActorIds: [],
      items: [],
      tableRolls: [],
      claimsLog: []
    },
    environment: {
      presetKey: "none",
      movementDc: 12,
      appliedActorIds: [],
      syncToSceneNonParty: true,
      note: "",
      logs: [],
      failureStreaks: {},
      checkResults: [],
      successiveByPreset: {}
    },
    weather: {
      current: null,
      logs: []
    },
    partyHealth: {
      modifierEnabled: {},
      customModifiers: [],
      stagedModifierQueue: [],
      modifierAddLog: [],
      archivedSyncEffects: [],
      syncToSceneNonParty: true,
      nonPartySyncScope: NON_PARTY_SYNC_SCOPES.SCENE
    },
    resources: {
      food: 14,
      partyFoodRations: 0,
      partyWaterRations: 0,
      water: 14,
      torches: 0,
      stewardPools: {
        food: { mode: STEWARD_POOL_MODES.NONE, amount: 0, source: "" },
        water: { mode: STEWARD_POOL_MODES.NONE, amount: 0, source: "" },
        torches: { mode: STEWARD_POOL_MODES.NONE, amount: 0, source: "" }
      },
      upkeepLastAppliedTs: null,
      gather: {
        weatherMods: {
          clear: 0,
          "light-rain": 2,
          "heavy-rain": 5,
          wind: 2,
          fog: 3,
          extreme: 5
        },
        foodCoverageDueKey: null,
        waterCoverageDueKey: null,
        history: []
      },
      encumbrance: "light",
      upkeep: {
        partySize: 4,
        foodPerMember: 1,
        waterPerMember: 1,
        foodMultiplier: 1,
        waterMultiplier: 1,
        torchPerRest: 0
      }
    }
  };
}

function isLootItemLikelyMajor(entry = {}) {
  const rarity = String(entry?.rarity ?? "").trim().toLowerCase();
  if (!rarity) return false;
  return rarity.includes("rare") || rarity.includes("legendary") || rarity.includes("artifact");
}

function getUpkeepDueCount(timestamp = getCurrentWorldTimestamp()) {
  const worldTs = Number(timestamp);
  if (!Number.isFinite(worldTs)) return 0;
  const duskOffsetSeconds = UPKEEP_DUSK_MINUTES * 60;
  return Math.floor((worldTs - duskOffsetSeconds) / 86400);
}

function getNextUpkeepDueKey(timestamp = getCurrentWorldTimestamp()) {
  return getUpkeepDueCount(timestamp) + 1;
}

function getUpkeepDaysFromCalendar(lastAppliedTimestamp, currentTimestamp = getCurrentWorldTimestamp()) {
  const now = Number(currentTimestamp);
  const last = Number(lastAppliedTimestamp);
  if (!Number.isFinite(now)) return 0;
  if (!Number.isFinite(last)) return 0;
  const nowDue = getUpkeepDueCount(now);
  const lastDue = getUpkeepDueCount(last);
  return Math.max(0, nowDue - lastDue);
}

function getOperationsLedger() {
  const stored = game.settings.get(MODULE_ID, SETTINGS.OPS_LEDGER);
  const defaults = buildDefaultOperationsLedger();
  const merged = foundry.utils.mergeObject(defaults, stored ?? {}, {
    inplace: false,
    insertKeys: true,
    insertValues: true
  });

  const ensureObject = (value, fallback) => {
    if (value && typeof value === "object" && !Array.isArray(value)) return value;
    return foundry.utils.deepClone(fallback);
  };

  merged.roles = ensureObject(merged.roles, defaults.roles);
  merged.sops = ensureObject(merged.sops, defaults.sops);
  merged.sopNotes = ensureObject(merged.sopNotes, defaults.sopNotes);
  merged.communication = ensureObject(merged.communication, defaults.communication);
  merged.reputation = ensureObject(merged.reputation, defaults.reputation);
  merged.supplyLines = ensureObject(merged.supplyLines, defaults.supplyLines);
  merged.recon = ensureObject(merged.recon, defaults.recon);
  merged.baseOperations = ensureObject(merged.baseOperations, defaults.baseOperations);
  merged.merchants = ensureObject(merged.merchants, defaults.merchants);
  merged.downtime = ensureObject(merged.downtime, defaults.downtime);
  merged.lootClaims = ensureObject(merged.lootClaims, defaults.lootClaims);
  merged.environment = ensureObject(merged.environment, defaults.environment);
  merged.weather = ensureObject(merged.weather, defaults.weather);
  merged.partyHealth = ensureObject(merged.partyHealth, defaults.partyHealth);
  merged.resources = ensureObject(merged.resources, defaults.resources);

  merged.reputation.factions = Array.isArray(merged.reputation.factions)
    ? merged.reputation.factions
    : foundry.utils.deepClone(defaults.reputation.factions);
  merged.supplyLines.caches = Array.isArray(merged.supplyLines.caches) ? merged.supplyLines.caches : [];
  merged.supplyLines.safehouses = Array.isArray(merged.supplyLines.safehouses) ? merged.supplyLines.safehouses : [];
  merged.baseOperations.sites = Array.isArray(merged.baseOperations.sites) ? merged.baseOperations.sites : [];
  merged.downtime.logs = Array.isArray(merged.downtime.logs) ? merged.downtime.logs : [];
  merged.lootClaims.boards = Array.isArray(merged.lootClaims.boards) ? merged.lootClaims.boards : [];
  merged.lootClaims.activeBoardId = normalizeLootClaimRunId(merged.lootClaims.activeBoardId);
  merged.lootClaims.items = Array.isArray(merged.lootClaims.items) ? merged.lootClaims.items : [];
  merged.lootClaims.tableRolls = Array.isArray(merged.lootClaims.tableRolls) ? merged.lootClaims.tableRolls : [];
  merged.lootClaims.claimsLog = Array.isArray(merged.lootClaims.claimsLog) ? merged.lootClaims.claimsLog : [];
  merged.lootClaims.currencyClaimedActorIds = Array.isArray(merged.lootClaims.currencyClaimedActorIds)
    ? merged.lootClaims.currencyClaimedActorIds
    : [];
  merged.environment.logs = Array.isArray(merged.environment.logs) ? merged.environment.logs : [];
  merged.environment.checkResults = Array.isArray(merged.environment.checkResults) ? merged.environment.checkResults : [];
  merged.weather.logs = Array.isArray(merged.weather.logs) ? merged.weather.logs : [];
  merged.partyHealth.customModifiers = Array.isArray(merged.partyHealth.customModifiers) ? merged.partyHealth.customModifiers : [];
  merged.partyHealth.stagedModifierQueue = Array.isArray(merged.partyHealth.stagedModifierQueue)
    ? merged.partyHealth.stagedModifierQueue
    : [];
  merged.partyHealth.modifierAddLog = Array.isArray(merged.partyHealth.modifierAddLog)
    ? merged.partyHealth.modifierAddLog
    : [];
  merged.partyHealth.archivedSyncEffects = Array.isArray(merged.partyHealth.archivedSyncEffects)
    ? merged.partyHealth.archivedSyncEffects
    : [];

  merged.resources.gather = ensureObject(merged.resources.gather, defaults.resources.gather);
  merged.resources.gather.weatherMods = ensureObject(merged.resources.gather.weatherMods, defaults.resources.gather.weatherMods);
  merged.resources.upkeep = ensureObject(merged.resources.upkeep, defaults.resources.upkeep);
  ensureOperationalResourceConfig(merged.resources);
  ensureMerchantsState(merged);

  return merged;
}

async function updateOperationsLedger(mutator, options = {}) {
  if (typeof mutator !== "function") return;
  try {
    const ledger = getOperationsLedger();
    mutator(ledger);

    if (!game.user?.isGM) {
      game.socket.emit(SOCKET_CHANNEL, {
        type: "ops:ledger-write",
        userId: game.user.id,
        ledger
      });
      return;
    }

    await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.OPS_LEDGER, ledger);
    scheduleIntegrationSync("operations-ledger");
    if (!options.skipLocalRefresh) refreshOpenApps();
    emitSocketRefresh();
  } catch (error) {
    logUiFailure("operations-ledger", "update failed", error, {
      skipLocalRefresh: Boolean(options?.skipLocalRefresh),
      isGM: Boolean(game.user?.isGM)
    });
    throw error;
  }
}

function buildRoleActorOptions(selectedActorId) {
  return game.actors.contents
    .filter((actor) => actor.type === "character" || actor.hasPlayerOwner)
    .sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""))
    .map((actor) => ({
      id: actor.id,
      name: actor.name,
      selected: actor.id === selectedActorId
    }));
}

function getOwnedPcActors() {
  const fromParty = Array.isArray(game.party?.members) ? game.party.members : [];
  const unique = new Map();
  for (const actor of fromParty) {
    if (!actor || actor.type !== "character" || !actor.hasPlayerOwner) continue;
    unique.set(actor.id, actor);
  }
  if (unique.size === 0) {
    for (const actor of game.actors.contents) {
      if (!actor || actor.type !== "character" || !actor.hasPlayerOwner) continue;
      unique.set(actor.id, actor);
    }
  }
  return Array.from(unique.values());
}

function getNeutralFriendlyActors() {
  const dispositions = CONST?.TOKEN_DISPOSITIONS ?? { HOSTILE: -1, NEUTRAL: 0, FRIENDLY: 1 };
  const allowed = new Set([dispositions.NEUTRAL, dispositions.FRIENDLY]);
  const unique = new Map();
  for (const actor of game.actors.contents) {
    if (!actor || actor.type === "character" || actor.hasPlayerOwner) continue;
    const disposition = Number(actor.prototypeToken?.disposition ?? dispositions.NEUTRAL);
    if (!allowed.has(disposition)) continue;
    unique.set(actor.id, actor);
  }
  return Array.from(unique.values()).sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""));
}

function getPartyMemberActorIds() {
  const ids = new Set();
  for (const actor of Array.isArray(game.party?.members) ? game.party.members : []) {
    if (!actor?.id) continue;
    ids.add(String(actor.id));
  }
  for (const actor of getOwnedPcActors()) {
    if (!actor?.id) continue;
    ids.add(String(actor.id));
  }
  return ids;
}

function getSceneNonPartyIntegrationTargets() {
  const scene = game.scenes?.current;
  if (!scene) return [];
  const partyActorIds = getPartyMemberActorIds();
  const unique = new Map();
  for (const tokenDoc of scene.tokens?.contents ?? []) {
    const actor = tokenDoc?.actor;
    if (!actor) continue;
    const actorId = String(actor.id ?? tokenDoc.actorId ?? "").trim();
    if (actorId && partyActorIds.has(actorId)) continue;
    if (actor.hasPlayerOwner) continue;
    const actorUuid = String(actor.uuid ?? "").trim();
    const tokenUuid = String(tokenDoc.uuid ?? "").trim();
    const key = actorUuid || tokenUuid || `${scene.id}:${tokenDoc.id}:${actorId || tokenDoc.id}`;
    if (!key) continue;
    if (!unique.has(key)) {
      unique.set(key, {
        key,
        actor,
        actorName: String(actor.name ?? tokenDoc.name ?? "Unknown Actor").trim() || "Unknown Actor",
        tokenCount: 0,
        tokenNames: []
      });
    }
    const row = unique.get(key);
    row.tokenCount += 1;
    const tokenName = String(tokenDoc.name ?? actor.name ?? "").trim();
    if (tokenName && !row.tokenNames.includes(tokenName)) row.tokenNames.push(tokenName);
  }
  return Array.from(unique.values())
    .map((row) => ({
      actor: row.actor,
      actorRef: String(row.key),
      actorName: row.actorName,
      tokenCount: Math.max(1, Number(row.tokenCount ?? 0) || 1),
      tokenNamesLabel: row.tokenNames.length > 0 ? row.tokenNames.join(", ") : row.actorName
    }))
    .sort((a, b) => a.actorName.localeCompare(b.actorName));
}

function getSceneNonPartyIntegrationActors() {
  return getSceneNonPartyIntegrationTargets()
    .map((entry) => entry.actor)
    .filter(Boolean);
}

function getNonPartySyncScope(rawScope) {
  const value = String(rawScope ?? "").trim().toLowerCase();
  if (value === NON_PARTY_SYNC_SCOPES.WORLD_NON_PARTY) return NON_PARTY_SYNC_SCOPES.WORLD_NON_PARTY;
  if (value === NON_PARTY_SYNC_SCOPES.WORLD_ALL) return NON_PARTY_SYNC_SCOPES.WORLD_ALL;
  return NON_PARTY_SYNC_SCOPES.SCENE;
}

function getNonPartySyncScopeLabel(scope) {
  if (scope === NON_PARTY_SYNC_SCOPES.WORLD_NON_PARTY) return "All Non-Party Monsters (World)";
  if (scope === NON_PARTY_SYNC_SCOPES.WORLD_ALL) return "All Actors (World)";
  return "Non-Party Actors on Current Scene";
}

function getWorldNonPartyIntegrationTargets() {
  const partyActorIds = getPartyMemberActorIds();
  return game.actors.contents
    .filter((actor) => actor && !actor.hasPlayerOwner && !partyActorIds.has(String(actor.id ?? "")))
    .map((actor) => ({
      actor,
      actorRef: String(actor.id ?? ""),
      actorName: String(actor.name ?? "Unknown Actor").trim() || "Unknown Actor",
      tokenCount: 0,
      tokenNamesLabel: "Not on active scene",
      isSceneTarget: false
    }))
    .sort((a, b) => a.actorName.localeCompare(b.actorName));
}

function getWorldAllIntegrationTargets() {
  return game.actors.contents
    .filter((actor) => Boolean(actor))
    .map((actor) => ({
      actor,
      actorRef: String(actor.id ?? ""),
      actorName: String(actor.name ?? "Unknown Actor").trim() || "Unknown Actor",
      tokenCount: 0,
      tokenNamesLabel: "Not on active scene",
      isSceneTarget: false
    }))
    .sort((a, b) => a.actorName.localeCompare(b.actorName));
}

function getNonPartyIntegrationTargets(scope = NON_PARTY_SYNC_SCOPES.SCENE) {
  const normalizedScope = getNonPartySyncScope(scope);
  if (normalizedScope === NON_PARTY_SYNC_SCOPES.WORLD_NON_PARTY) return getWorldNonPartyIntegrationTargets();
  if (normalizedScope === NON_PARTY_SYNC_SCOPES.WORLD_ALL) return getWorldAllIntegrationTargets();
  return getSceneNonPartyIntegrationTargets().map((entry) => ({ ...entry, isSceneTarget: true }));
}

function getNonPartyIntegrationActors(scope = NON_PARTY_SYNC_SCOPES.SCENE) {
  return getNonPartyIntegrationTargets(scope)
    .map((entry) => entry.actor)
    .filter(Boolean);
}

function resolveActorFromReference(actorRef) {
  const ref = String(actorRef ?? "").trim();
  if (!ref) return null;
  if (typeof fromUuidSync === "function" && ref.includes(".")) {
    try {
      const doc = fromUuidSync(ref);
      if (doc && doc.documentName === "Actor") return doc;
      if (doc && doc.documentName === "Token") return doc.actor ?? null;
      if (doc?.actor) return doc.actor;
    } catch {
      // Fall through to actor id lookup.
    }
  }
  return game.actors.get(ref) ?? null;
}

function getIntegrationModeLabel(mode) {
  if (mode === INTEGRATION_MODES.DAE) return "DAE + Flags";
  if (mode === INTEGRATION_MODES.FLAGS) return "Flags Only";
  if (mode === INTEGRATION_MODES.OFF) return "Off";
  return "Auto";
}

function getResourceOwnerActors() {
  return game.actors.contents
    .filter((actor) => actor && (actor.type === "character" || actor.hasPlayerOwner))
    .sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""));
}

function getResourceInventoryItems(actor) {
  if (!actor?.items?.contents) return [];
  return actor.items.contents
    .filter((item) => item && item.type === "consumable" && (item.system?.quantity !== undefined || item.system?.uses?.value !== undefined))
    .sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""));
}

function buildResourceSelectionContext(resourcesState, resourceKey) {
  const selectedActorId = String(resourcesState?.itemSelections?.[resourceKey]?.actorId ?? "");
  const selectedItemId = String(resourcesState?.itemSelections?.[resourceKey]?.itemId ?? "");
  const actors = getResourceOwnerActors();
  const actorOptions = [
    { id: "", name: "None", selected: !selectedActorId },
    ...actors.map((actor) => ({ id: actor.id, name: actor.name, selected: actor.id === selectedActorId }))
  ];

  const selectedActor = selectedActorId ? game.actors.get(selectedActorId) : null;
  const itemOptions = [{ id: "", name: "None", selected: !selectedItemId }];
  if (selectedActor) {
    const items = getResourceInventoryItems(selectedActor);
    for (const item of items) {
      const qty = Math.max(0, Math.floor(getItemTrackedQuantity(item)));
      itemOptions.push({
        id: item.id,
        name: `${item.name} (${qty})`,
        selected: item.id === selectedItemId
      });
    }
  }

  return {
    selectedActorId,
    selectedItemId,
    actorOptions,
    itemOptions,
    hasActor: Boolean(selectedActor)
  };
}

function getSelectedResourceItemQuantity(resourcesState, resourceKey) {
  const actorId = String(resourcesState?.itemSelections?.[resourceKey]?.actorId ?? "");
  const itemId = String(resourcesState?.itemSelections?.[resourceKey]?.itemId ?? "");
  if (!actorId || !itemId) return 0;
  const actor = game.actors.get(actorId);
  const item = actor?.items?.get(itemId);
  if (!item) return 0;
  return Math.max(0, Math.floor(getItemTrackedQuantity(item)));
}

function buildOperationsContext() {
  const ledger = getOperationsLedger();
  const roleMeta = [
    {
      key: "quartermaster",
      label: "Quartermaster",
      bonus: "+Supply discipline",
      penalty: "Missed ration/ammo tracking",
      hint: "Assign this role to keep supply usage, load tracking, and upkeep consistent."
    },
    {
      key: "cartographer",
      label: "Cartographer",
      bonus: "+Route clarity",
      penalty: "Navigation uncertainty",
      hint: "Assign this role to maintain route notes, landmarks, and navigation prep."
    },
    {
      key: "chronicler",
      label: "Chronicler",
      bonus: "+Operational recall",
      penalty: "Lost session intel",
      hint: "Assign this role to track key discoveries, risks, and mission outcomes."
    },
    {
      key: "steward",
      label: "Steward",
      bonus: "+Financial control",
      penalty: "Debt/coin drift",
      hint: "Assign this role to manage coin flow, contracts, and downtime costs."
    }
  ];

  const roles = roleMeta.map((role) => {
    const actorId = ledger.roles?.[role.key] ?? "";
    const actor = actorId ? game.actors.get(actorId) : null;
    return {
      key: role.key,
      label: role.label,
      actorId,
      actorName: actor?.name ?? "Unassigned",
      hasActor: Boolean(actor),
      bonus: role.bonus,
      penalty: role.penalty,
      hint: role.hint,
      actorOptions: buildRoleActorOptions(actorId)
    };
  });

  const sopMeta = [
    { key: "campSetup", label: "Camp setup" },
    { key: "watchRotation", label: "Watch rotation" },
    { key: "dungeonBreach", label: "Dungeon breach protocol" },
    { key: "urbanEntry", label: "Urban entry protocol" },
    { key: "prisonerHandling", label: "Prisoner handling" },
    { key: "retreatProtocol", label: "Retreat protocol" }
  ];

  const sops = sopMeta.map((sop) => ({
    key: sop.key,
    label: sop.label,
    active: Boolean(ledger.sops?.[sop.key]),
    ...(() => {
      const worldNote = String(ledger.sopNotes?.[sop.key] ?? "");
      const resolved = resolveSopNoteForView(sop.key, worldNote);
      return {
        note: resolved.note,
        pendingLocalSync: resolved.pendingSync
      };
    })()
  }));
  schedulePendingSopNoteSync("operations-context");

  const roleCoverage = roles.filter((role) => role.hasActor).length;
  const missingRoles = Math.max(0, roles.length - roleCoverage);
  const activeSops = sops.filter((sop) => sop.active).length;
  const disorderRisk = missingRoles + Math.max(0, 3 - activeSops);
  const effects = getOperationalEffects(ledger, roles, sops);
  const communication = ledger.communication ?? {};
  const communicationReadiness = getCommunicationReadiness(communication);
  const reconState = ensureReconState(ledger);
  const recon = buildReconContext(reconState);
  const reputationState = ensureReputationState(ledger);
  const reputationFilters = getReputationFilterState();
  const reputation = buildReputationContext(reputationState, reputationFilters);
  const partyHealthState = ensurePartyHealthState(ledger);
  const downtimeState = ensureDowntimeState(ledger);
  const downtime = buildDowntimeContext(downtimeState);
  const lootSources = buildLootSourceRegistryContext();
  const lootClaims = buildLootClaimsContext(game.user);
  const operationsJournal = buildOperationsJournalContext();
  const lootRegistryTab = getActiveLootRegistryTab();
  lootSources.registryTab = lootRegistryTab;
  lootSources.registryTabPreview = lootRegistryTab === "preview";
  lootSources.registryTabSettings = lootRegistryTab === "settings";
  lootSources.preview = buildLootPreviewContext();
  const baseOperations = buildBaseOperationsContext(ledger.baseOperations ?? {});
  const merchants = buildMerchantsContext(ledger, { user: game.user });
  const environmentState = ensureEnvironmentState(ledger);
  const weatherState = ensureWeatherState(ledger);
  const environmentPresetBase = getEnvironmentPresetByKey(environmentState.presetKey);
  const environmentPreset = applyEnvironmentSuccessiveConfigToPreset(environmentPresetBase, environmentState);
  const environmentOutcomes = buildEnvironmentOutcomeSummary(environmentPreset);
  const environmentSuccessiveConfig = getEnvironmentSuccessiveConfig(environmentState, environmentPresetBase);
  const daeAvailable = isDaeAvailable();
  const partyModifierKeyCatalog = buildPartyHealthModifierKeyCatalog();
  const partyModifierKeyOptions = partyModifierKeyCatalog.map((entry) => ({
    value: entry.key,
    label: entry.label,
    hint: entry.hint
  }));
  const partyModifierModeOptions = Object.entries(CONST.ACTIVE_EFFECT_MODES ?? {})
    .map(([label, value]) => ({ label, value: Number(value) }))
    .sort((a, b) => a.label.localeCompare(b.label));
  const daeModeOptions = Object.entries(CONST.ACTIVE_EFFECT_MODES ?? {})
    .map(([label, value]) => ({
      value: Number(value),
      label,
      selected: Number(value) === Number(environmentSuccessiveConfig.daeChangeMode)
    }))
    .sort((a, b) => a.label.localeCompare(b.label));
  const daeKeyOptions = buildEnvironmentDaeChangeKeyCatalog().map((entry) => ({
    value: entry.key,
    label: entry.label,
    hint: entry.hint,
    selected: entry.key === environmentSuccessiveConfig.daeChangeKey
  }));
  const selectedEnvDaeHint = daeKeyOptions.find((entry) => entry.selected)?.hint ?? "Select a system field to change on successive failure.";
  const statusEffectOptions = [
    { value: "", label: "None", selected: !environmentSuccessiveConfig.statusId },
    ...(CONFIG.statusEffects ?? []).map((entry) => {
      const value = String(entry?.id ?? "").trim();
      return {
        value,
        label: String((entry?.name ?? value) || "Status").trim(),
        selected: value && value === environmentSuccessiveConfig.statusId
      };
    }).filter((option) => option.value)
  ];
  const damageTypeOptions = buildDamageTypeOptions(environmentSuccessiveConfig.damageType);
  const gmQuickPanel = getActiveGmQuickPanel();
  const environmentTargets = getOwnedPcActors()
    .sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""))
    .map((actor) => ({
      actorId: actor.id,
      actorName: actor.name,
      selected: environmentState.appliedActorIds.includes(actor.id),
      failureStreak: Math.max(0, Number(environmentState.failureStreaks?.[actor.id] ?? 0) || 0)
    }));
  const environmentActorNames = new Map(environmentTargets.map((target) => [target.actorId, target.actorName]));
  const environmentLogs = (environmentState.logs ?? [])
    .filter((entry) => String(entry?.logType ?? "environment").trim().toLowerCase() !== "weather")
    .map((entry) => {
      const preset = getEnvironmentPresetByKey(entry.presetKey);
      const check = getEnvironmentCheckMeta({
        checkType: entry.checkType ?? preset.checkType,
        checkKey: entry.checkKey ?? preset.checkKey,
        checkLabel: entry.checkLabel ?? preset.checkLabel
      });
      const actorNames = (entry.actorIds ?? []).map((actorId) => environmentActorNames.get(actorId) ?? (game.actors.get(actorId)?.name ?? `Actor ${actorId}`));
      const createdAtDate = new Date(Number(entry.createdAt ?? Date.now()));
      return {
        id: entry.id,
        presetKey: entry.presetKey,
        presetLabel: preset.label,
        checkLabel: check.checkLabel,
        movementDc: Math.max(1, Math.floor(Number(entry.movementDc ?? 12) || 12)),
        actorNames,
        actorNamesText: actorNames.length > 0 ? actorNames.join(", ") : "No actors assigned",
        syncToSceneNonParty: entry.syncToSceneNonParty !== false,
        note: String(entry.note ?? ""),
        hasNote: String(entry.note ?? "").trim().length > 0,
        createdBy: String(entry.createdBy ?? "GM"),
        createdAtLabel: Number.isFinite(createdAtDate.getTime()) ? createdAtDate.toLocaleString() : "Unknown"
      };
    });
  const environmentCheckResults = (environmentState.checkResults ?? [])
    .map((entry) => {
      const preset = getEnvironmentPresetByKey(entry.presetKey);
      const actorName = String(entry.actorName ?? "").trim()
        || (entry.actorId ? String(game.actors.get(entry.actorId)?.name ?? `Actor ${entry.actorId}`) : "Unknown Actor");
      const createdAtDate = new Date(Number(entry.createdAt ?? Date.now()));
      const rollValue = Number(entry.rollTotal);
      const dcValue = Number(entry.dc);
      const rollLabel = Number.isFinite(rollValue) ? String(Math.floor(rollValue)) : "-";
      const dcLabel = Number.isFinite(dcValue) ? String(Math.floor(dcValue)) : "-";
      return {
        id: entry.id,
        actorName,
        presetLabel: preset.label,
        resultLabel: entry.result === "fail" ? "Fail" : "Pass",
        isFail: entry.result === "fail",
        rollVsDc: `${rollLabel} vs ${dcLabel}`,
        streak: Math.max(0, Number(entry.streak ?? 0) || 0),
        outcomeSummary: String(entry.outcomeSummary ?? ""),
        hasOutcomeSummary: String(entry.outcomeSummary ?? "").trim().length > 0,
        createdBy: String(entry.createdBy ?? "GM"),
        createdAtLabel: Number.isFinite(createdAtDate.getTime()) ? createdAtDate.toLocaleString() : "Unknown"
      };
    })
    .slice(0, 20);

  const upkeep = {
    partySize: Number(ledger.resources?.upkeep?.partySize ?? 4),
    foodPerMember: Number(ledger.resources?.upkeep?.foodPerMember ?? 1),
    waterPerMember: Number(ledger.resources?.upkeep?.waterPerMember ?? 1),
    foodMultiplier: Number(ledger.resources?.upkeep?.foodMultiplier ?? 1),
    waterMultiplier: Number(ledger.resources?.upkeep?.waterMultiplier ?? 1),
    torchPerRest: Number(ledger.resources?.upkeep?.torchPerRest ?? 0)
  };

  const resourcesState = foundry.utils.deepClone(ledger.resources ?? {});
  ensureOperationalResourceConfig(resourcesState);
  const stewardPools = {
    food: buildStewardPoolContext(resourcesState, "food"),
    water: buildStewardPoolContext(resourcesState, "water"),
    torches: buildStewardPoolContext(resourcesState, "torches")
  };
  const gatherHistoryView = getGatherHistoryViewState();
  const gatherWeatherOptions = getGatherWeatherOptions(resourcesState);
  const gatherPresets = buildGatherPresetContext();
  const gatherHistory = buildGatherHistoryContext(resourcesState, { viewState: gatherHistoryView });
  const foodDrainPerDay = Math.max(0, Math.ceil(upkeep.partySize * upkeep.foodPerMember * upkeep.foodMultiplier));
  const waterDrainPerDay = Math.max(0, Math.ceil(upkeep.partySize * upkeep.waterPerMember * upkeep.waterMultiplier));
  const torchDrainPerDay = Math.max(0, Math.ceil(upkeep.torchPerRest));
  const upkeepDaysPending = getUpkeepDaysFromCalendar(resourcesState.upkeepLastAppliedTs, getCurrentWorldTimestamp());
  const resourcesNumeric = {
    food: Number(resourcesState.food ?? 0),
    partyFoodRations: getStewardPoolFiniteAmount(stewardPools.food),
    partyWaterRations: getStewardPoolFiniteAmount(stewardPools.water),
    water: Number(resourcesState.water ?? 0),
    torches: getStewardPoolFiniteAmount(stewardPools.torches)
  };
  const hasInfiniteFoodSteward = isStewardPoolInfinite(stewardPools.food);
  const hasInfiniteWaterSteward = isStewardPoolInfinite(stewardPools.water);
  const linkedFoodStock = getSelectedResourceItemQuantity(resourcesState, "food");
  const linkedWaterStock = getSelectedResourceItemQuantity(resourcesState, "water");
  const totalFoodReserve = Math.max(0, resourcesNumeric.partyFoodRations) + linkedFoodStock;
  const totalWaterReserve = Math.max(0, resourcesNumeric.partyWaterRations) + linkedWaterStock;

  const formatCyclesLeft = (stock, drain, infinite = false) => {
    if (infinite) return "infinite";
    if (drain <= 0) return "infinite";
    return (Math.max(0, stock) / drain).toFixed(1);
  };

  const selectedBindingCount = RESOURCE_TRACK_KEYS.filter((key) => {
    const selected = resourcesState.itemSelections?.[key] ?? {};
    return Boolean(String(selected.actorId ?? "").trim() && String(selected.itemId ?? "").trim());
  }).length;

  const nextDueKey = getNextUpkeepDueKey(getCurrentWorldTimestamp());
  const gatherFoodCoveredNextUpkeep = Number(resourcesState.gather?.foodCoverageDueKey) === nextDueKey;
  const gatherWaterCoveredNextUpkeep = Number(resourcesState.gather?.waterCoverageDueKey) === nextDueKey;
  const archivedSyncActorIds = new Set(
    (partyHealthState.archivedSyncEffects ?? [])
      .map((entry) => String(entry?.actorId ?? "").trim())
      .filter(Boolean)
  );
  const activeSyncEffects = getOwnedPcActors()
    .map((actor) => {
      const effect = getIntegrationEffect(actor);
      if (!effect) return null;
      return {
        actorId: actor.id,
        actorName: actor.name,
        effectId: effect.id,
        effectName: String(effect.name ?? INTEGRATION_EFFECT_NAME)
      };
    })
    .filter((entry) => entry && !archivedSyncActorIds.has(String(entry.actorId ?? "").trim()));
  const currentWeather = weatherState.current ?? null;
  const weatherLogs = (weatherState.logs ?? []).map((entry) => {
    const loggedAtDate = new Date(Number(entry.loggedAt ?? Date.now()));
    return {
      ...entry,
      loggedAtLabel: Number.isFinite(loggedAtDate.getTime()) ? loggedAtDate.toLocaleString() : "Unknown"
    };
  });
  const weatherSceneSnapshot = resolveCurrentSceneWeatherSnapshot();
  const weatherQuickOptions = buildWeatherSelectionCatalog(weatherState, weatherSceneSnapshot);
  const storedWeatherDraft = getGmQuickWeatherDraft();
  const fallbackWeatherOption = weatherQuickOptions[0] ?? null;
  const selectedWeatherKey = String(storedWeatherDraft?.selectedKey ?? fallbackWeatherOption?.key ?? "").trim();
  const selectedWeatherOption = weatherQuickOptions.find((entry) => entry.key === selectedWeatherKey) ?? fallbackWeatherOption;
  const weatherQuickDraft = {
    selectedKey: String(selectedWeatherOption?.key ?? ""),
    darkness: Number.isFinite(Number(storedWeatherDraft?.darkness))
      ? Math.max(0, Math.min(1, Number(storedWeatherDraft.darkness)))
      : Math.max(0, Math.min(1, Number(selectedWeatherOption?.darkness ?? weatherSceneSnapshot.darkness ?? 0))),
    visibilityModifier: Number.isFinite(Number(storedWeatherDraft?.visibilityModifier))
      ? Math.max(-5, Math.min(5, Math.floor(Number(storedWeatherDraft.visibilityModifier))))
      : Math.max(-5, Math.min(5, Math.floor(Number(selectedWeatherOption?.visibilityModifier ?? 0) || 0))),
    note: String(storedWeatherDraft?.note ?? ""),
    presetName: String(storedWeatherDraft?.presetName ?? ""),
    daeChanges: Array.isArray(storedWeatherDraft?.daeChanges)
      ? storedWeatherDraft.daeChanges.map((entry) => normalizeWeatherDaeChange(entry)).filter((entry) => entry.key && entry.value)
      : (Array.isArray(selectedWeatherOption?.daeChanges)
        ? selectedWeatherOption.daeChanges.map((entry) => normalizeWeatherDaeChange(entry)).filter((entry) => entry.key && entry.value)
        : [])
  };
  const globalLogs = (environmentState.logs ?? [])
    .map((entry) => {
      const createdAt = Number(entry?.createdAt ?? Date.now());
      const createdAtLabel = Number.isFinite(createdAt) ? new Date(createdAt).toLocaleString() : "Unknown";
      const logType = String(entry?.logType ?? "environment").trim().toLowerCase() === "weather" ? "weather" : "environment";
      if (logType === "weather") {
        return {
          id: `weather:${entry.id}`,
          sourceId: entry.id,
          logType,
          logTypeLabel: "Weather",
          title: String(entry.label ?? "Weather").trim() || "Weather",
          summary: `Visibility ${formatSignedModifier(Number(entry.visibilityModifier ?? 0)) || "0"} - Darkness ${Number(entry.darkness ?? 0).toFixed(2)}`,
          details: `${getWeatherEffectSummary(Number(entry.visibilityModifier ?? 0))} - ${describeWeatherDaeChanges(entry.daeChanges ?? [])}`,
          note: String(entry.note ?? ""),
          hasNote: String(entry.note ?? "").trim().length > 0,
          createdBy: String(entry.createdBy ?? "GM"),
          createdAt: Number.isFinite(createdAt) ? createdAt : Date.now(),
          createdAtLabel
        };
      }
      const preset = getEnvironmentPresetByKey(entry.presetKey);
      const check = getEnvironmentCheckMeta(entry);
      const actorNames = (entry.actorIds ?? []).map((actorId) => environmentActorNames.get(actorId) ?? (game.actors.get(actorId)?.name ?? `Actor ${actorId}`));
      return {
        id: `env:${entry.id}`,
        sourceId: entry.id,
        logType,
        logTypeLabel: "Environment",
        title: preset.label,
        summary: `${check.checkLabel} - DC ${Math.max(1, Math.floor(Number(entry.movementDc ?? 12) || 12))}`,
        details: `Affected: ${actorNames.length > 0 ? actorNames.join(", ") : "No actors assigned"}${entry.syncToSceneNonParty !== false ? " - + non-party scene actors" : ""}`,
        note: String(entry.note ?? ""),
        hasNote: String(entry.note ?? "").trim().length > 0,
        createdBy: String(entry.createdBy ?? "GM"),
        createdAt: Number.isFinite(createdAt) ? createdAt : Date.now(),
        createdAtLabel
      };
    })
    .sort((a, b) => Number(b.createdAt ?? 0) - Number(a.createdAt ?? 0));
  const activeSyncEffectsTab = getActiveSyncEffectsTab();
  const archivedSyncEffects = (partyHealthState.archivedSyncEffects ?? [])
    .map((entry) => {
      const archivedAtDate = new Date(Number(entry.archivedAt ?? Date.now()));
      return {
        id: entry.id,
        actorId: entry.actorId,
        actorName: entry.actorName,
        effectName: entry.effectName,
        label: entry.label,
        note: entry.note,
        archivedBy: entry.archivedBy,
        archivedAt: Number(entry.archivedAt ?? 0) || 0,
        archivedAtLabel: Number.isFinite(archivedAtDate.getTime()) ? archivedAtDate.toLocaleString() : "Unknown"
      };
    })
    .sort((a, b) => Number(b.archivedAt ?? 0) - Number(a.archivedAt ?? 0));
  const modifierAddLog = (partyHealthState.modifierAddLog ?? [])
    .map((entry) => {
      const createdAt = Number(entry?.createdAt ?? Date.now()) || Date.now();
      const createdAtDate = new Date(createdAt);
      const origin = String(entry?.origin ?? "custom").trim() || "custom";
      return {
        id: String(entry?.id ?? foundry.utils.randomID()),
        customModifierId: String(entry?.customModifierId ?? "").trim(),
        origin,
        originLabel: origin === "quick" ? "Quick Panel" : "Custom Panel",
        label: String(entry?.label ?? "Custom Modifier").trim() || "Custom Modifier",
        key: String(entry?.key ?? "").trim(),
        modeLabel: getActiveEffectModeLabel(entry?.mode),
        value: String(entry?.value ?? "").trim(),
        note: String(entry?.note ?? ""),
        hasNote: String(entry?.note ?? "").trim().length > 0,
        createdBy: String(entry?.createdBy ?? "GM").trim() || "GM",
        createdAt,
        createdAtLabel: Number.isFinite(createdAtDate.getTime()) ? createdAtDate.toLocaleString() : "Unknown"
      };
    })
    .filter((entry) => entry.key && entry.value)
    .sort((a, b) => Number(b.createdAt ?? 0) - Number(a.createdAt ?? 0))
    .slice(0, 8);
  const stagedModifierQueue = (partyHealthState.stagedModifierQueue ?? [])
    .map((entry) => {
      const createdAt = Number(entry?.createdAt ?? Date.now()) || Date.now();
      const createdAtDate = new Date(createdAt);
      const key = String(entry?.key ?? "").trim();
      const mode = Math.floor(Number(entry?.mode ?? CONST.ACTIVE_EFFECT_MODES.ADD));
      return {
        id: String(entry?.id ?? foundry.utils.randomID()),
        label: String(entry?.label ?? "Custom Modifier").trim() || "Custom Modifier",
        key,
        keyLabel: getDaeKeyLabel(key),
        mode,
        modeLabel: getActiveEffectModeLabel(mode),
        value: String(entry?.value ?? "").trim(),
        note: String(entry?.note ?? ""),
        hasNote: String(entry?.note ?? "").trim().length > 0,
        modeOptions: partyModifierModeOptions.map((option) => ({
          ...option,
          selected: Number(option.value) === Number(mode)
        })),
        keyOptions: partyModifierKeyOptions.map((option) => ({
          ...option,
          selected: String(option.value ?? "").trim() === key
        })),
        createdBy: String(entry?.createdBy ?? "GM").trim() || "GM",
        createdAt,
        createdAtLabel: Number.isFinite(createdAtDate.getTime()) ? createdAtDate.toLocaleString() : "Unknown"
      };
    })
    .filter((entry) => entry.key && entry.value)
    .sort((a, b) => Number(b.createdAt ?? 0) - Number(a.createdAt ?? 0))
    .slice(0, 12);
  const resolvedIntegrationMode = resolveIntegrationMode();
  const integrationModeLabel = getIntegrationModeLabel(resolvedIntegrationMode);
  const nonPartySyncScope = getNonPartySyncScope(partyHealthState.nonPartySyncScope);
  const nonPartySyncScopeLabel = getNonPartySyncScopeLabel(nonPartySyncScope);
  const nonPartySyncScopeOptions = [
    { value: NON_PARTY_SYNC_SCOPES.SCENE, label: getNonPartySyncScopeLabel(NON_PARTY_SYNC_SCOPES.SCENE), selected: nonPartySyncScope === NON_PARTY_SYNC_SCOPES.SCENE },
    {
      value: NON_PARTY_SYNC_SCOPES.WORLD_NON_PARTY,
      label: getNonPartySyncScopeLabel(NON_PARTY_SYNC_SCOPES.WORLD_NON_PARTY),
      selected: nonPartySyncScope === NON_PARTY_SYNC_SCOPES.WORLD_NON_PARTY
    },
    { value: NON_PARTY_SYNC_SCOPES.WORLD_ALL, label: getNonPartySyncScopeLabel(NON_PARTY_SYNC_SCOPES.WORLD_ALL), selected: nonPartySyncScope === NON_PARTY_SYNC_SCOPES.WORLD_ALL }
  ];
  const nonPartySyncGlobal = Boolean(partyHealthState.syncToSceneNonParty);
  const nonPartySyncEnvironment = Boolean(environmentState.syncToSceneNonParty && String(environmentState.presetKey ?? "none") !== "none");
  const nonPartySyncEnabled = nonPartySyncGlobal || nonPartySyncEnvironment;
  const nonPartyTargets = getNonPartyIntegrationTargets(nonPartySyncScope);
  const nonPartyRowsAll = nonPartyTargets.map((target) => {
    const actor = target.actor;
    const hasSyncFlag = Boolean(actor?.getFlag(MODULE_ID, "sync"));
    const integrationEffect = getIntegrationEffect(actor);
    const injuryEffect = getInjuryStatusEffect(actor);
    const environmentEffect = getEnvironmentStatusEffect(actor);
    const hasIntegrationEffect = Boolean(integrationEffect);
    const hasInjuryEffect = Boolean(injuryEffect);
    const hasEnvironmentEffect = Boolean(environmentEffect);
    const hasAnySync = hasSyncFlag || hasIntegrationEffect || hasInjuryEffect || hasEnvironmentEffect;
    const effectNames = [];
    if (hasIntegrationEffect) effectNames.push(String(integrationEffect?.name ?? INTEGRATION_EFFECT_NAME));
    if (hasInjuryEffect) effectNames.push(String(injuryEffect?.name ?? `${INJURY_EFFECT_NAME_PREFIX} Status`));
    if (hasEnvironmentEffect) effectNames.push(String(environmentEffect?.name ?? `${ENVIRONMENT_EFFECT_NAME_PREFIX} Status`));
    const shouldBeCleared = hasAnySync && (!nonPartySyncEnabled || resolvedIntegrationMode === INTEGRATION_MODES.OFF);
    return {
      actorRef: target.actorRef,
      actorName: target.actorName,
      tokenCount: target.tokenCount,
      tokenNamesLabel: target.tokenNamesLabel,
      isSceneTarget: target.isSceneTarget === true,
      locationLabel: target.isSceneTarget === true
        ? `Scene Tokens: ${target.tokenCount} | ${target.tokenNamesLabel}`
        : "World Actor Target",
      hasSyncFlag,
      hasIntegrationEffect,
      hasInjuryEffect,
      hasEnvironmentEffect,
      hasAnySync,
      shouldBeCleared,
      statusLabel: hasAnySync ? (shouldBeCleared ? "Stale (should clear)" : "Synced") : "Clear",
      effectsSummary: effectNames.length > 0 ? effectNames.join(" | ") : "None"
    };
  });
  const nonPartyFilterKeyword = getNonPartySyncFilterKeyword();
  const nonPartyFilterQuery = normalizeLootPackSourcesFilter(nonPartyFilterKeyword);
  const nonPartyFilterActive = nonPartyFilterQuery.length > 0;
  const nonPartyRows = nonPartyFilterActive
    ? nonPartyRowsAll.filter((entry) => matchesLootSourceSearchQuery(nonPartyFilterQuery, {
      label: entry.actorName,
      id: entry.actorRef,
      sourceKind: `${entry.locationLabel} ${entry.effectsSummary} ${entry.statusLabel}`,
      available: entry.hasAnySync,
      enabled: !entry.shouldBeCleared
    }))
    : nonPartyRowsAll;
  const nonPartySyncedCount = nonPartyRowsAll.filter((entry) => entry.hasAnySync).length;
  const nonPartyStaleCount = nonPartyRowsAll.filter((entry) => entry.shouldBeCleared).length;

  return {
    roles,
    sops,
    resources: {
      food: resourcesNumeric.food,
      linkedFoodStock,
      linkedWaterStock,
      partyFoodRations: resourcesNumeric.partyFoodRations,
      partyWaterRations: resourcesNumeric.partyWaterRations,
      water: resourcesNumeric.water,
      torches: resourcesNumeric.torches,
      stewardPools,
      itemSelections: {
        food: buildResourceSelectionContext(resourcesState, "food"),
        water: buildResourceSelectionContext(resourcesState, "water"),
        torches: buildResourceSelectionContext(resourcesState, "torches")
      },
      gatherWeatherOptions,
      gatherFoodCoveredNextUpkeep,
      gatherWaterCoveredNextUpkeep,
      gatherPresets,
      hasGatherPresets: gatherPresets.length > 0,
      gatherHistory,
      hasGatherHistory: gatherHistory.hasRows,
      summary: {
        foodDrainPerDay,
        waterDrainPerDay,
        torchDrainPerDay,
        upkeepDaysPending,
        foodDrainPending: foodDrainPerDay * upkeepDaysPending,
        waterDrainPending: waterDrainPerDay * upkeepDaysPending,
        foodStewardPoolDisplay: stewardPools.food.amountDisplay,
        waterStewardPoolDisplay: stewardPools.water.amountDisplay,
        torchStewardPoolDisplay: stewardPools.torches.amountDisplay,
        foodCyclesLeft: formatCyclesLeft(totalFoodReserve, foodDrainPerDay, hasInfiniteFoodSteward),
        foodRationCyclesLeft: formatCyclesLeft(totalFoodReserve, foodDrainPerDay, hasInfiniteFoodSteward),
        waterCyclesLeft: formatCyclesLeft(totalWaterReserve, waterDrainPerDay, hasInfiniteWaterSteward),
        waterRationCyclesLeft: formatCyclesLeft(totalWaterReserve, waterDrainPerDay, hasInfiniteWaterSteward),
        selectedBindingCount
      },
      upkeep,
      encumbranceOptions: [
        { value: "light", label: "Light", selected: (resourcesState.encumbrance ?? "light") === "light" },
        { value: "moderate", label: "Moderate", selected: (resourcesState.encumbrance ?? "light") === "moderate" },
        { value: "heavy", label: "Heavy", selected: (resourcesState.encumbrance ?? "light") === "heavy" },
        { value: "overloaded", label: "Overloaded", selected: (resourcesState.encumbrance ?? "light") === "overloaded" }
      ]
    },
    communication: {
      silentSignals: communication.silentSignals ?? "",
      codePhrase: communication.codePhrase ?? "",
      signalFlare: Boolean(communication.signalFlare),
      signalBell: Boolean(communication.signalBell),
      preCombatPlan: Boolean(communication.preCombatPlan),
      readiness: communicationReadiness
    },
    recon,
    partyHealth: {
      customModifiers: partyHealthState.customModifiers.map((entry) => ({
        ...entry,
        modeLabel: getActiveEffectModeLabel(entry.mode),
        keyHint: partyModifierKeyOptions.find((option) => option.value === entry.key)?.hint ?? "",
        modeOptions: partyModifierModeOptions.map((option) => ({
          ...option,
          selected: Number(option.value) === Number(entry.mode)
        })),
        keyOptions: partyModifierKeyOptions
      })),
      modifierModeOptions: partyModifierModeOptions,
      modifierKeyOptions: partyModifierKeyOptions,
      modifierAddLog,
      hasModifierAddLog: modifierAddLog.length > 0,
      activeSyncEffects,
      hasActiveSyncEffects: activeSyncEffects.length > 0,
      activeSyncEffectsTab,
      activeSyncEffectsTabActive: activeSyncEffectsTab === "active",
      activeSyncEffectsTabArchived: activeSyncEffectsTab === "archived",
      activeSyncEffectsCount: activeSyncEffects.length,
      archivedSyncEffects,
      hasArchivedSyncEffects: archivedSyncEffects.length > 0,
      archivedSyncEffectsCount: archivedSyncEffects.length,
      daeAvailable,
      syncToSceneNonParty: Boolean(partyHealthState.syncToSceneNonParty),
      nonPartySyncScope: nonPartySyncScope
    },
    lootSources,
    lootClaims,
    nonPartySync: {
      sceneName: String(game.scenes?.current?.name ?? "No Active Scene"),
      scope: nonPartySyncScope,
      scopeLabel: nonPartySyncScopeLabel,
      scopeOptions: nonPartySyncScopeOptions,
      integrationMode: resolvedIntegrationMode,
      integrationModeLabel,
      syncGlobalEnabled: nonPartySyncGlobal,
      syncEnvironmentEnabled: nonPartySyncEnvironment,
      enabled: nonPartySyncEnabled,
      enabledLabel: nonPartySyncEnabled ? "ON" : "OFF",
      modeOff: resolvedIntegrationMode === INTEGRATION_MODES.OFF,
      environmentPresetLabel: String(environmentPreset?.label ?? "None"),
      actorCount: nonPartyRowsAll.length,
      syncedCount: nonPartySyncedCount,
      staleCount: nonPartyStaleCount,
      visibleCount: nonPartyRows.length,
      hasAnyTargets: nonPartyRowsAll.length > 0,
      filter: {
        keyword: nonPartyFilterKeyword,
        active: nonPartyFilterActive
      },
      hasTargets: nonPartyRows.length > 0,
      rows: nonPartyRows
    },
    environment: {
      presetKey: environmentState.presetKey,
      preset: environmentPreset,
      checkLabel: getEnvironmentCheckMeta(environmentPreset).checkLabel,
      movementDc: environmentState.movementDc,
      note: environmentState.note,
      syncToSceneNonParty: Boolean(environmentState.syncToSceneNonParty),
      movementCheckActive: Boolean(environmentPreset.movementCheck),
      outcomes: environmentOutcomes,
      successiveConfig: {
        ...environmentSuccessiveConfig,
        daeAvailable,
        statusOptions: statusEffectOptions,
        damageTypeOptions,
        daeModeOptions,
        daeKeyOptions,
        daeKeyHint: selectedEnvDaeHint
      },
      targetCount: environmentTargets.filter((target) => target.selected).length,
      appliedActorIds: [...environmentState.appliedActorIds],
      targets: environmentTargets,
      logs: environmentLogs,
      hasLogs: environmentLogs.length > 0,
      checkResults: environmentCheckResults,
      hasCheckResults: environmentCheckResults.length > 0,
      presetOptions: ENVIRONMENT_PRESETS.map((preset) => ({
        key: preset.key,
        label: preset.label,
        selected: preset.key === environmentState.presetKey
      }))
    },
    weather: {
      current: currentWeather,
      hasCurrent: Boolean(currentWeather),
      currentLabel: String(currentWeather?.label ?? "Not logged"),
      currentVisibilityModifier: Number(currentWeather?.visibilityModifier ?? 0),
      currentDarkness: Number(currentWeather?.darkness ?? 0),
      logs: weatherLogs,
      hasLogs: weatherLogs.length > 0
    },
    gmQuickTools: {
      activePanel: gmQuickPanel,
      showFactionPanel: gmQuickPanel === "faction",
      showModifierPanel: gmQuickPanel === "modifier",
      showWeatherPanel: gmQuickPanel === "weather",
      modifierModeOptions: partyModifierModeOptions,
      modifierKeyOptions: partyModifierKeyOptions,
      stagedModifierQueue,
      hasStagedModifierQueue: stagedModifierQueue.length > 0,
      modifierAddLog,
      hasModifierAddLog: modifierAddLog.length > 0,
      weatherSceneSnapshot,
      weatherOptions: weatherQuickOptions.map((option) => ({
        key: option.key,
        label: option.label,
        weatherId: option.weatherId,
        isBuiltIn: Boolean(option.isBuiltIn),
        visibilityModifier: Number(option.visibilityModifier ?? 0),
        visibilityLabel: formatSignedModifier(Number(option.visibilityModifier ?? 0)) || "0",
        effectSummary: getWeatherEffectSummary(Number(option.visibilityModifier ?? 0)),
        daeSummary: describeWeatherDaeChanges(option.daeChanges ?? []),
        selected: option.key === weatherQuickDraft.selectedKey
      })),
      weatherDaeModeOptions: Object.entries(CONST.ACTIVE_EFFECT_MODES ?? {})
        .map(([label, value]) => ({ label, value: Number(value) }))
        .sort((a, b) => a.label.localeCompare(b.label)),
      weatherDraft: weatherQuickDraft
    },
    downtime,
    operationsJournal,
    globalLogs: {
      entries: globalLogs,
      hasEntries: globalLogs.length > 0
    },
    reputation,
    baseOperations,
    merchants,
    summary: {
      roleCoverage,
      roleTotal: roles.length,
      activeSops,
      sopTotal: sops.length,
      prepEdge: roleCoverage >= 3 && activeSops >= 3,
      disorderRisk,
      reconReadiness: recon.readinessLabel,
      maintenancePressure: baseOperations.maintenancePressure,
      effects
    },
    diagnostics: {
      missingRoles: roles.filter((role) => !role.hasActor).map((role) => role.label),
      inactiveSops: sops.filter((sop) => !sop.active).map((sop) => sop.label)
    }
  };
}

function getOperationalEffects(ledger, roles, sops) {
  const roleCoverage = roles.filter((role) => role.hasActor).length;
  const activeSops = sops.filter((sop) => sop.active).length;
  const hasQuartermaster = Boolean(ledger.roles?.quartermaster);
  const hasCartographer = Boolean(ledger.roles?.cartographer);
  const hasChronicler = Boolean(ledger.roles?.chronicler);
  const hasSteward = Boolean(ledger.roles?.steward);
  const communication = ledger.communication ?? {};
  const comms = getCommunicationReadiness(communication);
  const recon = buildReconContext(ensureReconState(ledger));
  const reputation = buildReputationContext(ensureReputationState(ledger));
  const baseOperations = buildBaseOperationsContext(ledger.baseOperations ?? {});
  const weatherState = ensureWeatherState(ledger);
  const weatherVisibilityModifier = Number(weatherState.current?.visibilityModifier ?? 0);
  const weatherLabel = String(weatherState.current?.label ?? "Weather");
  const weatherDaeChanges = Array.isArray(weatherState.current?.daeChanges)
    ? weatherState.current.daeChanges.map((entry) => normalizeWeatherDaeChange(entry)).filter((entry) => entry.key && entry.value)
    : [];
  const prepEdge = roleCoverage >= 3 && activeSops >= 3;

  const bonuses = [];
  const globalMinorBonuses = [];
  const risks = [];
  const partyHealth = ensurePartyHealthState(ledger);
  const globalModifiers = {
    initiative: 0,
    abilityChecks: 0,
    perceptionChecks: 0,
    savingThrows: 0
  };
  const worldGlobalModifiers = {
    initiative: 0,
    abilityChecks: 0,
    perceptionChecks: 0,
    savingThrows: 0
  };
  const globalModifierRows = [];

  const addGlobalModifier = (modifierId, key, amount, label, appliesTo, options = {}) => {
    const value = Number(amount ?? 0);
    if (!Number.isFinite(value) || value === 0) return { enabled: true, value: 0 };
    const source = String(options.source ?? "derived");
    const note = String(options.note ?? "");
    const enabled = source === "custom"
      ? options.enabled !== false
      : partyHealth.modifierEnabled?.[modifierId] !== false;
    if (enabled) globalModifiers[key] = Number(globalModifiers[key] ?? 0) + value;
    globalModifierRows.push({
      modifierId,
      enabled,
      source,
      key,
      appliesTo,
      value,
      label,
      note,
      isPositive: value > 0,
      isNegative: value < 0,
      formatted: value > 0 ? `+${value}` : String(value),
      effectiveFormatted: enabled ? (value > 0 ? `+${value}` : String(value)) : "0"
    });
    return { enabled, value };
  };
  const addWorldModifier = (key, amount) => {
    const value = Number(amount ?? 0);
    if (!Number.isFinite(value) || value === 0) return;
    worldGlobalModifiers[key] = Number(worldGlobalModifiers[key] ?? 0) + value;
  };

  if (prepEdge) bonuses.push("Preparation edge active: grant advantage on one operational check this session.");
  if (hasQuartermaster && ledger.sops?.campSetup) bonuses.push("Supply discipline active: reduce one supply-tracking error this rest cycle.");
  if (hasCartographer && ledger.sops?.urbanEntry) bonuses.push("Route discipline active: reduce one navigation uncertainty this session.");
  if (hasChronicler) bonuses.push("Operational recall active: clarify one unknown clue or timeline detail once per session.");
  if (hasSteward) bonuses.push("Stewardship active: reduce one lifestyle/logistics cost friction once per session.");
  if (comms.ready) bonuses.push("Communication discipline active: improve one coordinated response roll by a minor margin.");
  if (reputation.highStandingCount >= 2) bonuses.push("Faction leverage active: ease one access or social gate this session.");
  if (baseOperations.readiness) bonuses.push("Base network stability active: soften one shelter or maintenance complication this cycle.");

  if (roleCoverage >= 2) {
    const modifier = addGlobalModifier("team-rhythm", "initiative", 1, "Team rhythm (2+ roles)", "Initiative rolls");
    if (modifier.enabled) globalMinorBonuses.push("Team rhythm: all player actors gain +1 initiative while 2+ operations roles are assigned.");
  }
  if (activeSops >= 2) {
    const modifier = addGlobalModifier("briefed-procedures", "abilityChecks", 1, "Briefed procedures (2+ SOPs)", "All ability checks");
    if (modifier.enabled) globalMinorBonuses.push("Briefed procedures: all player actors gain +1 to ability checks while 2+ SOPs are active.");
  }
  if (comms.ready) {
    const modifier = addGlobalModifier("signal-discipline", "perceptionChecks", 1, "Signal discipline (comms ready)", "Perception checks");
    if (modifier.enabled) globalMinorBonuses.push("Signal discipline: all player actors gain +1 to Perception checks while communication readiness is active.");
  }
  if (baseOperations.readiness) {
    const modifier = addGlobalModifier("operational-sheltering", "savingThrows", 1, "Operational sheltering (base ready)", "All saving throws");
    if (modifier.enabled) globalMinorBonuses.push("Operational sheltering: all player actors gain +1 to saving throws while base readiness is stable.");
  }
  if (weatherVisibilityModifier !== 0) {
    const modifier = addGlobalModifier(
      "weather-visibility",
      "perceptionChecks",
      weatherVisibilityModifier,
      `Weather visibility (${weatherLabel})`,
      "Perception checks",
      { note: `Logged weather visibility modifier ${weatherVisibilityModifier > 0 ? "+" : ""}${weatherVisibilityModifier}.` }
    );
    if (modifier.enabled) {
      addWorldModifier("perceptionChecks", weatherVisibilityModifier);
      if (weatherVisibilityModifier > 0) {
        globalMinorBonuses.push(`Weather visibility (${weatherLabel}): perception improves by ${weatherVisibilityModifier > 0 ? "+" : ""}${weatherVisibilityModifier}.`);
      } else {
        risks.push(`Weather visibility (${weatherLabel}): apply ${weatherVisibilityModifier} to perception checks.`);
      }
    }
  }
  if (weatherDaeChanges.length > 0) {
    bonuses.push(`Weather profile (${weatherLabel}) applies ${weatherDaeChanges.length} global DAE change(s).`);
  }

  if (!ledger.roles?.quartermaster) risks.push("No Quartermaster: increase supply error risk this rest cycle.");
  if (!ledger.sops?.retreatProtocol) risks.push("No retreat protocol: escalate retreat complication by one step.");
  if (activeSops <= 2) risks.push("Low SOP coverage: apply disadvantage on one unplanned operation check.");
  if (!comms.ready) risks.push("Communication gaps: increase misread signal risk during first contact.");
  if (recon.tier === "blind") risks.push("Recon gaps: increase first-contact uncertainty by one step.");
  if (reputation.hostileCount >= 1) risks.push("Faction pressure: increase social or legal complication risk by one step.");
  if (baseOperations.maintenancePressure >= 3) risks.push("Base maintenance pressure: increase safehouse compromise/discovery risk by one step.");

  if (roleCoverage <= 1) addGlobalModifier("poor-role-coverage", "initiative", -1, "Poor role coverage", "Initiative rolls");
  if (activeSops <= 1) addGlobalModifier("insufficient-sop-coverage", "abilityChecks", -1, "Insufficient SOP coverage", "All ability checks");
  if (!comms.ready) addGlobalModifier("communication-gaps", "perceptionChecks", -1, "Communication gaps", "Perception checks");
  if (baseOperations.maintenancePressure >= 3) addGlobalModifier("base-maintenance-pressure", "savingThrows", -1, "Base maintenance pressure", "All saving throws");

  const customDaeChanges = [];
  const worldDaeChanges = [];
  for (const [index, weatherChange] of weatherDaeChanges.entries()) {
    const normalized = {
      modifierId: `weather:${index}`,
      label: `Weather (${weatherLabel})`,
      note: String(weatherChange.note ?? ""),
      key: weatherChange.key,
      mode: weatherChange.mode,
      value: weatherChange.value
    };
    customDaeChanges.push(normalized);
    worldDaeChanges.push(foundry.utils.deepClone(normalized));
  }
  for (const custom of partyHealth.customModifiers ?? []) {
    const key = String(custom?.key ?? "").trim();
    const value = String(custom?.value ?? "").trim();
    const enabled = custom?.enabled !== false;
    const label = String(custom?.label ?? "Custom Modifier").trim() || "Custom Modifier";
    const note = String(custom?.note ?? "");
    const mode = Math.floor(Number(custom?.mode ?? CONST.ACTIVE_EFFECT_MODES.ADD));
    const appliesTo = "All player actors";

    const mappedSummaryKey = {
      "system.attributes.init.bonus": "initiative",
      "system.bonuses.abilities.check": "abilityChecks",
      "system.skills.prc.bonuses.check": "perceptionChecks",
      "system.bonuses.abilities.save": "savingThrows"
    }[key];

    const numericValue = Number(value);
    if (mappedSummaryKey && Number.isFinite(numericValue)) {
      addGlobalModifier(`custom:${custom.id}`, mappedSummaryKey, numericValue, label, appliesTo, {
        source: "custom",
        enabled,
        note
      });
      if (enabled) addWorldModifier(mappedSummaryKey, numericValue);
    } else {
      globalModifierRows.push({
        modifierId: `custom:${custom.id}`,
        enabled,
        source: "custom",
        key,
        appliesTo,
        value,
        label,
        note,
        isPositive: false,
        isNegative: false,
        formatted: value || "-",
        effectiveFormatted: enabled ? (value || "-") : "Off",
        modeLabel: getActiveEffectModeLabel(mode)
      });
    }

    if (enabled && key && value) {
      const normalized = {
        modifierId: `custom:${custom.id}`,
        label,
        note,
        key,
        mode,
        value
      };
      customDaeChanges.push(normalized);
      worldDaeChanges.push(foundry.utils.deepClone(normalized));
    }
  }

  const pressurePenalty = baseOperations.maintenancePressure >= 4 ? 2 : baseOperations.maintenancePressure >= 3 ? 1 : 0;
  const riskScore = roleCoverage + activeSops - pressurePenalty;
  const riskTier = riskScore >= 8 ? "low" : riskScore >= 5 ? "moderate" : "high";

  return {
    prepEdge,
    riskTier,
    bonuses,
    globalMinorBonuses,
    globalModifiers,
    worldGlobalModifiers,
    globalModifierRows,
    derivedModifierRows: globalModifierRows.filter((row) => row.source !== "custom"),
    customModifierRows: globalModifierRows.filter((row) => row.source === "custom"),
    hasGlobalModifiers: globalModifierRows.length > 0,
    hasCustomModifiers: globalModifierRows.some((row) => row.source === "custom"),
    customDaeChanges,
    worldDaeChanges,
    hasGlobalMinorBonuses: globalMinorBonuses.length > 0,
    hasRisks: risks.length > 0,
    risks
  };
}

function getCommunicationReadiness(communication) {
  const hasSignals = (communication.silentSignals ?? "").trim().length > 0;
  const hasCodePhrase = (communication.codePhrase ?? "").trim().length > 0;
  const toggles = [Boolean(communication.signalFlare), Boolean(communication.signalBell), Boolean(communication.preCombatPlan)];
  const enabledCount = toggles.filter(Boolean).length;
  const ready = hasSignals && hasCodePhrase && enabledCount >= 2;
  return {
    hasSignals,
    hasCodePhrase,
    enabledCount,
    ready,
    statusText: ready ? "Ready" : "At Risk"
  };
}

function getDefaultReputationFactions() {
  return [
    { id: "religious", label: "Religious Authority", score: 0, note: "", noteLogs: [], isCore: true },
    { id: "nobility", label: "Nobility", score: 0, note: "", noteLogs: [], isCore: true },
    { id: "criminal", label: "Criminal Factions", score: 0, note: "", noteLogs: [], isCore: true },
    { id: "commoners", label: "Common Populace", score: 0, note: "", noteLogs: [], isCore: true }
  ];
}

function normalizeReputationNoteLog(entry = {}) {
  const loggedAt = Number(entry?.loggedAt ?? Date.now());
  return {
    id: String(entry?.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID(),
    note: String(entry?.note ?? "").trim(),
    score: Math.max(-5, Math.min(5, Math.floor(Number(entry?.score ?? 0) || 0))),
    loggedAt: Number.isFinite(loggedAt) ? loggedAt : Date.now(),
    loggedBy: String(entry?.loggedBy ?? "GM").trim() || "GM",
    dayLabel: String(entry?.dayLabel ?? "").trim(),
    clockLabel: String(entry?.clockLabel ?? "").trim(),
    calendarEntryId: String(entry?.calendarEntryId ?? "").trim()
  };
}

function normalizeReputationFaction(entry = {}) {
  const noteLogs = Array.isArray(entry?.noteLogs)
    ? entry.noteLogs
      .map((row) => normalizeReputationNoteLog(row))
      .filter((row) => row.note)
      .sort((a, b) => Number(b.loggedAt ?? 0) - Number(a.loggedAt ?? 0))
      .slice(0, 100)
    : [];
  return {
    id: String(entry.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID(),
    label: String(entry.label ?? "Faction").trim() || "Faction",
    score: Math.max(-5, Math.min(5, Math.floor(Number(entry.score ?? 0) || 0))),
    note: String(entry.note ?? ""),
    noteLogs,
    isCore: Boolean(entry.isCore)
  };
}

function ensureReputationState(ledger) {
  if (!ledger.reputation || typeof ledger.reputation !== "object") ledger.reputation = {};
  if (!Array.isArray(ledger.reputation.factions)) {
    const defaults = getDefaultReputationFactions();
    const legacyLookup = {
      religious: ledger.reputation.religious,
      nobility: ledger.reputation.nobility,
      criminal: ledger.reputation.criminal,
      commoners: ledger.reputation.commoners
    };
    ledger.reputation.factions = defaults.map((row) => {
      const legacy = legacyLookup[row.id] ?? {};
      return normalizeReputationFaction({
        ...row,
        score: Number(legacy?.score ?? row.score),
        note: String(legacy?.note ?? row.note),
        noteLogs: Array.isArray(legacy?.noteLogs) ? legacy.noteLogs : []
      });
    });
  }
  ledger.reputation.factions = ledger.reputation.factions
    .map((entry) => normalizeReputationFaction(entry))
    .filter((entry, index, arr) => entry.id && arr.findIndex((candidate) => candidate.id === entry.id) === index);
  return ledger.reputation;
}

function getReputationBand(score) {
  const value = Number(score ?? 0);
  if (value <= -3) return "hostile";
  if (value <= -1) return "cold";
  if (value >= 3) return "trusted";
  if (value >= 1) return "favorable";
  return "neutral";
}

function getReputationStandingClass(score) {
  const value = Math.max(-5, Math.min(5, Math.floor(Number(score ?? 0) || 0)));
  if (value >= 0) return `po-reputation-standing-p${value}`;
  return `po-reputation-standing-n${Math.abs(value)}`;
}

function getReputationStandingStyle(score) {
  const numeric = Number(score ?? 0);
  const value = Math.max(-5, Math.min(5, Number.isFinite(numeric) ? numeric : 0));
  const isPositive = value >= 0;
  const intensity = isPositive ? (value / 5) : (Math.abs(value) / 5);

  const hue = isPositive
    ? (212 + ((148 - 212) * intensity))
    : (34 + ((2 - 34) * intensity));
  const saturation = isPositive
    ? (30 + ((58 - 30) * intensity))
    : (48 + ((76 - 48) * intensity));
  const lightness = isPositive
    ? (54 + ((46 - 54) * intensity))
    : (54 + ((44 - 54) * intensity));

  const accent = `hsl(${Math.round(hue)} ${Math.round(saturation)}% ${Math.round(lightness)}%)`;
  const bgMix = Math.round((isPositive ? 10 : 12) + ((isPositive ? 16 : 24) * intensity));
  const pillMix = Math.round((isPositive ? 16 : 20) + ((isPositive ? 22 : 28) * intensity));
  const pillText = (isPositive && intensity >= 0.82) || (!isPositive && intensity >= 0.56)
    ? "var(--po-accent-contrast)"
    : "var(--po-text)";

  return `--po-rep-accent:${accent};--po-rep-bg:color-mix(in srgb, ${accent} ${bgMix}%, var(--po-bg-alt));--po-rep-pill-bg:color-mix(in srgb, ${accent} ${pillMix}%, var(--po-bg-alt));--po-rep-pill-text:${pillText};`;
}

function getReputationAccessLabel(score) {
  const value = Math.max(-5, Math.min(5, Math.floor(Number(score ?? 0) || 0)));
  const map = {
    "-5": "Nemesis",
    "-4": "Hated",
    "-3": "Hostile",
    "-2": "Distrusted",
    "-1": "Cold",
    "0": "Neutral",
    "1": "Noticed",
    "2": "Friendly",
    "3": "Favored",
    "4": "Allied",
    "5": "Exalted"
  };
  return map[String(value)] ?? "Neutral";
}

function buildReputationContext(reputationState, filters = {}) {
  const noteLogSelections = getReputationNoteLogSelections();
  const rawFactions = Array.isArray(reputationState?.factions)
    ? reputationState.factions.map((entry) => normalizeReputationFaction(entry))
    : getDefaultReputationFactions().map((entry) => normalizeReputationFaction(entry));
  const factions = rawFactions.map((faction) => {
    const band = getReputationBand(faction.score);
    const noteLogs = Array.isArray(faction.noteLogs)
      ? faction.noteLogs.map((row) => normalizeReputationNoteLog(row)).sort((a, b) => Number(b.loggedAt ?? 0) - Number(a.loggedAt ?? 0))
      : [];
    let selectedNoteLogId = String(noteLogSelections[faction.id] ?? "").trim();
    if (selectedNoteLogId && !noteLogs.some((row) => String(row.id ?? "") === selectedNoteLogId)) {
      selectedNoteLogId = "";
    }
    const selectedNoteLog = selectedNoteLogId
      ? (noteLogs.find((row) => String(row.id ?? "") === selectedNoteLogId) ?? null)
      : null;
    const noteLogOptions = noteLogs.slice(0, 50).map((row) => {
      const signedScore = row.score > 0 ? `+${row.score}` : String(row.score);
      const stamp = row.dayLabel || formatRecoveryDueLabel(Number(row.loggedAt ?? Date.now()));
      const summary = row.note.length > 64 ? `${row.note.slice(0, 61)}...` : row.note;
      return {
        value: row.id,
        label: `${stamp} - Rep ${signedScore} - ${summary}`,
        note: row.note,
        selected: selectedNoteLogId === String(row.id ?? "")
      };
    });
    const selectedScore = Number(selectedNoteLog?.score ?? 0);
    const selectedScoreLabel = selectedScore > 0 ? `+${selectedScore}` : String(selectedScore);
    const selectedDayLabel = String(selectedNoteLog?.dayLabel ?? "").trim()
      || formatRecoveryDueLabel(Number(selectedNoteLog?.loggedAt ?? Date.now()));
    const selectedPreviewSource = String(selectedNoteLog?.note ?? "").trim();
    const selectedPreview = selectedPreviewSource.length > 160
      ? `${selectedPreviewSource.slice(0, 157)}...`
      : selectedPreviewSource;
    return {
      ...faction,
      key: faction.id,
      band,
      standingClass: getReputationStandingClass(faction.score),
      standingStyle: getReputationStandingStyle(faction.score),
      access: getReputationAccessLabel(faction.score),
      noteLogs,
      noteLogOptions,
      hasNoteLogs: noteLogOptions.length > 0,
      noteLogCount: noteLogOptions.length,
      selectedNoteLogId,
      selectedNoteLog,
      hasSelectedNoteLog: Boolean(selectedNoteLog),
      selectedNoteLogScoreLabel: selectedScoreLabel,
      selectedNoteLogDayLabel: selectedDayLabel,
      selectedNoteLogPreview: selectedPreview
    };
  });

  const filterKeyword = String(filters?.keyword ?? "").trim().toLowerCase();
  const filterStanding = String(filters?.standing ?? "all").trim().toLowerCase();
  const filteredFactions = factions.filter((faction) => {
    const numericStanding = Number(filterStanding);
    const filterAsExactScore = Number.isFinite(numericStanding) && String(Math.floor(numericStanding)) === filterStanding;
    const standingMatch = filterStanding === "all"
      || (filterAsExactScore && faction.score === Math.floor(numericStanding))
      || faction.band === filterStanding;
    if (!standingMatch) return false;
    if (!filterKeyword) return true;
    const historical = (faction.noteLogs ?? []).map((row) => String(row.note ?? "")).join(" ");
    const haystack = `${faction.label} ${faction.note} ${historical} ${faction.band} ${faction.access} ${faction.score}`.toLowerCase();
    return haystack.includes(filterKeyword);
  });

  return {
    factions,
    filteredFactions,
    coreCount: factions.filter((faction) => faction.isCore).length,
    customCount: factions.filter((faction) => !faction.isCore).length,
    totalCount: factions.length,
    visibleCount: filteredFactions.length,
    filters: {
      keyword: String(filters?.keyword ?? ""),
      standing: filterStanding || "all",
      standingOptions: [
        { value: "all", label: "All Standing", selected: (filterStanding || "all") === "all" },
        { value: "5", label: "+5 Exalted", selected: filterStanding === "5" },
        { value: "4", label: "+4 Allied", selected: filterStanding === "4" },
        { value: "3", label: "+3 Favored", selected: filterStanding === "3" },
        { value: "2", label: "+2 Friendly", selected: filterStanding === "2" },
        { value: "1", label: "+1 Noticed", selected: filterStanding === "1" },
        { value: "0", label: "0 Neutral", selected: filterStanding === "0" },
        { value: "-1", label: "-1 Cold", selected: filterStanding === "-1" },
        { value: "-2", label: "-2 Distrusted", selected: filterStanding === "-2" },
        { value: "-3", label: "-3 Hostile", selected: filterStanding === "-3" },
        { value: "-4", label: "-4 Hated", selected: filterStanding === "-4" },
        { value: "-5", label: "-5 Nemesis", selected: filterStanding === "-5" }
      ]
    },
    highStandingCount: factions.filter((faction) => ["favorable", "trusted"].includes(faction.band)).length,
    hostileCount: factions.filter((faction) => faction.band === "hostile").length
  };
}

function getBaseSiteTypeLabel(type) {
  const map = {
    safehouse: "Safehouse",
    chapel: "Chapel",
    watchtower: "Watchtower",
    cell: "Underground Cell",
    "storage-cache": "Storage Cache"
  };
  return map[type] ?? "Site";
}

function getBaseSiteStatusLabel(status) {
  const map = {
    secure: "Secure",
    contested: "Contested",
    compromised: "Compromised",
    abandoned: "Abandoned"
  };
  return map[status] ?? "Secure";
}

function getItemWeightValue(itemLike) {
  const direct = Number(itemLike?.weight);
  if (Number.isFinite(direct)) return direct;
  const systemWeight = Number(itemLike?.system?.weight?.value);
  if (Number.isFinite(systemWeight)) return systemWeight;
  const flatWeight = Number(itemLike?.system?.weight);
  if (Number.isFinite(flatWeight)) return flatWeight;
  const bulk = Number(itemLike?.system?.bulk);
  if (Number.isFinite(bulk)) return bulk;
  return 0;
}

function normalizeBaseSiteStorageItem(entry = {}) {
  const quantityRaw = Number(entry?.quantity ?? 1);
  const quantity = Number.isFinite(quantityRaw) ? Math.max(1, Math.floor(quantityRaw)) : 1;
  const weightRaw = Number(entry?.weight ?? 0);
  const weight = Number.isFinite(weightRaw) ? Math.max(0, weightRaw) : 0;
  return {
    id: String(entry?.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID(),
    name: String(entry?.name ?? "Stored Item").trim() || "Stored Item",
    type: String(entry?.type ?? "item").trim() || "item",
    quantity,
    weight,
    note: String(entry?.note ?? ""),
    img: String(entry?.img ?? "icons/svg/item-bag.svg"),
    uuid: String(entry?.uuid ?? "")
  };
}

function normalizeBaseSiteEntry(site = {}, index = 0) {
  const storageRaw = site?.storage && typeof site.storage === "object" ? site.storage : {};
  const maxWeightRaw = Number(storageRaw?.maxWeight ?? site?.maxWeight ?? 0);
  const maxSpaceRaw = Number(storageRaw?.maxSpace ?? site?.maxSpace ?? 0);
  const maxWeight = Number.isFinite(maxWeightRaw) ? Math.max(0, maxWeightRaw) : 0;
  const maxSpace = Number.isFinite(maxSpaceRaw) ? Math.max(0, Math.floor(maxSpaceRaw)) : 0;
  const items = Array.isArray(storageRaw?.items)
    ? storageRaw.items.map((entry) => normalizeBaseSiteStorageItem(entry))
    : [];
  return {
    id: site.id ?? `legacy-base-site-${index}`,
    type: String(site.type ?? "safehouse"),
    name: String(site.name ?? "Unnamed Site"),
    status: String(site.status ?? "secure"),
    risk: String(site.risk ?? "moderate"),
    pressure: Math.max(0, Number(site.pressure ?? 0) || 0),
    note: String(site.note ?? ""),
    storage: {
      maxWeight,
      maxSpace,
      items
    }
  };
}

function buildBaseOperationsContext(baseState) {
  const sites = Array.isArray(baseState?.sites)
    ? baseState.sites.map((site, index) => {
      const normalizedSite = normalizeBaseSiteEntry(site, index);
      const type = normalizedSite.type;
      const status = normalizedSite.status;
      const risk = normalizedSite.risk;
      const pressure = normalizedSite.pressure;
      const storageItems = normalizedSite.storage.items;
      const storageItemCount = storageItems.reduce((sum, entry) => sum + Math.max(0, Number(entry.quantity ?? 0) || 0), 0);
      const storageWeightUsed = storageItems.reduce((sum, entry) => {
        const quantity = Math.max(0, Number(entry.quantity ?? 0) || 0);
        const weight = Math.max(0, Number(entry.weight ?? 0) || 0);
        return sum + (quantity * weight);
      }, 0);
      const maxWeight = Math.max(0, Number(normalizedSite.storage.maxWeight ?? 0) || 0);
      const maxSpace = Math.max(0, Number(normalizedSite.storage.maxSpace ?? 0) || 0);
      return {
        id: normalizedSite.id,
        type,
        typeLabel: getBaseSiteTypeLabel(type),
        name: normalizedSite.name,
        status,
        statusLabel: getBaseSiteStatusLabel(status),
        risk,
        pressure,
        note: normalizedSite.note,
        storageMaxWeight: maxWeight,
        storageMaxSpace: maxSpace,
        storageWeightUsed,
        storageSpaceUsed: storageItemCount,
        storageItemCount,
        hasStorageCapacity: maxWeight > 0 || maxSpace > 0,
        storageWeightSummary: maxWeight > 0 ? `${storageWeightUsed.toFixed(1)} / ${maxWeight.toFixed(1)}` : `${storageWeightUsed.toFixed(1)} / infinite`,
        storageSpaceSummary: maxSpace > 0 ? `${storageItemCount} / ${maxSpace}` : `${storageItemCount} / infinite`
      };
    })
    : [];

  const activeSites = sites.filter((site) => site.status !== "abandoned").length;
  const contestedSites = sites.filter((site) => ["contested", "compromised"].includes(site.status)).length;
  const pressureSum = sites.reduce((sum, site) => sum + Number(site.pressure ?? 0), 0);
  const maintenanceRisk = String(baseState?.maintenanceRisk ?? "moderate");
  const riskBase = maintenanceRisk === "high" ? 2 : maintenanceRisk === "low" ? 0 : 1;
  const maintenancePressure = riskBase + (activeSites === 0 ? 2 : Math.max(0, activeSites - 2)) + Math.floor(pressureSum / 5) + contestedSites;
  const readiness = activeSites >= 2 && maintenancePressure <= 3;

  return {
    sites,
    maintenanceRisk,
    maintenancePressure,
    activeSites,
    contestedSites,
    readiness,
    pressureSum,
    riskOptions: [
      { value: "low", label: "Low", selected: maintenanceRisk === "low" },
      { value: "moderate", label: "Moderate", selected: maintenanceRisk === "moderate" },
      { value: "high", label: "High", selected: maintenanceRisk === "high" }
    ],
    siteTypeOptions: [
      { value: "safehouse", label: "Safehouse", selected: true },
      { value: "chapel", label: "Chapel", selected: false },
      { value: "watchtower", label: "Watchtower", selected: false },
      { value: "cell", label: "Underground Cell", selected: false },
      { value: "storage-cache", label: "Storage Cache", selected: false }
    ],
    statusOptions: [
      { value: "secure", label: "Secure", selected: true },
      { value: "contested", label: "Contested", selected: false },
      { value: "compromised", label: "Compromised", selected: false },
      { value: "abandoned", label: "Abandoned", selected: false }
    ],
    siteRiskOptions: [
      { value: "low", label: "Low", selected: false },
      { value: "moderate", label: "Moderate", selected: true },
      { value: "high", label: "High", selected: false }
    ]
  };
}

function ensureBaseOperationsState(ledger) {
  if (!ledger.baseOperations) {
    ledger.baseOperations = {
      maintenanceRisk: "moderate",
      sites: []
    };
  }
  if (!Array.isArray(ledger.baseOperations.sites)) ledger.baseOperations.sites = [];
  ledger.baseOperations.sites = ledger.baseOperations.sites.map((site, index) => normalizeBaseSiteEntry(site, index));
  if (!ledger.baseOperations.maintenanceRisk) ledger.baseOperations.maintenanceRisk = "moderate";
  return ledger.baseOperations;
}

function normalizeMerchantTagList(values = []) {
  return normalizeMerchantTagListDomain(values);
}

function normalizeMerchantKeywordList(values = []) {
  return normalizeMerchantKeywordListDomain(values);
}

function normalizeMerchantSourcePackIds(values = [], fallbackSourceRef = "") {
  return normalizeMerchantSourcePackIdsDomain(values, fallbackSourceRef);
}

function normalizeMerchantAllowedItemTypes(values = []) {
  return normalizeMerchantAllowedItemTypesDomain(values);
}

function normalizeMerchantCuratedItemUuids(values = []) {
  return normalizeMerchantCuratedItemUuidsDomain(values);
}

function parseMerchantUuidListInput(value) {
  return parseMerchantUuidListInputDomain(value);
}

function formatMerchantUuidListInput(values = []) {
  return formatMerchantUuidListInputDomain(values);
}

function normalizeMerchantSourceType(value) {
  return normalizeMerchantSourceTypeDomain(value);
}

function normalizeMerchantScarcity(value) {
  return normalizeMerchantScarcityDomain(value);
}

function getMerchantScarcityProfile(value) {
  return getMerchantScarcityProfileDomain(value);
}

function normalizeMerchantRace(value) {
  return normalizeMerchantRaceDomain(value);
}

function normalizeMerchantRarity(value) {
  return normalizeMerchantRarityDomain(value);
}

function getMerchantRarityBucket(value) {
  return getMerchantRarityBucketDomain(value);
}

function normalizeMerchantRarityWeights(raw = {}, fallback = undefined) {
  return normalizeMerchantRarityWeightsDomain(raw, fallback);
}

function normalizeMerchantCityList(values = []) {
  return normalizeMerchantCityListDomain(values);
}

function parseMerchantCityListInput(value = "") {
  return parseMerchantCityListInputDomain(value);
}

function formatMerchantCityListInput(values = []) {
  return formatMerchantCityListInputDomain(values);
}

function getMerchantRaceKey(value) {
  return getMerchantRaceKeyDomain(value);
}

function getMerchantEditorRaceOptions(selectedRaceInput = "") {
  return getMerchantEditorRaceOptionsDomain(selectedRaceInput);
}

function pickRandomMerchantRace(fallback = "Human") {
  return pickRandomMerchantRaceDomain(fallback);
}

function pickRandomMerchantTitle(fallback = "Merchant") {
  return pickRandomMerchantTitleDomain(fallback);
}

function pickRandomMerchantNamePart(values = [], fallback = "") {
  return pickRandomMerchantNamePartDomain(values, fallback);
}

function generateRandomMerchantName(raceInput = "") {
  return generateRandomMerchantNameDomain(raceInput);
}

function generateRandomMerchantNameUnbound() {
  return generateRandomMerchantNameUnboundDomain();
}

function buildMerchantOfferTagOptions(selectedTypes = []) {
  return buildMerchantOfferTagOptionsDomain(selectedTypes);
}

function resolveMerchantAllowedTypesFromOfferTags(selectedTagIds = [], fallbackTypes = MERCHANT_ALLOWED_ITEM_TYPE_LIST) {
  return resolveMerchantAllowedTypesFromOfferTagsDomain(selectedTagIds, fallbackTypes);
}

function buildMerchantCityOptions(cityList = [], selectedCity = "") {
  return buildMerchantCityOptionsDomain(cityList, selectedCity);
}

function getMerchantEditorSourceTypeOptions(selected = MERCHANT_SOURCE_TYPES.WORLD_FOLDER) {
  return getMerchantEditorSourceTypeOptionsDomain(selected);
}

function normalizeMerchantAccessMode(value, fallback = MERCHANT_ACCESS_MODES.ALL) {
  const normalized = String(value ?? "").trim().toLowerCase();
  if (normalized === MERCHANT_ACCESS_MODES.ASSIGNED) return MERCHANT_ACCESS_MODES.ASSIGNED;
  if (normalized === MERCHANT_ACCESS_MODES.ALL) return MERCHANT_ACCESS_MODES.ALL;
  return normalizeMerchantAccessMode(fallback, MERCHANT_ACCESS_MODES.ALL);
}

function normalizeMerchantBarterAbility(value, fallback = MERCHANT_DEFAULTS.pricing.barterAbility ?? "cha") {
  const normalized = String(value ?? "").trim().toLowerCase();
  if (Object.prototype.hasOwnProperty.call(MERCHANT_BARTER_ABILITY_LABELS, normalized)) return normalized;
  const fallbackKey = String(fallback ?? "cha").trim().toLowerCase();
  if (Object.prototype.hasOwnProperty.call(MERCHANT_BARTER_ABILITY_LABELS, fallbackKey)) return fallbackKey;
  return "cha";
}

function getMerchantAccessModeOptions(selected = MERCHANT_ACCESS_MODES.ALL) {
  const active = normalizeMerchantAccessMode(selected, MERCHANT_ACCESS_MODES.ALL);
  return [
    { value: MERCHANT_ACCESS_MODES.ALL, label: "All Players", selected: active === MERCHANT_ACCESS_MODES.ALL },
    { value: MERCHANT_ACCESS_MODES.ASSIGNED, label: "Assigned Players", selected: active === MERCHANT_ACCESS_MODES.ASSIGNED }
  ];
}

function getMerchantBarterAbilityOptions(selected = MERCHANT_DEFAULTS.pricing.barterAbility ?? "cha") {
  const active = normalizeMerchantBarterAbility(selected);
  return Object.entries(MERCHANT_BARTER_ABILITY_LABELS).map(([value, label]) => ({
    value,
    label,
    selected: value === active
  }));
}

function normalizeMerchantDefinition(raw = {}, index = 0) {
  const source = raw && typeof raw === "object" ? raw : {};
  const fallbackId = foundry.utils.randomID();
  const id = String(source.id ?? fallbackId).trim() || fallbackId;
  const name = String(source.name ?? "").trim() || `Merchant ${Math.max(1, Number(index) + 1)}`;
  const title = String(source.title ?? "").trim();
  const race = normalizeMerchantRace(source.race ?? "");
  const img = String(source.img ?? "").trim() || "icons/svg/item-bag.svg";
  const settlement = String(source.settlement ?? MERCHANT_DEFAULTS.settlement).trim().slice(0, 120);
  const accessMode = normalizeMerchantAccessMode(source?.accessMode ?? source?.access?.mode ?? MERCHANT_ACCESS_MODES.ALL);
  const isHidden = false;
  const requiresContract = false;
  const contractKey = "";
  const socialGateEnabled = false;
  const minSocialScore = 0;
  const buyMarkupRaw = Number(source?.pricing?.buyMarkup ?? source.buyMarkup ?? MERCHANT_DEFAULTS.pricing.buyMarkup);
  const sellRateRaw = Number(source?.pricing?.sellRate ?? source.sellRate ?? MERCHANT_DEFAULTS.pricing.sellRate);
  const sellEnabled = source?.pricing?.sellEnabled === undefined
    ? Boolean(source?.sellEnabled ?? MERCHANT_DEFAULTS.pricing.sellEnabled)
    : Boolean(source?.pricing?.sellEnabled);
  const cashOnHandGpRaw = Number(
    source?.pricing?.cashOnHandGp
    ?? source?.cashOnHandGp
    ?? MERCHANT_DEFAULTS.pricing.cashOnHandGp
  );
  const buybackAllowedTypes = normalizeMerchantAllowedItemTypes(
    source?.pricing?.buybackAllowedTypes
    ?? source?.buybackAllowedTypes
    ?? MERCHANT_DEFAULTS.pricing.buybackAllowedTypes
    ?? MERCHANT_ALLOWED_ITEM_TYPE_LIST
  );
  const barterEnabled = source?.pricing?.barterEnabled === undefined
    ? Boolean(source?.barterEnabled ?? MERCHANT_DEFAULTS.pricing.barterEnabled)
    : Boolean(source?.pricing?.barterEnabled);
  const barterDcRaw = Number(source?.pricing?.barterDc ?? source?.barterDc ?? MERCHANT_DEFAULTS.pricing.barterDc);
  const barterAbility = normalizeMerchantBarterAbility(
    source?.pricing?.barterAbility ?? source?.barterAbility,
    MERCHANT_DEFAULTS.pricing.barterAbility ?? "cha"
  );
  const buyMarkup = Number.isFinite(buyMarkupRaw) ? Math.max(0, Math.min(10, Number(buyMarkupRaw.toFixed(2)))) : MERCHANT_DEFAULTS.pricing.buyMarkup;
  const sellRate = Number.isFinite(sellRateRaw) ? Math.max(0, Math.min(10, Number(sellRateRaw.toFixed(2)))) : MERCHANT_DEFAULTS.pricing.sellRate;
  const cashOnHandGp = Number.isFinite(cashOnHandGpRaw)
    ? Math.max(0, Math.min(1000000, Number(cashOnHandGpRaw.toFixed(2))))
    : Number(MERCHANT_DEFAULTS.pricing.cashOnHandGp);
  const barterDc = Number.isFinite(barterDcRaw)
    ? Math.max(1, Math.min(40, Math.floor(barterDcRaw)))
    : Number(MERCHANT_DEFAULTS.pricing.barterDc);
  const stock = source.stock && typeof source.stock === "object" ? source.stock : {};
  const sourceType = normalizeMerchantSourceType(stock.sourceType ?? source.sourceType);
  const sourceRef = String(stock.sourceRef ?? source.sourceRef ?? "").trim();
  const sourcePackIds = normalizeMerchantSourcePackIds(
    stock.sourcePackIds ?? source.sourcePackIds ?? [],
    sourceType === MERCHANT_SOURCE_TYPES.WORLD_ITEMS ? "" : sourceRef
  );
  const includeTags = normalizeMerchantTagList(stock.includeTags ?? source.includeTags ?? []);
  const excludeTags = normalizeMerchantTagList(stock.excludeTags ?? source.excludeTags ?? []);
  const keywordInclude = normalizeMerchantKeywordList(stock.keywordInclude ?? source.keywordInclude ?? []);
  const keywordExclude = normalizeMerchantKeywordList(stock.keywordExclude ?? source.keywordExclude ?? []);
  const allowedTypes = normalizeMerchantAllowedItemTypes(stock.allowedTypes ?? source.allowedTypes ?? []);
  const curatedItemUuids = normalizeMerchantCuratedItemUuids(stock.curatedItemUuids ?? source.curatedItemUuids ?? []);
  const maxItemsRaw = Number(stock.maxItems ?? source.maxItems ?? MERCHANT_DEFAULTS.stock.maxItems);
  const maxItems = Number.isFinite(maxItemsRaw)
    ? Math.max(1, Math.min(100, Math.floor(maxItemsRaw)))
    : Math.max(1, Math.min(100, Math.floor(Number(MERCHANT_DEFAULTS.stock.maxItems) || 20)));
  const targetValueGpRaw = Number(stock.targetValueGp ?? source.targetValueGp ?? MERCHANT_DEFAULTS.stock.targetValueGp);
  const targetValueGp = Number.isFinite(targetValueGpRaw)
    ? Math.max(0, Math.min(1000000, Number(targetValueGpRaw.toFixed(2))))
    : MERCHANT_DEFAULTS.stock.targetValueGp;
  const scarcity = normalizeMerchantScarcity(stock.scarcity ?? source.scarcity ?? MERCHANT_DEFAULTS.stock.scarcity);
  const duplicateChanceRaw = Number(stock.duplicateChance ?? source.duplicateChance ?? MERCHANT_DEFAULTS.stock.duplicateChance ?? 25);
  const duplicateChance = Number.isFinite(duplicateChanceRaw)
    ? Math.max(0, Math.min(100, Math.floor(duplicateChanceRaw)))
    : Math.max(0, Math.min(100, Math.floor(Number(MERCHANT_DEFAULTS.stock.duplicateChance ?? 25) || 25)));
  const maxStackSize = 20;
  const rarityWeights = normalizeMerchantRarityWeights(
    stock.rarityWeights ?? source.rarityWeights ?? MERCHANT_DEFAULTS.stock.rarityWeights,
    MERCHANT_DEFAULTS.stock.rarityWeights
  );
  const actorId = String(source.actorId ?? "").trim();
  return {
    id,
    name,
    title,
    race,
    img,
    settlement,
    accessMode,
    isHidden,
    requiresContract,
    contractKey,
    socialGateEnabled,
    minSocialScore,
    pricing: {
      buyMarkup,
      sellRate,
      sellEnabled,
      cashOnHandGp,
      buybackAllowedTypes,
      barterEnabled,
      barterDc,
      barterAbility
    },
    stock: {
      sourceType,
      sourceRef: sourceType === MERCHANT_SOURCE_TYPES.WORLD_ITEMS
        ? ""
        : String(sourcePackIds[0] ?? sourceRef).trim(),
      sourcePackIds,
      includeTags,
      excludeTags,
      keywordInclude,
      keywordExclude,
      allowedTypes,
      curatedItemUuids,
      maxItems,
      targetValueGp,
      scarcity,
      duplicateChance,
      maxStackSize,
      rarityWeights
    },
    actorId
  };
}

function normalizeMerchantStockStateEntry(raw = {}, fallbackActorId = "") {
  const source = raw && typeof raw === "object" ? raw : {};
  const refreshedAtRaw = Number(source.lastRefreshedAt ?? source.refreshedAt ?? 0);
  const lastRefreshedAt = Number.isFinite(refreshedAtRaw) ? Math.max(0, Math.floor(refreshedAtRaw)) : 0;
  return {
    lastRefreshedAt,
    lastRefreshedBy: String(source.lastRefreshedBy ?? source.refreshedBy ?? "").trim() || "GM",
    actorId: String(source.actorId ?? fallbackActorId ?? "").trim()
  };
}

function normalizeMerchantAccessLogEntry(raw = {}) {
  const source = raw && typeof raw === "object" ? raw : {};
  const viewedAtRaw = Number(source.viewedAt ?? source.createdAt ?? source.ts ?? Date.now());
  const viewedAt = Number.isFinite(viewedAtRaw) ? Math.max(0, Math.floor(viewedAtRaw)) : Date.now();
  return {
    id: String(source.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID(),
    viewedAt,
    userId: String(source.userId ?? "").trim(),
    userName: String(source.userName ?? source.viewer ?? "Player").trim() || "Player",
    actorId: String(source.actorId ?? "").trim(),
    actorName: String(source.actorName ?? "").trim(),
    settlement: normalizeMerchantSettlementSelection(source.settlement ?? source.city ?? ""),
    merchantId: String(source.merchantId ?? "").trim(),
    merchantName: String(source.merchantName ?? "").trim()
  };
}

function ensureMerchantsState(ledger) {
  if (!ledger || typeof ledger !== "object") return {
    currentSettlement: "",
    cityCatalog: [],
    definitions: [],
    stockStateById: {},
    accessLog: []
  };
  if (!ledger.merchants || typeof ledger.merchants !== "object" || Array.isArray(ledger.merchants)) {
    ledger.merchants = {};
  }
  const merchants = ledger.merchants;
  merchants.currentSettlement = String(merchants.currentSettlement ?? "").trim().slice(0, 120);
  if (!Array.isArray(merchants.cityCatalog)) merchants.cityCatalog = [];
  merchants.cityCatalog = normalizeMerchantCityList(merchants.cityCatalog);
  if (!Array.isArray(merchants.definitions)) merchants.definitions = [];
  if (!merchants.stockStateById || typeof merchants.stockStateById !== "object" || Array.isArray(merchants.stockStateById)) {
    merchants.stockStateById = {};
  }
  if (!Array.isArray(merchants.accessLog)) merchants.accessLog = [];
  const seenIds = new Set();
  merchants.definitions = merchants.definitions
    .map((entry, index) => normalizeMerchantDefinition(entry, index))
    .filter((entry) => {
      if (!entry.id || seenIds.has(entry.id)) return false;
      seenIds.add(entry.id);
      return true;
    });
  const normalizedStockState = {};
  for (const definition of merchants.definitions) {
    const merchantId = String(definition.id ?? "").trim();
    if (!merchantId) continue;
    normalizedStockState[merchantId] = normalizeMerchantStockStateEntry(
      merchants.stockStateById?.[merchantId],
      definition.actorId
    );
  }
  merchants.stockStateById = normalizedStockState;
  merchants.accessLog = merchants.accessLog
    .map((entry) => normalizeMerchantAccessLogEntry(entry))
    .filter((entry, index, arr) => entry.id && arr.findIndex((candidate) => candidate.id === entry.id) === index)
    .sort((a, b) => Number(b.viewedAt ?? 0) - Number(a.viewedAt ?? 0))
    .slice(0, MERCHANT_ACCESS_LOG_LIMIT);
  return merchants;
}

function getMerchants() {
  const ledger = getOperationsLedger();
  const merchants = ensureMerchantsState(ledger);
  return foundry.utils.deepClone(merchants.definitions ?? []);
}

async function upsertMerchant(definitionPatch = {}) {
  let persisted = null;
  await updateOperationsLedger((ledger) => {
    const merchants = ensureMerchantsState(ledger);
    const incomingId = String(definitionPatch?.id ?? "").trim();
    const existingIndex = incomingId
      ? merchants.definitions.findIndex((entry) => String(entry?.id ?? "") === incomingId)
      : -1;
    const base = existingIndex >= 0 ? merchants.definitions[existingIndex] : {};
    const merged = {
      ...foundry.utils.deepClone(base),
      ...foundry.utils.deepClone(definitionPatch),
      id: incomingId || String(base?.id ?? "")
    };
    const normalized = normalizeMerchantDefinition(merged, existingIndex >= 0 ? existingIndex : merchants.definitions.length);
    if (existingIndex >= 0) merchants.definitions[existingIndex] = normalized;
    else merchants.definitions.push(normalized);
    merchants.stockStateById[normalized.id] = normalizeMerchantStockStateEntry(
      merchants.stockStateById?.[normalized.id],
      normalized.actorId
    );
    persisted = foundry.utils.deepClone(normalized);
  });
  return persisted;
}

function normalizeMerchantFolderAlias(value = "") {
  return normalizeMerchantFolderAliasDomain(value);
}

function findMerchantItemFolderByAliases(aliases = []) {
  return findMerchantFolderByAliasesDomain(aliases, game.folders?.contents ?? []);
}

function buildStarterMerchantPatch(blueprint = {}, index = 0) {
  return buildStarterMerchantPatchDomain(blueprint, index, {
    resolveFolderByAliases: (aliasesInput) => findMerchantItemFolderByAliases(aliasesInput)
  });
}

async function createStarterMerchants(options = {}) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can create starter merchants.");
    return { ok: false, createdCount: 0, updatedCount: 0, refreshedCount: 0, missingFolders: [] };
  }
  const blueprints = Array.isArray(MERCHANT_STARTER_BLUEPRINTS) ? MERCHANT_STARTER_BLUEPRINTS : [];
  if (blueprints.length <= 0) {
    ui.notifications?.warn("No starter merchant presets are configured.");
    return { ok: false, createdCount: 0, updatedCount: 0, refreshedCount: 0, missingFolders: [] };
  }

  let createdCount = 0;
  let updatedCount = 0;
  let refreshedCount = 0;
  const missingFolders = [];

  for (let index = 0; index < blueprints.length; index += 1) {
    const blueprint = blueprints[index];
    const patch = buildStarterMerchantPatch(blueprint, index);
    const existed = Boolean(getMerchantById(patch.id));
    if (!patch?.stock?.sourceRef) missingFolders.push(String(patch.name ?? `Merchant ${index + 1}`));
    const saved = await upsertMerchant(patch);
    if (!saved?.id) continue;
    if (existed) updatedCount += 1;
    else createdCount += 1;
    if (patch?.stock?.sourceRef) {
      const result = await refreshMerchantStock(saved.id, { silent: true });
      if (result?.ok) refreshedCount += 1;
    }
  }

  const totalSynced = createdCount + updatedCount;
  if (totalSynced > 0) {
    ui.notifications?.info(
      `Starter merchants synced: ${createdCount} created, ${updatedCount} updated, ${refreshedCount} stocked.`
    );
  }
  if (missingFolders.length > 0) {
    ui.notifications?.warn(
      `No matching item folders for: ${missingFolders.join(", ")}. Set Stock Source in Merchant Editor.`
    );
  }

  return {
    ok: totalSynced > 0,
    createdCount,
    updatedCount,
    refreshedCount,
    missingFolders
  };
}

async function deleteMerchant(merchantIdInput) {
  const merchantId = String(merchantIdInput ?? "").trim();
  if (!merchantId) return;
  const cleanupActors = getOwnedPcActors();
  await updateOperationsLedger((ledger) => {
    const merchants = ensureMerchantsState(ledger);
    merchants.definitions = merchants.definitions.filter((entry) => String(entry?.id ?? "") !== merchantId);
    if (merchants.stockStateById && typeof merchants.stockStateById === "object") {
      delete merchants.stockStateById[merchantId];
    }
  });
  for (const actor of cleanupActors) {
    if (!actor) continue;
    const contracts = getActorMerchantContracts(actor);
    if (!contracts[merchantId]) continue;
    const next = foundry.utils.deepClone(contracts);
    delete next[merchantId];
    await actor.setFlag(MODULE_ID, "merchantContracts", next);
  }
}

async function setMerchantCurrentSettlement(value) {
  const settlement = String(value ?? "").trim().slice(0, 120);
  await updateOperationsLedger((ledger) => {
    const merchants = ensureMerchantsState(ledger);
    merchants.currentSettlement = settlement;
  });
}

function buildMerchantCityCatalogRows(merchantsState = {}, definitions = []) {
  const rows = [];
  rows.push(...normalizeMerchantCityList(merchantsState?.cityCatalog ?? []));
  for (const definition of (Array.isArray(definitions) ? definitions : [])) {
    const settlement = normalizeMerchantSettlementSelection(definition?.settlement ?? "");
    if (settlement) rows.push(settlement);
  }
  return normalizeMerchantCityList(rows);
}

async function saveMerchantCityCatalog(rawInput = "") {
  const cityCatalog = parseMerchantCityListInput(rawInput);
  await updateOperationsLedger((ledger) => {
    const merchants = ensureMerchantsState(ledger);
    merchants.cityCatalog = cityCatalog;
  });
  return cityCatalog;
}

async function setMerchantCityById(merchantIdInput, cityInput = "") {
  const merchantId = String(merchantIdInput ?? "").trim();
  if (!merchantId) return null;
  const settlement = normalizeMerchantSettlementSelection(cityInput);
  return upsertMerchant({
    id: merchantId,
    settlement
  });
}

function getActorMerchantContracts(actor) {
  const raw = actor?.getFlag?.(MODULE_ID, "merchantContracts");
  if (!raw || typeof raw !== "object" || Array.isArray(raw)) return {};
  const normalized = {};
  for (const [keyRaw, valueRaw] of Object.entries(raw)) {
    const key = String(keyRaw ?? "").trim();
    if (!key) continue;
    if (valueRaw === true) normalized[key] = true;
  }
  return normalized;
}

async function setMerchantAssignment(actorIdInput, merchantIdInput, assigned) {
  const actorId = String(actorIdInput ?? "").trim();
  const merchantId = String(merchantIdInput ?? "").trim();
  if (!actorId || !merchantId) return false;
  const actor = game.actors.get(actorId);
  if (!actor) return false;
  const current = foundry.utils.deepClone(getActorMerchantContracts(actor));
  if (assigned) current[merchantId] = true;
  else delete current[merchantId];
  await actor.setFlag(MODULE_ID, "merchantContracts", current);
  return true;
}

function computeActorSocialScore(actor) {
  if (!actor) return 0;
  const moduleFlag = Number(actor.getFlag?.(MODULE_ID, "socialScore"));
  if (Number.isFinite(moduleFlag)) return Math.max(-20, Math.min(20, Math.floor(moduleFlag)));
  const legacyFlag = Number(getLegacyPartyOpsFlag(actor, "socialScore"));
  if (Number.isFinite(legacyFlag)) return Math.max(-20, Math.min(20, Math.floor(legacyFlag)));
  return 0;
}

function isMerchantSettlementMatch(merchant, currentSettlementInput) {
  const merchantSettlement = String(merchant?.settlement ?? "").trim().toLowerCase();
  if (!merchantSettlement || merchantSettlement === "global") return true;
  const currentSettlement = String(currentSettlementInput ?? "").trim().toLowerCase();
  if (!currentSettlement) return true;
  return merchantSettlement === currentSettlement;
}

function isMerchantAvailableToActor(merchant, actor, currentSettlement, options = {}) {
  if (!merchant || !actor) return false;
  if (options?.isGM) return true;
  if (!isMerchantSettlementMatch(merchant, currentSettlement)) return false;
  const contracts = getActorMerchantContracts(actor);
  const hasContract = Boolean(contracts[merchant.id] || (merchant.contractKey && contracts[merchant.contractKey]));
  const accessMode = normalizeMerchantAccessMode(merchant?.accessMode ?? MERCHANT_ACCESS_MODES.ALL);
  if (accessMode === MERCHANT_ACCESS_MODES.ASSIGNED && !hasContract) return false;
  if (merchant.requiresContract && !hasContract) return false;
  if (merchant.isHidden && !hasContract) return false;
  if (merchant.socialGateEnabled) {
    const score = computeActorSocialScore(actor);
    if (score < Number(merchant.minSocialScore ?? 0)) return false;
  }
  return true;
}

function getActorMerchants(actor) {
  const ledger = getOperationsLedger();
  const merchants = ensureMerchantsState(ledger);
  const isGM = canAccessAllPlayerOps();
  return merchants.definitions
    .filter((entry) => isMerchantAvailableToActor(entry, actor, merchants.currentSettlement, { isGM }))
    .map((entry) => foundry.utils.deepClone(entry));
}

function getMerchantById(merchantIdInput, ledger = getOperationsLedger()) {
  const merchantId = String(merchantIdInput ?? "").trim();
  if (!merchantId) return null;
  const merchants = ensureMerchantsState(ledger);
  return merchants.definitions.find((entry) => String(entry?.id ?? "") === merchantId) ?? null;
}

function getMerchantStockStateById(merchantIdInput, ledger = getOperationsLedger()) {
  const merchantId = String(merchantIdInput ?? "").trim();
  if (!merchantId) return null;
  const merchants = ensureMerchantsState(ledger);
  const stockState = merchants.stockStateById?.[merchantId];
  return stockState ? normalizeMerchantStockStateEntry(stockState) : null;
}

function getMerchantSourceTypeOptions(selected = MERCHANT_SOURCE_TYPES.WORLD_ITEMS) {
  const value = normalizeMerchantSourceType(selected);
  return [
    { value: MERCHANT_SOURCE_TYPES.WORLD_ITEMS, label: "World Items", selected: value === MERCHANT_SOURCE_TYPES.WORLD_ITEMS },
    { value: MERCHANT_SOURCE_TYPES.WORLD_FOLDER, label: "World Folder", selected: value === MERCHANT_SOURCE_TYPES.WORLD_FOLDER },
    { value: MERCHANT_SOURCE_TYPES.COMPENDIUM_PACK, label: "Compendium Pack", selected: value === MERCHANT_SOURCE_TYPES.COMPENDIUM_PACK }
  ];
}

function getMerchantScarcityOptions(selected = MERCHANT_SCARCITY_LEVELS.NORMAL) {
  const value = normalizeMerchantScarcity(selected);
  return MERCHANT_SCARCITY_PROFILES.map((profile) => {
    const multiplier = Number(profile?.multiplier ?? 1);
    const percent = Math.round(multiplier * 100);
    return {
      value: String(profile?.value ?? MERCHANT_SCARCITY_LEVELS.NORMAL),
      label: `${String(profile?.label ?? "Normal")} (${percent}%)`,
      selected: String(profile?.value ?? "").trim().toLowerCase() === value
    };
  });
}

function normalizeMerchantTagsCsv(value) {
  const text = String(value ?? "");
  if (!text.trim()) return [];
  return normalizeMerchantTagList(text.split(/[\n,;]+/));
}

function formatMerchantTagsCsv(values = []) {
  return normalizeMerchantTagList(values).join(", ");
}

function normalizeMerchantKeywordsCsv(value) {
  const text = String(value ?? "");
  if (!text.trim()) return [];
  return normalizeMerchantKeywordList(text.split(/[\n,;]+/));
}

function formatMerchantKeywordsCsv(values = []) {
  return normalizeMerchantKeywordList(values).join(", ");
}

function getMerchantSettlementLabel(value) {
  const settlement = String(value ?? "").trim();
  if (!settlement || settlement.toLowerCase() === "global") return "Global";
  return settlement;
}

function formatMerchantTimestampLabel(value) {
  const ts = Number(value ?? 0);
  if (!Number.isFinite(ts) || ts <= 0) return "-";
  const date = new Date(ts);
  return Number.isFinite(date.getTime()) ? date.toLocaleString() : "-";
}

function getMerchantSourceTypeLabel(value) {
  const normalized = normalizeMerchantSourceType(value);
  if (normalized === MERCHANT_SOURCE_TYPES.COMPENDIUM_PACK) return "Compendium Pack";
  if (normalized === MERCHANT_SOURCE_TYPES.WORLD_FOLDER) return "World Folder";
  return "World Items";
}

function normalizeMerchantTradeLineItems(raw = []) {
  if (!Array.isArray(raw)) return [];
  const byItemId = new Map();
  for (const entry of raw) {
    const itemId = String(entry?.itemId ?? "").trim();
    const qtyRaw = Number(entry?.qty ?? entry?.quantity ?? 0);
    const qty = Number.isFinite(qtyRaw) ? Math.max(0, Math.min(999, Math.floor(qtyRaw))) : 0;
    if (!itemId || qty <= 0) continue;
    byItemId.set(itemId, Math.max(0, (byItemId.get(itemId) ?? 0) + qty));
  }
  return Array.from(byItemId.entries()).map(([itemId, qty]) => ({ itemId, qty }));
}

function getMerchantItemData(itemLike) {
  if (!itemLike) return {};
  if (typeof itemLike.toObject === "function") return itemLike.toObject();
  return itemLike;
}

function getMerchantItemDataQuantity(itemData = {}) {
  const quantity = Number(itemData?.system?.quantity);
  if (Number.isFinite(quantity)) return Math.max(0, Math.floor(quantity));
  const quantityValue = Number(itemData?.system?.quantity?.value);
  if (Number.isFinite(quantityValue)) return Math.max(0, Math.floor(quantityValue));
  const uses = Number(itemData?.system?.uses?.value);
  if (Number.isFinite(uses)) return Math.max(0, Math.floor(uses));
  return 1;
}

function setMerchantItemDataQuantity(itemData = {}, quantity = 1) {
  const next = Math.max(0, Math.floor(Number(quantity ?? 0) || 0));
  const data = itemData && typeof itemData === "object" ? itemData : {};
  if (!data.system || typeof data.system !== "object") data.system = {};
  if (data.system.quantity !== undefined && data.system.quantity !== null) {
    if (typeof data.system.quantity === "object") data.system.quantity.value = next;
    else data.system.quantity = next;
    return data;
  }
  if (data.system.uses?.value !== undefined) {
    data.system.uses.value = next;
    return data;
  }
  data.system.quantity = next;
  return data;
}

function getMerchantItemTagsFromData(itemData = {}) {
  return normalizeMerchantTagList(
    itemData?.flags?.[MODULE_ID]?.tags
    ?? itemData?.flags?.["party-operations"]?.tags
    ?? []
  );
}

function getMerchantItemKeywordTokensFromData(itemData = {}) {
  const explicitTags = getMerchantItemTagsFromData(itemData);
  const explicitKeywords = getLootKeywordsFromData(itemData);
  const itemType = String(itemData?.type ?? "").trim().toLowerCase();
  const rarity = normalizeMerchantRarity(getLootRarityFromData(itemData));
  const name = String(itemData?.name ?? "").trim().toLowerCase();
  const description = String(itemData?.system?.description?.value ?? "")
    .replace(/<[^>]*>/g, " ")
    .trim()
    .toLowerCase();
  const nameTokens = name.split(/[^a-z0-9]+/).filter((entry) => entry.length >= 3).slice(0, 18);
  const descriptionTokens = description.split(/[^a-z0-9]+/).filter((entry) => entry.length >= 4).slice(0, 24);
  return normalizeMerchantKeywordList([
    ...explicitTags,
    ...explicitKeywords,
    itemType,
    rarity,
    name,
    ...nameTokens,
    ...descriptionTokens
  ]);
}

function getActorCurrencyBundle(actor) {
  return {
    pp: getActorCurrentCurrencyValue(actor, "pp"),
    gp: getActorCurrentCurrencyValue(actor, "gp"),
    sp: getActorCurrentCurrencyValue(actor, "sp"),
    cp: getActorCurrentCurrencyValue(actor, "cp")
  };
}

function currencyBundleToCp(bundle = {}) {
  const pp = Math.max(0, Math.floor(Number(bundle?.pp ?? 0) || 0));
  const gp = Math.max(0, Math.floor(Number(bundle?.gp ?? 0) || 0));
  const sp = Math.max(0, Math.floor(Number(bundle?.sp ?? 0) || 0));
  const cp = Math.max(0, Math.floor(Number(bundle?.cp ?? 0) || 0));
  return (pp * 1000) + (gp * 100) + (sp * 10) + cp;
}

function cpToCurrencyBundle(totalCpInput) {
  const totalCp = Math.max(0, Math.floor(Number(totalCpInput ?? 0) || 0));
  let remaining = totalCp;
  const pp = Math.floor(remaining / 1000);
  remaining -= pp * 1000;
  const gp = Math.floor(remaining / 100);
  remaining -= gp * 100;
  const sp = Math.floor(remaining / 10);
  remaining -= sp * 10;
  const cp = Math.floor(remaining);
  return { pp, gp, sp, cp };
}

async function setActorCurrencyBundle(actor, bundle = {}) {
  if (!actor) return cpToCurrencyBundle(0);
  const normalized = {
    pp: Math.max(0, Math.floor(Number(bundle?.pp ?? 0) || 0)),
    gp: Math.max(0, Math.floor(Number(bundle?.gp ?? 0) || 0)),
    sp: Math.max(0, Math.floor(Number(bundle?.sp ?? 0) || 0)),
    cp: Math.max(0, Math.floor(Number(bundle?.cp ?? 0) || 0))
  };
  const updates = {};
  for (const denom of ["pp", "gp", "sp", "cp"]) {
    if (typeof actor.system?.currency?.[denom] === "object") updates[`system.currency.${denom}.value`] = normalized[denom];
    else updates[`system.currency.${denom}`] = normalized[denom];
  }
  await actor.update(updates);
  return normalized;
}

async function setActorCurrencyFromCp(actor, totalCp) {
  const bundle = cpToCurrencyBundle(totalCp);
  return setActorCurrencyBundle(actor, bundle);
}

function formatMerchantCp(totalCp) {
  return formatMerchantCpDomain(totalCp);
}

function getMerchantItemUnitPriceCp(itemData = {}, rate = 1) {
  return getMerchantItemUnitPriceCpDomain(itemData, rate, {
    getItemGpValue: getLootItemGpValueFromData
  });
}

function getMerchantSourceRefIdsFromStock(stock = {}) {
  const sourceType = normalizeMerchantSourceType(stock?.sourceType);
  if (sourceType === MERCHANT_SOURCE_TYPES.WORLD_ITEMS) return [];
  const sourceRef = String(stock?.sourceRef ?? "").trim();
  return normalizeMerchantSourcePackIds(stock?.sourcePackIds ?? [], sourceRef);
}

function getMerchantCompendiumPackIdsFromStock(stock = {}) {
  const sourceType = normalizeMerchantSourceType(stock?.sourceType);
  if (sourceType !== MERCHANT_SOURCE_TYPES.COMPENDIUM_PACK) return [];
  return getMerchantSourceRefIdsFromStock(stock);
}

function getMerchantCompendiumPackLabelMap() {
  return new Map(
    getAvailableLootItemPackSources()
      .filter((entry) => String(entry?.sourceKind ?? "").trim() === "compendium-pack")
      .map((entry) => [String(entry?.id ?? "").trim(), String(entry?.label ?? "").trim() || String(entry?.id ?? "").trim()])
  );
}

function getMerchantSourceRefLabel(merchant = {}) {
  const stock = merchant?.stock ?? {};
  const sourceType = normalizeMerchantSourceType(stock?.sourceType);
  if (sourceType === MERCHANT_SOURCE_TYPES.WORLD_ITEMS) return "All World Items";
  if (sourceType === MERCHANT_SOURCE_TYPES.COMPENDIUM_PACK) {
    const packIds = getMerchantCompendiumPackIdsFromStock(stock);
    if (!packIds.length) return "Pack not selected";
    const labelMap = getMerchantCompendiumPackLabelMap();
    const labels = packIds.map((id) => labelMap.get(id) ?? id).filter(Boolean);
    if (labels.length <= 1) return labels[0] ?? packIds[0];
    return `${labels.length} packs selected`;
  }
  const folderIds = getMerchantSourceRefIdsFromStock(stock);
  if (!folderIds.length) return "Folder not selected";
  const folderLabelMap = new Map(
    (game.folders?.contents ?? [])
      .filter((folder) => {
        const type = String(folder?.type ?? folder?.documentName ?? "").trim().toLowerCase();
        return type === "item";
      })
      .map((folder) => [String(folder?.id ?? "").trim(), String(folder?.name ?? folder?.id ?? "").trim() || String(folder?.id ?? "").trim()])
  );
  const labels = folderIds.map((id) => folderLabelMap.get(id) ?? id).filter(Boolean);
  if (labels.length <= 1) return labels[0] ?? folderIds[0];
  return `${labels.length} folders selected`;
}

function getMerchantCompendiumPackOptionsForEditor(stock = {}) {
  const selectedPackIds = new Set(getMerchantCompendiumPackIdsFromStock(stock));
  const options = getAvailableLootItemPackSources()
    .filter((entry) => String(entry?.sourceKind ?? "").trim() === "compendium-pack")
    .map((entry) => {
      const id = String(entry?.id ?? "").trim();
      return {
        id,
        label: String(entry?.label ?? id).trim() || id,
        sourceKind: String(entry?.sourceKind ?? "compendium-pack"),
        available: true,
        enabled: selectedPackIds.has(id)
      };
    });
  for (const selectedPackId of selectedPackIds) {
    if (!selectedPackId) continue;
    if (options.some((entry) => entry.id === selectedPackId)) continue;
    options.push({
      id: selectedPackId,
      label: `${selectedPackId} (Unavailable)`,
      sourceKind: "compendium-pack",
      available: false,
      enabled: true
    });
  }
  options.sort((a, b) => {
    const enabledDelta = Number(Boolean(b.enabled)) - Number(Boolean(a.enabled));
    if (enabledDelta !== 0) return enabledDelta;
    return String(a.label ?? "").localeCompare(String(b.label ?? ""));
  });
  return options;
}

function getMerchantWorldFolderOptions(selectedFolderIds = []) {
  const selectedValues = normalizeMerchantSourcePackIds(selectedFolderIds);
  const selectedSet = new Set(selectedValues);
  const options = (game.folders?.contents ?? [])
    .filter((folder) => {
      const type = String(folder?.type ?? folder?.documentName ?? "").trim().toLowerCase();
      return type === "item";
    })
    .map((folder) => {
      const id = String(folder?.id ?? "").trim();
      const label = String(folder?.name ?? id).trim() || id;
      return {
        value: id,
        label,
        selected: selectedSet.has(id)
      };
    })
    .filter((entry) => entry.value)
    .sort((a, b) => String(a.label ?? "").localeCompare(String(b.label ?? "")));
  for (const selectedFolderId of selectedValues) {
    if (!selectedFolderId) continue;
    if (options.some((entry) => entry.value === selectedFolderId)) continue;
    options.push({
      value: selectedFolderId,
      label: `${selectedFolderId} (Unavailable)`,
      selected: true
    });
  }
  if (options.length <= 0) {
    return [{
      value: "",
      label: "No Item Folders Available",
      selected: true,
      disabled: true
    }];
  }
  if (selectedValues.length <= 0) {
    options.unshift({
      value: "",
      label: "Select one or more item folders",
      selected: true,
      disabled: true
    });
  }
  return options;
}

function getMerchantSourceRefOptionsForEditor(sourceTypeInput, selectedSourceRefs = [], sourcePackOptions = []) {
  return getMerchantSourceRefOptionsForEditorDomain(
    sourceTypeInput,
    selectedSourceRefs,
    sourcePackOptions,
    {
      getWorldFolderOptions: getMerchantWorldFolderOptions
    }
  );
}

function getMerchantAllowedTypeOptionsForEditor(selectedTypes = []) {
  const selected = new Set(normalizeMerchantAllowedItemTypes(selectedTypes));
  return [...MERCHANT_ALLOWED_ITEM_TYPE_LIST]
    .map((value) => {
      const label = String(LOOT_ITEM_TYPE_LABELS[value] ?? value).trim() || value;
      return {
        value,
        label,
        selected: selected.has(value)
      };
    })
    .sort((a, b) => String(a.label ?? "").localeCompare(String(b.label ?? "")));
}

function buildMerchantTagCatalogForEditor(merchant = {}) {
  const tags = new Set();
  const documents = getMerchantSourceDocumentsSync(merchant);
  for (const documentRef of documents) {
    const data = getMerchantItemData(documentRef);
    const itemTags = getMerchantItemTagsFromData(data);
    for (const tag of itemTags) {
      const normalized = String(tag ?? "").trim().toLowerCase();
      if (!normalized) continue;
      tags.add(normalized);
    }
  }
  return Array.from(tags)
    .sort((a, b) => String(a).localeCompare(String(b)))
    .slice(0, 400);
}

function buildMerchantTagOptionsForEditor(tagCatalog = [], selectedTags = []) {
  const selected = new Set(normalizeMerchantTagList(selectedTags));
  const options = (Array.isArray(tagCatalog) ? tagCatalog : [])
    .map((entry) => String(entry ?? "").trim().toLowerCase())
    .filter(Boolean)
    .map((value) => ({
      value,
      label: value,
      selected: selected.has(value)
    }));
  for (const tag of selected) {
    if (options.some((entry) => entry.value === tag)) continue;
    options.push({
      value: tag,
      label: `${tag} (Unavailable)`,
      selected: true
    });
  }
  return options.sort((a, b) => String(a.label ?? "").localeCompare(String(b.label ?? "")));
}

function buildMerchantKeywordCatalogForEditor(merchant = {}) {
  const keywords = new Set();
  const documents = getMerchantSourceDocumentsSync(merchant);
  for (const documentRef of documents) {
    const data = getMerchantItemData(documentRef);
    const tokens = getMerchantItemKeywordTokensFromData(data);
    for (const token of tokens) {
      const normalized = String(token ?? "").trim().toLowerCase();
      if (!normalized) continue;
      keywords.add(normalized);
    }
  }
  return Array.from(keywords)
    .sort((a, b) => String(a).localeCompare(String(b)))
    .slice(0, 500);
}

function buildMerchantKeywordOptionsForEditor(keywordCatalog = [], selectedKeywords = []) {
  const selected = new Set(normalizeMerchantKeywordList(selectedKeywords));
  const options = (Array.isArray(keywordCatalog) ? keywordCatalog : [])
    .map((entry) => String(entry ?? "").trim().toLowerCase())
    .filter(Boolean)
    .map((value) => ({
      value,
      label: value,
      selected: selected.has(value)
    }));
  for (const keyword of selected) {
    if (options.some((entry) => entry.value === keyword)) continue;
    options.push({
      value: keyword,
      label: `${keyword} (Unavailable)`,
      selected: true
    });
  }
  return options.sort((a, b) => String(a.label ?? "").localeCompare(String(b.label ?? "")));
}

function describeMerchantUuidSource(uuidInput) {
  const uuid = String(uuidInput ?? "").trim();
  if (!uuid) return "Source";
  if (uuid.startsWith("Compendium.")) {
    const parts = uuid.split(".");
    if (parts.length >= 3) return `${parts[1]}.${parts[2]}`;
    return "Compendium";
  }
  if (uuid.startsWith("Item.")) return "World Item Directory";
  return "Source";
}

function buildMerchantCuratedRowsForEditor(curatedItemUuids = []) {
  return normalizeMerchantCuratedItemUuids(curatedItemUuids).map((uuid) => {
    let documentRef = null;
    if (typeof fromUuidSync === "function") {
      try {
        documentRef = fromUuidSync(uuid);
      } catch {
        documentRef = null;
      }
    }
    const data = getMerchantItemData(documentRef ?? {});
    const itemType = String(data?.type ?? "").trim().toLowerCase();
    const itemTypeLabel = String(LOOT_ITEM_TYPE_LABELS[itemType] ?? itemType).trim() || "Item";
    return {
      uuid,
      name: String(data?.name ?? uuid).trim() || uuid,
      img: String(data?.img ?? "icons/svg/item-bag.svg").trim() || "icons/svg/item-bag.svg",
      itemType,
      itemTypeLabel,
      sourceLabel: describeMerchantUuidSource(uuid),
      canOpen: Boolean(uuid)
    };
  });
}

function getMerchantSourceDocumentsSync(merchant = {}) {
  const stock = merchant?.stock ?? {};
  const sourceType = normalizeMerchantSourceType(stock?.sourceType);
  if (sourceType === MERCHANT_SOURCE_TYPES.COMPENDIUM_PACK) {
    const packIds = getMerchantCompendiumPackIdsFromStock(stock);
    const packLabelMap = getMerchantCompendiumPackLabelMap();
    const documents = [];
    for (const packId of packIds) {
      const pack = game.packs?.get(packId);
      if (!pack) continue;
      const sourceLabel = packLabelMap.get(packId) ?? packId;
      const indexRows = getCollectionValues(pack.index);
      for (const indexRow of indexRows) {
        const entry = Array.isArray(indexRow) ? indexRow[1] : indexRow;
        const docId = String(entry?._id ?? entry?.id ?? "").trim();
        if (!docId) continue;
        documents.push({
          uuid: `Compendium.${packId}.Item.${docId}`,
          name: String(entry?.name ?? docId).trim() || docId,
          img: String(entry?.img ?? "icons/svg/item-bag.svg").trim() || "icons/svg/item-bag.svg",
          type: String(entry?.type ?? "").trim(),
          flags: foundry.utils.deepClone(entry?.flags ?? {}),
          system: foundry.utils.deepClone(entry?.system ?? {}),
          _merchantSourceLabel: sourceLabel
        });
      }
    }
    return documents;
  }
  if (sourceType === MERCHANT_SOURCE_TYPES.WORLD_FOLDER) {
    const sourceRefs = getMerchantSourceRefIdsFromStock(stock);
    if (!sourceRefs.length) return [];
    const sourceRefSet = new Set(sourceRefs);
    return (game.items?.contents ?? []).filter((item) => sourceRefSet.has(String(item?.folder?.id ?? "")));
  }
  return game.items?.contents ?? [];
}

function buildMerchantEditorCandidateRows(editorDraft = {}, options = {}) {
  const stock = editorDraft?.stock ?? {};
  const curated = new Set(normalizeMerchantCuratedItemUuids(stock.curatedItemUuids ?? []));
  const filterNeedle = normalizeMerchantEditorFilter(options?.filter ?? getMerchantEditorItemFilter()).toLowerCase();
  const sourceDocuments = getMerchantSourceDocumentsSync(editorDraft);
  const rows = buildMerchantCandidateRows(sourceDocuments, editorDraft)
    .map((candidate) => {
      const data = getMerchantItemData(candidate?.data ?? {});
      const uuid = String(candidate?.key ?? data?.uuid ?? "").trim();
      const itemType = String(data?.type ?? "").trim().toLowerCase();
      const sourceLabel = String(data?._merchantSourceLabel ?? describeMerchantUuidSource(uuid)).trim() || "Source";
      const name = String(data?.name ?? uuid).trim() || uuid;
      const searchBlob = `${name} ${uuid} ${itemType} ${sourceLabel}`.toLowerCase();
      return {
        uuid,
        name,
        img: String(data?.img ?? "icons/svg/item-bag.svg").trim() || "icons/svg/item-bag.svg",
        itemType,
        itemTypeLabel: String(LOOT_ITEM_TYPE_LABELS[itemType] ?? itemType).trim() || "Item",
        sourceLabel,
        gpValue: Math.max(0, Number(candidate?.gpValue ?? 0) || 0),
        searchBlob
      };
    })
    .filter((entry) => entry.uuid && !curated.has(entry.uuid))
    .filter((entry) => !filterNeedle || entry.searchBlob.includes(filterNeedle))
    .sort((a, b) => String(a.name ?? "").localeCompare(String(b.name ?? "")))
    .slice(0, MERCHANT_EDITOR_CANDIDATE_LIMIT);
  return rows;
}

function getMerchantDefinitionDraftSource(raw = {}) {
  const source = raw && typeof raw === "object" ? raw : {};
  const draft = normalizeMerchantDefinition(source);
  if (!source?.id) draft.id = "";
  if (!source?.name) draft.name = "";
  return draft;
}

function getMerchantEditorActorOptions(selectedActorId = "") {
  const selected = String(selectedActorId ?? "").trim();
  const actors = game.actors?.contents ?? [];
  const sorted = [...actors].sort((a, b) => String(a?.name ?? "").localeCompare(String(b?.name ?? "")));
  return [
    { id: "", name: "Create on refresh", selected: !selected },
    ...sorted.map((actor) => ({
      id: String(actor?.id ?? ""),
      name: String(actor?.name ?? `Actor ${actor?.id ?? ""}`).trim() || `Actor ${actor?.id ?? ""}`,
      selected: String(actor?.id ?? "") === selected
    }))
  ];
}

function getMerchantTargetStockCount(stock = {}) {
  return getMerchantTargetStockCountDomain(stock);
}

function sortMerchantDefinitions(definitions = []) {
  return [...definitions].sort((left, right) => String(left?.name ?? "").localeCompare(String(right?.name ?? "")));
}

function buildMerchantSettlementOptions(definitions = [], selectionInput = "", fallbackInput = "") {
  const selection = normalizeMerchantSettlementSelection(selectionInput);
  const fallback = normalizeMerchantSettlementSelection(fallbackInput);
  const catalog = new Map();
  for (const merchant of Array.isArray(definitions) ? definitions : []) {
    const settlement = normalizeMerchantSettlementSelection(merchant?.settlement ?? "");
    if (!settlement) continue;
    const key = settlement.toLowerCase();
    if (!catalog.has(key)) catalog.set(key, settlement);
  }
  if (fallback) {
    const key = fallback.toLowerCase();
    if (!catalog.has(key)) catalog.set(key, fallback);
  }
  if (selection) {
    const key = selection.toLowerCase();
    if (!catalog.has(key)) catalog.set(key, selection);
  }
  const cityRows = Array.from(catalog.values())
    .sort((a, b) => a.localeCompare(b))
    .map((value) => ({
      value,
      label: getMerchantSettlementLabel(value),
      selected: false
    }));
  const options = [
    { value: "", label: "All Cities", selected: false },
    ...cityRows
  ];
  const activeValue = options.some((entry) => entry.value.toLowerCase() === selection.toLowerCase())
    ? selection
    : (options.some((entry) => entry.value.toLowerCase() === fallback.toLowerCase()) ? fallback : "");
  for (const entry of options) {
    entry.selected = entry.value.toLowerCase() === activeValue.toLowerCase();
  }
  return {
    activeValue,
    activeLabel: activeValue ? getMerchantSettlementLabel(activeValue) : "All Cities",
    options
  };
}

function buildMerchantInventoryRowsForDisplay(merchant = {}) {
  const merchantActor = merchant?.actorId ? game.actors.get(String(merchant.actorId ?? "")) : null;
  const buyMarkup = 1 + Math.max(0, Number(merchant?.pricing?.buyMarkup ?? MERCHANT_DEFAULTS.pricing.buyMarkup) || 0);
  const rows = (merchantActor?.items?.contents ?? [])
    .filter((item) => MERCHANT_ALLOWED_ITEM_TYPES.has(String(item?.type ?? "").trim().toLowerCase()))
    .map((item) => {
      const itemData = getMerchantItemData(item);
      const quantity = Math.max(0, Math.floor(getItemTrackedQuantity(item)));
      const baseCp = getMerchantItemUnitPriceCp(itemData, 1);
      const buyCp = getMerchantItemUnitPriceCp(itemData, buyMarkup);
      const weight = Math.max(0, Number(getItemWeightValue(itemData) || getItemWeightValue(item) || 0));
      const weightLabel = weight > 0
        ? `${weight % 1 === 0 ? weight.toFixed(0) : weight.toFixed(1)} lb`
        : "-";
      return {
        id: String(item?.id ?? ""),
        name: String(item?.name ?? "Item").trim() || "Item",
        img: String(item?.img ?? "icons/svg/item-bag.svg").trim() || "icons/svg/item-bag.svg",
        quantity,
        weight,
        weightLabel,
        baseCp,
        buyCp,
        basePriceLabel: formatMerchantCp(baseCp),
        buyPriceLabel: formatMerchantCp(buyCp),
        markupLabel: buyMarkup.toFixed(2)
      };
    })
    .filter((entry) => entry.quantity > 0)
    .sort((a, b) => String(a.name ?? "").localeCompare(String(b.name ?? "")))
    .slice(0, MERCHANT_PREVIEW_ITEM_LIMIT);
  return {
    rows,
    hasRows: rows.length > 0,
    buyMarkupLabel: buyMarkup.toFixed(2),
    itemCount: rows.reduce((sum, row) => sum + Math.max(0, Number(row?.quantity ?? 0) || 0), 0)
  };
}

async function logMerchantUiAccess(payload = {}) {
  const userId = String(payload?.userId ?? game.user?.id ?? "").trim();
  if (!userId) return false;
  const now = Date.now();
  const actorId = String(payload?.actorId ?? "").trim();
  const settlement = normalizeMerchantSettlementSelection(payload?.settlement ?? "");
  const merchantId = String(payload?.merchantId ?? "").trim();
  const throttleKey = `${userId}:${actorId}:${settlement.toLowerCase()}:${merchantId}`;
  const lastViewedAt = Number(merchantUiAccessThrottleByKey.get(throttleKey) ?? 0);
  if (Number.isFinite(lastViewedAt) && (now - lastViewedAt) < MERCHANT_ACCESS_LOG_THROTTLE_MS) return false;

  merchantUiAccessThrottleByKey.set(throttleKey, now);
  if (merchantUiAccessThrottleByKey.size > 1000) {
    for (const [key, ts] of merchantUiAccessThrottleByKey.entries()) {
      if ((now - Number(ts ?? 0)) > (MERCHANT_ACCESS_LOG_THROTTLE_MS * 10)) merchantUiAccessThrottleByKey.delete(key);
    }
  }

  await updateOperationsLedger((ledger) => {
    const merchants = ensureMerchantsState(ledger);
    if (!Array.isArray(merchants.accessLog)) merchants.accessLog = [];
    merchants.accessLog.unshift(normalizeMerchantAccessLogEntry({
      viewedAt: now,
      userId,
      userName: String(payload?.userName ?? game.user?.name ?? "Player").trim() || "Player",
      actorId,
      actorName: String(payload?.actorName ?? "").trim(),
      settlement,
      merchantId,
      merchantName: String(payload?.merchantName ?? "").trim()
    }));
    merchants.accessLog = merchants.accessLog
      .sort((a, b) => Number(b?.viewedAt ?? 0) - Number(a?.viewedAt ?? 0))
      .slice(0, MERCHANT_ACCESS_LOG_LIMIT);
  }, { skipLocalRefresh: true });
  return true;
}

function buildMerchantsContext(ledger = getOperationsLedger(), options = {}) {
  const user = options?.user ?? game.user;
  const merchantsState = ensureMerchantsState(ledger);
  const definitions = sortMerchantDefinitions(merchantsState.definitions ?? []);
  const stockStateById = merchantsState.stockStateById ?? {};
  const selectableActors = getDowntimeSelectableActorsForUser(user);
  const actorOptions = selectableActors.map((actor) => ({
    id: String(actor?.id ?? ""),
    name: String(actor?.name ?? `Actor ${actor?.id ?? ""}`).trim() || `Actor ${actor?.id ?? ""}`,
    selected: false
  }));
  const storedActorId = getSelectedMerchantActorId();
  const preferredActorId = storedActorId
    || String(getActiveActorForUser()?.id ?? "").trim()
    || String(user?.character?.id ?? "").trim();
  const fallbackActorId = actorOptions[0]?.id ?? "";
  const activeActorId = actorOptions.find((entry) => entry.id === preferredActorId)?.id ?? fallbackActorId;
  for (const option of actorOptions) option.selected = option.id === activeActorId;
  if (!storedActorId || storedActorId !== activeActorId) setSelectedMerchantActorId(activeActorId);
  const activeActor = activeActorId ? game.actors.get(activeActorId) : null;
  const activeActorContracts = activeActor ? getActorMerchantContracts(activeActor) : {};
  const activeActorSocialScore = activeActor ? computeActorSocialScore(activeActor) : 0;
  const assignmentActors = getOwnedPcActors().sort((left, right) => String(left?.name ?? "").localeCompare(String(right?.name ?? "")));
  const storedSettlement = getSelectedMerchantSettlement();
  const hasStoredSettlement = hasSelectedMerchantSettlementPreference();

  const definitionsForDisplay = definitions.map((merchant) => {
    const merchantActor = merchant.actorId ? game.actors.get(merchant.actorId) : null;
    const stockMeta = normalizeMerchantStockStateEntry(stockStateById?.[merchant.id], merchant.actorId);
    const scarcityProfile = getMerchantScarcityProfile(merchant?.stock?.scarcity ?? MERCHANT_DEFAULTS.stock.scarcity);
    const buyMarkupRaw = Number(merchant?.pricing?.buyMarkup ?? MERCHANT_DEFAULTS.pricing.buyMarkup) || 0;
    const sellRateRaw = Number(merchant?.pricing?.sellRate ?? MERCHANT_DEFAULTS.pricing.sellRate);
    const sellRate = Number.isFinite(sellRateRaw)
      ? Math.max(0, Math.min(10, Number(sellRateRaw.toFixed(2))))
      : Number(MERCHANT_DEFAULTS.pricing.sellRate);
    const sellEnabled = merchant?.pricing?.sellEnabled !== false;
    const cashOnHandGpRaw = Number(merchant?.pricing?.cashOnHandGp ?? MERCHANT_DEFAULTS.pricing.cashOnHandGp);
    const cashOnHandGp = Number.isFinite(cashOnHandGpRaw)
      ? Math.max(0, Math.min(1000000, Number(cashOnHandGpRaw.toFixed(2))))
      : Number(MERCHANT_DEFAULTS.pricing.cashOnHandGp);
    const cashOnHandLabel = `${cashOnHandGp.toLocaleString(undefined, { maximumFractionDigits: 2 })} gp`;
    const buybackAllowedTypes = normalizeMerchantAllowedItemTypes(
      merchant?.pricing?.buybackAllowedTypes
      ?? MERCHANT_DEFAULTS.pricing.buybackAllowedTypes
      ?? MERCHANT_ALLOWED_ITEM_TYPE_LIST
    );
    const buybackTypeLabels = buybackAllowedTypes
      .map((itemType) => String(LOOT_ITEM_TYPE_LABELS[itemType] ?? itemType).trim() || itemType)
      .sort((left, right) => left.localeCompare(right));
    const buybackTypeSummary = buybackTypeLabels.length >= MERCHANT_ALLOWED_ITEM_TYPE_LIST.length
      ? "All Item Types"
      : (buybackTypeLabels.join(", ") || "None");
    const barterEnabled = merchant?.pricing?.barterEnabled !== false;
    const barterDcRaw = Number(merchant?.pricing?.barterDc ?? MERCHANT_DEFAULTS.pricing.barterDc);
    const barterDc = Number.isFinite(barterDcRaw)
      ? Math.max(1, Math.min(40, Math.floor(barterDcRaw)))
      : Number(MERCHANT_DEFAULTS.pricing.barterDc);
    const barterAbility = normalizeMerchantBarterAbility(
      merchant?.pricing?.barterAbility,
      MERCHANT_DEFAULTS.pricing.barterAbility ?? "cha"
    );
    const barterAbilityLabel = String(MERCHANT_BARTER_ABILITY_LABELS[barterAbility] ?? "Charisma");
    const accessMode = normalizeMerchantAccessMode(merchant?.accessMode ?? MERCHANT_ACCESS_MODES.ALL);
    const offerTagOptions = buildMerchantOfferTagOptions(merchant?.stock?.allowedTypes ?? []);
    const offerTagLabels = offerTagOptions
      .filter((entry) => entry.selected)
      .map((entry) => String(entry.label ?? "").trim())
      .filter(Boolean);
    const stockItemCount = merchantActor
      ? (merchantActor.items?.contents ?? [])
        .filter((item) => MERCHANT_ALLOWED_ITEM_TYPES.has(String(item?.type ?? "").trim().toLowerCase()))
        .reduce((sum, item) => sum + Math.max(0, Math.floor(getItemTrackedQuantity(item))), 0)
      : 0;
    const assignmentRows = assignmentActors.map((actorRef) => {
      const actorId = String(actorRef?.id ?? "").trim();
      const contracts = actorRef ? getActorMerchantContracts(actorRef) : {};
      const assigned = Boolean(actorId && contracts[merchant.id]);
      return {
        actorId,
        actorName: String(actorRef?.name ?? `Actor ${actorId}`).trim() || `Actor ${actorId}`,
        assigned
      };
    });
    const assignedCount = assignmentRows.reduce((sum, row) => sum + (row.assigned ? 1 : 0), 0);
    return {
      ...merchant,
      accessMode,
      accessModeIsAssigned: accessMode === MERCHANT_ACCESS_MODES.ASSIGNED,
      accessModeIsAll: accessMode === MERCHANT_ACCESS_MODES.ALL,
      accessModeLabel: accessMode === MERCHANT_ACCESS_MODES.ASSIGNED ? "Assigned Players" : "All Players",
      raceLabel: normalizeMerchantRace(merchant.race ?? "") || "Unspecified",
      settlementLabel: getMerchantSettlementLabel(merchant.settlement),
      sourceTypeLabel: getMerchantSourceTypeLabel(merchant.stock?.sourceType),
      sourceRefLabel: getMerchantSourceRefLabel(merchant),
      scarcityLabel: String(scarcityProfile?.label ?? "6 - Normal"),
      scarcityMultiplierPercent: Math.round(Math.max(0, Number(scarcityProfile?.multiplier ?? 1) || 1) * 100),
      buyMarkupLabel: Number(1 + buyMarkupRaw).toFixed(2),
      buyMarkupPercentLabel: `${Math.round(Math.max(0, buyMarkupRaw) * 100)}%`,
      sellRate,
      sellRatePercentLabel: `${Math.round(sellRate * 100)}%`,
      sellEnabled,
      sellEnabledLabel: sellEnabled ? "Buys from players" : "Not buying items",
      cashOnHandGp,
      cashOnHandLabel,
      buybackAllowedTypes,
      buybackTypeSummary,
      barterEnabled,
      barterDc,
      barterAbility,
      barterAbilityLabel,
      includeTagsText: formatMerchantTagsCsv(merchant?.stock?.includeTags ?? []),
      excludeTagsText: formatMerchantTagsCsv(merchant?.stock?.excludeTags ?? []),
      keywordIncludeText: formatMerchantTagsCsv(merchant?.stock?.keywordInclude ?? []),
      keywordExcludeText: formatMerchantTagsCsv(merchant?.stock?.keywordExclude ?? []),
      hasIncludeTags: normalizeMerchantTagList(merchant?.stock?.includeTags ?? []).length > 0,
      hasExcludeTags: normalizeMerchantTagList(merchant?.stock?.excludeTags ?? []).length > 0,
      hasKeywordInclude: normalizeMerchantKeywordList(merchant?.stock?.keywordInclude ?? []).length > 0,
      hasKeywordExclude: normalizeMerchantKeywordList(merchant?.stock?.keywordExclude ?? []).length > 0,
      sourcePackCount: getMerchantCompendiumPackIdsFromStock(merchant?.stock ?? {}).length,
      allowedTypeCount: normalizeMerchantAllowedItemTypes(merchant?.stock?.allowedTypes ?? []).length,
      offerTagLabels,
      offerTagSummary: offerTagLabels.join(", ") || "All",
      curatedItemCount: normalizeMerchantCuratedItemUuids(merchant?.stock?.curatedItemUuids ?? []).length,
      maxStackSize: 20,
      stockItemCount,
      hasStock: stockItemCount > 0,
      actorName: String(merchantActor?.name ?? "").trim(),
      hasActor: Boolean(merchantActor),
      lastRefreshedAt: Number(stockMeta?.lastRefreshedAt ?? 0) || 0,
      lastRefreshedAtLabel: formatMerchantTimestampLabel(stockMeta?.lastRefreshedAt),
      lastRefreshedBy: String(stockMeta?.lastRefreshedBy ?? "").trim() || "-",
      activeActorHasContract: Boolean(activeActorContracts[merchant.id] || (merchant.contractKey && activeActorContracts[merchant.contractKey])),
      activeActorMeetsSocialGate: !merchant.socialGateEnabled || activeActorSocialScore >= Number(merchant.minSocialScore ?? 0),
      assignmentRows,
      hasAssignmentRows: assignmentRows.length > 0,
      assignedCount,
      unassignedCount: Math.max(0, assignmentRows.length - assignedCount),
      accessModeOptions: getMerchantAccessModeOptions(accessMode)
    };
  });
  const cityCatalogRows = buildMerchantCityCatalogRows(merchantsState, definitionsForDisplay);
  const settlementView = buildMerchantSettlementOptions(
    definitionsForDisplay,
    storedSettlement,
    hasStoredSettlement ? "" : merchantsState.currentSettlement
  );
  if (hasStoredSettlement) setSelectedMerchantSettlement(settlementView.activeValue);

  const availableMerchants = (!activeActor)
    ? []
    : definitionsForDisplay
      .filter((merchant) => isMerchantAvailableToActor(merchant, activeActor, settlementView.activeValue, { isGM: false }))
      .map((merchant) => {
        const canOpenShop = Boolean(activeActorId)
          && Boolean(merchant.actorId && game.actors.get(merchant.actorId));
        return {
          ...merchant,
          canOpenShop
        };
      });
  const storedMerchantTabId = getSelectedMerchantTabId();
  const fallbackMerchantTabId = availableMerchants[0]?.id ?? "";
  const activeMerchantId = availableMerchants.some((entry) => entry.id === storedMerchantTabId)
    ? storedMerchantTabId
    : fallbackMerchantTabId;
  if (storedMerchantTabId !== activeMerchantId) setSelectedMerchantTabId(activeMerchantId);
  const availableMerchantsWithTabs = availableMerchants.map((merchant) => ({
    ...merchant,
    tabActive: merchant.id === activeMerchantId
  }));
  const activeMerchant = availableMerchantsWithTabs.find((entry) => entry.id === activeMerchantId) ?? null;
  const activeMerchantInventory = buildMerchantInventoryRowsForDisplay(activeMerchant ?? {});
  const userId = String(user?.id ?? "").trim();
  const accessLog = (merchantsState.accessLog ?? [])
    .map((entry) => normalizeMerchantAccessLogEntry(entry))
    .sort((a, b) => Number(b.viewedAt ?? 0) - Number(a.viewedAt ?? 0))
    .slice(0, MERCHANT_ACCESS_LOG_LIMIT);
  const latestUserAccess = accessLog.find((entry) => String(entry?.userId ?? "").trim() === userId) ?? null;
  const accessLogPayload = {
    userId,
    userName: String(user?.name ?? "Player").trim() || "Player",
    actorId: activeActorId,
    actorName: String(activeActor?.name ?? "").trim(),
    settlement: settlementView.activeValue,
    merchantId: activeMerchantId,
    merchantName: String(activeMerchant?.name ?? "").trim()
  };

  const editorSelection = getMerchantEditorSelection();
  const editorSelectionIsNew = editorSelection === "__new__";
  const fallbackEditorId = definitionsForDisplay[0]?.id ?? "";
  const activeEditorId = editorSelectionIsNew
    ? "__new__"
    : (definitionsForDisplay.some((entry) => entry.id === editorSelection)
      ? editorSelection
      : fallbackEditorId);
  if (editorSelection !== activeEditorId) setMerchantEditorSelection(activeEditorId);
  const editingDefinition = activeEditorId === "__new__"
    ? null
    : (definitionsForDisplay.find((entry) => entry.id === activeEditorId) ?? null);
  const baseEditorDraft = getMerchantDefinitionDraftSource(editingDefinition ?? {});
  const editorSelectionKey = normalizeMerchantEditorSelectionKey(activeEditorId);
  const draftState = getMerchantEditorDraftState();
  const editorDraft = (() => {
    if (!draftState || draftState.selectionKey !== editorSelectionKey || !draftState.draft) {
      const fallback = foundry.utils.deepClone(baseEditorDraft);
      if (editorSelectionKey === "__new__") fallback.id = "";
      return fallback;
    }
    const source = draftState.draft ?? {};
    const merged = {
      ...foundry.utils.deepClone(baseEditorDraft),
      ...foundry.utils.deepClone(source),
      pricing: {
        ...foundry.utils.deepClone(baseEditorDraft?.pricing ?? {}),
        ...foundry.utils.deepClone(source?.pricing ?? {})
      },
      stock: {
        ...foundry.utils.deepClone(baseEditorDraft?.stock ?? {}),
        ...foundry.utils.deepClone(source?.stock ?? {})
      }
    };
    if (editorSelectionKey === "__new__") merged.id = "";
    return getMerchantDefinitionDraftSource(merged);
  })();
  const editorSourceTypeRaw = normalizeMerchantSourceType(editorDraft?.stock?.sourceType ?? MERCHANT_SOURCE_TYPES.WORLD_FOLDER);
  const editorSourceType = editorSourceTypeRaw === MERCHANT_SOURCE_TYPES.WORLD_ITEMS
    ? MERCHANT_SOURCE_TYPES.WORLD_FOLDER
    : editorSourceTypeRaw;
  const editorScarcity = normalizeMerchantScarcity(editorDraft?.stock?.scarcity ?? MERCHANT_SCARCITY_LEVELS.NORMAL);
  const editorSourceRefs = getMerchantSourceRefIdsFromStock(editorDraft?.stock ?? {});
  const editorSourcePackOptions = getMerchantCompendiumPackOptionsForEditor(editorDraft?.stock ?? {});
  const editorSourceRefOptions = getMerchantSourceRefOptionsForEditor(
    editorSourceType,
    editorSourceRefs,
    editorSourcePackOptions
  );
  const editorSourceRefHintLabel = String(
    editorSourceRefOptions.find((entry) => !String(entry?.value ?? "").trim())?.label ?? ""
  ).trim();
  const editorSourceRefSelectableOptions = editorSourceRefOptions
    .filter((entry) => String(entry?.value ?? "").trim().length > 0);
  const editorSourceRefSelectedCount = editorSourceRefSelectableOptions
    .filter((entry) => Boolean(entry?.selected))
    .length;
  const editorAllowedTypes = normalizeMerchantAllowedItemTypes(editorDraft?.stock?.allowedTypes ?? []);
  const editorOfferTagOptions = buildMerchantOfferTagOptions(editorAllowedTypes);
  const editorCityOptions = buildMerchantCityOptions(cityCatalogRows, editorDraft?.settlement ?? "");
  const editorViewTab = getMerchantEditorViewTab();
  const editorAccessMode = normalizeMerchantAccessMode(editorDraft?.accessMode ?? MERCHANT_ACCESS_MODES.ALL);
  const editorBuyMarkup = Math.max(0, Number(editorDraft?.pricing?.buyMarkup ?? MERCHANT_DEFAULTS.pricing.buyMarkup) || 0);
  const editorBuyMarkupPercent = Number((editorBuyMarkup * 100).toFixed(2));
  const editorSellRateRaw = Number(editorDraft?.pricing?.sellRate ?? MERCHANT_DEFAULTS.pricing.sellRate);
  const editorSellRate = Number.isFinite(editorSellRateRaw)
    ? Math.max(0, Math.min(10, Number(editorSellRateRaw.toFixed(2))))
    : Number(MERCHANT_DEFAULTS.pricing.sellRate);
  const editorSellRatePercent = Number((editorSellRate * 100).toFixed(2));
  const editorSellEnabled = editorDraft?.pricing?.sellEnabled !== false;
  const editorCashOnHandGpRaw = Number(editorDraft?.pricing?.cashOnHandGp ?? MERCHANT_DEFAULTS.pricing.cashOnHandGp);
  const editorCashOnHandGp = Number.isFinite(editorCashOnHandGpRaw)
    ? Math.max(0, Math.min(1000000, Number(editorCashOnHandGpRaw.toFixed(2))))
    : Number(MERCHANT_DEFAULTS.pricing.cashOnHandGp);
  const editorBuybackAllowedTypes = normalizeMerchantAllowedItemTypes(
    editorDraft?.pricing?.buybackAllowedTypes
    ?? MERCHANT_DEFAULTS.pricing.buybackAllowedTypes
    ?? MERCHANT_ALLOWED_ITEM_TYPE_LIST
  );
  const editorBuybackTypeOptions = getMerchantAllowedTypeOptionsForEditor(editorBuybackAllowedTypes);
  const editorBarterEnabled = editorDraft?.pricing?.barterEnabled !== false;
  const editorBarterDcRaw = Number(editorDraft?.pricing?.barterDc ?? MERCHANT_DEFAULTS.pricing.barterDc);
  const editorBarterDc = Number.isFinite(editorBarterDcRaw)
    ? Math.max(1, Math.min(40, Math.floor(editorBarterDcRaw)))
    : Number(MERCHANT_DEFAULTS.pricing.barterDc);
  const editorBarterAbility = normalizeMerchantBarterAbility(
    editorDraft?.pricing?.barterAbility,
    MERCHANT_DEFAULTS.pricing.barterAbility ?? "cha"
  );
  const editorStockCountRaw = Number(editorDraft?.stock?.maxItems ?? MERCHANT_DEFAULTS.stock.maxItems);
  const editorStockCount = Number.isFinite(editorStockCountRaw)
    ? Math.max(1, Math.min(100, Math.floor(editorStockCountRaw)))
    : MERCHANT_DEFAULTS.stock.maxItems;
  const editorTargetValueGpRaw = Number(editorDraft?.stock?.targetValueGp ?? MERCHANT_DEFAULTS.stock.targetValueGp);
  const editorTargetValueGp = Number.isFinite(editorTargetValueGpRaw)
    ? Math.max(0, Math.min(1000000, Number(editorTargetValueGpRaw.toFixed(2))))
    : MERCHANT_DEFAULTS.stock.targetValueGp;
  const editorRarityWeights = normalizeMerchantRarityWeights(
    editorDraft?.stock?.rarityWeights ?? MERCHANT_DEFAULTS.stock.rarityWeights,
    MERCHANT_DEFAULTS.stock.rarityWeights
  );
  const editorTagCatalog = buildMerchantTagCatalogForEditor(editorDraft);
  const editorIncludeTagOptions = buildMerchantTagOptionsForEditor(editorTagCatalog, editorDraft?.stock?.includeTags ?? []);
  const editorExcludeTagOptions = buildMerchantTagOptionsForEditor(editorTagCatalog, editorDraft?.stock?.excludeTags ?? []);
  const editorKeywordCatalog = buildMerchantKeywordCatalogForEditor(editorDraft);
  const editorKeywordIncludeOptions = buildMerchantKeywordOptionsForEditor(editorKeywordCatalog, editorDraft?.stock?.keywordInclude ?? []);
  const editorKeywordExcludeOptions = buildMerchantKeywordOptionsForEditor(editorKeywordCatalog, editorDraft?.stock?.keywordExclude ?? []);
  const editorAllowedTypeOptions = getMerchantAllowedTypeOptionsForEditor(editorAllowedTypes);
  const editorCuratedRows = [];
  const editorItemFilter = "";
  const editorCandidateRows = [];
  const assignmentRows = [];

  return {
    currentSettlement: String(merchantsState.currentSettlement ?? ""),
    currentSettlementLabel: getMerchantSettlementLabel(merchantsState.currentSettlement),
    settlementOptions: settlementView.options,
    selectedSettlement: settlementView.activeValue,
    selectedSettlementLabel: settlementView.activeLabel,
    actorOptions,
    hasActorOptions: actorOptions.length > 0,
    activeActorId,
    activeActorName: String(activeActor?.name ?? "").trim(),
    hasActiveActor: Boolean(activeActor),
    activeActorSocialScore,
    availableMerchants: availableMerchantsWithTabs,
    hasAvailableMerchants: availableMerchantsWithTabs.length > 0,
    activeMerchantId,
    hasActiveMerchant: Boolean(activeMerchant),
    activeMerchantName: String(activeMerchant?.name ?? "").trim() || "No Merchant Selected",
    activeMerchantTitle: String(activeMerchant?.title ?? "").trim(),
    activeMerchantRace: normalizeMerchantRace(activeMerchant?.race ?? ""),
    activeMerchantImg: String(activeMerchant?.img ?? "icons/svg/mystery-man.svg").trim() || "icons/svg/mystery-man.svg",
    activeMerchantStockCount: Math.max(0, Number(activeMerchant?.stockItemCount ?? 0) || 0),
    activeMerchantBuyMarkupLabel: String(activeMerchantInventory?.buyMarkupLabel ?? "1.00"),
    activeMerchantCanOpenShop: Boolean(activeMerchant?.canOpenShop),
    inventoryRows: activeMerchantInventory.rows,
    hasInventoryRows: activeMerchantInventory.hasRows,
    inventoryItemCount: Math.max(0, Number(activeMerchantInventory.itemCount ?? 0) || 0),
    viewerName: String(user?.name ?? "Player").trim() || "Player",
    viewerLastAccessLabel: formatMerchantTimestampLabel(latestUserAccess?.viewedAt),
    shouldLogAccess: true,
    accessLogPayload,
    gm: {
      definitions: definitionsForDisplay.map((merchant) => ({
        ...merchant,
        cityOptions: buildMerchantCityOptions(cityCatalogRows, merchant?.settlement ?? ""),
        selectedForEdit: merchant.id === activeEditorId
      })),
      hasDefinitions: definitionsForDisplay.length > 0,
      editorViewTab,
      editorViewTabEditor: editorViewTab !== "settings",
      editorViewTabSettings: editorViewTab === "settings",
      cityCatalogInput: formatMerchantCityListInput(merchantsState?.cityCatalog ?? []),
      editor: {
        id: String(editorDraft?.id ?? ""),
        name: String(editorDraft?.name ?? ""),
        title: String(editorDraft?.title ?? ""),
        race: normalizeMerchantRace(editorDraft?.race ?? ""),
        img: String(editorDraft?.img ?? "icons/svg/item-bag.svg"),
        settlement: String(editorDraft?.settlement ?? ""),
        accessMode: editorAccessMode,
        isHidden: Boolean(editorDraft?.isHidden),
        requiresContract: Boolean(editorDraft?.requiresContract),
        contractKey: String(editorDraft?.contractKey ?? ""),
        socialGateEnabled: Boolean(editorDraft?.socialGateEnabled),
        minSocialScore: Number(editorDraft?.minSocialScore ?? 0) || 0,
        buyMarkup: Number(editorDraft?.pricing?.buyMarkup ?? MERCHANT_DEFAULTS.pricing.buyMarkup),
        buyMarkupPercent: editorBuyMarkupPercent,
        buyMarkupMultiplierLabel: (1 + editorBuyMarkup).toFixed(2),
        sellRate: editorSellRate,
        sellRatePercent: editorSellRatePercent,
        sellEnabled: editorSellEnabled,
        cashOnHandGp: editorCashOnHandGp,
        buybackAllowedTypes: editorBuybackAllowedTypes,
        barterEnabled: editorBarterEnabled,
        barterDc: editorBarterDc,
        barterAbility: editorBarterAbility,
        sourceType: editorSourceType,
        sourceRef: String(editorSourceRefs[0] ?? editorDraft?.stock?.sourceRef ?? ""),
        sourcePackIds: editorSourceRefs,
        includeTagsInput: formatMerchantTagsCsv(editorDraft?.stock?.includeTags ?? []),
        excludeTagsInput: formatMerchantTagsCsv(editorDraft?.stock?.excludeTags ?? []),
        keywordIncludeInput: formatMerchantKeywordsCsv(editorDraft?.stock?.keywordInclude ?? []),
        keywordExcludeInput: formatMerchantKeywordsCsv(editorDraft?.stock?.keywordExclude ?? []),
        allowedTypes: editorAllowedTypes,
        curatedItemUuidsInput: formatMerchantUuidListInput(editorDraft?.stock?.curatedItemUuids ?? []),
        maxItems: editorStockCount,
        stockCount: editorStockCount,
        targetValueGp: editorTargetValueGp,
        scarcity: editorScarcity,
        scarcityLabel: String(getMerchantScarcityProfile(editorScarcity)?.label ?? "6 - Normal"),
        duplicateChance: Number(MERCHANT_DEFAULTS.stock.duplicateChance ?? 25),
        maxStackSize: 20,
        rarityWeightCommon: Number(editorRarityWeights?.common ?? 100),
        rarityWeightUncommon: Number(editorRarityWeights?.uncommon ?? 45),
        rarityWeightRare: Number(editorRarityWeights?.rare ?? 16),
        rarityWeightVeryRare: Number(editorRarityWeights?.["very-rare"] ?? 5),
        rarityWeightLegendary: Number(editorRarityWeights?.legendary ?? 1),
        actorId: String(editorDraft?.actorId ?? "")
      },
      sourceTypeOptions: getMerchantEditorSourceTypeOptions(editorSourceType),
      accessModeOptions: getMerchantAccessModeOptions(editorAccessMode),
      barterAbilityOptions: getMerchantBarterAbilityOptions(editorBarterAbility),
      raceOptions: getMerchantEditorRaceOptions(editorDraft?.race ?? ""),
      cityOptions: editorCityOptions,
      offerTagOptions: editorOfferTagOptions,
      scarcityOptions: getMerchantScarcityOptions(editorScarcity),
      actorOptions: getMerchantEditorActorOptions(editorDraft?.actorId ?? ""),
      sourceRefOptions: editorSourceRefOptions,
      sourceRefSelectableOptions: editorSourceRefSelectableOptions,
      hasSourceRefSelectableOptions: editorSourceRefSelectableOptions.length > 0,
      sourceRefOptionCount: editorSourceRefSelectableOptions.length,
      sourceRefSelectedCount: editorSourceRefSelectedCount,
      sourceRefHintLabel: editorSourceRefHintLabel,
      sourcePackFilter: "",
      sourcePackOptions: editorSourcePackOptions,
      sourcePackVisibleOptions: editorSourcePackOptions,
      sourcePackVisibleCount: editorSourcePackOptions.length,
      sourcePackFilterActive: false,
      tagCatalogCount: editorTagCatalog.length,
      hasTagCatalog: editorTagCatalog.length > 0,
      includeTagOptions: editorIncludeTagOptions,
      excludeTagOptions: editorExcludeTagOptions,
      keywordCatalogCount: editorKeywordCatalog.length,
      hasKeywordCatalog: editorKeywordCatalog.length > 0,
      keywordIncludeOptions: editorKeywordIncludeOptions,
      keywordExcludeOptions: editorKeywordExcludeOptions,
      allowedTypeOptions: editorAllowedTypeOptions,
      buybackTypeOptions: editorBuybackTypeOptions,
      curatedRows: editorCuratedRows,
      hasCuratedRows: editorCuratedRows.length > 0,
      itemFilter: editorItemFilter,
      candidateRows: editorCandidateRows,
      hasCandidateRows: editorCandidateRows.length > 0,
      assignmentRows,
      hasAssignmentRows: assignmentRows.length > 0
    }
  };
}

function readMerchantDefinitionPatchFromElement(element) {
  const pageRoot = element?.closest?.("#po-gm-merchants")
    ?? element?.closest?.("#po-ops-merchants")
    ?? element?.closest?.(".po-merchants-page");
  if (!pageRoot) return null;
  const getText = (selector, options = {}) => {
    const node = pageRoot.querySelector(selector);
    if (!node) {
      if (Object.prototype.hasOwnProperty.call(options, "missing")) return String(options.missing ?? "").trim();
      return "";
    }
    return String(node?.value ?? "").trim();
  };
  const getNumber = (selector, fallback = 0) => {
    const raw = Number(pageRoot.querySelector(selector)?.value ?? fallback);
    return Number.isFinite(raw) ? raw : fallback;
  };
  const getCheckbox = (selector, fallback = false) => {
    const node = pageRoot.querySelector(selector);
    if (!(node instanceof HTMLInputElement)) return Boolean(fallback);
    return Boolean(node.checked);
  };
  const getList = (selector, normalizer = normalizeMerchantTagList) => {
    const node = pageRoot.querySelector(selector);
    if (!node) return undefined;
    const text = String(node?.value ?? "").trim();
    if (!text) return [];
    return normalizer(text.split(/[\n,;]+/));
  };
  const getCheckedValues = (selector, normalizer = normalizeMerchantAllowedItemTypes, fallback = []) => {
    const nodes = Array.from(pageRoot.querySelectorAll(selector));
    if (nodes.length <= 0) return normalizer(fallback);
    const values = nodes
      .filter((entry) => Boolean(entry?.checked))
      .map((entry) => String(entry?.value ?? "").trim())
      .filter(Boolean);
    return normalizer(values);
  };
  const getSelectedValues = (selector, fallback = []) => {
    const nodes = Array.from(pageRoot.querySelectorAll(selector));
    if (nodes.length <= 0) return normalizeMerchantSourcePackIds(fallback);
    const checkboxNodes = nodes.filter(
      (entry) => entry instanceof HTMLInputElement && String(entry.type ?? "").toLowerCase() === "checkbox"
    );
    if (checkboxNodes.length > 0) {
      const selectedValues = checkboxNodes
        .filter((entry) => Boolean(entry?.checked))
        .map((entry) => String(entry?.value ?? "").trim())
        .filter(Boolean);
      return normalizeMerchantSourcePackIds(selectedValues);
    }
    const [node] = nodes;
    const selectedValues = Array.from(node?.selectedOptions ?? [])
      .map((entry) => String(entry?.value ?? "").trim())
      .filter(Boolean);
    return normalizeMerchantSourcePackIds(selectedValues);
  };
  const merchantId = getText("input[name='merchantId']");
  const existingMerchant = merchantId ? getMerchantById(merchantId) : null;
  const existingStock = existingMerchant?.stock ?? {};
  const existingPricing = existingMerchant?.pricing ?? {};
  const existingAllowedTypes = normalizeMerchantAllowedItemTypes(existingMerchant?.stock?.allowedTypes ?? MERCHANT_ALLOWED_ITEM_TYPE_LIST);
  const raceInput = (
    getText("select[name='merchantRace']", { missing: existingMerchant?.race ?? "" })
    || getText("input[name='merchantRace']", { missing: existingMerchant?.race ?? "" })
  );
  const selectedOfferTags = Array.from(pageRoot.querySelectorAll("input[name='merchantOfferTag']:checked"))
    .map((entry) => String(entry?.value ?? "").trim().toLowerCase())
    .filter(Boolean);
  const accessMode = getText("select[name='merchantAccessMode']", { missing: existingMerchant?.accessMode ?? MERCHANT_ACCESS_MODES.ALL });
  const sellRatePercent = getNumber(
    "input[name='merchantSellRatePercent']",
    Number(existingPricing?.sellRate ?? MERCHANT_DEFAULTS.pricing.sellRate) * 100
  );
  const sellEnabled = getCheckbox("input[name='merchantSellEnabled']", existingPricing?.sellEnabled ?? MERCHANT_DEFAULTS.pricing.sellEnabled);
  const cashOnHandGp = getNumber(
    "input[name='merchantCashOnHandGp']",
    Number(existingPricing?.cashOnHandGp ?? MERCHANT_DEFAULTS.pricing.cashOnHandGp)
  );
  const buybackAllowedTypes = getCheckedValues(
    "input[name='merchantBuybackType']",
    normalizeMerchantAllowedItemTypes,
    existingPricing?.buybackAllowedTypes ?? MERCHANT_DEFAULTS.pricing.buybackAllowedTypes ?? MERCHANT_ALLOWED_ITEM_TYPE_LIST
  );
  const barterEnabled = getCheckbox("input[name='merchantBarterEnabled']", existingPricing?.barterEnabled ?? MERCHANT_DEFAULTS.pricing.barterEnabled);
  const barterDc = getNumber(
    "input[name='merchantBarterDc']",
    Number(existingPricing?.barterDc ?? MERCHANT_DEFAULTS.pricing.barterDc)
  );
  const barterAbility = (
    getText("select[name='merchantBarterAbility']", { missing: existingPricing?.barterAbility ?? MERCHANT_DEFAULTS.pricing.barterAbility ?? "cha" })
    || getText("input[name='merchantBarterAbility']", { missing: existingPricing?.barterAbility ?? MERCHANT_DEFAULTS.pricing.barterAbility ?? "cha" })
  );
  const allowedTypes = resolveMerchantAllowedTypesFromOfferTags(selectedOfferTags, existingAllowedTypes);
  const markupPercent = getNumber(
    "input[name='merchantMarkupPercent']",
    Number(existingPricing?.buyMarkup ?? MERCHANT_DEFAULTS.pricing.buyMarkup) * 100
  );
  const sourceType = getText("select[name='merchantSourceType']", { missing: existingStock?.sourceType ?? MERCHANT_SOURCE_TYPES.WORLD_FOLDER });
  const previousDraft = getMerchantEditorDraftState()?.draft ?? {};
  const previousSourceType = normalizeMerchantSourceType(
    previousDraft?.stock?.sourceType
    ?? existingStock?.sourceType
    ?? MERCHANT_SOURCE_TYPES.WORLD_FOLDER
  );
  const existingSourceRefs = getMerchantSourceRefIdsFromStock(existingStock);
  const hasSourceRefCheckboxes = pageRoot.querySelectorAll("input[name='merchantSourceRef']").length > 0;
  const sourceRefsFromSelect = normalizeMerchantSourceType(sourceType) === previousSourceType
    ? getSelectedValues("select[name='merchantSourceRef']", existingSourceRefs)
    : [];
  const sourceRefsFromCheckboxes = normalizeMerchantSourceType(sourceType) === previousSourceType
    ? getSelectedValues("input[name='merchantSourceRef']", existingSourceRefs)
    : [];
  const selectedSourceRefs = hasSourceRefCheckboxes ? sourceRefsFromCheckboxes : sourceRefsFromSelect;
  const sourceRef = String(
    selectedSourceRefs[0]
    ?? getText("select[name='merchantSourceRef']", { missing: "" })
    ?? ""
  ).trim();
  const rarityWeights = normalizeMerchantRarityWeights({
    common: getNumber("input[name='merchantRarityWeightCommon']", Number(existingStock?.rarityWeights?.common ?? MERCHANT_DEFAULTS.stock.rarityWeights?.common ?? 100)),
    uncommon: getNumber("input[name='merchantRarityWeightUncommon']", Number(existingStock?.rarityWeights?.uncommon ?? MERCHANT_DEFAULTS.stock.rarityWeights?.uncommon ?? 45)),
    rare: getNumber("input[name='merchantRarityWeightRare']", Number(existingStock?.rarityWeights?.rare ?? MERCHANT_DEFAULTS.stock.rarityWeights?.rare ?? 16)),
    "very-rare": getNumber("input[name='merchantRarityWeightVeryRare']", Number(existingStock?.rarityWeights?.["very-rare"] ?? MERCHANT_DEFAULTS.stock.rarityWeights?.["very-rare"] ?? 5)),
    legendary: getNumber("input[name='merchantRarityWeightLegendary']", Number(existingStock?.rarityWeights?.legendary ?? MERCHANT_DEFAULTS.stock.rarityWeights?.legendary ?? 1))
  }, existingStock?.rarityWeights ?? MERCHANT_DEFAULTS.stock.rarityWeights);
  return buildMerchantDefinitionPatchFromEditorFormDomain({
    id: merchantId,
    name: getText("input[name='merchantName']", { missing: existingMerchant?.name ?? "" }),
    title: getText("input[name='merchantTitle']", { missing: existingMerchant?.title ?? "" }),
    race: normalizeMerchantRace(raceInput),
    img: getText("input[name='merchantImg']", { missing: existingMerchant?.img ?? "" }),
    settlement: getText("select[name='merchantSettlement']", { missing: existingMerchant?.settlement ?? "" }) || getText("input[name='merchantSettlement']", { missing: existingMerchant?.settlement ?? "" }),
    accessMode,
    sourceType,
    sourceRef: sourceRef || getText("input[name='merchantSourceRef']", { missing: "" }),
    sourceRefs: selectedSourceRefs,
    actorId: getText("select[name='merchantActorId']") || String(existingMerchant?.actorId ?? ""),
    scarcity: getText("select[name='merchantScarcity']", { missing: existingStock?.scarcity ?? MERCHANT_DEFAULTS.stock.scarcity }),
    includeTags: getList("input[name='merchantIncludeTags']", normalizeMerchantTagList) ?? existingStock?.includeTags ?? [],
    excludeTags: getList("input[name='merchantExcludeTags']", normalizeMerchantTagList) ?? existingStock?.excludeTags ?? [],
    keywordInclude: getList("input[name='merchantKeywordInclude']", normalizeMerchantKeywordList) ?? existingStock?.keywordInclude ?? [],
    keywordExclude: getList("input[name='merchantKeywordExclude']", normalizeMerchantKeywordList) ?? existingStock?.keywordExclude ?? [],
    allowedTypes,
    markupPercent,
    sellRatePercent,
    sellEnabled,
    cashOnHandGp,
    buybackAllowedTypes,
    barterEnabled,
    barterDc,
    barterAbility,
    stockCount: Number(existingStock?.maxItems ?? MERCHANT_DEFAULTS.stock.maxItems),
    targetValueGp: getNumber("input[name='merchantTargetValueGp']", Number(existingStock?.targetValueGp ?? MERCHANT_DEFAULTS.stock.targetValueGp)),
    duplicateChance: Number(MERCHANT_DEFAULTS.stock.duplicateChance ?? 25),
    maxStackSize: 20,
    rarityWeights,
    existingStock,
    existingPricing
  });
}

async function getMerchantSourceDocuments(merchant = {}) {
  const stock = merchant?.stock ?? {};
  const sourceType = normalizeMerchantSourceType(stock?.sourceType);
  if (sourceType === MERCHANT_SOURCE_TYPES.COMPENDIUM_PACK) {
    const packIds = getMerchantCompendiumPackIdsFromStock(stock);
    if (!packIds.length) return [];
    const documents = [];
    for (const packId of packIds) {
      const docs = await loadItemsFromPack(packId);
      if (!Array.isArray(docs) || docs.length === 0) continue;
      documents.push(...docs);
    }
    return documents;
  }
  if (sourceType === MERCHANT_SOURCE_TYPES.WORLD_FOLDER) {
    const sourceRefs = getMerchantSourceRefIdsFromStock(stock);
    if (!sourceRefs.length) return [];
    const sourceRefSet = new Set(sourceRefs);
    return (game.items?.contents ?? []).filter((item) => sourceRefSet.has(String(item?.folder?.id ?? "")));
  }
  return game.items?.contents ?? [];
}

function buildMerchantCandidateRows(documents = [], merchant = {}) {
  return buildMerchantStockCandidateRowsDomain(documents, merchant, {
    getItemData: getMerchantItemData,
    getItemTags: getMerchantItemTagsFromData,
    getItemKeywords: getMerchantItemKeywordTokensFromData,
    matchesTagFilters: isLootKeywordMatch,
    matchesKeywordFilters: isLootKeywordMatch,
    getItemRarity: getLootRarityFromData,
    getRarityBucket: getMerchantRarityBucket,
    getItemGpValue: getLootItemGpValueFromData,
    allowedItemTypes: MERCHANT_ALLOWED_ITEM_TYPES,
    normalizeCuratedItemUuids: normalizeMerchantCuratedItemUuids,
    normalizeAllowedItemTypes: normalizeMerchantAllowedItemTypes,
    normalizeTagList: normalizeMerchantTagList,
    normalizeKeywordList: normalizeMerchantKeywordList
  });
}

function shuffleMerchantRows(values = []) {
  return shuffleMerchantRowsDomain(values);
}

function selectMerchantStockRows(candidates = [], merchant = {}) {
  return selectMerchantStockRowsDomain(candidates, merchant, {
    normalizeCuratedItemUuids: normalizeMerchantCuratedItemUuids,
    normalizeRarityWeights: normalizeMerchantRarityWeights,
    getTargetStockCount: getMerchantTargetStockCount,
    getRarityBucket: getMerchantRarityBucket,
    shuffleRows: shuffleMerchantRows
  });
}

function createMerchantOwnershipDefaults() {
  const ownership = {
    default: CONST?.DOCUMENT_OWNERSHIP_LEVELS?.NONE ?? 0
  };
  for (const user of game.users?.contents ?? []) {
    if (!user?.isGM) continue;
    ownership[String(user.id)] = CONST?.DOCUMENT_OWNERSHIP_LEVELS?.OWNER ?? 3;
  }
  return ownership;
}

async function ensureMerchantActor(merchantInput, options = {}) {
  const merchant = (merchantInput && typeof merchantInput === "object")
    ? merchantInput
    : getMerchantById(merchantInput);
  if (!merchant) return null;
  const existing = merchant.actorId ? game.actors.get(String(merchant.actorId ?? "")) : null;
  if (existing) return existing;
  if (!canAccessAllPlayerOps()) return null;

  const actorName = String(merchant.name ?? "Merchant").trim() || "Merchant";
  const actorImg = String(merchant.img ?? "icons/svg/item-bag.svg").trim() || "icons/svg/item-bag.svg";
  const actorData = {
    name: `Merchant Stock: ${actorName}`,
    type: "npc",
    img: actorImg,
    ownership: createMerchantOwnershipDefaults(),
    flags: {
      [MODULE_ID]: {
        merchantId: String(merchant.id ?? "").trim()
      }
    }
  };
  const created = await Actor.create(actorData, { renderSheet: false });
  if (!created) return null;

  if (options?.skipLedgerUpdate !== true) {
    await updateOperationsLedger((ledger) => {
      const merchants = ensureMerchantsState(ledger);
      const entry = merchants.definitions.find((row) => String(row?.id ?? "") === String(merchant.id ?? ""));
      if (entry) entry.actorId = String(created.id ?? "");
      merchants.stockStateById[String(merchant.id ?? "")] = normalizeMerchantStockStateEntry(
        merchants.stockStateById?.[String(merchant.id ?? "")],
        String(created.id ?? "")
      );
    });
  }
  return created;
}

async function refreshMerchantStock(merchantIdInput, options = {}) {
  if (!canAccessAllPlayerOps()) return { ok: false, message: "Only the GM can refresh merchant stock." };
  const merchantId = String(merchantIdInput ?? "").trim();
  if (!merchantId) return { ok: false, message: "Merchant id is required." };
  const ledger = getOperationsLedger();
  const merchant = getMerchantById(merchantId, ledger);
  if (!merchant) return { ok: false, message: "Merchant not found." };
  const merchantActor = await ensureMerchantActor(merchant, { skipLedgerUpdate: true });
  if (!merchantActor) return { ok: false, message: "Merchant actor could not be created." };

  const sourceDocuments = await getMerchantSourceDocuments(merchant);
  const candidates = buildMerchantCandidateRows(sourceDocuments, merchant);
  const selected = selectMerchantStockRows(candidates, merchant);
  const generatedItemIds = (merchantActor.items?.contents ?? [])
    .filter((item) => item?.flags?.[MODULE_ID]?.merchantGenerated === true)
    .map((item) => String(item?.id ?? ""))
    .filter(Boolean);
  if (generatedItemIds.length > 0) {
    await merchantActor.deleteEmbeddedDocuments("Item", generatedItemIds);
  }

  const createData = [];
  for (const candidate of selected) {
    const data = foundry.utils.deepClone(candidate.data ?? {});
    if (!data || typeof data !== "object") continue;
    if (Object.prototype.hasOwnProperty.call(data, "_id")) delete data._id;
    const requestedQuantity = Number(candidate?.quantity ?? getMerchantItemDataQuantity(data));
    const quantity = Number.isFinite(requestedQuantity)
      ? Math.max(1, Math.floor(requestedQuantity))
      : 1;
    setMerchantItemDataQuantity(data, quantity);
    if (!data.flags || typeof data.flags !== "object") data.flags = {};
    if (!data.flags[MODULE_ID] || typeof data.flags[MODULE_ID] !== "object") data.flags[MODULE_ID] = {};
    data.flags[MODULE_ID].merchantGenerated = true;
    data.flags[MODULE_ID].merchantId = merchantId;
    createData.push(data);
  }
  if (createData.length > 0) {
    await merchantActor.createEmbeddedDocuments("Item", createData);
  }

  const refreshedAt = Date.now();
  const refreshedBy = String(game.user?.name ?? "GM").trim() || "GM";
  await updateOperationsLedger((nextLedger) => {
    const merchants = ensureMerchantsState(nextLedger);
    const entry = merchants.definitions.find((row) => String(row?.id ?? "") === merchantId);
    if (entry) entry.actorId = String(merchantActor.id ?? "");
    merchants.stockStateById[merchantId] = {
      lastRefreshedAt: refreshedAt,
      lastRefreshedBy: refreshedBy,
      actorId: String(merchantActor.id ?? "")
    };
  });

  const createdCount = createData.length;
  if (!options?.silent) {
    ui.notifications?.info(`Refreshed stock for ${merchant.name} (${createdCount} item${createdCount === 1 ? "" : "s"}).`);
  }
  return {
    ok: true,
    merchantId,
    merchantName: String(merchant.name ?? "Merchant"),
    actorId: String(merchantActor.id ?? ""),
    createdCount,
    refreshedAt,
    refreshedBy
  };
}

async function refreshAllMerchantStocks(options = {}) {
  if (!canAccessAllPlayerOps()) return { ok: false, refreshed: 0, failed: 0, results: [] };
  const merchants = getMerchants();
  const results = [];
  for (const merchant of merchants) {
    const result = await refreshMerchantStock(merchant.id, { silent: true });
    results.push(result);
  }
  const refreshed = results.filter((entry) => entry?.ok).length;
  const failed = results.length - refreshed;
  if (!options?.silent) {
    ui.notifications?.info(`Merchant stock refresh complete: ${refreshed} succeeded, ${failed} failed.`);
  }
  return { ok: failed === 0, refreshed, failed, results };
}

function findTradeTargetItem(actor, sourceItem) {
  const name = String(sourceItem?.name ?? "").trim().toLowerCase();
  const type = String(sourceItem?.type ?? "").trim().toLowerCase();
  if (!actor || !name || !type) return null;
  return (actor.items?.contents ?? []).find((item) => {
    if (!item) return false;
    return String(item.name ?? "").trim().toLowerCase() === name
      && String(item.type ?? "").trim().toLowerCase() === type;
  }) ?? null;
}

function buildTradeItemData(sourceItem, quantity, options = {}) {
  const data = getMerchantItemData(sourceItem);
  if (!data || typeof data !== "object") return null;
  const clone = foundry.utils.deepClone(data);
  if (Object.prototype.hasOwnProperty.call(clone, "_id")) delete clone._id;
  setMerchantItemDataQuantity(clone, Math.max(1, Math.floor(Number(quantity ?? 1) || 1)));
  if (!clone.flags || typeof clone.flags !== "object") clone.flags = {};
  if (!clone.flags[MODULE_ID] || typeof clone.flags[MODULE_ID] !== "object") clone.flags[MODULE_ID] = {};
  if (options?.clearGeneratedFlag) delete clone.flags[MODULE_ID].merchantGenerated;
  return clone;
}

async function transferItemBetweenActors(sourceActor, targetActor, sourceItem, quantity, options = {}) {
  const qty = Math.max(0, Math.floor(Number(quantity ?? 0) || 0));
  if (!sourceActor || !targetActor || !sourceItem || qty <= 0) return false;
  const sourceCurrent = Math.max(0, Math.floor(getItemTrackedQuantity(sourceItem)));
  if (sourceCurrent < qty) return false;

  const targetExisting = findTradeTargetItem(targetActor, sourceItem);
  if (targetExisting) {
    const existingQty = Math.max(0, Math.floor(getItemTrackedQuantity(targetExisting)));
    await setItemTrackedQuantity(targetExisting, existingQty + qty);
  } else {
    const itemData = buildTradeItemData(sourceItem, qty, options);
    if (!itemData) return false;
    await targetActor.createEmbeddedDocuments("Item", [itemData]);
  }

  const sourceNext = sourceCurrent - qty;
  if (sourceNext <= 0) await sourceItem.delete();
  else await setItemTrackedQuantity(sourceItem, sourceNext);
  return true;
}

function getMerchantBarterResolutionKey({ userId, actorId, merchantId, settlement } = {}) {
  const normalizedUserId = String(userId ?? "").trim();
  const normalizedActorId = String(actorId ?? "").trim();
  const normalizedMerchantId = String(merchantId ?? "").trim();
  const normalizedSettlement = normalizeMerchantSettlementSelection(settlement ?? "");
  if (!normalizedUserId || !normalizedActorId || !normalizedMerchantId) return "";
  return `${normalizedUserId}:${normalizedActorId}:${normalizedMerchantId}:${normalizedSettlement}`;
}

function getMerchantBarterResolutionEntryByKey(keyInput = "") {
  const key = String(keyInput ?? "").trim();
  if (!key) return null;
  const entry = merchantBarterResolutionByKey.get(key);
  return entry && typeof entry === "object"
    ? foundry.utils.deepClone(entry)
    : null;
}

function setMerchantBarterResolutionEntry(entry = {}) {
  const key = getMerchantBarterResolutionKey(entry);
  if (!key) return "";
  const stored = {
    key,
    userId: String(entry?.userId ?? "").trim(),
    actorId: String(entry?.actorId ?? "").trim(),
    merchantId: String(entry?.merchantId ?? "").trim(),
    settlement: normalizeMerchantSettlementSelection(entry?.settlement ?? ""),
    applied: entry?.applied !== false,
    source: String(entry?.source ?? "").trim(),
    ability: normalizeMerchantBarterAbility(entry?.ability ?? "cha", "cha"),
    abilityLabel: String(entry?.abilityLabel ?? MERCHANT_BARTER_ABILITY_LABELS[normalizeMerchantBarterAbility(entry?.ability ?? "cha", "cha")] ?? "Charisma"),
    checkTotal: Number.isFinite(Number(entry?.checkTotal)) ? Math.floor(Number(entry.checkTotal)) : null,
    margin: Number.isFinite(Number(entry?.margin)) ? Math.floor(Number(entry.margin)) : 0,
    success: Boolean(entry?.success),
    delta: Number.isFinite(Number(entry?.delta)) ? Number(entry.delta) : 0,
    buyMarkupDelta: Number.isFinite(Number(entry?.buyMarkupDelta)) ? Number(entry.buyMarkupDelta) : 0,
    sellRateDelta: Number.isFinite(Number(entry?.sellRateDelta)) ? Number(entry.sellRateDelta) : 0,
    createdAt: Math.max(0, Number(entry?.createdAt ?? Date.now()) || Date.now())
  };
  merchantBarterResolutionByKey.set(key, stored);
  return key;
}

function clearMerchantBarterResolutionEntryByKey(keyInput = "") {
  const key = String(keyInput ?? "").trim();
  if (!key) return;
  merchantBarterResolutionByKey.delete(key);
}

function getMerchantBarterUiSummaryText(barter = {}, options = {}) {
  if (!barter || barter.applied === false) return String(options?.fallback ?? "No barter adjustment applied.");
  const buyShift = Math.abs(Math.round((Number(barter?.buyMarkupDelta ?? 0) || 0) * 100));
  const sellShift = Math.abs(Math.round((Number(barter?.sellRateDelta ?? 0) || 0) * 100));
  const buyLabel = `${Number(barter?.buyMarkupDelta ?? 0) >= 0 ? "+" : "-"}${buyShift}% buy`;
  const sellLabel = `${Number(barter?.sellRateDelta ?? 0) >= 0 ? "+" : "-"}${sellShift}% sell`;
  const verdict = barter?.success ? "Favorable" : "Unfavorable";
  const total = Number.isFinite(Number(barter?.checkTotal)) ? ` (${Math.floor(Number(barter.checkTotal))})` : "";
  return `${verdict}${total}: ${buyLabel}, ${sellLabel}`;
}

function getMerchantTradeDialogRoot(htmlOrRoot) {
  if (!htmlOrRoot) return null;
  if (htmlOrRoot instanceof HTMLElement && htmlOrRoot.classList?.contains("po-merchant-trade-dialog")) return htmlOrRoot;
  const htmlRoot = htmlOrRoot?.[0]?.querySelector?.(".po-merchant-trade-dialog");
  if (htmlRoot) return htmlRoot;
  const jQueryRoot = htmlOrRoot?.find?.(".po-merchant-trade-dialog")?.[0];
  if (jQueryRoot) return jQueryRoot;
  return null;
}

function readMerchantTradeMetaFromDialogRoot(root) {
  if (!(root instanceof HTMLElement)) return null;
  const merchantId = String(root.dataset?.merchantId ?? "").trim();
  const actorId = String(root.dataset?.actorId ?? "").trim();
  const settlement = normalizeMerchantSettlementSelection(root.dataset?.settlement ?? "");
  if (!merchantId || !actorId) return null;
  return { merchantId, actorId, settlement };
}

function setMerchantTradeDialogBarterStatus(root, options = {}) {
  if (!(root instanceof HTMLElement)) return;
  const statusNode = root.querySelector("[data-merchant-barter-status]");
  if (!statusNode) return;
  if (options.pending) {
    statusNode.textContent = String(options.pendingLabel ?? "Barter pending GM resolution...");
    return;
  }
  if (options.error) {
    statusNode.textContent = String(options.errorLabel ?? "Barter request failed.");
    return;
  }
  const summary = String(options.summary ?? "").trim();
  statusNode.textContent = summary || "No barter adjustment applied.";
}

async function postMerchantTradeToChat(outcome = {}) {
  const actorName = String(outcome?.actorName ?? "Actor").trim() || "Actor";
  const merchantName = String(outcome?.merchantName ?? "Merchant").trim() || "Merchant";
  const buyRows = Array.isArray(outcome?.buyLines) ? outcome.buyLines : [];
  const sellRows = Array.isArray(outcome?.sellLines) ? outcome.sellLines : [];
  const buyHtml = buyRows.length > 0
    ? `<p><strong>Bought:</strong> ${buyRows.map((row) => `${poEscapeHtml(row.itemName)} x${row.qty}`).join(", ")}</p>`
    : "";
  const sellHtml = sellRows.length > 0
    ? `<p><strong>Sold:</strong> ${sellRows.map((row) => `${poEscapeHtml(row.itemName)} x${row.qty}`).join(", ")}</p>`
    : "";
  const netCp = Math.floor(Number(outcome?.netCp ?? 0) || 0);
  const netLabel = netCp > 0
    ? `${formatMerchantCp(netCp)} paid`
    : (netCp < 0 ? `${formatMerchantCp(Math.abs(netCp))} received` : "Even trade");
  const barter = (outcome?.barter && typeof outcome.barter === "object") ? outcome.barter : null;
  const barterHtml = barter?.applied
    ? `<p><strong>Barter:</strong> ${poEscapeHtml(getMerchantBarterUiSummaryText(barter))}</p>`
    : "";
  await ChatMessage.create({
    speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
    content: `
      <div class="po-chat-claim">
        <p><strong>Merchant Trade</strong></p>
        <p>${poEscapeHtml(actorName)} traded with ${poEscapeHtml(merchantName)}.</p>
        ${barterHtml}
        ${buyHtml}
        ${sellHtml}
        <p><strong>Net:</strong> ${poEscapeHtml(netLabel)}</p>
      </div>
    `
  });
}

function computeMerchantBarterAdjustment(checkTotalInput, dcInput) {
  const checkTotal = Math.floor(Number(checkTotalInput ?? 0) || 0);
  const dc = Math.max(1, Math.floor(Number(dcInput ?? 10) || 10));
  const margin = checkTotal - dc;
  const success = margin >= 0;
  const tiers = 1 + Math.floor(Math.abs(margin) / 5);
  const delta = Math.min(0.25, tiers * 0.05);
  return {
    checkTotal,
    dc,
    margin,
    success,
    delta,
    buyMarkupDelta: success ? -delta : delta,
    sellRateDelta: success ? delta : -delta
  };
}

async function rollMerchantBarterCheck(actor, merchant = {}, options = {}) {
  const pricing = merchant?.pricing ?? {};
  const enabled = pricing?.barterEnabled !== false;
  if (!enabled || !actor) return { enabled, applied: false };
  const ability = normalizeMerchantBarterAbility(pricing?.barterAbility ?? options?.ability ?? "cha", "cha");
  const abilityLabel = String(MERCHANT_BARTER_ABILITY_LABELS[ability] ?? "Charisma");
  const dc = Math.max(1, Math.min(40, Math.floor(Number(pricing?.barterDc ?? options?.dc ?? 15) || 15)));
  const flavor = `Barter Check (${abilityLabel})`;
  const showDc = options?.showDc === true;
  let total = null;
  let source = "none";

  try {
    const monksResult = await requestMonksActorCheck(actor, `ability:${ability}`, dc, flavor, { showDc });
    const monksTotal = Number(monksResult?.total);
    if (Number.isFinite(monksTotal)) {
      total = monksTotal;
      source = "monks";
    }
  } catch (error) {
    console.warn(`${MODULE_ID}: barter monks check failed`, error);
  }

  if (!Number.isFinite(total) && typeof actor?.rollAbilityTest === "function") {
    try {
      const rollResult = await actor.rollAbilityTest(ability, { fastForward: true, chatMessage: false });
      const nativeTotal = Number(rollResult?.total ?? rollResult?.roll?.total);
      if (Number.isFinite(nativeTotal)) {
        total = nativeTotal;
        source = "native";
      }
    } catch (error) {
      console.warn(`${MODULE_ID}: barter ability check failed`, error);
    }
  }

  if (!Number.isFinite(total)) {
    const abilityMod = Number(actor?.system?.abilities?.[ability]?.mod ?? 0);
    const roll = await (new Roll("1d20 + @mod", { mod: abilityMod })).evaluate();
    await roll.toMessage({
      speaker: ChatMessage.getSpeaker({ actor }),
      flavor
    });
    total = Number(roll.total ?? 0);
    source = "fallback";
  }

  const adjustment = computeMerchantBarterAdjustment(total, dc);
  return {
    enabled: true,
    applied: true,
    source,
    ability,
    abilityLabel,
    ...adjustment
  };
}

function normalizeMerchantTradeBarterResolution(barterInput, merchant = {}) {
  const pricing = merchant?.pricing ?? {};
  const enabled = pricing?.barterEnabled !== false;
  if (!enabled) return { enabled: false, applied: false };
  const payload = barterInput && typeof barterInput === "object" ? barterInput : null;
  const checkTotalRaw = Number(payload?.checkTotal);
  if (!payload || !payload.applied || !Number.isFinite(checkTotalRaw)) {
    return { enabled: true, applied: false };
  }
  const ability = normalizeMerchantBarterAbility(payload?.ability ?? pricing?.barterAbility ?? "cha", "cha");
  const abilityLabel = String(MERCHANT_BARTER_ABILITY_LABELS[ability] ?? "Charisma");
  const dc = Math.max(1, Math.min(40, Math.floor(Number(pricing?.barterDc ?? MERCHANT_DEFAULTS.pricing.barterDc ?? 15) || 15)));
  return {
    enabled: true,
    applied: true,
    source: String(payload?.source ?? "resolved").trim() || "resolved",
    ability,
    abilityLabel,
    ...computeMerchantBarterAdjustment(Math.floor(checkTotalRaw), dc)
  };
}

async function applyMerchantTradeForUser(user, payload = {}) {
  const actorId = String(payload?.actorId ?? "").trim();
  const merchantId = String(payload?.merchantId ?? "").trim();
  if (!actorId || !merchantId) return { ok: false, message: "Missing trade payload." };

  const actor = game.actors.get(actorId);
  if (!actor) return { ok: false, message: "Actor not found." };
  if (!canUserManageDowntimeActor(user, actor)) return { ok: false, message: "You cannot access that actor." };

  const ledger = getOperationsLedger();
  const merchants = ensureMerchantsState(ledger);
  const merchant = merchants.definitions.find((entry) => String(entry?.id ?? "") === merchantId);
  if (!merchant) return { ok: false, message: "Merchant not found." };
  const settlementPreference = hasSelectedMerchantSettlementPreference()
    ? getSelectedMerchantSettlement()
    : merchants.currentSettlement;
  const settlement = normalizeMerchantSettlementSelection(payload?.settlement ?? settlementPreference);
  if (!isMerchantAvailableToActor(merchant, actor, settlement, { isGM: false })) {
    return { ok: false, message: "Merchant is not currently available to this actor." };
  }

  const merchantActor = merchant.actorId ? game.actors.get(String(merchant.actorId ?? "")) : null;
  if (!merchantActor) return { ok: false, message: "Merchant stock actor is unavailable. Ask the GM to refresh stock." };

  const pricing = merchant?.pricing ?? {};
  const baseBuyMarkup = 1 + Math.max(0, Number(pricing?.buyMarkup ?? MERCHANT_DEFAULTS.pricing.buyMarkup) || 0);
  const baseSellRateRaw = Number(pricing?.sellRate ?? MERCHANT_DEFAULTS.pricing.sellRate);
  const baseSellRate = Number.isFinite(baseSellRateRaw)
    ? Math.max(0, Math.min(10, Number(baseSellRateRaw.toFixed(2))))
    : Number(MERCHANT_DEFAULTS.pricing.sellRate);
  const sellEnabled = pricing?.sellEnabled !== false;
  const buybackAllowedTypeSet = new Set(normalizeMerchantAllowedItemTypes(
    pricing?.buybackAllowedTypes
    ?? MERCHANT_DEFAULTS.pricing.buybackAllowedTypes
    ?? MERCHANT_ALLOWED_ITEM_TYPE_LIST
  ));
  const configuredCashGpRaw = Number(pricing?.cashOnHandGp ?? MERCHANT_DEFAULTS.pricing.cashOnHandGp);
  const configuredCashCp = Number.isFinite(configuredCashGpRaw)
    ? Math.max(0, Math.floor(Number(configuredCashGpRaw.toFixed(2)) * 100))
    : 0;

  const buyLinesRequested = normalizeMerchantTradeLineItems(payload?.buyItems ?? []);
  const sellLinesRequestedRaw = normalizeMerchantTradeLineItems(payload?.sellItems ?? []);
  const sellLinesRequested = sellEnabled ? sellLinesRequestedRaw : [];
  if (buyLinesRequested.length === 0 && sellLinesRequested.length === 0) {
    if (!sellEnabled && sellLinesRequestedRaw.length > 0) {
      return { ok: false, message: `${merchant.name} is not buying goods right now.` };
    }
    return { ok: false, message: "No items selected for trade." };
  }

  let barter = normalizeMerchantTradeBarterResolution(payload?.barterResolution, merchant);
  if (!barter?.applied && payload?.autoResolveBarter === true) {
    barter = await rollMerchantBarterCheck(actor, merchant, { showDc: false });
  }
  const effectiveBuyMarkup = Math.max(
    0,
    Math.min(10, Number((baseBuyMarkup + Number(barter?.buyMarkupDelta ?? 0)).toFixed(2)))
  );
  const effectiveSellRate = Math.max(
    0,
    Math.min(10, Number((baseSellRate + Number(barter?.sellRateDelta ?? 0)).toFixed(2)))
  );

  const buyLines = [];
  for (const request of buyLinesRequested) {
    const item = merchantActor.items?.get(String(request.itemId ?? ""));
    if (!item) continue;
    const availableQty = Math.max(0, Math.floor(getItemTrackedQuantity(item)));
    if (availableQty <= 0) continue;
    const qty = Math.min(availableQty, Math.max(0, Math.floor(Number(request.qty ?? 0) || 0)));
    if (qty <= 0) continue;
    const itemData = getMerchantItemData(item);
    buyLines.push({
      itemId: String(item.id ?? ""),
      itemName: String(item.name ?? "Item"),
      qty,
      unitCp: getMerchantItemUnitPriceCp(itemData, effectiveBuyMarkup),
      sourceItem: item
    });
  }

  const sellLines = [];
  for (const request of sellLinesRequested) {
    const item = actor.items?.get(String(request.itemId ?? ""));
    if (!item) continue;
    const itemType = String(item?.type ?? "").trim().toLowerCase();
    if (!buybackAllowedTypeSet.has(itemType)) continue;
    const availableQty = Math.max(0, Math.floor(getItemTrackedQuantity(item)));
    if (availableQty <= 0) continue;
    const qty = Math.min(availableQty, Math.max(0, Math.floor(Number(request.qty ?? 0) || 0)));
    if (qty <= 0) continue;
    const itemData = getMerchantItemData(item);
    sellLines.push({
      itemId: String(item.id ?? ""),
      itemName: String(item.name ?? "Item"),
      qty,
      unitCp: getMerchantItemUnitPriceCp(itemData, effectiveSellRate),
      sourceItem: item
    });
  }

  if (buyLines.length === 0 && sellLines.length === 0) {
    if (!sellEnabled && buyLinesRequested.length <= 0 && Array.isArray(payload?.sellItems) && payload.sellItems.length > 0) {
      return { ok: false, message: `${merchant.name} is not buying goods right now.` };
    }
    if (buyLinesRequested.length <= 0 && sellLinesRequested.length > 0) {
      return { ok: false, message: "Selected items cannot be sold to this merchant." };
    }
    return { ok: false, message: "Selected trade quantities are no longer available." };
  }

  const totalBuyCp = buyLines.reduce((sum, row) => sum + (row.unitCp * row.qty), 0);
  const totalSellCp = sellLines.reduce((sum, row) => sum + (row.unitCp * row.qty), 0);
  const netCp = totalBuyCp - totalSellCp;
  const actorCurrencyBeforeCp = currencyBundleToCp(getActorCurrencyBundle(actor));
  let merchantCurrencyBeforeCp = currencyBundleToCp(getActorCurrencyBundle(merchantActor));
  if (merchantCurrencyBeforeCp <= 0 && configuredCashCp > 0) merchantCurrencyBeforeCp = configuredCashCp;
  if (netCp > 0 && actorCurrencyBeforeCp < netCp) {
    return { ok: false, message: `${actor.name} cannot afford ${formatMerchantCp(netCp)}.` };
  }
  if (netCp < 0 && merchantCurrencyBeforeCp < Math.abs(netCp)) {
    return {
      ok: false,
      message: `${merchant.name} only has ${formatMerchantCp(merchantCurrencyBeforeCp)} available for purchases.`
    };
  }

  try {
    for (const line of buyLines) {
      // eslint-disable-next-line no-await-in-loop
      const ok = await transferItemBetweenActors(merchantActor, actor, line.sourceItem, line.qty, { clearGeneratedFlag: true });
      if (!ok) return { ok: false, message: "Buy transfer failed due to stock changes. Reopen shop and retry." };
    }
    for (const line of sellLines) {
      // eslint-disable-next-line no-await-in-loop
      const ok = await transferItemBetweenActors(actor, merchantActor, line.sourceItem, line.qty);
      if (!ok) return { ok: false, message: "Sell transfer failed due to inventory changes. Reopen shop and retry." };
    }
    const actorCurrencyAfterCp = actorCurrencyBeforeCp - netCp;
    const merchantCurrencyAfterCp = merchantCurrencyBeforeCp + netCp;
    await setActorCurrencyFromCp(actor, actorCurrencyAfterCp);
    await setActorCurrencyFromCp(merchantActor, merchantCurrencyAfterCp);

    const outcome = {
      ok: true,
      actorId: String(actor.id ?? ""),
      actorName: String(actor.name ?? "Actor"),
      merchantId,
      merchantName: String(merchant.name ?? "Merchant"),
      settlement,
      totalBuyCp,
      totalSellCp,
      netCp,
      effectiveBuyMarkup,
      effectiveSellRate,
      barter: barter?.applied
        ? {
          applied: true,
          source: String(barter.source ?? ""),
          ability: String(barter.ability ?? "cha"),
          abilityLabel: String(barter.abilityLabel ?? "Charisma"),
          dc: Number(barter.dc ?? 0),
          checkTotal: Number(barter.checkTotal ?? 0),
          margin: Number(barter.margin ?? 0),
          success: Boolean(barter.success),
          buyMarkupDelta: Number(barter.buyMarkupDelta ?? 0),
          sellRateDelta: Number(barter.sellRateDelta ?? 0)
        }
        : { applied: false },
      buyLines: buyLines.map((row) => ({
        itemId: row.itemId,
        itemName: row.itemName,
        qty: row.qty,
        unitCp: row.unitCp
      })),
      sellLines: sellLines.map((row) => ({
        itemId: row.itemId,
        itemName: row.itemName,
        qty: row.qty,
        unitCp: row.unitCp
      }))
    };
    await postMerchantTradeToChat(outcome);
    return outcome;
  } catch (error) {
    console.warn(`${MODULE_ID}: merchant trade failed`, { merchantId, actorId, error });
    return { ok: false, message: String(error?.message ?? "Trade failed.") };
  }
}

function buildMerchantTradeDialogContent(merchant, actor, merchantActor, settlementInput = "") {
  const buyMarkup = 1 + Math.max(0, Number(merchant?.pricing?.buyMarkup ?? MERCHANT_DEFAULTS.pricing.buyMarkup) || 0);
  const sellRateRaw = Number(merchant?.pricing?.sellRate ?? MERCHANT_DEFAULTS.pricing.sellRate);
  const sellRate = Number.isFinite(sellRateRaw)
    ? Math.max(0, Math.min(10, Number(sellRateRaw.toFixed(2))))
    : Number(MERCHANT_DEFAULTS.pricing.sellRate);
  const sellEnabled = merchant?.pricing?.sellEnabled !== false;
  const cashOnHandGpRaw = Number(merchant?.pricing?.cashOnHandGp ?? MERCHANT_DEFAULTS.pricing.cashOnHandGp);
  const configuredCashCp = Number.isFinite(cashOnHandGpRaw)
    ? Math.max(0, Math.floor(Number(cashOnHandGpRaw.toFixed(2)) * 100))
    : 0;
  const buybackAllowedTypeSet = new Set(normalizeMerchantAllowedItemTypes(
    merchant?.pricing?.buybackAllowedTypes
    ?? MERCHANT_DEFAULTS.pricing.buybackAllowedTypes
    ?? MERCHANT_ALLOWED_ITEM_TYPE_LIST
  ));
  const barterEnabled = merchant?.pricing?.barterEnabled !== false;
  const barterAbility = normalizeMerchantBarterAbility(merchant?.pricing?.barterAbility ?? MERCHANT_DEFAULTS.pricing.barterAbility ?? "cha");
  const barterAbilityLabel = String(MERCHANT_BARTER_ABILITY_LABELS[barterAbility] ?? "Charisma");
  const settlement = normalizeMerchantSettlementSelection(settlementInput);
  const currentUserId = String(game.user?.id ?? "").trim();
  const barterResolutionKey = getMerchantBarterResolutionKey({
    userId: currentUserId,
    actorId: String(actor?.id ?? "").trim(),
    merchantId: String(merchant?.id ?? "").trim(),
    settlement
  });
  const existingBarterResolution = getMerchantBarterResolutionEntryByKey(barterResolutionKey);
  const barterButtonLabel = game.user?.isGM ? "Barter" : "Barter (Ask GM)";
  const barterStatusLabel = barterEnabled
    ? (existingBarterResolution?.applied
      ? getMerchantBarterUiSummaryText(existingBarterResolution)
      : "No barter adjustment applied yet.")
    : "Barter is disabled.";
  const settlementLabel = settlement ? getMerchantSettlementLabel(settlement) : "All Cities";
  const merchantItems = (merchantActor?.items?.contents ?? [])
    .filter((item) => MERCHANT_ALLOWED_ITEM_TYPES.has(String(item?.type ?? "").trim().toLowerCase()))
    .map((item) => {
      const qty = Math.max(0, Math.floor(getItemTrackedQuantity(item)));
      const unitCp = getMerchantItemUnitPriceCp(getMerchantItemData(item), buyMarkup);
      return {
        itemId: String(item?.id ?? ""),
        itemName: String(item?.name ?? "Item"),
        qty,
        unitCp
      };
    })
    .filter((row) => row.qty > 0)
    .sort((a, b) => a.itemName.localeCompare(b.itemName));

  const buyRowsHtml = merchantItems.length > 0
    ? merchantItems.map((row) => `
      <tr>
        <td>${poEscapeHtml(row.itemName)}</td>
        <td>${row.qty}</td>
        <td>${poEscapeHtml(formatMerchantCp(row.unitCp))}</td>
        <td><input type="number" min="0" max="${row.qty}" value="0" data-merchant-buy-item="${poEscapeHtml(row.itemId)}" data-unit-cp="${row.unitCp}" /></td>
      </tr>
    `).join("")
    : "<tr><td colspan='4'>No wares available.</td></tr>";

  const actorSellItems = !sellEnabled
    ? []
    : (actor?.items?.contents ?? [])
      .filter((item) => {
        const itemType = String(item?.type ?? "").trim().toLowerCase();
        return buybackAllowedTypeSet.has(itemType) && MERCHANT_ALLOWED_ITEM_TYPES.has(itemType);
      })
      .map((item) => {
        const qty = Math.max(0, Math.floor(getItemTrackedQuantity(item)));
        const unitCp = getMerchantItemUnitPriceCp(getMerchantItemData(item), sellRate);
        return {
          itemId: String(item?.id ?? ""),
          itemName: String(item?.name ?? "Item"),
          itemType: String(item?.type ?? "").trim().toLowerCase(),
          itemTypeLabel: String(LOOT_ITEM_TYPE_LABELS[String(item?.type ?? "").trim().toLowerCase()] ?? item?.type ?? "item"),
          qty,
          unitCp
        };
      })
      .filter((row) => row.qty > 0)
      .sort((a, b) => a.itemName.localeCompare(b.itemName));
  const sellRowsHtml = !sellEnabled
    ? "<tr><td colspan='5'>This merchant is not buying goods.</td></tr>"
    : (actorSellItems.length > 0
      ? actorSellItems.map((row) => `
      <tr>
        <td>${poEscapeHtml(row.itemName)}</td>
        <td>${poEscapeHtml(row.itemTypeLabel)}</td>
        <td>${row.qty}</td>
        <td>${poEscapeHtml(formatMerchantCp(row.unitCp))}</td>
        <td><input type="number" min="0" max="${row.qty}" value="0" data-merchant-sell-item="${poEscapeHtml(row.itemId)}" data-unit-cp="${row.unitCp}" /></td>
      </tr>
    `).join("")
      : "<tr><td colspan='5'>No eligible items to sell.</td></tr>");

  const actorFunds = formatMerchantCp(currencyBundleToCp(getActorCurrencyBundle(actor)));
  const merchantFundsBase = currencyBundleToCp(getActorCurrencyBundle(merchantActor));
  const merchantFunds = formatMerchantCp(Math.max(merchantFundsBase, configuredCashCp));
  const buybackTypeSummary = buybackAllowedTypeSet.size >= MERCHANT_ALLOWED_ITEM_TYPE_LIST.length
    ? "All item types"
    : (Array.from(buybackAllowedTypeSet).map((itemType) => String(LOOT_ITEM_TYPE_LABELS[itemType] ?? itemType)).join(", ") || "None");

  return `
    <div class="po-merchant-trade-dialog" data-merchant-id="${poEscapeHtml(String(merchant?.id ?? ""))}" data-actor-id="${poEscapeHtml(String(actor?.id ?? ""))}" data-settlement="${poEscapeHtml(settlement)}" data-barter-key="${poEscapeHtml(barterResolutionKey)}">
      <p><strong>${poEscapeHtml(String(actor?.name ?? "Actor"))}</strong> shopping with <strong>${poEscapeHtml(String(merchant?.name ?? "Merchant"))}</strong>.</p>
      <p>City: ${poEscapeHtml(settlementLabel)}</p>
      <p>Player Funds: ${poEscapeHtml(actorFunds)}</p>
      <p>Merchant Funds: ${poEscapeHtml(merchantFunds)}</p>
      <p>Buy Markup: x${buyMarkup.toFixed(2)} | Sell Rate: ${Math.round(sellRate * 100)}%</p>
      ${barterEnabled
    ? `<p>Barter Check: ${poEscapeHtml(barterAbilityLabel)} (GM-resolved).</p>
      <div class="po-op-action-row">
        <button type="button" class="po-btn po-btn-sm" data-merchant-barter-request>${poEscapeHtml(barterButtonLabel)}</button>
        <span class="po-op-summary" data-merchant-barter-status>${poEscapeHtml(barterStatusLabel)}</span>
      </div>`
    : "<p>Barter Check: Disabled.</p>"}
      <details open>
        <summary><strong>Buy</strong></summary>
        <table class="po-table po-table-sm" style="width:100%;">
          <thead><tr><th>Item</th><th>Stock</th><th>Unit</th><th>Qty</th></tr></thead>
          <tbody>${buyRowsHtml}</tbody>
        </table>
      </details>
      <details open>
        <summary><strong>Sell</strong></summary>
        <div class="po-op-summary">Accepted Types: ${poEscapeHtml(buybackTypeSummary)}</div>
        <table class="po-table po-table-sm" style="width:100%;">
          <thead><tr><th>Item</th><th>Type</th><th>Owned</th><th>Unit</th><th>Qty</th></tr></thead>
          <tbody>${sellRowsHtml}</tbody>
        </table>
      </details>
      <div class="po-op-summary">Buy Total: <strong data-merchant-buy-total>0.00 gp</strong></div>
      <div class="po-op-summary">Sell Total: <strong data-merchant-sell-total>0.00 gp</strong></div>
      <div class="po-op-summary">Net: <strong data-merchant-net-total>0.00 gp</strong></div>
    </div>
  `;
}

function readMerchantTradeInputsFromDialog(html) {
  const root = getMerchantTradeDialogRoot(html);
  if (!root) return null;
  const meta = readMerchantTradeMetaFromDialogRoot(root);
  if (!meta) return null;
  const readLines = (selector, datasetKey) => Array.from(root.querySelectorAll(selector))
    .map((input) => {
      const qtyRaw = Number(input?.value ?? 0);
      const qty = Number.isFinite(qtyRaw) ? Math.max(0, Math.floor(qtyRaw)) : 0;
      const itemId = String(input?.dataset?.[datasetKey] ?? "").trim();
      return { itemId, qty };
    })
    .filter((entry) => entry.itemId && entry.qty > 0);
  return {
    merchantId: meta.merchantId,
    actorId: meta.actorId,
    settlement: meta.settlement,
    buyItems: readLines("input[data-merchant-buy-item]", "merchantBuyItem"),
    sellItems: readLines("input[data-merchant-sell-item]", "merchantSellItem")
  };
}

function bindMerchantTradeDialogTotals(html) {
  const root = getMerchantTradeDialogRoot(html);
  if (!root) return;
  const buyNode = root.querySelector("[data-merchant-buy-total]");
  const sellNode = root.querySelector("[data-merchant-sell-total]");
  const netNode = root.querySelector("[data-merchant-net-total]");
  const recalc = () => {
    const sumBySelector = (selector) => Array.from(root.querySelectorAll(selector)).reduce((sum, input) => {
      const qty = Math.max(0, Math.floor(Number(input?.value ?? 0) || 0));
      const max = Math.max(0, Math.floor(Number(input?.getAttribute?.("max") ?? 0) || 0));
      if (qty > max) input.value = String(max);
      const unitCp = Math.max(0, Math.floor(Number(input?.dataset?.unitCp ?? 0) || 0));
      return sum + (Math.max(0, Math.min(qty, max)) * unitCp);
    }, 0);
    const buyCp = sumBySelector("input[data-merchant-buy-item]");
    const sellCp = sumBySelector("input[data-merchant-sell-item]");
    const netCp = buyCp - sellCp;
    if (buyNode) buyNode.textContent = formatMerchantCp(buyCp);
    if (sellNode) sellNode.textContent = formatMerchantCp(sellCp);
    if (netNode) {
      netNode.textContent = netCp >= 0
        ? `${formatMerchantCp(netCp)} paid`
        : `${formatMerchantCp(Math.abs(netCp))} received`;
    }
  };
  root.addEventListener("input", (event) => {
    const target = event.target;
    if (!(target instanceof HTMLInputElement)) return;
    if (!target.matches("input[data-merchant-buy-item], input[data-merchant-sell-item]")) return;
    recalc();
  });
  recalc();
}

async function resolveMerchantBarterForUser(user, payload = {}) {
  const userId = String(user?.id ?? "").trim();
  const actorId = String(payload?.actorId ?? "").trim();
  const merchantId = String(payload?.merchantId ?? "").trim();
  const settlement = normalizeMerchantSettlementSelection(payload?.settlement ?? "");
  if (!userId || !actorId || !merchantId) return { ok: false, message: "Missing barter payload." };

  const actor = game.actors.get(actorId);
  if (!actor) return { ok: false, message: "Actor not found." };
  if (!canUserManageDowntimeActor(user, actor)) return { ok: false, message: "You cannot access that actor." };

  const ledger = getOperationsLedger();
  const merchants = ensureMerchantsState(ledger);
  const merchant = merchants.definitions.find((entry) => String(entry?.id ?? "").trim() === merchantId);
  if (!merchant) return { ok: false, message: "Merchant not found." };
  if (!isMerchantAvailableToActor(merchant, actor, settlement, { isGM: false })) {
    return { ok: false, message: "Merchant is not currently available to this actor." };
  }
  if (merchant?.pricing?.barterEnabled === false) {
    return { ok: false, message: "Barter is disabled for this merchant." };
  }

  const barter = await rollMerchantBarterCheck(actor, merchant, { showDc: false });
  if (!barter?.applied || !Number.isFinite(Number(barter?.checkTotal))) {
    return { ok: false, message: "Barter check could not be resolved." };
  }

  const stored = {
    userId,
    actorId,
    merchantId,
    settlement,
    applied: true,
    source: String(barter?.source ?? "resolved"),
    ability: String(barter?.ability ?? "cha"),
    abilityLabel: String(barter?.abilityLabel ?? "Charisma"),
    checkTotal: Number(barter?.checkTotal ?? 0),
    margin: Number(barter?.margin ?? 0),
    success: Boolean(barter?.success),
    delta: Number(barter?.delta ?? 0),
    buyMarkupDelta: Number(barter?.buyMarkupDelta ?? 0),
    sellRateDelta: Number(barter?.sellRateDelta ?? 0),
    createdAt: Date.now()
  };
  const key = setMerchantBarterResolutionEntry(stored);
  const cached = getMerchantBarterResolutionEntryByKey(key);
  if (!cached) return { ok: false, message: "Failed to store barter resolution." };
  return {
    ok: true,
    key,
    userId,
    actorId,
    merchantId,
    settlement,
    summary: getMerchantBarterUiSummaryText(cached),
    resolution: cached
  };
}

function bindMerchantTradeDialogBarterButton(html) {
  const root = getMerchantTradeDialogRoot(html);
  if (!root) return;
  const barterButton = root.querySelector("[data-merchant-barter-request]");
  if (!(barterButton instanceof HTMLButtonElement)) return;
  if (barterButton.dataset.poBound === "1") return;
  barterButton.dataset.poBound = "1";

  const applyStatusFromCache = () => {
    const meta = readMerchantTradeMetaFromDialogRoot(root);
    if (!meta) return;
    const key = getMerchantBarterResolutionKey({
      userId: String(game.user?.id ?? "").trim(),
      actorId: meta.actorId,
      merchantId: meta.merchantId,
      settlement: meta.settlement
    });
    const cached = getMerchantBarterResolutionEntryByKey(key);
    if (cached?.applied) setMerchantTradeDialogBarterStatus(root, { summary: getMerchantBarterUiSummaryText(cached) });
  };

  barterButton.addEventListener("click", async () => {
    if (barterButton.disabled) return;
    const meta = readMerchantTradeMetaFromDialogRoot(root);
    if (!meta) return;
    barterButton.disabled = true;
    setMerchantTradeDialogBarterStatus(root, { pending: true });

    try {
      if (game.user?.isGM) {
        const resolved = await resolveMerchantBarterForUser(game.user, meta);
        if (!resolved.ok) {
          setMerchantTradeDialogBarterStatus(root, { error: true, errorLabel: resolved.message ?? "Barter request failed." });
          return;
        }
        setMerchantTradeDialogBarterStatus(root, { summary: String(resolved.summary ?? "").trim() });
        ui.notifications?.info("Barter resolved.");
        return;
      }
      if (!hasActiveGmClient()) {
        setMerchantTradeDialogBarterStatus(root, { error: true, errorLabel: "No active GM to resolve barter." });
        ui.notifications?.warn("No active GM to resolve barter.");
        return;
      }
      game.socket.emit(SOCKET_CHANNEL, {
        type: "ops:merchant-barter-request",
        userId: game.user.id,
        merchantId: meta.merchantId,
        actorId: meta.actorId,
        settlement: meta.settlement
      });
      ui.notifications?.info("Barter request sent to GM.");
    } catch (error) {
      console.warn(`${MODULE_ID}: barter request failed`, error);
      setMerchantTradeDialogBarterStatus(root, { error: true });
    } finally {
      barterButton.disabled = false;
      applyStatusFromCache();
    }
  });

  applyStatusFromCache();
}

function syncMerchantBarterStatusForOpenDialogs(payload = {}) {
  const targetUserId = String(payload?.userId ?? "").trim();
  const currentUserId = String(game.user?.id ?? "").trim();
  if (!targetUserId || targetUserId !== currentUserId) return;

  const merchantId = String(payload?.merchantId ?? "").trim();
  const actorId = String(payload?.actorId ?? "").trim();
  const settlement = normalizeMerchantSettlementSelection(payload?.settlement ?? "");
  const summary = String(payload?.summary ?? "").trim();
  const ok = payload?.ok !== false;

  const resolution = ok && payload?.resolution && typeof payload.resolution === "object"
    ? payload.resolution
    : null;
  const key = getMerchantBarterResolutionKey({ userId: currentUserId, actorId, merchantId, settlement });
  if (resolution) setMerchantBarterResolutionEntry({
    ...resolution,
    userId: currentUserId,
    actorId,
    merchantId,
    settlement
  });
  else if (!ok) clearMerchantBarterResolutionEntryByKey(key);

  const roots = Array.from(document.querySelectorAll(".po-merchant-trade-dialog"));
  for (const root of roots) {
    if (!(root instanceof HTMLElement)) continue;
    const meta = readMerchantTradeMetaFromDialogRoot(root);
    if (!meta) continue;
    if (meta.merchantId !== merchantId || meta.actorId !== actorId || meta.settlement !== settlement) continue;
    if (ok) setMerchantTradeDialogBarterStatus(root, { summary: summary || getMerchantBarterUiSummaryText(getMerchantBarterResolutionEntryByKey(key) ?? {}) });
    else setMerchantTradeDialogBarterStatus(root, { error: true, errorLabel: summary || "Barter request failed." });
  }

  if (ok) ui.notifications?.info(summary || "Barter resolved by GM.");
  else ui.notifications?.warn(summary || "GM could not resolve barter.");
}

async function openMerchantShopById(merchantIdInput, actorIdInput, settlementInput = undefined) {
  const merchantId = String(merchantIdInput ?? "").trim();
  const actorId = String(actorIdInput ?? "").trim() || getSelectedMerchantActorId();
  if (!merchantId || !actorId) {
    ui.notifications?.warn("Select a merchant and actor first.");
    return;
  }
  const actor = game.actors.get(actorId);
  if (!actor || !canUserManageDowntimeActor(game.user, actor)) {
    ui.notifications?.warn("You can only trade for an actor you can access.");
    return;
  }
  const ledger = getOperationsLedger();
  const merchants = ensureMerchantsState(ledger);
  const settlementPreference = hasSelectedMerchantSettlementPreference()
    ? getSelectedMerchantSettlement()
    : merchants.currentSettlement;
  const settlement = normalizeMerchantSettlementSelection(
    settlementInput === undefined ? settlementPreference : settlementInput
  );
  const merchant = merchants.definitions.find((entry) => String(entry?.id ?? "") === merchantId);
  if (!merchant) {
    ui.notifications?.warn("Merchant not found.");
    return;
  }
  if (!isMerchantAvailableToActor(merchant, actor, settlement, { isGM: false })) {
    ui.notifications?.warn("Merchant is not available to this actor.");
    return;
  }
  const merchantActor = merchant.actorId ? game.actors.get(String(merchant.actorId ?? "")) : null;
  if (!merchantActor) {
    ui.notifications?.warn("Merchant stock actor is unavailable. Ask the GM to refresh stock.");
    return;
  }

  const dialog = new Dialog({
    title: `Merchant Shop - ${String(merchant.name ?? "Merchant")}`,
    content: buildMerchantTradeDialogContent(merchant, actor, merchantActor, settlement),
    buttons: {
      finalize: {
        label: "Finalize",
        callback: async (html) => {
          const trade = readMerchantTradeInputsFromDialog(html);
          if (!trade) {
            ui.notifications?.warn("Trade form could not be read.");
            return;
          }
          const barterKey = getMerchantBarterResolutionKey({
            userId: String(game.user?.id ?? "").trim(),
            actorId: trade.actorId,
            merchantId: trade.merchantId,
            settlement: trade.settlement
          });
          if (canAccessAllPlayerOps()) {
            const barterResolution = getMerchantBarterResolutionEntryByKey(barterKey);
            const outcome = await applyMerchantTradeForUser(game.user, {
              ...trade,
              barterResolution
            });
            if (!outcome.ok) {
              ui.notifications?.warn(outcome.message ?? "Trade failed.");
              return;
            }
            clearMerchantBarterResolutionEntryByKey(barterKey);
            ui.notifications?.info(`Trade complete: ${outcome.actorName} and ${outcome.merchantName}.`);
            return;
          }
          game.socket.emit(SOCKET_CHANNEL, {
            type: "ops:merchant-trade",
            userId: game.user.id,
            merchantId: trade.merchantId,
            actorId: trade.actorId,
            settlement: trade.settlement,
            buyItems: trade.buyItems,
            sellItems: trade.sellItems
          });
          clearMerchantBarterResolutionEntryByKey(barterKey);
          ui.notifications?.info("Merchant trade request sent to GM.");
        }
      },
      cancel: { label: "Cancel" }
    },
    default: "finalize",
    render: (html) => {
      bindMerchantTradeDialogTotals(html);
      bindMerchantTradeDialogBarterButton(html);
    }
  });
  dialog.render(true);
}

function getMerchantEditorRootFromElement(element) {
  return element?.closest?.("#po-gm-merchants")
    ?? element?.closest?.("#po-ops-merchants")
    ?? element?.closest?.(".po-merchants-page")
    ?? null;
}

function getMerchantIdFromElementOrEditor(element) {
  const explicit = String(element?.dataset?.merchantId ?? "").trim();
  if (explicit) return explicit;
  const root = getMerchantEditorRootFromElement(element);
  return String(root?.querySelector?.("input[name='merchantId']")?.value ?? "").trim();
}

async function setMerchantSettlementFromElement(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can set the current settlement.");
    return false;
  }
  const settlement = String(element?.value ?? "").trim();
  await setMerchantCurrentSettlement(settlement);
  return true;
}

function setMerchantActorSelectionFromElement(element) {
  return setSelectedMerchantActorFromElement(element);
}

function setMerchantSettlementSelectionFromElement(element) {
  return setSelectedMerchantSettlementFromElement(element);
}

async function saveMerchantCityCatalogFromElement(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can manage merchant cities.");
    return false;
  }
  const root = getMerchantEditorRootFromElement(element);
  if (!root) return false;
  const rawInput = String(root.querySelector("input[name='merchantCityCatalog']")?.value ?? "").trim();
  const cityCatalog = await saveMerchantCityCatalog(rawInput);
  ui.notifications?.info(`Saved merchant cities (${cityCatalog.length}).`);
  return true;
}

async function assignMerchantCityFromElement(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can assign merchant cities.");
    return false;
  }
  const merchantId = String(element?.dataset?.merchantId ?? "").trim();
  if (!merchantId) return false;
  const city = normalizeMerchantSettlementSelection(element?.value ?? element?.dataset?.city ?? "");
  const saved = await setMerchantCityById(merchantId, city);
  if (!saved?.id) return false;
  if (String(getMerchantEditorSelection() ?? "").trim() === saved.id) {
    setMerchantEditorDraftState(saved.id, saved);
  }
  return true;
}

function randomizeMerchantNameFromElement(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can randomize merchant names.");
    return false;
  }
  const draft = cacheMerchantEditorDraftFromElement(element, { suppressMissingFormWarning: true })
    ?? getMerchantDefinitionDraftSource({});
  const randomName = generateRandomMerchantNameUnbound();
  const randomTitle = pickRandomMerchantTitle("Merchant");
  draft.name = randomName;
  draft.title = randomTitle;
  cacheMerchantEditorDraftFromPatch(draft);
  ui.notifications?.info(`Randomized merchant identity: ${randomName} - ${randomTitle}.`);
  return true;
}

function randomizeMerchantRaceFromElement(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can randomize merchant race.");
    return false;
  }
  const draft = cacheMerchantEditorDraftFromElement(element, { suppressMissingFormWarning: true })
    ?? getMerchantDefinitionDraftSource({});
  const randomRace = pickRandomMerchantRace("Human");
  draft.race = randomRace;
  cacheMerchantEditorDraftFromPatch(draft);
  ui.notifications?.info(`Randomized race: ${randomRace}.`);
  return true;
}

function resetMerchantEditorSelection() {
  setMerchantEditorSelection("__new__");
  setMerchantEditorDraftState("__new__", getMerchantDefinitionDraftSource({}));
}

function setMerchantEditorSelectionFromElement(element) {
  const merchantId = String(element?.dataset?.merchantId ?? "").trim();
  if (!merchantId) return false;
  const merchant = getMerchantById(merchantId);
  setMerchantEditorSelection(merchantId);
  if (merchant) setMerchantEditorDraftState(merchantId, merchant);
  return true;
}

function getMerchantEditorSelectionKeyForPatch(patch = {}) {
  const selected = normalizeMerchantEditorSelectionKey(getMerchantEditorSelection());
  const patchId = String(patch?.id ?? "").trim();
  if (selected === "__new__") return "__new__";
  if (patchId) return patchId;
  if (selected) return selected;
  return "__new__";
}

function cacheMerchantEditorDraftFromPatch(patch = {}, selectionKeyInput = "") {
  const selectionKey = normalizeMerchantEditorSelectionKey(selectionKeyInput || getMerchantEditorSelectionKeyForPatch(patch));
  const draft = getMerchantDefinitionDraftSource(patch);
  if (selectionKey === "__new__") draft.id = "";
  setMerchantEditorDraftState(selectionKey, draft);
  return draft;
}

function cacheMerchantEditorDraftFromElement(element, options = {}) {
  const patch = readMerchantDefinitionPatchFromElement(element);
  if (!patch) {
    if (!options.suppressMissingFormWarning) ui.notifications?.warn("Merchant editor form not found.");
    return null;
  }
  return cacheMerchantEditorDraftFromPatch(patch);
}

async function persistMerchantEditorPatchFromElement(element, options = {}) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can save merchants.");
    return null;
  }
  const patch = readMerchantDefinitionPatchFromElement(element);
  if (!patch) {
    if (!options.suppressMissingFormWarning) ui.notifications?.warn("Merchant editor form not found.");
    return null;
  }
  if (!String(patch.name ?? "").trim()) {
    if (!options.suppressNameWarning) ui.notifications?.warn("Merchant name is required.");
    return null;
  }
  const saved = await upsertMerchant(patch);
  if (saved?.id) setMerchantEditorSelection(saved.id);
  clearMerchantEditorDraftState();
  if (options.notifySaved) ui.notifications?.info(`Saved merchant: ${String(saved?.name ?? "Merchant")}.`);
  return saved;
}

async function saveMerchantFromElement(element) {
  return persistMerchantEditorPatchFromElement(element, { notifySaved: true });
}

async function saveMerchantStockControlsFromElement(element) {
  const draft = cacheMerchantEditorDraftFromElement(element, { suppressMissingFormWarning: true });
  return Boolean(draft);
}

async function toggleMerchantPackSourceFromElement(element) {
  return saveMerchantStockControlsFromElement(element);
}

async function toggleMerchantAllowedTypeFromElement(element) {
  return saveMerchantStockControlsFromElement(element);
}

async function addMerchantCuratedItemFromElement(element, uuidInput = "") {
  const itemUuid = String(uuidInput ?? element?.dataset?.itemUuid ?? "").trim();
  if (!itemUuid) return false;
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can curate merchant items.");
    return false;
  }
  const patch = cacheMerchantEditorDraftFromElement(element);
  if (!patch) return false;
  const current = normalizeMerchantCuratedItemUuids(patch?.stock?.curatedItemUuids ?? []);
  if (current.includes(itemUuid)) return false;
  patch.stock.curatedItemUuids = normalizeMerchantCuratedItemUuids([...current, itemUuid]);
  cacheMerchantEditorDraftFromPatch(patch);
  return true;
}

async function removeMerchantCuratedItemFromElement(element) {
  const itemUuid = String(element?.dataset?.itemUuid ?? "").trim();
  if (!itemUuid) return false;
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can curate merchant items.");
    return false;
  }
  const patch = cacheMerchantEditorDraftFromElement(element);
  if (!patch) return false;
  const current = normalizeMerchantCuratedItemUuids(patch?.stock?.curatedItemUuids ?? []);
  const next = current.filter((entry) => entry !== itemUuid);
  if (next.length === current.length) return false;
  patch.stock.curatedItemUuids = next;
  cacheMerchantEditorDraftFromPatch(patch);
  return true;
}

async function clearMerchantCuratedItemsFromElement(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can curate merchant items.");
    return false;
  }
  const patch = cacheMerchantEditorDraftFromElement(element);
  if (!patch) return false;
  if (normalizeMerchantCuratedItemUuids(patch?.stock?.curatedItemUuids ?? []).length <= 0) return false;
  patch.stock.curatedItemUuids = [];
  cacheMerchantEditorDraftFromPatch(patch);
  return true;
}

async function reorderMerchantCuratedItemsFromElement(element, draggedUuidInput, targetUuidInput = "") {
  const draggedUuid = String(draggedUuidInput ?? "").trim();
  const targetUuid = String(targetUuidInput ?? "").trim();
  if (!draggedUuid) return false;
  if (!canAccessAllPlayerOps()) return false;
  const patch = cacheMerchantEditorDraftFromElement(element, { suppressMissingFormWarning: true });
  if (!patch) return false;
  const current = normalizeMerchantCuratedItemUuids(patch?.stock?.curatedItemUuids ?? []);
  if (!current.includes(draggedUuid)) return false;
  const next = current.filter((entry) => entry !== draggedUuid);
  const targetIndex = targetUuid ? next.indexOf(targetUuid) : -1;
  if (targetIndex < 0) next.push(draggedUuid);
  else next.splice(targetIndex, 0, draggedUuid);
  if (JSON.stringify(next) === JSON.stringify(current)) return false;
  patch.stock.curatedItemUuids = next;
  cacheMerchantEditorDraftFromPatch(patch);
  return true;
}

function getMerchantCuratedDragUuidFromEvent(event) {
  const transfer = event?.dataTransfer;
  if (!transfer) return "";
  return String(transfer.getData("application/x-po-merchant-curated") || "").trim();
}

function getMerchantCandidateDragUuidFromEvent(event) {
  const transfer = event?.dataTransfer;
  if (!transfer) return "";
  return String(transfer.getData("application/x-po-merchant-candidate") || "").trim();
}

async function addMerchantCuratedItemFromDropEvent(event) {
  if (!canAccessAllPlayerOps()) return false;
  let data = null;
  try {
    data = TextEditor.getDragEventData(event);
  } catch {
    data = null;
  }
  if (!data || typeof data !== "object") return false;
  const document = await resolveLootItemDocumentFromDropData(data);
  if (!document) {
    ui.notifications?.warn("Drop an Item from the sidebar or compendium.");
    return false;
  }
  return addMerchantCuratedItemFromElement(event?.target, String(document.uuid ?? "").trim());
}

function applyMerchantEditorFilters(rootLike) {
  const root = getAppRootElement(rootLike);
  if (!root?.querySelectorAll) return;
  const packFilterInput = root.querySelector("input[data-merchant-pack-filter]");
  const itemFilterInput = root.querySelector("input[data-merchant-item-filter]");
  const packFilter = normalizeMerchantEditorFilter(packFilterInput?.value ?? getMerchantEditorPackFilter()).toLowerCase();
  const itemFilter = normalizeMerchantEditorFilter(itemFilterInput?.value ?? getMerchantEditorItemFilter()).toLowerCase();
  const applyFilter = (selector, filterNeedle) => {
    const rows = Array.from(root.querySelectorAll(selector));
    let visibleCount = 0;
    for (const row of rows) {
      const searchBlob = String(row?.dataset?.search ?? row?.textContent ?? "").toLowerCase();
      const visible = !filterNeedle || searchBlob.includes(filterNeedle);
      row.hidden = !visible;
      row.classList.toggle("is-hidden", !visible);
      if (visible) visibleCount += 1;
    }
    return { visibleCount, totalCount: rows.length };
  };

  const packStats = applyFilter("[data-merchant-pack-row]", packFilter);
  const itemStats = applyFilter("[data-merchant-candidate-row]", itemFilter);
  for (const node of root.querySelectorAll("[data-merchant-pack-visible-count]")) {
    node.textContent = String(packStats.visibleCount);
  }
  for (const node of root.querySelectorAll("[data-merchant-pack-total-count]")) {
    node.textContent = String(packStats.totalCount);
  }
  for (const node of root.querySelectorAll("[data-merchant-candidate-visible-count]")) {
    node.textContent = String(itemStats.visibleCount);
  }
  for (const node of root.querySelectorAll("[data-merchant-candidate-total-count]")) {
    node.textContent = String(itemStats.totalCount);
  }
  const packEmptyNode = root.querySelector("[data-merchant-pack-empty]");
  if (packEmptyNode) packEmptyNode.hidden = packStats.visibleCount > 0;
  const candidateEmptyNode = root.querySelector("[data-merchant-candidate-empty]");
  if (candidateEmptyNode) candidateEmptyNode.hidden = itemStats.visibleCount > 0;
}

async function deleteMerchantFromElement(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can delete merchants.");
    return false;
  }
  const merchantId = getMerchantIdFromElementOrEditor(element);
  if (!merchantId) {
    ui.notifications?.warn("Select a merchant to delete.");
    return false;
  }
  const merchant = getMerchantById(merchantId);
  if (!merchant) {
    ui.notifications?.warn("Merchant not found.");
    return false;
  }
  const confirmed = await Dialog.confirm({
    title: "Delete Merchant",
    content: `<p>Delete <strong>${poEscapeHtml(String(merchant.name ?? "Merchant"))}</strong>?</p>`
  });
  if (!confirmed) return false;
  await deleteMerchant(merchantId);
  if (getMerchantEditorSelection() === merchantId) setMerchantEditorSelection("");
  ui.notifications?.info(`Deleted merchant: ${merchant.name}.`);
  return true;
}

async function refreshMerchantStockFromElement(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can refresh merchant stock.");
    return null;
  }
  const merchantId = getMerchantIdFromElementOrEditor(element);
  if (!merchantId) {
    ui.notifications?.warn("Select a merchant first.");
    return null;
  }
  return refreshMerchantStock(merchantId);
}

async function refreshAllMerchantStocksFromElement(_element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can refresh merchant stock.");
    return null;
  }
  return refreshAllMerchantStocks();
}

async function setMerchantAccessModeById(merchantIdInput, modeInput) {
  const merchantId = String(merchantIdInput ?? "").trim();
  if (!merchantId) return null;
  const saved = await upsertMerchant({
    id: merchantId,
    accessMode: normalizeMerchantAccessMode(modeInput, MERCHANT_ACCESS_MODES.ALL)
  });
  if (saved?.id && String(getMerchantEditorSelection() ?? "").trim() === saved.id) {
    setMerchantEditorDraftState(saved.id, saved);
  }
  return saved;
}

async function setMerchantAccessModeFromElement(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update merchant access.");
    return false;
  }
  const merchantId = getMerchantIdFromElementOrEditor(element);
  if (!merchantId) return false;
  const nextMode = normalizeMerchantAccessMode(
    element?.value
    ?? element?.dataset?.accessMode
    ?? MERCHANT_ACCESS_MODES.ALL,
    MERCHANT_ACCESS_MODES.ALL
  );
  const saved = await setMerchantAccessModeById(merchantId, nextMode);
  return Boolean(saved?.id);
}

async function setMerchantAssignmentsForAllActors(merchantIdInput, assigned = true) {
  const merchantId = String(merchantIdInput ?? "").trim();
  if (!merchantId) return { updated: 0, total: 0 };
  const actors = getOwnedPcActors();
  let updated = 0;
  for (const actor of actors) {
    if (!actor?.id) continue;
    const actorId = String(actor.id).trim();
    if (!actorId) continue;
    const contracts = getActorMerchantContracts(actor);
    const alreadyAssigned = Boolean(contracts[merchantId]);
    if (Boolean(assigned) === alreadyAssigned) continue;
    // eslint-disable-next-line no-await-in-loop
    const ok = await setMerchantAssignment(actorId, merchantId, Boolean(assigned));
    if (ok) updated += 1;
  }
  return { updated, total: actors.length };
}

async function setMerchantAssignmentAllFromElement(element, assigned = true) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can assign merchant contracts.");
    return false;
  }
  const merchantId = getMerchantIdFromElementOrEditor(element);
  if (!merchantId) return false;
  const merchant = getMerchantById(merchantId);
  if (!merchant) return false;
  const result = await setMerchantAssignmentsForAllActors(merchantId, assigned);
  const merchantName = String(merchant.name ?? "Merchant").trim() || "Merchant";
  const verb = assigned ? "Assigned" : "Cleared";
  ui.notifications?.info(`${verb} ${merchantName} for ${result.updated}/${result.total} actor(s).`);
  return true;
}

async function setMerchantAssignmentAllEnabledFromElement(element) {
  return setMerchantAssignmentAllFromElement(element, true);
}

async function setMerchantAssignmentAllDisabledFromElement(element) {
  return setMerchantAssignmentAllFromElement(element, false);
}

async function assignMerchantByContractKeyFromElement(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can assign by contract key.");
    return null;
  }
  const merchantId = getMerchantIdFromElementOrEditor(element);
  if (!merchantId) {
    ui.notifications?.warn("Select a merchant first.");
    return null;
  }
  const merchant = getMerchantById(merchantId);
  if (!merchant) {
    ui.notifications?.warn("Merchant not found.");
    return null;
  }
  const contractKey = String(merchant.contractKey ?? "").trim().toLowerCase();
  if (!contractKey) {
    ui.notifications?.warn("Set a contract key on the merchant first.");
    return null;
  }

  const actors = getOwnedPcActors();
  let matched = 0;
  let assigned = 0;
  for (const actor of actors) {
    const contracts = getActorMerchantContracts(actor);
    if (!contracts[contractKey]) continue;
    matched += 1;
    if (contracts[merchantId]) continue;
    const nextContracts = foundry.utils.deepClone(contracts);
    nextContracts[merchantId] = true;
    await actor.setFlag(MODULE_ID, "merchantContracts", nextContracts);
    assigned += 1;
  }

  if (matched <= 0) {
    ui.notifications?.warn(`No actors currently have contract key "${contractKey}".`);
    return { ok: false, merchantId, contractKey, matched, assigned };
  }
  const alreadyAssigned = Math.max(0, matched - assigned);
  const merchantName = String(merchant.name ?? "Merchant").trim() || "Merchant";
  if (alreadyAssigned > 0) {
    ui.notifications?.info(`Assigned ${merchantName} to ${assigned} actor(s) via "${contractKey}" (${alreadyAssigned} already assigned).`);
  } else {
    ui.notifications?.info(`Assigned ${merchantName} to ${assigned} actor(s) via "${contractKey}".`);
  }
  return { ok: true, merchantId, contractKey, matched, assigned };
}

async function setMerchantAssignmentFromElement(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can assign merchant contracts.");
    return false;
  }
  const actorId = String(element?.dataset?.actorId ?? "").trim();
  const merchantId = String(element?.dataset?.merchantId ?? "").trim();
  if (!actorId || !merchantId) return false;
  const assigned = Boolean(element?.checked);
  return setMerchantAssignment(actorId, merchantId, assigned);
}

async function openMerchantActorFromElement(element) {
  const merchantId = getMerchantIdFromElementOrEditor(element);
  if (!merchantId) return false;
  const merchant = getMerchantById(merchantId);
  if (!merchant) return false;
  const merchantActor = merchant.actorId ? game.actors.get(merchant.actorId) : null;
  if (!merchantActor) {
    ui.notifications?.warn("Merchant actor is not configured yet. Use Refresh Stock first.");
    return false;
  }
  merchantActor.sheet?.render(true);
  return true;
}

async function openMerchantShopFromElement(element) {
  const merchantId = String(element?.dataset?.merchantId ?? "").trim();
  const actorId = String(element?.dataset?.actorId ?? "").trim() || getSelectedMerchantActorId();
  const settlementDataset = Object.prototype.hasOwnProperty.call(element?.dataset ?? {}, "settlement")
    ? element.dataset.settlement
    : undefined;
  const settlement = settlementDataset === undefined ? undefined : normalizeMerchantSettlementSelection(settlementDataset);
  if (!merchantId || !actorId) {
    ui.notifications?.warn("Select an actor and merchant first.");
    return false;
  }
  await openMerchantShopById(merchantId, actorId, settlement);
  return true;
}

function getDowntimeActionDefinition(actionKey = "") {
  const key = String(actionKey ?? "").trim().toLowerCase();
  return DOWNTIME_ACTION_OPTIONS.find((entry) => entry.key === key) ?? DOWNTIME_ACTION_OPTIONS[0];
}

function getDowntimeSocialContractDefinition(contractKey = "") {
  const key = String(contractKey ?? "").trim().toLowerCase();
  return DOWNTIME_SOCIAL_CONTRACT_OPTIONS.find((entry) => entry.key === key) ?? DOWNTIME_SOCIAL_CONTRACT_OPTIONS[0];
}

function buildDowntimeSocialContractOptions(selectedKey = "") {
  const selected = String(selectedKey ?? "").trim().toLowerCase();
  return DOWNTIME_SOCIAL_CONTRACT_OPTIONS.map((entry) => ({
    value: entry.key,
    label: entry.label,
    summary: entry.summary,
    limitations: entry.limitations,
    selected: entry.key === selected
  }));
}

function normalizeDowntimeSocialContract(rawContract = {}, actionKey = "") {
  const source = (rawContract && typeof rawContract === "object")
    ? rawContract
    : { key: rawContract };
  const definition = getDowntimeSocialContractDefinition(source?.key ?? source?.value ?? "");
  const notes = String(source?.notes ?? source?.detail ?? "").trim().slice(0, 800);
  const featureItemId = String(source?.featureItemId ?? "").trim();
  const action = String(actionKey ?? "").trim().toLowerCase();
  const hasContract = Boolean(definition.key);
  const available = hasContract && action === "carousing";
  return {
    key: available ? definition.key : "",
    label: available ? definition.label : "",
    summary: available ? definition.summary : "",
    limitations: available ? definition.limitations : "",
    notes: available ? notes : "",
    featureItemId: available ? featureItemId : "",
    hasContract: available
  };
}

function normalizeDowntimeItemRewardDrop(rawDrop = {}) {
  const source = (rawDrop && typeof rawDrop === "object")
    ? rawDrop
    : { name: rawDrop };
  const id = String(source?.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID();
  const uuid = String(source?.uuid ?? "").trim();
  const name = String(source?.name ?? "Item").trim() || "Item";
  const img = String(source?.img ?? "icons/svg/item-bag.svg").trim() || "icons/svg/item-bag.svg";
  const itemType = String(source?.itemType ?? source?.type ?? "loot").trim() || "loot";
  const quantityRaw = Number(source?.quantity ?? 1);
  const quantity = Number.isFinite(quantityRaw) ? Math.max(1, Math.floor(quantityRaw)) : 1;
  return {
    id,
    uuid,
    name,
    img,
    itemType,
    quantity
  };
}

function normalizeDowntimeItemRewardDrops(rawDrops = []) {
  if (!Array.isArray(rawDrops)) return [];
  return rawDrops
    .map((entry) => normalizeDowntimeItemRewardDrop(entry))
    .filter((entry) => entry.name.length > 0)
    .slice(0, DOWNTIME_ITEM_REWARD_DROP_LIMIT);
}

function serializeDowntimeItemRewardDrops(rawDrops = []) {
  const drops = normalizeDowntimeItemRewardDrops(rawDrops);
  try {
    return JSON.stringify(drops);
  } catch {
    return "[]";
  }
}

function parseDowntimeItemRewardDrops(rawValue = "[]") {
  const text = String(rawValue ?? "").trim();
  if (!text) return [];
  try {
    const parsed = JSON.parse(text);
    return normalizeDowntimeItemRewardDrops(parsed);
  } catch {
    return [];
  }
}

function buildDowntimeItemRewardDropFromDocument(documentRef) {
  if (!documentRef || documentRef.documentName !== "Item") return null;
  return normalizeDowntimeItemRewardDrop({
    id: foundry.utils.randomID(),
    uuid: String(documentRef.uuid ?? "").trim(),
    name: String(documentRef.name ?? "Item").trim() || "Item",
    img: String(documentRef.img ?? "icons/svg/item-bag.svg").trim() || "icons/svg/item-bag.svg",
    itemType: String(documentRef.type ?? "loot").trim() || "loot",
    quantity: 1
  });
}

function normalizeDowntimeResult(result = {}) {
  const resolvedAtRaw = Number(result?.resolvedAt ?? result?.rolledAt ?? Date.now());
  const resolvedAt = Number.isFinite(resolvedAtRaw) ? resolvedAtRaw : Date.now();
  const actionDef = getDowntimeActionDefinition(result?.actionKey);
  const details = Array.isArray(result?.details)
    ? result.details.map((entry) => String(entry ?? "").trim()).filter(Boolean).slice(0, 8)
    : [];
  const rollTotalRaw = Number(result?.rollTotal ?? 0);
  const gpDeltaRaw = Number(result?.gpDelta ?? 0);
  const hasAwardField = result?.gpAward !== undefined && result?.gpAward !== null;
  const hasCostField = result?.gpCost !== undefined && result?.gpCost !== null;
  const gpAwardRaw = Number(result?.gpAward);
  const gpCostRaw = Number(result?.gpCost);
  const progressRaw = Number(result?.progress ?? 0);
  const rumorCountRaw = Number(result?.rumorCount ?? 0);
  const itemRewards = Array.isArray(result?.itemRewards)
    ? result.itemRewards
      .map((entry) => String(entry ?? "").trim())
      .filter(Boolean)
      .slice(0, DOWNTIME_ITEM_REWARD_DROP_LIMIT)
    : [];
  const itemRewardDrops = normalizeDowntimeItemRewardDrops(result?.itemRewardDrops ?? []);
  const gmNotes = String(result?.gmNotes ?? "").trim();
  const collected = result?.collected === true;
  const collectedAtRaw = Number(result?.collectedAt ?? 0);
  const collectedAt = Number.isFinite(collectedAtRaw) && collectedAtRaw > 0 ? collectedAtRaw : 0;
  const collectedBy = String(result?.collectedBy ?? "").trim();
  const legacyGpDelta = Number.isFinite(gpDeltaRaw) ? Math.floor(gpDeltaRaw) : 0;
  const gpAward = hasAwardField && Number.isFinite(gpAwardRaw)
    ? Math.max(0, Math.floor(gpAwardRaw))
    : Math.max(0, legacyGpDelta);
  const gpCost = hasCostField && Number.isFinite(gpCostRaw)
    ? Math.max(0, Math.floor(gpCostRaw))
    : Math.max(0, -legacyGpDelta);
  const gpDelta = gpAward - gpCost;
  const rumorCount = Number.isFinite(rumorCountRaw) ? Math.max(0, Math.floor(rumorCountRaw)) : 0;
  const socialContract = normalizeDowntimeSocialContract(result?.socialContract ?? {}, actionDef.key);
  const hasClaimableRewards = gpAward > 0
    || gpCost > 0
    || rumorCount > 0
    || itemRewards.length > 0
    || itemRewardDrops.length > 0
    || gmNotes.length > 0
    || socialContract.hasContract;
  return {
    id: String(result?.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID(),
    actionKey: actionDef.key,
    actionLabel: String(result?.actionLabel ?? actionDef.label).trim() || actionDef.label,
    summary: String(result?.summary ?? "").trim(),
    details,
    rollTotal: Number.isFinite(rollTotalRaw) ? Math.floor(rollTotalRaw) : 0,
    gpAward,
    gpCost,
    gpDelta,
    progress: Number.isFinite(progressRaw) ? Math.max(0, Math.floor(progressRaw)) : 0,
    complication: String(result?.complication ?? "").trim(),
    resolvedAt,
    resolvedBy: String(result?.resolvedBy ?? "GM").trim() || "GM",
    rumorCount,
    itemRewards,
    itemRewardDrops,
    gmNotes,
    socialContract,
    hasClaimableRewards,
    collected,
    collectedAt,
    collectedBy
  };
}

function ensureDowntimeState(ledger) {
  if (!ledger.downtime || typeof ledger.downtime !== "object") {
    ledger.downtime = {};
  }
  const downtime = ledger.downtime;
  const hoursGrantedRaw = Number(downtime.hoursGranted ?? 4);
  downtime.hoursGranted = Number.isFinite(hoursGrantedRaw)
    ? Math.max(1, Math.min(24, Math.floor(hoursGrantedRaw)))
    : 4;
  if (!downtime.tuning || typeof downtime.tuning !== "object") downtime.tuning = {};

  const economyAllowed = new Set(DOWNTIME_TUNING_ECONOMY_OPTIONS.map((entry) => entry.value));
  const riskAllowed = new Set(DOWNTIME_TUNING_RISK_OPTIONS.map((entry) => entry.value));
  const discoveryAllowed = new Set(DOWNTIME_TUNING_DISCOVERY_OPTIONS.map((entry) => entry.value));
  const economy = String(downtime.tuning.economy ?? "standard").trim().toLowerCase();
  const risk = String(downtime.tuning.risk ?? "standard").trim().toLowerCase();
  const discovery = String(downtime.tuning.discovery ?? "standard").trim().toLowerCase();
  downtime.tuning.economy = economyAllowed.has(economy) ? economy : "standard";
  downtime.tuning.risk = riskAllowed.has(risk) ? risk : "standard";
  downtime.tuning.discovery = discoveryAllowed.has(discovery) ? discovery : "standard";

  if (!downtime.entries || typeof downtime.entries !== "object" || Array.isArray(downtime.entries)) {
    downtime.entries = {};
  }

  const normalizedEntries = {};
  const archivedCollectedEntries = [];
  for (const [rawActorId, rawEntry] of Object.entries(downtime.entries ?? {})) {
    const actorId = String(rawEntry?.actorId ?? rawActorId ?? "").trim();
    if (!actorId) continue;
    const actionDef = getDowntimeActionDefinition(rawEntry?.actionKey);
    const rawHours = Number(rawEntry?.hours ?? downtime.hoursGranted);
    const hours = Number.isFinite(rawHours) ? Math.max(1, Math.min(downtime.hoursGranted, Math.floor(rawHours))) : downtime.hoursGranted;
    const updatedAtRaw = Number(rawEntry?.updatedAt ?? rawEntry?.submittedAt ?? 0);
    const updatedAt = Number.isFinite(updatedAtRaw) ? updatedAtRaw : 0;
    const pending = rawEntry?.pending !== false;
    const lastResult = rawEntry?.lastResult && typeof rawEntry.lastResult === "object"
      ? normalizeDowntimeResult(rawEntry.lastResult)
      : null;
    const stagedResult = pending && rawEntry?.stagedResult && typeof rawEntry.stagedResult === "object"
      ? normalizeDowntimeResult(rawEntry.stagedResult)
      : null;
    const stagedAtRaw = Number(rawEntry?.stagedAt ?? 0);
    const stagedAt = stagedResult && Number.isFinite(stagedAtRaw) && stagedAtRaw > 0 ? stagedAtRaw : 0;
    const stagedBy = stagedResult ? (String(rawEntry?.stagedBy ?? "").trim() || "GM") : "";
    const actorName = String(rawEntry?.actorName ?? game.actors.get(actorId)?.name ?? `Actor ${actorId}`).trim() || `Actor ${actorId}`;
    if (!pending && lastResult?.collected === true) {
      archivedCollectedEntries.push({
        ...lastResult,
        actorId,
        actorName,
        hours
      });
      continue;
    }
    normalizedEntries[actorId] = {
      actorId,
      actorName,
      actionKey: actionDef.key,
      hours,
      note: String(rawEntry?.note ?? "").slice(0, 1000),
      pending,
      updatedAt,
      updatedBy: String(rawEntry?.updatedBy ?? rawEntry?.submittedBy ?? "").trim() || "Player",
      updatedByUserId: String(rawEntry?.updatedByUserId ?? rawEntry?.submittedByUserId ?? "").trim(),
      lastResult,
      stagedResult,
      stagedAt,
      stagedBy
    };
  }
  downtime.entries = normalizedEntries;

  if (!Array.isArray(downtime.logs)) downtime.logs = [];
  const mergedLogsSource = [...downtime.logs, ...archivedCollectedEntries];
  const seenLogKeys = new Set();
  downtime.logs = mergedLogsSource
    .map((entry) => {
      const normalized = normalizeDowntimeResult(entry);
      return {
        ...normalized,
        actorId: String(entry?.actorId ?? "").trim(),
        actorName: String(entry?.actorName ?? "Unknown Actor").trim() || "Unknown Actor",
        hours: Math.max(1, Math.floor(Number(entry?.hours ?? 4) || 4))
      };
    })
    .filter((entry) => {
      if (!entry.actorId) return false;
      const idKey = String(entry.id ?? "").trim();
      const resolvedAtKey = Number(entry.resolvedAt ?? 0);
      const dedupeKey = `${entry.actorId}::${idKey || resolvedAtKey}`;
      if (seenLogKeys.has(dedupeKey)) return false;
      seenLogKeys.add(dedupeKey);
      return true;
    })
    .sort((a, b) => Number(b.resolvedAt ?? 0) - Number(a.resolvedAt ?? 0))
    .slice(0, 80);

  return downtime;
}

function normalizeLootClaimCurrencyRecord(value = {}, fallback = {}) {
  const source = value && typeof value === "object" ? value : {};
  const base = fallback && typeof fallback === "object" ? fallback : {};
  const pp = Math.max(0, Math.floor(Number(source.pp ?? base.pp ?? 0) || 0));
  const gp = Math.max(0, Math.floor(Number(source.gp ?? base.gp ?? 0) || 0));
  const sp = Math.max(0, Math.floor(Number(source.sp ?? base.sp ?? 0) || 0));
  const cp = Math.max(0, Math.floor(Number(source.cp ?? base.cp ?? 0) || 0));
  const gpEquivalentRaw = Number(source.gpEquivalent ?? base.gpEquivalent);
  const gpEquivalent = Number.isFinite(gpEquivalentRaw) && gpEquivalentRaw >= 0
    ? gpEquivalentRaw
    : (pp * 10) + gp + (sp * 0.1) + (cp * 0.01);
  return { pp, gp, sp, cp, gpEquivalent };
}

function normalizeLootClaimActorIdList(values = []) {
  if (!Array.isArray(values)) return [];
  return values
    .map((entry) => String(entry ?? "").trim())
    .filter((entry, index, arr) => entry.length > 0 && arr.indexOf(entry) === index);
}

function normalizeLootClaimItemsList(values = []) {
  const source = Array.isArray(values) ? values : [];
  return source
    .map((entry) => ({
      id: String(entry?.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID(),
      uuid: String(entry?.uuid ?? "").trim(),
      name: String(entry?.name ?? "Item").trim() || "Item",
      img: String(entry?.img ?? "icons/svg/item-bag.svg").trim() || "icons/svg/item-bag.svg",
      itemType: String(entry?.itemType ?? "").trim(),
      rarity: String(entry?.rarity ?? "").trim(),
      sourceLabel: String(entry?.sourceLabel ?? "").trim(),
      majorItem: Boolean(entry?.majorItem),
      vouchedByActorIds: normalizeLootClaimActorIdList(entry?.vouchedByActorIds)
    }))
    .filter((entry, index, arr) => entry.id && arr.findIndex((candidate) => candidate.id === entry.id) === index);
}

function normalizeLootClaimTableRolls(values = []) {
  const source = Array.isArray(values) ? values : [];
  return source
    .map((entry) => ({
      sourceLabel: String(entry?.sourceLabel ?? "Source").trim() || "Source",
      sourceType: String(entry?.sourceType ?? "currency").trim() || "currency",
      tableName: String(entry?.tableName ?? "Roll Table").trim() || "Roll Table",
      formula: String(entry?.formula ?? "").trim(),
      total: Math.max(0, Math.floor(Number(entry?.total ?? 0) || 0)),
      result: String(entry?.result ?? "No result").trim() || "No result"
    }))
    .slice(0, 40);
}

function normalizeLootClaimLogEntries(values = []) {
  const source = Array.isArray(values) ? values : [];
  return source
    .map((entry) => ({
      id: String(entry?.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID(),
      itemId: String(entry?.itemId ?? "").trim(),
      itemName: String(entry?.itemName ?? "Item").trim() || "Item",
      actorId: String(entry?.actorId ?? "").trim(),
      actorName: String(entry?.actorName ?? "Actor").trim() || "Actor",
      claimedByUserId: String(entry?.claimedByUserId ?? "").trim(),
      claimedByName: String(entry?.claimedByName ?? "Player").trim() || "Player",
      claimedAt: Math.max(0, Number(entry?.claimedAt ?? 0) || 0)
    }))
    .filter((entry) => entry.itemId && entry.actorId)
    .sort((a, b) => Number(b.claimedAt ?? 0) - Number(a.claimedAt ?? 0))
    .slice(0, 120);
}

function normalizeLootClaimBoardRecord(value = {}, fallback = {}) {
  const source = value && typeof value === "object" ? value : {};
  const base = fallback && typeof fallback === "object" ? fallback : {};
  const id = normalizeLootClaimRunId(source.id ?? base.id) || foundry.utils.randomID();
  const publishedAtRaw = Number(source.publishedAt ?? base.publishedAt ?? 0);
  const publishedAt = Number.isFinite(publishedAtRaw) && publishedAtRaw > 0 ? publishedAtRaw : 0;
  const archivedAtRaw = Number(source.archivedAt ?? base.archivedAt ?? 0);
  const archivedAt = Number.isFinite(archivedAtRaw) && archivedAtRaw > 0 ? archivedAtRaw : 0;
  const statusRaw = String(source.status ?? base.status ?? "").trim().toLowerCase();
  const status = (statusRaw === "archived" || archivedAt > 0) ? "archived" : "open";
  const publishedBy = String(source.publishedBy ?? base.publishedBy ?? "").trim();
  const archivedBy = String(source.archivedBy ?? base.archivedBy ?? "").trim();
  const currency = normalizeLootClaimCurrencyRecord(source.currency, base.currency);
  const currencyRemaining = normalizeLootClaimCurrencyRecord(source.currencyRemaining, currency);
  const currencyClaimedActorIds = normalizeLootClaimActorIdList(source.currencyClaimedActorIds ?? base.currencyClaimedActorIds);
  const items = normalizeLootClaimItemsList(source.items ?? base.items);
  const tableRolls = normalizeLootClaimTableRolls(source.tableRolls ?? base.tableRolls);
  const claimsLog = normalizeLootClaimLogEntries(source.claimsLog ?? base.claimsLog);
  return {
    id,
    status,
    publishedAt,
    publishedBy,
    archivedAt: status === "archived" ? archivedAt : 0,
    archivedBy: status === "archived" ? archivedBy : "",
    currency,
    currencyRemaining,
    currencyClaimedActorIds,
    items,
    tableRolls,
    claimsLog
  };
}

function lootClaimBoardHasData(board = {}) {
  if (!board || typeof board !== "object") return false;
  const publishedAt = Math.max(0, Number(board.publishedAt ?? 0) || 0);
  const itemCount = Array.isArray(board.items) ? board.items.length : 0;
  const tableRollCount = Array.isArray(board.tableRolls) ? board.tableRolls.length : 0;
  const claimCount = Array.isArray(board.claimsLog) ? board.claimsLog.length : 0;
  const currencySource = board.currencyRemaining ?? board.currency ?? {};
  const hasCurrency = ["pp", "gp", "sp", "cp"].some((denom) => Math.max(0, Math.floor(Number(currencySource?.[denom] ?? 0) || 0)) > 0);
  return publishedAt > 0 || itemCount > 0 || tableRollCount > 0 || claimCount > 0 || hasCurrency;
}

function ensureLootClaimsState(ledger) {
  if (!ledger.lootClaims || typeof ledger.lootClaims !== "object") {
    ledger.lootClaims = {};
  }
  const claims = ledger.lootClaims;
  if (!Array.isArray(claims.boards)) claims.boards = [];

  if (claims.boards.length === 0) {
    const legacyBoard = normalizeLootClaimBoardRecord({
      id: normalizeLootClaimRunId(claims.activeBoardId) || foundry.utils.randomID(),
      status: "open",
      publishedAt: claims.publishedAt,
      publishedBy: claims.publishedBy,
      currency: claims.currency,
      currencyRemaining: claims.currencyRemaining,
      currencyClaimedActorIds: claims.currencyClaimedActorIds,
      items: claims.items,
      tableRolls: claims.tableRolls,
      claimsLog: claims.claimsLog
    });
    if (lootClaimBoardHasData(legacyBoard)) claims.boards = [legacyBoard];
  }

  const seenBoardIds = new Set();
  claims.boards = claims.boards
    .map((entry) => normalizeLootClaimBoardRecord(entry))
    .filter((entry) => {
      if (!entry.id) return false;
      if (seenBoardIds.has(entry.id)) return false;
      seenBoardIds.add(entry.id);
      return lootClaimBoardHasData(entry);
    })
    .sort((left, right) => {
      const leftRank = left.status === "archived" ? 1 : 0;
      const rightRank = right.status === "archived" ? 1 : 0;
      if (leftRank !== rightRank) return leftRank - rightRank;
      const leftSortTs = left.status === "archived"
        ? Math.max(Number(left.archivedAt ?? 0), Number(left.publishedAt ?? 0))
        : Number(left.publishedAt ?? 0);
      const rightSortTs = right.status === "archived"
        ? Math.max(Number(right.archivedAt ?? 0), Number(right.publishedAt ?? 0))
        : Number(right.publishedAt ?? 0);
      return rightSortTs - leftSortTs;
    });

  const openBoardIds = new Set(
    claims.boards
      .filter((entry) => String(entry?.status ?? "open") !== "archived")
      .map((entry) => String(entry?.id ?? ""))
      .filter(Boolean)
  );
  const requestedActiveBoardId = normalizeLootClaimRunId(claims.activeBoardId);
  const activeBoardId = openBoardIds.has(requestedActiveBoardId)
    ? requestedActiveBoardId
    : (claims.boards.find((entry) => String(entry?.status ?? "open") !== "archived")?.id ?? "");
  claims.activeBoardId = normalizeLootClaimRunId(activeBoardId);

  const activeBoard = claims.boards.find((entry) => String(entry?.id ?? "") === claims.activeBoardId)
    ?? claims.boards[0]
    ?? null;

  if (activeBoard) {
    claims.publishedAt = Math.max(0, Number(activeBoard.publishedAt ?? 0) || 0);
    claims.publishedBy = String(activeBoard.publishedBy ?? "").trim();
    claims.currency = foundry.utils.deepClone(activeBoard.currency ?? { pp: 0, gp: 0, sp: 0, cp: 0, gpEquivalent: 0 });
    claims.currencyRemaining = foundry.utils.deepClone(activeBoard.currencyRemaining ?? claims.currency);
    claims.currencyClaimedActorIds = normalizeLootClaimActorIdList(activeBoard.currencyClaimedActorIds);
    claims.items = normalizeLootClaimItemsList(activeBoard.items);
    claims.tableRolls = normalizeLootClaimTableRolls(activeBoard.tableRolls);
    claims.claimsLog = normalizeLootClaimLogEntries(activeBoard.claimsLog);
  } else {
    claims.publishedAt = 0;
    claims.publishedBy = "";
    claims.currency = { pp: 0, gp: 0, sp: 0, cp: 0, gpEquivalent: 0 };
    claims.currencyRemaining = { pp: 0, gp: 0, sp: 0, cp: 0, gpEquivalent: 0 };
    claims.currencyClaimedActorIds = [];
    claims.items = [];
    claims.tableRolls = [];
    claims.claimsLog = [];
  }
  return claims;
}

function getDowntimeSelectableActorsForUser(user = game.user) {
  if (!user) return [];
  const unique = new Map();
  const addActor = (actor) => {
    if (!actor || actor.type !== "character" || !actor.id) return;
    if (!canUserManageDowntimeActor(user, actor)) return;
    unique.set(String(actor.id), actor);
  };

  if (canAccessAllPlayerOps(user)) {
    for (const actor of getOwnedPcActors()) addActor(actor);
  } else {
    for (const actor of getOwnedPcActors()) addActor(actor);
    if (unique.size === 0) {
      for (const actor of game.actors.contents) addActor(actor);
    }
    if (user.character && user.character.type === "character") addActor(user.character);
  }

  return Array.from(unique.values()).sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""));
}

function canUserManageDowntimeActor(user, actor) {
  if (!user || !actor) return false;
  if (canAccessAllPlayerOps(user)) return true;
  if (actor.type !== "character") return false;
  try {
    if (typeof actor.testUserPermission === "function") {
      return Boolean(
        actor.testUserPermission(user, "OWNER")
        || actor.testUserPermission(user, "OBSERVER")
      );
    }
  } catch {
    // Fall through to conservative rejection.
  }
  return false;
}

function getDowntimeResolutionBase(entry = {}, downtimeState = {}) {
  const actionDef = getDowntimeActionDefinition(entry?.actionKey);
  const hoursGranted = Math.max(1, Math.min(24, Math.floor(Number(downtimeState?.hoursGranted ?? 4) || 4)));
  const hours = Math.max(1, Math.min(hoursGranted, Math.floor(Number(entry?.hours ?? hoursGranted) || hoursGranted)));
  const blocks = Math.max(1, Math.ceil(hours / 4));
  const tuning = downtimeState?.tuning ?? {};
  const economy = String(tuning.economy ?? "standard");
  const discovery = String(tuning.discovery ?? "standard");
  const economyMultiplier = economy === "stingy" ? 0.8 : economy === "generous" ? 1.3 : 1;
  const discoveryBonus = discovery === "low" ? 0 : discovery === "high" ? 1 : 0;

  let gpAward = 0;
  let gpCost = 0;
  let rumorCount = 0;
  let itemRewards = [];
  let itemRewardDrops = [];
  let summary = `${actionDef.label} resolved.`;
  let hint = DOWNTIME_RESOLVE_DEFAULT_HINT;
  let socialContract = normalizeDowntimeSocialContract({}, actionDef.key);

  switch (actionDef.key) {
    case "carousing": {
      const socialSpend = Math.max(2, Math.round((5 * blocks) * economyMultiplier));
      rumorCount = Math.max(1, blocks + discoveryBonus);
      gpAward = Math.max(0, Math.floor(blocks * economyMultiplier));
      gpCost = socialSpend;
      summary = `Carousing established ${rumorCount} rumor/contact lead(s).`;
      hint = "Carousing can establish a social contract connection. Choose the contract type and confirm costs.";
      socialContract = normalizeDowntimeSocialContract({ key: "potion-broker" }, actionDef.key);
      break;
    }
    case "crafting":
      itemRewards = ["Crafting materials package"];
      itemRewardDrops = [];
      gpAward = Math.max(0, Math.floor((2 * blocks) * economyMultiplier));
      summary = "Crafting yielded usable materials or a completed mundane item.";
      hint = "Crafting defaults to item/material rewards plus optional reimbursement. Drag dropped crafting items are granted directly on collect.";
      break;
    case "profession":
      gpAward = Math.max(1, Math.floor((3 * blocks) * economyMultiplier));
      summary = `Professional work earned ${gpAward} gp.`;
      hint = "Profession defaults to direct coin payout.";
      break;
    case "recuperating":
      summary = "Recuperation granted recovery progress and treatment stabilization.";
      hint = "Recuperating usually grants notes/progress; coin and items are optional.";
      break;
    case "research":
      rumorCount = Math.max(1, blocks + discoveryBonus);
      summary = `Research uncovered ${rumorCount} actionable lead(s).`;
      hint = "Research defaults to rumors/leads and reference notes.";
      break;
    case "training":
      itemRewards = ["Training milestone credit"];
      summary = `Training logged ${hours} hour(s) of progress.`;
      hint = "Training defaults to milestone notes and optional certification reward.";
      break;
    default:
      summary = `${actionDef.label} resolved for ${hours} hour(s).`;
      hint = "Set any payout and notes, then resolve.";
      break;
  }

  return {
    actionKey: actionDef.key,
    actionLabel: actionDef.label,
    gpAward: Math.max(0, Math.floor(gpAward)),
    gpCost: Math.max(0, Math.floor(gpCost)),
    rumorCount: Math.max(0, Math.floor(rumorCount)),
    itemRewards,
    itemRewardDrops,
    itemRewardsText: itemRewards.join("\n"),
    summary,
    gmNotes: "",
    socialContract,
    hint
  };
}

function buildDowntimeContext(downtimeState = {}, options = {}) {
  const user = options.user ?? game.user;
  const isGMUser = Boolean(user?.isGM);
  const entriesSort = normalizeDowntimeEntriesSort(options?.entriesSort);
  const logsSort = normalizeDowntimeLogsSort(options?.logsSort);
  const hoursGranted = Math.max(1, Math.min(24, Math.floor(Number(downtimeState?.hoursGranted ?? 4) || 4)));
  const tuning = downtimeState?.tuning ?? {};
  const economy = String(tuning.economy ?? "standard");
  const risk = String(tuning.risk ?? "standard");
  const discovery = String(tuning.discovery ?? "standard");
  const selectableActors = getDowntimeSelectableActorsForUser(user);
  const activeActorId = String(getActiveActorForUser()?.id ?? "").trim();
  const defaultActorId = selectableActors.some((actor) => String(actor.id) === activeActorId)
    ? activeActorId
    : String(selectableActors[0]?.id ?? "");
  const actorOptions = [
    { id: "", name: "Select actor", selected: !defaultActorId },
    ...selectableActors.map((actor) => ({
      id: actor.id,
      name: actor.name,
      selected: String(actor.id) === defaultActorId
    }))
  ];

  const actorEntries = Object.values(downtimeState?.entries ?? {}).map((entry) => {
    const actor = game.actors.get(String(entry?.actorId ?? "").trim());
    const actionDef = getDowntimeActionDefinition(entry?.actionKey);
    const updatedAtRawValue = Number(entry?.updatedAt ?? 0);
    const updatedAtRaw = Number.isFinite(updatedAtRawValue) ? updatedAtRawValue : 0;
    const updatedAtDate = updatedAtRaw > 0 ? new Date(updatedAtRaw) : null;
    const updatedAtLabel = updatedAtDate && Number.isFinite(updatedAtDate.getTime()) ? updatedAtDate.toLocaleString() : "Not set";
    const result = entry?.lastResult ? normalizeDowntimeResult(entry.lastResult) : null;
    const stagedResult = entry?.pending !== false && entry?.stagedResult ? normalizeDowntimeResult(entry.stagedResult) : null;
    const stagedAtValue = Number(entry?.stagedAt ?? stagedResult?.resolvedAt ?? 0);
    const stagedAtLabel = stagedAtValue > 0 ? new Date(stagedAtValue).toLocaleString() : "";
    const hasPreResolved = Boolean(stagedResult);
    const gpAward = Math.max(0, Number(result?.gpAward ?? 0) || 0);
    const gpCost = Math.max(0, Number(result?.gpCost ?? 0) || 0);
    const gpDelta = Number(result?.gpDelta ?? (gpAward - gpCost) ?? 0);
    const rumorCount = Math.max(0, Number(result?.rumorCount ?? 0) || 0);
    const itemRewards = Array.isArray(result?.itemRewards) ? result.itemRewards : [];
    const itemRewardDrops = normalizeDowntimeItemRewardDrops(result?.itemRewardDrops ?? []);
    const gmNotes = String(result?.gmNotes ?? "");
    const socialContract = normalizeDowntimeSocialContract(result?.socialContract ?? {}, actionDef.key);
    const isCollected = result?.collected === true;
    const collectedAt = Number(result?.collectedAt ?? 0);
    const collectedAtLabel = collectedAt > 0 ? new Date(collectedAt).toLocaleString() : "";
    const canCollect = Boolean(result)
      && result.hasClaimableRewards === true
      && !isCollected
      && canUserManageDowntimeActor(user, actor);
    const rewardParts = [];
    if (gpAward > 0) rewardParts.push(`+${gpAward} gp`);
    if (gpCost > 0) rewardParts.push(`-${gpCost} gp cost`);
    if (rumorCount > 0) rewardParts.push(`${rumorCount} rumor/lead`);
    if (itemRewards.length > 0) rewardParts.push(`${itemRewards.length} item reward(s)`);
    if (itemRewardDrops.length > 0) rewardParts.push(`${itemRewardDrops.length} crafted item drop(s)`);
    if (socialContract.hasContract) rewardParts.push(`Connection: ${socialContract.label}`);
    if (gmNotes.trim().length > 0) rewardParts.push("GM notes");
    return {
      actorId: String(entry?.actorId ?? "").trim(),
      actorName: String(entry?.actorName ?? actor?.name ?? "Unknown Actor").trim() || "Unknown Actor",
      actionKey: actionDef.key,
      actionLabel: actionDef.label,
      actionGuidance: actionDef.guidance,
      hours: Math.max(1, Math.min(hoursGranted, Math.floor(Number(entry?.hours ?? hoursGranted) || hoursGranted))),
      note: String(entry?.note ?? ""),
      hasNote: String(entry?.note ?? "").trim().length > 0,
      pending: entry?.pending !== false,
      statusLabel: entry?.pending !== false
        ? (isGMUser && hasPreResolved ? "Pre-Resolved (GM Draft)" : "Pending Resolution")
        : "Resolved",
      updatedAtValue: updatedAtRaw,
      updatedAtLabel,
      updatedBy: String(entry?.updatedBy ?? "Player"),
      canClear: canUserManageDowntimeActor(user, actor),
      hasResult: Boolean(result),
      resultSummary: String(result?.summary ?? ""),
      resultDetails: Array.isArray(result?.details) ? result.details : [],
      hasResultDetails: Array.isArray(result?.details) && result.details.length > 0,
      rollTotal: Number(result?.rollTotal ?? 0),
      resolvedAtValue: Number.isFinite(Number(result?.resolvedAt ?? 0))
        ? Number(result?.resolvedAt ?? 0)
        : 0,
      gpAward,
      gpCost,
      gpDelta,
      gpAwardLabel: `+${Math.floor(gpAward)}`,
      gpCostLabel: `-${Math.floor(gpCost)}`,
      gpDeltaLabel: gpDelta > 0 ? `+${gpDelta}` : String(gpDelta),
      progress: Math.max(0, Number(result?.progress ?? 0) || 0),
      hasComplication: String(result?.complication ?? "").trim().length > 0,
      complication: String(result?.complication ?? ""),
      resolvedAtLabel: result?.resolvedAt ? new Date(Number(result.resolvedAt)).toLocaleString() : "",
      resolvedBy: String(result?.resolvedBy ?? ""),
      rumorCount,
      hasRumorCount: rumorCount > 0,
      itemRewards,
      hasItemRewards: itemRewards.length > 0,
      itemRewardDrops,
      hasItemRewardDrops: itemRewardDrops.length > 0,
      gmNotes,
      hasGmNotes: gmNotes.trim().length > 0,
      socialContract,
      hasSocialContract: socialContract.hasContract,
      socialContractLabel: socialContract.label,
      socialContractSummary: socialContract.summary,
      socialContractLimitations: socialContract.limitations,
      socialContractNotes: socialContract.notes,
      hasSocialContractNotes: socialContract.notes.length > 0,
      isCollected,
      canCollect,
      hasClaimableRewards: Boolean(result?.hasClaimableRewards),
      rewardSummary: rewardParts.length > 0 ? rewardParts.join(" | ") : "No claimable rewards",
      collectedAtLabel,
      collectedBy: String(result?.collectedBy ?? ""),
      hasPreResolved: isGMUser && hasPreResolved,
      preResolvedAtLabel: isGMUser && hasPreResolved ? stagedAtLabel : "",
      preResolvedBy: isGMUser && hasPreResolved ? String(entry?.stagedBy ?? "GM") : ""
    };
  });

  const compareActorNameAsc = (a, b) => a.actorName.localeCompare(b.actorName);
  const compareActorNameDesc = (a, b) => b.actorName.localeCompare(a.actorName);
  const compareUpdatedDesc = (a, b) => {
    const diff = Number(b.updatedAtValue ?? 0) - Number(a.updatedAtValue ?? 0);
    if (diff !== 0) return diff;
    return compareActorNameAsc(a, b);
  };
  const compareUpdatedAsc = (a, b) => {
    const diff = Number(a.updatedAtValue ?? 0) - Number(b.updatedAtValue ?? 0);
    if (diff !== 0) return diff;
    return compareActorNameAsc(a, b);
  };
  actorEntries.sort((a, b) => {
    if (entriesSort === "completed") {
      if (a.pending !== b.pending) return a.pending ? 1 : -1;
      return compareActorNameAsc(a, b);
    }
    if (entriesSort === "actor-asc") return compareActorNameAsc(a, b);
    if (entriesSort === "actor-desc") return compareActorNameDesc(a, b);
    if (entriesSort === "updated-desc") return compareUpdatedDesc(a, b);
    if (entriesSort === "updated-asc") return compareUpdatedAsc(a, b);
    if (a.pending !== b.pending) return a.pending ? -1 : 1;
    return compareActorNameAsc(a, b);
  });

  const currentEntry = actorEntries.find((entry) => entry.actorId === defaultActorId) ?? null;
  const selectedActionKey = currentEntry?.actionKey ?? DOWNTIME_ACTION_OPTIONS[0]?.key ?? "carousing";
  const submitHours = Math.max(1, Math.min(hoursGranted, Math.floor(Number(currentEntry?.hours ?? hoursGranted) || hoursGranted)));
  const actionOptions = DOWNTIME_ACTION_OPTIONS.map((entry) => ({
    ...entry,
    selected: entry.key === selectedActionKey
  }));

  const logs = Array.isArray(downtimeState?.logs)
    ? downtimeState.logs
      .map((entry) => {
        const normalized = normalizeDowntimeResult(entry);
        const gpAward = Math.max(0, Number(normalized.gpAward ?? 0) || 0);
        const gpCost = Math.max(0, Number(normalized.gpCost ?? 0) || 0);
        const gpDelta = Number(normalized.gpDelta ?? (gpAward - gpCost) ?? 0);
        const resolvedAtRaw = Number(normalized.resolvedAt);
        const resolvedAtValue = Number.isFinite(resolvedAtRaw) ? resolvedAtRaw : 0;
        const resolvedAtDate = new Date(resolvedAtValue);
        const rumorCount = Math.max(0, Number(normalized.rumorCount ?? 0) || 0);
        const itemRewards = Array.isArray(normalized.itemRewards) ? normalized.itemRewards : [];
        const itemRewardDrops = normalizeDowntimeItemRewardDrops(normalized.itemRewardDrops ?? []);
        const gmNotes = String(normalized.gmNotes ?? "");
        const socialContract = normalizeDowntimeSocialContract(normalized.socialContract ?? {}, normalized.actionKey);
        const collectedAt = Number(normalized.collectedAt ?? 0);
        const rewardParts = [];
        if (gpAward > 0) rewardParts.push(`+${gpAward} gp`);
        if (gpCost > 0) rewardParts.push(`-${gpCost} gp cost`);
        if (rumorCount > 0) rewardParts.push(`${rumorCount} rumor/lead`);
        if (itemRewards.length > 0) rewardParts.push(`${itemRewards.length} item reward(s)`);
        if (itemRewardDrops.length > 0) rewardParts.push(`${itemRewardDrops.length} crafted item drop(s)`);
        if (socialContract.hasContract) rewardParts.push(`Connection: ${socialContract.label}`);
        if (gmNotes.trim().length > 0) rewardParts.push("GM notes");
        return {
          logId: String(normalized.id ?? "").trim() || foundry.utils.randomID(),
          actorId: String(entry?.actorId ?? "").trim(),
          actorName: String(entry?.actorName ?? "Unknown Actor").trim() || "Unknown Actor",
          actionLabel: normalized.actionLabel,
          hours: Math.max(1, Math.floor(Number(entry?.hours ?? 4) || 4)),
          summary: normalized.summary,
          details: Array.isArray(normalized.details) ? normalized.details : [],
          hasDetails: Array.isArray(normalized.details) && normalized.details.length > 0,
          resolvedAtValue,
          resolvedAtLabel: Number.isFinite(resolvedAtDate.getTime()) ? resolvedAtDate.toLocaleString() : "Unknown",
          resolvedBy: normalized.resolvedBy,
          gpAward,
          gpCost,
          gpDelta,
          gpAwardLabel: `+${Math.floor(gpAward)}`,
          gpCostLabel: `-${Math.floor(gpCost)}`,
          gpDeltaLabel: gpDelta > 0 ? `+${gpDelta}` : String(gpDelta),
          hasComplication: normalized.complication.length > 0,
          complication: normalized.complication,
          rumorCount,
          hasRumorCount: rumorCount > 0,
          itemRewards,
          hasItemRewards: itemRewards.length > 0,
          itemRewardDrops,
          hasItemRewardDrops: itemRewardDrops.length > 0,
          gmNotes,
          hasGmNotes: gmNotes.trim().length > 0,
          socialContract,
          hasSocialContract: socialContract.hasContract,
          socialContractLabel: socialContract.label,
          socialContractSummary: socialContract.summary,
          socialContractLimitations: socialContract.limitations,
          socialContractNotes: socialContract.notes,
          hasSocialContractNotes: socialContract.notes.length > 0,
          isCollected: normalized.collected === true,
          hasClaimableRewards: normalized.hasClaimableRewards === true,
          rewardSummary: rewardParts.length > 0 ? rewardParts.join(" | ") : "No claimable rewards",
          collectedAtLabel: collectedAt > 0 ? new Date(collectedAt).toLocaleString() : "",
          collectedBy: String(normalized.collectedBy ?? "")
        };
      })
    : [];

  const compareLogResolvedDesc = (a, b) => {
    const diff = Number(b.resolvedAtValue ?? 0) - Number(a.resolvedAtValue ?? 0);
    if (diff !== 0) return diff;
    return a.actorName.localeCompare(b.actorName);
  };
  const compareLogResolvedAsc = (a, b) => {
    const diff = Number(a.resolvedAtValue ?? 0) - Number(b.resolvedAtValue ?? 0);
    if (diff !== 0) return diff;
    return a.actorName.localeCompare(b.actorName);
  };
  logs.sort((a, b) => {
    if (logsSort === "resolved-asc") return compareLogResolvedAsc(a, b);
    if (logsSort === "actor-asc") return a.actorName.localeCompare(b.actorName);
    if (logsSort === "actor-desc") return b.actorName.localeCompare(a.actorName);
    if (logsSort === "action-asc") {
      const actionDiff = a.actionLabel.localeCompare(b.actionLabel);
      if (actionDiff !== 0) return actionDiff;
      return compareLogResolvedDesc(a, b);
    }
    return compareLogResolvedDesc(a, b);
  });
  if (logs.length > 20) logs.length = 20;

  const pendingEntries = actorEntries.filter((entry) => entry.pending);
  const pendingOptions = pendingEntries.map((entry, index) => {
    const fallback = getDowntimeResolutionBase(entry, downtimeState);
    const staged = downtimeState?.entries?.[entry.actorId]?.stagedResult
      ? normalizeDowntimeResult(downtimeState.entries[entry.actorId].stagedResult)
      : null;
    const stagedAtValue = Number(downtimeState?.entries?.[entry.actorId]?.stagedAt ?? staged?.resolvedAt ?? 0);
    const stagedBy = String(downtimeState?.entries?.[entry.actorId]?.stagedBy ?? "GM").trim() || "GM";
    const stagedLabel = stagedAtValue > 0 ? new Date(stagedAtValue).toLocaleString() : "just now";
    const base = staged
      ? {
          summary: String(staged.summary ?? fallback.summary),
          gpAward: Math.max(0, Math.floor(Number(staged.gpAward ?? Math.max(0, Number(staged.gpDelta ?? 0) || 0)) || 0)),
          gpCost: Math.max(0, Math.floor(Number(staged.gpCost ?? Math.max(0, -(Number(staged.gpDelta ?? 0) || 0))) || 0)),
          rumorCount: Math.max(0, Math.floor(Number(staged.rumorCount ?? 0) || 0)),
          itemRewardsText: Array.isArray(staged.itemRewards) ? staged.itemRewards.join("\n") : "",
          itemRewardDrops: normalizeDowntimeItemRewardDrops(staged.itemRewardDrops ?? fallback.itemRewardDrops ?? []),
          gmNotes: String(staged.gmNotes ?? ""),
          socialContract: normalizeDowntimeSocialContract(staged.socialContract ?? fallback.socialContract ?? {}, entry.actionKey),
          hint: `Pre-resolved roll ${Number(staged.rollTotal ?? 0)}. Edit rewards/notes, then Final Resolve to player inbox.`
        }
      : fallback;
    return {
      actorId: entry.actorId,
      actionKey: String(entry.actionKey ?? ""),
      label: `${entry.actorName} - ${entry.actionLabel} (${entry.hours}h)${staged ? " [Pre-Resolved]" : ""}`,
      selected: index === 0,
      isPreResolved: Boolean(staged),
      preResolvedLabel: staged ? `Pre-resolved ${stagedLabel} by ${stagedBy}.` : "",
      baseSummary: base.summary,
      baseGpAward: base.gpAward,
      baseGpCost: base.gpCost ?? 0,
      baseRumorCount: base.rumorCount,
      baseItemRewardsText: base.itemRewardsText,
      baseItemRewardDropsJson: serializeDowntimeItemRewardDrops(base.itemRewardDrops ?? []),
      baseNotes: base.gmNotes,
      baseSocialContractKey: String(base.socialContract?.key ?? ""),
      baseSocialContractNotes: String(base.socialContract?.notes ?? ""),
      baseHint: base.hint
    };
  });
  const selectedPending = pendingOptions.find((entry) => entry.selected) ?? null;
  const selectedPendingItemRewardDrops = parseDowntimeItemRewardDrops(String(selectedPending?.baseItemRewardDropsJson ?? "[]"));

  return {
    hoursGranted,
    tuning: {
      economy,
      risk,
      discovery,
      economyOptions: DOWNTIME_TUNING_ECONOMY_OPTIONS.map((entry) => ({
        ...entry,
        selected: entry.value === economy
      })),
      riskOptions: DOWNTIME_TUNING_RISK_OPTIONS.map((entry) => ({
        ...entry,
        selected: entry.value === risk
      })),
      discoveryOptions: DOWNTIME_TUNING_DISCOVERY_OPTIONS.map((entry) => ({
        ...entry,
        selected: entry.value === discovery
      }))
    },
    submit: {
      actorOptions,
      actionOptions,
      hours: submitHours,
      note: currentEntry?.note ?? ""
    },
    entriesSort,
    entriesSortOptions: DOWNTIME_ENTRY_SORT_OPTIONS.map((entry) => ({
      ...entry,
      selected: entry.value === entriesSort
    })),
    entries: actorEntries,
    hasEntries: actorEntries.length > 0,
    pendingCount: actorEntries.filter((entry) => entry.pending).length,
    resolvedCount: actorEntries.filter((entry) => entry.hasResult).length,
    logsSort,
    logsSortOptions: DOWNTIME_LOG_SORT_OPTIONS.map((entry) => ({
      ...entry,
      selected: entry.value === logsSort
    })),
    logs,
    logCount: logs.length,
    hasLogs: logs.length > 0,
    gmResolve: {
      hasPending: pendingOptions.length > 0,
      pendingOptions,
      selectedActorId: String(selectedPending?.actorId ?? ""),
      selectedIsPreResolved: selectedPending?.isPreResolved === true,
      selectedPreResolvedLabel: String(selectedPending?.preResolvedLabel ?? ""),
      summary: String(selectedPending?.baseSummary ?? ""),
      gpAward: Number(selectedPending?.baseGpAward ?? 0),
      gpCost: Number(selectedPending?.baseGpCost ?? 0),
      rumorCount: Number(selectedPending?.baseRumorCount ?? 0),
      itemRewardsText: String(selectedPending?.baseItemRewardsText ?? ""),
      itemRewardDrops: selectedPendingItemRewardDrops,
      hasItemRewardDrops: selectedPendingItemRewardDrops.length > 0,
      itemRewardDropsJson: String(selectedPending?.baseItemRewardDropsJson ?? "[]"),
      gmNotes: String(selectedPending?.baseNotes ?? ""),
      socialContractKey: String(selectedPending?.baseSocialContractKey ?? ""),
      socialContractNotes: String(selectedPending?.baseSocialContractNotes ?? ""),
      socialContractOptions: buildDowntimeSocialContractOptions(String(selectedPending?.baseSocialContractKey ?? "")),
      hint: String(selectedPending?.baseHint ?? DOWNTIME_RESOLVE_DEFAULT_HINT)
    }
  };
}

function getRandomDowntimeComplication(actionKey = "") {
  const catalog = {
    carousing: [
      "A rival social contact starts spreading false rumors.",
      "A favor is now owed to a dangerous patron.",
      "A local authority notices the character's spending and asks questions."
    ],
    crafting: [
      "Critical materials are delayed by a supplier dispute.",
      "A flaw forces rework and wastes part of the effort.",
      "A competitor undercuts the project and drives up costs."
    ],
    profession: [
      "Unexpected fees or guild dues reduce net earnings.",
      "A difficult client disputes payment terms.",
      "Work demand drops suddenly for this cycle."
    ],
    recuperating: [
      "Recovery is interrupted by stress, weather, or poor shelter.",
      "Treatment supplies are consumed faster than expected.",
      "A follow-up check or specialist consultation is required."
    ],
    research: [
      "A key source is missing, damaged, or intentionally altered.",
      "Conflicting accounts produce misleading conclusions.",
      "A relevant authority restricts access to records."
    ],
    training: [
      "Instruction quality drops and progress slows this block.",
      "An interruption forces missed practice sessions.",
      "Additional equipment or tutoring costs are required."
    ]
  };
  const list = Array.isArray(catalog[actionKey]) ? catalog[actionKey] : [];
  if (list.length === 0) return "";
  return String(list[Math.floor(Math.random() * list.length)] ?? "").trim();
}

async function generateDowntimeResult(entry, downtimeState) {
  const actionDef = getDowntimeActionDefinition(entry?.actionKey);
  const hoursGranted = Math.max(1, Math.min(24, Math.floor(Number(downtimeState?.hoursGranted ?? 4) || 4)));
  const hours = Math.max(1, Math.min(hoursGranted, Math.floor(Number(entry?.hours ?? hoursGranted) || hoursGranted)));
  const blocks = Math.max(1, Math.ceil(hours / 4));
  const tuning = downtimeState?.tuning ?? {};
  const economy = String(tuning.economy ?? "standard");
  const risk = String(tuning.risk ?? "standard");
  const discovery = String(tuning.discovery ?? "standard");

  const economyMultiplier = economy === "stingy" ? 0.8 : economy === "generous" ? 1.3 : 1;
  const discoveryBonus = discovery === "low" ? 0 : discovery === "high" ? 2 : 1;
  const riskComplicationChance = risk === "safe" ? 0.1 : risk === "hazardous" ? 0.38 : 0.22;

  const roll = await (new Roll("1d20")).evaluate();
  const rollTotal = Math.max(1, Math.floor(Number(roll?.total ?? 1) || 1));
  let gpDelta = 0;
  let progress = 0;
  let summary = "";
  const details = [];

  switch (actionDef.key) {
    case "carousing": {
      progress = Math.max(0, Math.min(3, Math.floor((rollTotal + discoveryBonus - 4) / 6)));
      const spend = Math.max(2, Math.round((5 * blocks) * economyMultiplier));
      gpDelta = -spend;
      summary = progress > 0
        ? `Built ${progress} social contact(s) while carousing.`
        : "No lasting contact was secured while carousing.";
      details.push(`Spent ${spend} gp on social costs and favors.`);
      break;
    }
    case "crafting": {
      progress = Math.max(1, Math.round((2 * blocks) + Math.floor((rollTotal + discoveryBonus) / 10)));
      const cost = Math.max(1, Math.round(progress * (economy === "stingy" ? 2 : economy === "generous" ? 1 : 1.5)));
      gpDelta = -cost;
      summary = `Made ${progress} crafting progress point(s).`;
      details.push(`Materials consumed: ${cost} gp.`);
      break;
    }
    case "profession": {
      const lifestyleTier = rollTotal >= 16 ? 2 : rollTotal >= 11 ? 1 : 0;
      const wageBase = lifestyleTier === 2 ? 2 : lifestyleTier === 1 ? 1 : 0;
      const wage = Math.max(0, Math.round((wageBase * blocks) * economyMultiplier));
      gpDelta = wage;
      progress = Math.max(1, blocks);
      summary = wage > 0
        ? `Earned ${wage} gp through professional work.`
        : "Covered basic living expenses but earned no spare coin.";
      break;
    }
    case "recuperating": {
      const recoveryScore = rollTotal + (risk === "safe" ? 2 : risk === "hazardous" ? -2 : 0);
      progress = recoveryScore >= 18 ? 3 : recoveryScore >= 13 ? 2 : recoveryScore >= 8 ? 1 : 0;
      summary = progress >= 3
        ? "Exceptional recovery progress."
        : progress === 2
          ? "Solid recovery progress."
          : progress === 1
            ? "Minor recovery progress."
            : "No meaningful recovery progress this cycle.";
      details.push(`Recovery score ${recoveryScore} (${rollTotal} on d20).`);
      break;
    }
    case "research": {
      progress = Math.max(0, Math.floor((rollTotal + (discoveryBonus * 2) - 6) / 7));
      summary = progress > 0
        ? `Uncovered ${progress} research lead(s).`
        : "No actionable lead was uncovered this cycle.";
      details.push("Cross-reference discovered leads with faction, map, and journal notes.");
      break;
    }
    case "training": {
      progress = Math.max(1, Math.floor(hours / 2));
      summary = `Logged ${hours} hour(s) of structured training (${progress} progress).`;
      details.push("Apply progress toward language/tool proficiency milestones.");
      break;
    }
    default: {
      progress = Math.max(1, blocks);
      summary = `${actionDef.label} advanced by ${progress} progress point(s).`;
      break;
    }
  }

  const adjustedComplicationChance = Math.max(0, Math.min(0.9, riskComplicationChance + (rollTotal <= 6 ? 0.1 : 0) - (rollTotal >= 18 ? 0.08 : 0)));
  const complication = Math.random() < adjustedComplicationChance
    ? getRandomDowntimeComplication(actionDef.key)
    : "";
  if (complication) details.push(`Complication: ${complication}`);

  return normalizeDowntimeResult({
    id: foundry.utils.randomID(),
    actionKey: actionDef.key,
    actionLabel: actionDef.label,
    rollTotal,
    summary,
    details,
    gpDelta,
    progress,
    complication,
    resolvedAt: Date.now(),
    resolvedBy: String(game.user?.name ?? "GM")
  });
}

function ensureReconState(ledger) {
  if (!ledger.recon || typeof ledger.recon !== "object") {
    ledger.recon = {};
  }
  const recon = ledger.recon;
  const toText = (value) => String(value ?? "");
  recon.objective = toText(recon.objective);
  recon.region = toText(recon.region);
  recon.intelSource = toText(recon.intelSource);
  recon.recentFindings = toText(recon.recentFindings);
  recon.lastBriefAt = toText(recon.lastBriefAt || "-");
  recon.lastBriefBy = toText(recon.lastBriefBy || "-");

  const heat = String(recon.heatLevel ?? "moderate").trim().toLowerCase();
  recon.heatLevel = ["low", "moderate", "high"].includes(heat) ? heat : "moderate";

  const network = String(recon.network ?? "limited").trim().toLowerCase();
  recon.network = ["limited", "established", "deep"].includes(network) ? network : "limited";

  const reliability = Number(recon.rumorReliability ?? 50);
  recon.rumorReliability = Number.isFinite(reliability)
    ? Math.max(0, Math.min(100, Math.floor(reliability)))
    : 50;

  const bribeBudget = Number(recon.bribeBudget ?? 0);
  recon.bribeBudget = Number.isFinite(bribeBudget)
    ? Math.max(0, Math.floor(bribeBudget))
    : 0;

  const spySlots = Number(recon.spySlots ?? 0);
  recon.spySlots = Number.isFinite(spySlots)
    ? Math.max(0, Math.floor(spySlots))
    : 0;

  return recon;
}

function buildReconContext(reconState = {}) {
  const objective = String(reconState.objective ?? "").trim();
  const region = String(reconState.region ?? "").trim();
  const intelSource = String(reconState.intelSource ?? "").trim();
  const recentFindings = String(reconState.recentFindings ?? "").trim();
  const heatLevel = String(reconState.heatLevel ?? "moderate").trim().toLowerCase();
  const network = String(reconState.network ?? "limited").trim().toLowerCase();
  const rumorReliability = Math.max(0, Math.min(100, Math.floor(Number(reconState.rumorReliability ?? 50) || 0)));
  const bribeBudget = Math.max(0, Math.floor(Number(reconState.bribeBudget ?? 0) || 0));
  const spySlots = Math.max(0, Math.floor(Number(reconState.spySlots ?? 0) || 0));
  const intelCoverage = [objective, region, intelSource, recentFindings].filter((entry) => entry.length > 0).length;

  const heatPenalty = heatLevel === "high" ? 2 : heatLevel === "low" ? 0 : 1;
  const networkScore = network === "deep" ? 2 : network === "established" ? 1 : 0;
  const reliabilityScore = rumorReliability >= 70 ? 2 : rumorReliability >= 50 ? 1 : 0;
  const budgetScore = bribeBudget >= 100 ? 2 : bribeBudget >= 25 ? 1 : 0;
  const spyScore = spySlots >= 2 ? 2 : spySlots >= 1 ? 1 : 0;

  const readinessScore = intelCoverage + networkScore + reliabilityScore + budgetScore + spyScore - heatPenalty;
  const tier = readinessScore >= 6 ? "ready" : readinessScore >= 3 ? "contested" : "blind";
  const readinessLabel = tier === "ready" ? "Ready" : tier === "contested" ? "Contested" : "Blind";
  const suggestedDc = Math.max(
    8,
    Math.min(
      22,
      10
      + (heatLevel === "high" ? 4 : heatLevel === "moderate" ? 2 : 0)
      + (network === "limited" ? 2 : 0)
     - (network === "deep" ? 1 : 0)
     - (rumorReliability >= 70 ? 1 : 0)
    )
  );

  const recommendations = [];
  if (!objective) recommendations.push("Define a concrete mission objective before the next recon pass.");
  if (!region) recommendations.push("Set target region to tighten scouting scope.");
  if (rumorReliability < 50) recommendations.push("Corroborate rumor channels before acting on intel.");
  if (network === "limited") recommendations.push("Expand local network contacts to reduce blind approaches.");
  if (spySlots <= 0) recommendations.push("Allocate at least one spy slot for forward observation.");
  if (heatLevel === "high") recommendations.push("High heat: expect counter-surveillance and misinformation.");
  if (recommendations.length === 0) recommendations.push("Recon plan is stable. Maintain cadence and refresh leads after major events.");

  return {
    objective,
    region,
    intelSource,
    recentFindings,
    heatLevel,
    network,
    rumorReliability,
    bribeBudget,
    spySlots,
    intelCoverage,
    readinessScore,
    tier,
    readinessLabel,
    suggestedDc,
    recommendations,
    hasRecentFindings: recentFindings.length > 0,
    hasObjective: objective.length > 0,
    hasRegion: region.length > 0,
    hasIntelSource: intelSource.length > 0,
    lastBriefAt: String(reconState.lastBriefAt ?? "-"),
    lastBriefBy: String(reconState.lastBriefBy ?? "-"),
    heatOptions: [
      { value: "low", label: "Low", selected: heatLevel === "low" },
      { value: "moderate", label: "Moderate", selected: heatLevel === "moderate" },
      { value: "high", label: "High", selected: heatLevel === "high" }
    ],
    networkOptions: [
      { value: "limited", label: "Limited", selected: network === "limited" },
      { value: "established", label: "Established", selected: network === "established" },
      { value: "deep", label: "Deep", selected: network === "deep" }
    ]
  };
}

const WEATHER_PRESET_DEFINITIONS = [
  { id: "clear", label: "Clear", visibilityModifier: 0, darkness: 0.1, note: "Clear skies and stable visibility." },
  { id: "cloudy", label: "Cloudy", visibilityModifier: -1, darkness: 0.3, note: "Low cloud cover and muted light." },
  { id: "rainy", label: "Rainy", visibilityModifier: -1, darkness: 0.4, note: "Rain interferes with spotting and footing." },
  { id: "stormy", label: "Stormy", visibilityModifier: -3, darkness: 0.65, note: "Thunderstorm conditions reduce awareness." },
  { id: "snowy", label: "Snowy", visibilityModifier: -2, darkness: 0.45, note: "Snowfall obscures distance and tracks." },
  { id: "hail", label: "Hail", visibilityModifier: -2, darkness: 0.5, note: "Hail disrupts movement and ranged visibility." }
];

function normalizeWeatherDaeChange(entry = {}) {
  const rawMode = Math.floor(Number(entry?.mode ?? CONST.ACTIVE_EFFECT_MODES.ADD));
  const validModes = new Set(Object.values(CONST.ACTIVE_EFFECT_MODES ?? {}).map((value) => Number(value)));
  return {
    id: String(entry?.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID(),
    key: String(entry?.key ?? "").trim(),
    mode: validModes.has(rawMode) ? rawMode : Number(CONST.ACTIVE_EFFECT_MODES.ADD),
    value: String(entry?.value ?? "").trim(),
    label: String(entry?.label ?? "Weather Effect").trim() || "Weather Effect",
    note: String(entry?.note ?? "")
  };
}

function normalizeWeatherPreset(entry = {}, defaults = {}) {
  const daeChanges = Array.isArray(entry?.daeChanges)
    ? entry.daeChanges.map((change) => normalizeWeatherDaeChange(change)).filter((change) => change.key && change.value)
    : [];
  return {
    id: String(entry?.id ?? defaults?.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID(),
    label: String(entry?.label ?? defaults?.label ?? "Custom Weather").trim() || "Custom Weather",
    visibilityModifier: Number.isFinite(Number(entry?.visibilityModifier))
      ? Math.max(-5, Math.min(5, Math.floor(Number(entry.visibilityModifier))))
      : Math.max(-5, Math.min(5, Math.floor(Number(defaults?.visibilityModifier ?? 0)))),
    darkness: Number.isFinite(Number(entry?.darkness))
      ? Math.max(0, Math.min(1, Number(entry.darkness)))
      : Math.max(0, Math.min(1, Number(defaults?.darkness ?? 0))),
    note: String(entry?.note ?? defaults?.note ?? ""),
    isBuiltIn: Boolean(entry?.isBuiltIn ?? defaults?.isBuiltIn),
    daeChanges
  };
}

function getBuiltInWeatherPresets() {
  return WEATHER_PRESET_DEFINITIONS.map((entry) => normalizeWeatherPreset({
    ...entry,
    isBuiltIn: true,
    daeChanges: []
  }, entry));
}

function getWeatherPresetCatalog(weatherState = {}) {
  const builtIns = getBuiltInWeatherPresets();
  const customPresets = Array.isArray(weatherState?.customPresets)
    ? weatherState.customPresets
      .map((entry) => normalizeWeatherPreset(entry, { isBuiltIn: false }))
      .filter((entry) => !entry.isBuiltIn)
    : [];
  const seen = new Set();
  return [...builtIns, ...customPresets].filter((entry) => {
    const id = String(entry.id ?? "").trim().toLowerCase();
    if (!id || seen.has(id)) return false;
    seen.add(id);
    return true;
  });
}

function describeWeatherDaeChanges(changes = []) {
  const rows = Array.isArray(changes) ? changes : [];
  if (!rows.length) return "No additional global DAE changes.";
  return rows
    .map((entry) => `${entry.label || entry.key}: ${entry.value} (${getActiveEffectModeLabel(entry.mode)})`)
    .join("; ");
}

function ensureWeatherState(ledger) {
  if (!ledger.weather || typeof ledger.weather !== "object") {
    ledger.weather = { current: null, logs: [], customPresets: [] };
  }
  if (!Array.isArray(ledger.weather.customPresets)) ledger.weather.customPresets = [];
  ledger.weather.customPresets = ledger.weather.customPresets
    .map((entry) => normalizeWeatherPreset(entry, { isBuiltIn: false }))
    .filter((entry, index, arr) => {
      const id = String(entry.id ?? "").trim();
      if (!id || entry.isBuiltIn) return false;
      return arr.findIndex((candidate) => String(candidate.id ?? "").trim() === id) === index;
    });
  if (!Array.isArray(ledger.weather.logs)) ledger.weather.logs = [];
  ledger.weather.logs = ledger.weather.logs
    .map((entry) => ({
      id: String(entry?.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID(),
      label: String(entry?.label ?? "Unknown Weather").trim() || "Unknown Weather",
      weatherId: String(entry?.weatherId ?? "").trim(),
      darkness: Number.isFinite(Number(entry?.darkness)) ? Math.max(0, Math.min(1, Number(entry.darkness))) : 0,
      visibilityModifier: Number.isFinite(Number(entry?.visibilityModifier)) ? Math.max(-5, Math.min(5, Math.floor(Number(entry.visibilityModifier)))) : 0,
      note: String(entry?.note ?? ""),
      daeChanges: Array.isArray(entry?.daeChanges)
        ? entry.daeChanges.map((change) => normalizeWeatherDaeChange(change)).filter((change) => change.key && change.value)
        : [],
      loggedAt: Number.isFinite(Number(entry?.loggedAt)) ? Number(entry.loggedAt) : Date.now(),
      loggedBy: String(entry?.loggedBy ?? "GM")
    }))
    .filter((entry, index, arr) => entry.id && arr.findIndex((candidate) => candidate.id === entry.id) === index)
    .slice(0, 100);

  const current = ledger.weather.current;
  if (current && typeof current === "object") {
    ledger.weather.current = {
      id: String(current?.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID(),
      label: String(current?.label ?? "Unknown Weather").trim() || "Unknown Weather",
      weatherId: String(current?.weatherId ?? "").trim(),
      darkness: Number.isFinite(Number(current?.darkness)) ? Math.max(0, Math.min(1, Number(current.darkness))) : 0,
      visibilityModifier: Number.isFinite(Number(current?.visibilityModifier)) ? Math.max(-5, Math.min(5, Math.floor(Number(current.visibilityModifier)))) : 0,
      note: String(current?.note ?? ""),
      daeChanges: Array.isArray(current?.daeChanges)
        ? current.daeChanges.map((change) => normalizeWeatherDaeChange(change)).filter((change) => change.key && change.value)
        : [],
      loggedAt: Number.isFinite(Number(current?.loggedAt)) ? Number(current.loggedAt) : Date.now(),
      loggedBy: String(current?.loggedBy ?? "GM")
    };
  } else {
    ledger.weather.current = null;
  }

  return ledger.weather;
}

function computeWeatherVisibilityModifier({ label = "", weatherId = "", darkness = 0 } = {}) {
  const normalizedLabel = String(label ?? "").toLowerCase();
  const normalizedId = String(weatherId ?? "").toLowerCase();
  const normalizedDarkness = Number.isFinite(Number(darkness)) ? Math.max(0, Math.min(1, Number(darkness))) : 0;

  const text = `${normalizedLabel} ${normalizedId}`;
  let visibilityModifier = 0;
  if (!normalizedId || text.includes("clear") || text.includes("sun")) visibilityModifier += 0;
  if (text.includes("rain") || text.includes("wind") || text.includes("cloud")) visibilityModifier -= 1;
  if (text.includes("heavy") || text.includes("storm") || text.includes("fog") || text.includes("mist") || text.includes("blizzard") || text.includes("smoke") || text.includes("snow")) {
    visibilityModifier -= 2;
  }

  if (normalizedDarkness >= 0.75) visibilityModifier -= 2;
  else if (normalizedDarkness >= 0.4) visibilityModifier -= 1;
  else if (normalizedDarkness <= 0.15 && (!normalizedId || text.includes("clear"))) visibilityModifier += 1;

  return Math.max(-5, Math.min(5, Math.floor(visibilityModifier)));
}

function getWeatherEffectSummary(visibilityModifier) {
  const value = Math.max(-5, Math.min(5, Math.floor(Number(visibilityModifier) || 0)));
  if (value > 0) return `Perception checks gain +${value}.`;
  if (value < 0) return `Perception checks suffer ${value}.`;
  return "No perception modifier from weather.";
}

function buildWeatherSelectionCatalog(weatherState = {}, sceneSnapshot = null) {
  const sceneDarkness = Number.isFinite(Number(sceneSnapshot?.darkness))
    ? Math.max(0, Math.min(1, Number(sceneSnapshot.darkness)))
    : null;
  return getWeatherPresetCatalog(weatherState)
    .map((preset) => ({
      key: String(preset.id ?? "").trim(),
      label: String(preset.label ?? "Weather").trim() || "Weather",
      weatherId: String(preset.id ?? "").trim(),
      darkness: sceneDarkness ?? Math.max(0, Math.min(1, Number(preset.darkness ?? 0))),
      visibilityModifier: Math.max(-5, Math.min(5, Math.floor(Number(preset.visibilityModifier ?? 0) || 0))),
      note: String(preset.note ?? ""),
      daeChanges: Array.isArray(preset.daeChanges) ? preset.daeChanges : [],
      isBuiltIn: Boolean(preset.isBuiltIn)
    }))
    .filter((entry) => entry.key);
}

function resolveWeatherFxEffectIdForPreset(preset = {}) {
  const presetKey = String(preset?.key ?? preset?.weatherId ?? "").trim().toLowerCase();
  const presetLabel = String(preset?.label ?? "").trim().toLowerCase();
  if (!presetKey || presetKey.includes("clear") || presetLabel.includes("clear")) return "";

  const effects = Object.entries(CONFIG.weatherEffects ?? {})
    .map(([id, cfg]) => ({
      id: String(id ?? "").trim(),
      text: `${String(id ?? "")} ${String(cfg?.label ?? cfg?.name ?? "")}`.toLowerCase()
    }))
    .filter((entry) => entry.id);
  if (!effects.length) return "";

  const keywordMap = {
    rainy: ["rain", "drizzle", "shower"],
    stormy: ["storm", "thunder", "lightning", "tempest"],
    snowy: ["snow", "blizzard", "flurry"],
    cloudy: ["cloud", "overcast", "fog", "mist"],
    hail: ["hail", "sleet", "ice"]
  };
  const targetWords = keywordMap[presetKey]
    ?? keywordMap[String(presetLabel).split(" ")[0]]
    ?? Object.values(keywordMap).find((words) => words.some((word) => presetLabel.includes(word)))
    ?? [];
  if (!targetWords.length) return "";
  const match = effects.find((entry) => targetWords.some((word) => entry.text.includes(word)));
  return String(match?.id ?? "").trim();
}

async function applyWeatherSceneFxForPreset(preset = {}) {
  if (!canAccessAllPlayerOps()) return;
  const scene = game.scenes?.current;
  if (!scene) return;
  const presetKey = String(preset?.key ?? preset?.weatherId ?? "").trim().toLowerCase();
  const effectId = resolveWeatherFxEffectIdForPreset(preset);
  const nextWeatherId = (presetKey.includes("clear") || !effectId) ? "" : effectId;
  const currentWeatherId = String(scene.weather ?? "").trim();
  if (nextWeatherId === currentWeatherId) return;
  await scene.update({ weather: nextWeatherId });
}

function resolveCurrentSceneWeatherSnapshot() {
  const scene = game.scenes?.current;
  const rawId = String(scene?.weather ?? "").trim();
  const weatherId = rawId;
  const weatherCfg = weatherId ? CONFIG.weatherEffects?.[weatherId] : null;
  const label = String(weatherCfg?.label ?? weatherCfg?.name ?? (weatherId ? weatherId : "Clear")).trim() || "Clear";
  const darknessLevel = scene?.environment?.darknessLevel;
  const darkness = Number.isFinite(Number(darknessLevel)) ? Math.max(0, Math.min(1, Number(darknessLevel))) : 0;
  const visibilityModifier = computeWeatherVisibilityModifier({ label, weatherId, darkness });

  return {
    id: foundry.utils.randomID(),
    label,
    weatherId,
    darkness,
    visibilityModifier,
    note: `Scene weather${weatherId ? ` (${weatherId})` : ""} | darkness ${darkness.toFixed(2)}`,
    loggedAt: Date.now(),
    loggedBy: String(game.user?.name ?? "GM")
  };
}

function ensurePartyHealthState(ledger) {
  if (!ledger.partyHealth || typeof ledger.partyHealth !== "object") {
    ledger.partyHealth = {
      modifierEnabled: {},
      customModifiers: [],
      stagedModifierQueue: [],
      modifierAddLog: [],
      archivedSyncEffects: [],
      syncToSceneNonParty: true,
      nonPartySyncScope: NON_PARTY_SYNC_SCOPES.SCENE
    };
  }
  if (!ledger.partyHealth.modifierEnabled || typeof ledger.partyHealth.modifierEnabled !== "object") {
    ledger.partyHealth.modifierEnabled = {};
  }
  if (!Array.isArray(ledger.partyHealth.customModifiers)) ledger.partyHealth.customModifiers = [];
  if (!Array.isArray(ledger.partyHealth.stagedModifierQueue)) ledger.partyHealth.stagedModifierQueue = [];
  if (!Array.isArray(ledger.partyHealth.modifierAddLog)) ledger.partyHealth.modifierAddLog = [];
  if (!Array.isArray(ledger.partyHealth.archivedSyncEffects)) ledger.partyHealth.archivedSyncEffects = [];
  ledger.partyHealth.syncToSceneNonParty = ledger.partyHealth.syncToSceneNonParty !== false;
  ledger.partyHealth.nonPartySyncScope = getNonPartySyncScope(ledger.partyHealth.nonPartySyncScope);
  ledger.partyHealth.customModifiers = ledger.partyHealth.customModifiers
    .map((entry) => {
      const rawMode = Math.floor(Number(entry?.mode ?? CONST.ACTIVE_EFFECT_MODES.ADD));
      const validModes = new Set(Object.values(CONST.ACTIVE_EFFECT_MODES ?? {}).map((value) => Number(value)));
      return {
        id: String(entry?.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID(),
        label: String(entry?.label ?? "Custom Modifier").trim() || "Custom Modifier",
        key: String(entry?.key ?? "").trim(),
        mode: validModes.has(rawMode) ? rawMode : Number(CONST.ACTIVE_EFFECT_MODES.ADD),
        value: String(entry?.value ?? "").trim(),
        note: String(entry?.note ?? ""),
        enabled: entry?.enabled !== false
      };
    })
    .filter((entry, index, arr) => entry.id && arr.findIndex((candidate) => candidate.id === entry.id) === index);
  ledger.partyHealth.stagedModifierQueue = ledger.partyHealth.stagedModifierQueue
    .map((entry) => ({
      id: String(entry?.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID(),
      label: String(entry?.label ?? "Custom Modifier").trim() || "Custom Modifier",
      key: String(entry?.key ?? "").trim(),
      mode: Math.floor(Number(entry?.mode ?? CONST.ACTIVE_EFFECT_MODES.ADD)),
      value: String(entry?.value ?? "").trim(),
      note: String(entry?.note ?? ""),
      createdAt: Number(entry?.createdAt ?? Date.now()) || Date.now(),
      createdBy: String(entry?.createdBy ?? game.user?.name ?? "GM").trim() || "GM"
    }))
    .filter((entry, index, arr) => entry.key && entry.value && entry.id && arr.findIndex((candidate) => candidate.id === entry.id) === index)
    .sort((a, b) => Number(b.createdAt ?? 0) - Number(a.createdAt ?? 0))
    .slice(0, 24);
  ledger.partyHealth.modifierAddLog = ledger.partyHealth.modifierAddLog
    .map((entry) => ({
      id: String(entry?.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID(),
      customModifierId: String(entry?.customModifierId ?? "").trim(),
      origin: String(entry?.origin ?? "custom").trim() || "custom",
      label: String(entry?.label ?? "Custom Modifier").trim() || "Custom Modifier",
      key: String(entry?.key ?? "").trim(),
      mode: Math.floor(Number(entry?.mode ?? CONST.ACTIVE_EFFECT_MODES.ADD)),
      value: String(entry?.value ?? "").trim(),
      note: String(entry?.note ?? ""),
      createdAt: Number(entry?.createdAt ?? Date.now()) || Date.now(),
      createdBy: String(entry?.createdBy ?? game.user?.name ?? "GM").trim() || "GM"
    }))
    .filter((entry) => entry.key && entry.value)
    .sort((a, b) => Number(b.createdAt ?? 0) - Number(a.createdAt ?? 0))
    .slice(0, 12);
  ledger.partyHealth.archivedSyncEffects = ledger.partyHealth.archivedSyncEffects
    .map((entry) => {
      const effectData = entry?.effectData && typeof entry.effectData === "object"
        ? foundry.utils.deepClone(entry.effectData)
        : {};
      if (effectData && typeof effectData === "object" && Object.prototype.hasOwnProperty.call(effectData, "_id")) delete effectData._id;
      return {
        id: String(entry?.id ?? foundry.utils.randomID()).trim() || foundry.utils.randomID(),
        actorId: String(entry?.actorId ?? "").trim(),
        actorName: String(entry?.actorName ?? "Unknown Actor").trim() || "Unknown Actor",
        effectName: String(entry?.effectName ?? INTEGRATION_EFFECT_NAME).trim() || INTEGRATION_EFFECT_NAME,
        label: String(entry?.label ?? entry?.effectName ?? "Archived Sync Effect").trim() || "Archived Sync Effect",
        note: String(entry?.note ?? ""),
        archivedAt: Number.isFinite(Number(entry?.archivedAt)) ? Number(entry.archivedAt) : Date.now(),
        archivedBy: String(entry?.archivedBy ?? game.user?.name ?? "GM"),
        effectData
      };
    })
    .filter((entry, index, arr) => entry.id && arr.findIndex((candidate) => candidate.id === entry.id) === index);
  return ledger.partyHealth;
}

function logAddedPartyHealthModifier(partyHealth, payload = {}) {
  if (!partyHealth || typeof partyHealth !== "object") return;
  if (!Array.isArray(partyHealth.modifierAddLog)) partyHealth.modifierAddLog = [];
  partyHealth.modifierAddLog.unshift({
    id: foundry.utils.randomID(),
    customModifierId: String(payload.customModifierId ?? "").trim(),
    origin: String(payload.origin ?? "custom").trim() || "custom",
    label: String(payload.label ?? "Custom Modifier").trim() || "Custom Modifier",
    key: String(payload.key ?? "").trim(),
    mode: Math.floor(Number(payload.mode ?? CONST.ACTIVE_EFFECT_MODES.ADD)),
    value: String(payload.value ?? "").trim(),
    note: String(payload.note ?? ""),
    createdAt: Date.now(),
    createdBy: String(game.user?.name ?? "GM").trim() || "GM"
  });
  partyHealth.modifierAddLog = partyHealth.modifierAddLog.slice(0, 12);
}

function filterModifierPresetSelect(element, selectName) {
  const root = element?.closest(".po-op-role-row") ?? element?.closest(".po-party-health-manager") ?? element?.closest(".po-gm-section");
  if (!root) return;
  const select = root.querySelector(`select[name='${selectName}']`);
  if (!(select instanceof HTMLSelectElement)) return;
  const query = String(element?.value ?? "").trim().toLowerCase();
  const options = Array.from(select.options ?? []);
  for (const option of options) {
    const value = String(option?.value ?? "").trim();
    if (!value) {
      option.hidden = false;
      option.disabled = false;
      continue;
    }
    if (!query) {
      option.hidden = false;
      option.disabled = false;
      continue;
    }
    const label = String(option?.textContent ?? "").toLowerCase();
    const visible = label.includes(query) || value.toLowerCase().includes(query);
    option.hidden = !visible;
    option.disabled = !visible;
  }
  const selectedValue = String(select.value ?? "").trim();
  if (selectedValue) {
    const selectedOption = options.find((option) => String(option.value ?? "").trim() === selectedValue);
    if (selectedOption?.hidden || selectedOption?.disabled) select.value = "";
  }
}

function resetQuickModifierForm(root) {
  if (!root) return;
  const label = root.querySelector("input[name='quickGlobalModifierLabel']");
  const filter = root.querySelector("input[name='quickGlobalModifierKeyFilter']");
  const mode = root.querySelector("select[name='quickGlobalModifierMode']");
  const value = root.querySelector("input[name='quickGlobalModifierValue']");
  const note = root.querySelector("textarea[name='quickGlobalModifierNote']");
  const preset = root.querySelector("select[name='quickGlobalModifierKey']");
  if (label) label.value = "Custom Modifier";
  if (filter) filter.value = "";
  if (mode) mode.value = String(Number(CONST.ACTIVE_EFFECT_MODES.ADD));
  if (value) value.value = "1";
  if (note) note.value = "";
  if (preset) preset.value = "";
}

function resetCustomModifierForm(root) {
  if (!root) return;
  const label = root.querySelector("input[name='customModifierLabel']");
  const filter = root.querySelector("input[name='customModifierKeyFilter']");
  const mode = root.querySelector("select[name='customModifierMode']");
  const value = root.querySelector("input[name='customModifierValue']");
  const note = root.querySelector("textarea[name='customModifierNote']");
  const preset = root.querySelector("select[name='customModifierKeySelect']");
  if (label) label.value = "";
  if (filter) filter.value = "";
  if (mode) mode.value = String(Number(CONST.ACTIVE_EFFECT_MODES.ADD));
  if (value) value.value = "";
  if (note) note.value = "";
  if (preset) preset.value = "";
}

function ensureSopNotesState(ledger) {
  if (!ledger.sopNotes || typeof ledger.sopNotes !== "object") ledger.sopNotes = {};
  for (const key of SOP_KEYS) {
    if (typeof ledger.sopNotes[key] !== "string") ledger.sopNotes[key] = "";
  }
  return ledger.sopNotes;
}

async function setOperationalRole(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can assign operational roles.");
    return;
  }
  const roleKey = element?.dataset?.role;
  const actorId = element?.value ?? "";
  if (!roleKey) return;
  await updateOperationsLedger((ledger) => {
    if (!ledger.roles) ledger.roles = {};
    ledger.roles[roleKey] = actorId;
  });
}

async function clearOperationalRole(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can assign operational roles.");
    return;
  }
  const roleKey = element?.dataset?.role;
  if (!roleKey) return;
  await updateOperationsLedger((ledger) => {
    if (!ledger.roles) ledger.roles = {};
    ledger.roles[roleKey] = "";
  });
}

async function toggleOperationalSOP(element, options = {}) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update SOP status.");
    return;
  }
  const sopKey = element?.dataset?.sop;
  if (!sopKey || !SOP_KEYS.includes(String(sopKey))) return;
  await updateOperationsLedger((ledger) => {
    if (!ledger.sops) ledger.sops = {};
    ledger.sops[sopKey] = Boolean(element?.checked);
  }, options);
}

async function setOperationalResource(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can edit resources.");
    return;
  }
  const resourceKey = element?.dataset?.resource;
  if (!resourceKey) return;
  const upkeepNumericKeys = new Set([
    "partySize",
    "foodPerMember",
    "waterPerMember",
    "foodMultiplier",
    "waterMultiplier",
    "torchPerRest"
  ]);
  const stewardPoolKeys = new Set(STEWARD_POOL_KEYS);
  const legacyStewardByField = {
    partyFoodRations: "food",
    partyWaterRations: "water",
    torches: "torches"
  };

  await updateOperationsLedger((ledger) => {
    if (!ledger.resources) ledger.resources = {};
    ensureOperationalResourceConfig(ledger.resources);
    if (resourceKey === "encumbrance") {
      ledger.resources.encumbrance = element?.value ?? "light";
      return;
    }
    const itemLinkKeys = new Set(RESOURCE_TRACK_KEYS);
    if (resourceKey.startsWith("itemSelectionActor:")) {
      const selectionKey = resourceKey.split(":")[1] ?? "";
      if (!itemLinkKeys.has(selectionKey)) return;
      const actorId = String(element?.value ?? "");
      ledger.resources.itemSelections[selectionKey].actorId = actorId;
      if (!actorId) ledger.resources.itemSelections[selectionKey].itemId = "";
      else {
        const actor = game.actors.get(actorId);
        const itemId = ledger.resources.itemSelections[selectionKey].itemId;
        if (!itemId || !actor?.items?.get(itemId)) ledger.resources.itemSelections[selectionKey].itemId = "";
      }
      return;
    }
    if (resourceKey.startsWith("itemSelectionItem:")) {
      const selectionKey = resourceKey.split(":")[1] ?? "";
      if (!itemLinkKeys.has(selectionKey)) return;
      ledger.resources.itemSelections[selectionKey].itemId = String(element?.value ?? "");
      return;
    }
    if (resourceKey.startsWith("weatherMod:")) {
      const weatherKey = resourceKey.split(":")[1] ?? "";
      const validWeatherKeys = new Set(["clear", "light-rain", "heavy-rain", "wind", "fog", "extreme"]);
      if (!validWeatherKeys.has(weatherKey)) return;
      const raw = Number(element?.value ?? 0);
      const value = Number.isFinite(raw) ? Math.max(-10, Math.min(20, Math.floor(raw))) : 0;
      ledger.resources.gather.weatherMods[weatherKey] = value;
      return;
    }
    if (resourceKey.startsWith("stewardPoolMode:")) {
      const poolKey = String(resourceKey.split(":")[1] ?? "").trim();
      if (!stewardPoolKeys.has(poolKey)) return;
      const pool = getStewardPoolEntry(ledger.resources, poolKey);
      pool.mode = normalizeStewardPoolMode(element?.value);
      ledger.resources.stewardPools[poolKey] = pool;
      ensureStewardPoolsState(ledger.resources);
      return;
    }
    if (resourceKey.startsWith("stewardPoolAmount:")) {
      const poolKey = String(resourceKey.split(":")[1] ?? "").trim();
      if (!stewardPoolKeys.has(poolKey)) return;
      const raw = Number(element?.value ?? 0);
      const amount = Number.isFinite(raw) ? Math.max(0, Math.floor(raw)) : 0;
      const pool = getStewardPoolEntry(ledger.resources, poolKey);
      pool.amount = amount;
      if (pool.mode === STEWARD_POOL_MODES.NONE && amount > 0) pool.mode = STEWARD_POOL_MODES.FINITE;
      ledger.resources.stewardPools[poolKey] = pool;
      ensureStewardPoolsState(ledger.resources);
      return;
    }
    if (resourceKey.startsWith("stewardPoolSource:")) {
      const poolKey = String(resourceKey.split(":")[1] ?? "").trim();
      if (!stewardPoolKeys.has(poolKey)) return;
      const pool = getStewardPoolEntry(ledger.resources, poolKey);
      pool.source = String(element?.value ?? "").trim().slice(0, 180);
      ledger.resources.stewardPools[poolKey] = pool;
      ensureStewardPoolsState(ledger.resources);
      return;
    }
    if (upkeepNumericKeys.has(resourceKey)) {
      const raw = Number(element?.value ?? 0);
      const value = Number.isFinite(raw) ? Math.max(0, raw) : 0;
      ledger.resources.upkeep[resourceKey] = value;
      return;
    }
    if (Object.prototype.hasOwnProperty.call(legacyStewardByField, resourceKey)) {
      const raw = Number(element?.value ?? 0);
      const amount = Number.isFinite(raw) ? Math.max(0, Math.floor(raw)) : 0;
      const poolKey = legacyStewardByField[resourceKey];
      const pool = getStewardPoolEntry(ledger.resources, poolKey);
      pool.amount = amount;
      pool.mode = amount > 0 ? STEWARD_POOL_MODES.FINITE : STEWARD_POOL_MODES.NONE;
      ledger.resources.stewardPools[poolKey] = pool;
      ensureStewardPoolsState(ledger.resources);
      return;
    }
    const value = Number(element?.value ?? 0);
    ledger.resources[resourceKey] = Number.isFinite(value) ? Math.max(0, Math.floor(value)) : 0;
  });
}

function normalizeDowntimeSubmission(raw = {}, downtimeState = {}) {
  const hoursGranted = Math.max(1, Math.min(24, Math.floor(Number(downtimeState?.hoursGranted ?? 4) || 4)));
  const actorId = String(raw?.actorId ?? "").trim();
  const actionDef = getDowntimeActionDefinition(raw?.actionKey);
  const hoursRaw = Number(raw?.hours ?? hoursGranted);
  const hours = Number.isFinite(hoursRaw)
    ? Math.max(1, Math.min(hoursGranted, Math.floor(hoursRaw)))
    : hoursGranted;
  const note = String(raw?.note ?? "").slice(0, 1000);
  return {
    actorId,
    actionKey: actionDef.key,
    hours,
    note
  };
}

function readDowntimeSubmissionFromUi(element) {
  const root = element?.closest(".po-downtime-panel");
  if (!root) return null;
  return {
    actorId: String(root.querySelector("select[name='downtimeActorId']")?.value ?? "").trim(),
    actionKey: String(root.querySelector("select[name='downtimeActionKey']")?.value ?? "").trim(),
    hours: Number(root.querySelector("input[name='downtimeHours']")?.value ?? 0),
    note: String(root.querySelector("textarea[name='downtimeNote']")?.value ?? "")
  };
}

async function applyDowntimeSubmissionForUser(user, rawSubmission = {}) {
  if (!user) return false;
  const ledger = getOperationsLedger();
  const downtimeState = ensureDowntimeState(ledger);
  const submission = normalizeDowntimeSubmission(rawSubmission, downtimeState);
  if (!submission.actorId) return false;

  const actor = game.actors.get(submission.actorId);
  if (!actor || !canUserManageDowntimeActor(user, actor)) return false;

  await updateOperationsLedger((ledger) => {
    const downtime = ensureDowntimeState(ledger);
    const normalized = normalizeDowntimeSubmission(submission, downtime);
    const previous = downtime.entries?.[normalized.actorId] ?? {};
    downtime.entries[normalized.actorId] = {
      ...previous,
      actorId: normalized.actorId,
      actorName: String(actor.name ?? `Actor ${normalized.actorId}`),
      actionKey: normalized.actionKey,
      hours: normalized.hours,
      note: normalized.note,
      pending: true,
      updatedAt: Date.now(),
      updatedBy: String(user.name ?? "Player"),
      updatedByUserId: String(user.id ?? ""),
      lastResult: null,
      stagedResult: null,
      stagedAt: 0,
      stagedBy: ""
    };
  });
  return true;
}

async function submitDowntimeAction(element) {
  const submission = readDowntimeSubmissionFromUi(element);
  if (!submission) return;
  if (!submission.actorId) {
    ui.notifications?.warn("Select an actor for downtime submission.");
    return;
  }

  if (canAccessAllPlayerOps()) {
    const applied = await applyDowntimeSubmissionForUser(game.user, submission);
    if (!applied) ui.notifications?.warn("Downtime submission failed.");
    else ui.notifications?.info("Downtime action submitted.");
    return;
  }

  const actor = game.actors.get(submission.actorId);
  if (!actor || !canUserManageDowntimeActor(game.user, actor)) {
    ui.notifications?.warn("You can only submit downtime for party characters you can access.");
    return;
  }

  game.socket.emit(SOCKET_CHANNEL, {
    type: "ops:downtime-submit",
    userId: game.user.id,
    entry: submission
  });
  ui.notifications?.info("Downtime request sent to GM.");
}

async function clearDowntimeEntry(element) {
  const actorId = String(element?.dataset?.actorId ?? readDowntimeSubmissionFromUi(element)?.actorId ?? "").trim();
  if (!actorId) return;
  const actor = game.actors.get(actorId);
  if (!actor) {
    ui.notifications?.warn("Actor for downtime entry was not found.");
    return;
  }

  if (canAccessAllPlayerOps()) {
    await updateOperationsLedger((ledger) => {
      const downtime = ensureDowntimeState(ledger);
      if (!downtime.entries) return;
      delete downtime.entries[actorId];
    });
    ui.notifications?.info(`Cleared downtime entry for ${actor.name}.`);
    return;
  }

  if (!canUserManageDowntimeActor(game.user, actor)) {
    ui.notifications?.warn("You can only clear downtime entries for party characters you can access.");
    return;
  }
  game.socket.emit(SOCKET_CHANNEL, {
    type: "ops:downtime-clear",
    userId: game.user.id,
    actorId
  });
  ui.notifications?.info("Downtime clear request sent to GM.");
}

async function setDowntimeHoursGranted(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can set downtime hours.");
    return;
  }
  const valueRaw = Number(element?.value ?? 4);
  const value = Number.isFinite(valueRaw) ? Math.max(1, Math.min(24, Math.floor(valueRaw))) : 4;
  await updateOperationsLedger((ledger) => {
    const downtime = ensureDowntimeState(ledger);
    downtime.hoursGranted = value;
  });
}

async function setDowntimeTuningField(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can edit downtime tuning.");
    return;
  }
  const key = String(element?.dataset?.tuning ?? "").trim().toLowerCase();
  const value = String(element?.value ?? "").trim().toLowerCase();
  if (!key) return;
  await updateOperationsLedger((ledger) => {
    const downtime = ensureDowntimeState(ledger);
    if (!downtime.tuning || typeof downtime.tuning !== "object") downtime.tuning = {};
    if (key === "economy") {
      const allowed = new Set(DOWNTIME_TUNING_ECONOMY_OPTIONS.map((entry) => entry.value));
      downtime.tuning.economy = allowed.has(value) ? value : "standard";
      return;
    }
    if (key === "risk") {
      const allowed = new Set(DOWNTIME_TUNING_RISK_OPTIONS.map((entry) => entry.value));
      downtime.tuning.risk = allowed.has(value) ? value : "standard";
      return;
    }
    if (key === "discovery") {
      const allowed = new Set(DOWNTIME_TUNING_DISCOVERY_OPTIONS.map((entry) => entry.value));
      downtime.tuning.discovery = allowed.has(value) ? value : "standard";
    }
  });
}

function parseDowntimeItemRewardsText(value) {
  return String(value ?? "")
    .split(/\r?\n|,/)
    .map((entry) => String(entry ?? "").trim())
    .filter(Boolean)
    .slice(0, DOWNTIME_ITEM_REWARD_DROP_LIMIT);
}

async function addDowntimeResolverItemRewardFromDropEvent(event) {
  if (!canAccessAllPlayerOps()) return false;
  let data = null;
  try {
    data = TextEditor.getDragEventData(event);
  } catch {
    data = null;
  }
  if (!data || typeof data !== "object") return false;
  const document = await resolveLootItemDocumentFromDropData(data);
  if (!document) {
    ui.notifications?.warn("Drop an Item from the sidebar or compendium.");
    return false;
  }
  const dropZone = event?.target?.closest?.("[data-downtime-item-dropzone]");
  const resolverRoot = dropZone?.closest?.(".po-downtime-resolver");
  const rewardsField = resolverRoot?.querySelector?.("textarea[name='resolveDowntimeItems']");
  if (!rewardsField) return false;

  const currentRewards = parseDowntimeItemRewardsText(rewardsField.value);
  const itemName = String(document?.name ?? "Item").trim() || "Item";
  if (currentRewards.length >= DOWNTIME_ITEM_REWARD_DROP_LIMIT) {
    ui.notifications?.warn(`Item rewards can include up to ${DOWNTIME_ITEM_REWARD_DROP_LIMIT} entries.`);
    return false;
  }
  currentRewards.push(itemName);
  rewardsField.value = currentRewards.join("\n");
  rewardsField.dispatchEvent(new Event("input", { bubbles: true }));
  ui.notifications?.info(`Added item reward: ${itemName}`);
  return true;
}

function getDowntimeResolverItemDropsFromUi(root) {
  const field = root?.querySelector("input[name='resolveDowntimeItemDrops']");
  return parseDowntimeItemRewardDrops(field?.value ?? "[]");
}

function setDowntimeResolverItemDropsInUi(root, drops = []) {
  const field = root?.querySelector("input[name='resolveDowntimeItemDrops']");
  if (!field) return;
  field.value = serializeDowntimeItemRewardDrops(drops);
}

function renderDowntimeResolverItemDropList(root) {
  const list = root?.querySelector("[data-downtime-item-drop-list]");
  if (!list) return;
  const drops = getDowntimeResolverItemDropsFromUi(root);
  if (!drops.length) {
    list.innerHTML = "<div class='po-op-summary'>No direct item grants queued.</div>";
    return;
  }
  list.innerHTML = drops.map((entry) => `
    <div class="po-op-role-row">
      <div class="po-op-role-head">
        <div class="po-op-role-name"><img src="${poEscapeHtml(String(entry.img ?? "icons/svg/item-bag.svg"))}" width="18" height="18" /> ${poEscapeHtml(String(entry.name ?? "Item"))}</div>
        <div class="po-op-role-status">x${Math.max(1, Math.floor(Number(entry.quantity ?? 1) || 1))}</div>
      </div>
      <div class="po-op-summary">${poEscapeHtml(String(entry.uuid ?? "").trim() || "World Item / Snapshot")}</div>
      <div class="po-op-action-row">
        <button type="button" class="po-btn po-btn-sm is-danger" data-action="remove-downtime-item-drop" data-drop-id="${poEscapeHtml(String(entry.id ?? ""))}">Remove</button>
      </div>
    </div>
  `).join("");
}

function removeDowntimeResolverItemDropFromUi(element) {
  const root = getDowntimeResolverRoot(element);
  if (!root) return false;
  const dropId = String(element?.dataset?.dropId ?? "").trim();
  if (!dropId) return false;
  const current = getDowntimeResolverItemDropsFromUi(root);
  const next = current.filter((entry) => String(entry?.id ?? "").trim() !== dropId);
  if (next.length === current.length) return false;
  setDowntimeResolverItemDropsInUi(root, next);
  renderDowntimeResolverItemDropList(root);
  return true;
}

async function addDowntimeResolverCraftingItemDropFromDropEvent(event) {
  if (!canAccessAllPlayerOps()) return false;
  const dropZone = event?.target?.closest?.("[data-downtime-crafting-item-dropzone]");
  const resolverRoot = dropZone?.closest?.(".po-downtime-resolver");
  if (!resolverRoot) return false;

  const { selectedOption } = readDowntimeResolverSelection(resolverRoot);
  const actionKey = String(selectedOption?.dataset?.actionKey ?? "").trim().toLowerCase();
  if (actionKey !== "crafting") {
    ui.notifications?.warn("Direct item drops are only applied for Crafting entries.");
    return false;
  }

  let data = null;
  try {
    data = TextEditor.getDragEventData(event);
  } catch {
    data = null;
  }
  if (!data || typeof data !== "object") return false;
  const document = await resolveLootItemDocumentFromDropData(data);
  if (!document) {
    ui.notifications?.warn("Drop an Item from the sidebar or compendium.");
    return false;
  }

  const nextDrop = buildDowntimeItemRewardDropFromDocument(document);
  if (!nextDrop) return false;
  const current = getDowntimeResolverItemDropsFromUi(resolverRoot);
  if (current.length >= DOWNTIME_ITEM_REWARD_DROP_LIMIT) {
    ui.notifications?.warn(`Direct item drops are limited to ${DOWNTIME_ITEM_REWARD_DROP_LIMIT}.`);
    return false;
  }
  current.push(nextDrop);
  setDowntimeResolverItemDropsInUi(resolverRoot, current);
  renderDowntimeResolverItemDropList(resolverRoot);
  ui.notifications?.info(`Queued crafted item grant: ${nextDrop.name}`);
  return true;
}

function getDowntimeResolverRoot(element) {
  return element?.closest(".po-downtime-resolver") ?? null;
}

function readDowntimeResolverSelection(root) {
  const select = root?.querySelector("select[name='resolveDowntimeActorId']");
  const actorId = String(select?.value ?? "").trim();
  const selectedOption = select?.selectedOptions?.[0] ?? null;
  return {
    actorId,
    selectedOption
  };
}

function applyDowntimeResolverBaseToUi(element, options = {}) {
  if (!canAccessAllPlayerOps()) return;
  const root = getDowntimeResolverRoot(element);
  if (!root) return;
  const { selectedOption } = readDowntimeResolverSelection(root);
  if (!selectedOption) return;
  const force = options?.force === true;

  const summaryInput = root.querySelector("input[name='resolveDowntimeSummary']");
  const gpInput = root.querySelector("input[name='resolveDowntimeGp']");
  const gpCostInput = root.querySelector("input[name='resolveDowntimeCost']");
  const rumorInput = root.querySelector("input[name='resolveDowntimeRumors']");
  const itemTextarea = root.querySelector("textarea[name='resolveDowntimeItems']");
  const itemDropsInput = root.querySelector("input[name='resolveDowntimeItemDrops']");
  const notesTextarea = root.querySelector("textarea[name='resolveDowntimeNotes']");
  const contractSelect = root.querySelector("select[name='resolveDowntimeContractKey']");
  const contractNotesTextarea = root.querySelector("textarea[name='resolveDowntimeContractNotes']");
  const hintNode = root.querySelector("[data-downtime-resolve-hint]");

  if (summaryInput && (force || !String(summaryInput.value ?? "").trim())) summaryInput.value = String(selectedOption.dataset.baseSummary ?? "");
  if (gpInput && (force || !String(gpInput.value ?? "").trim())) gpInput.value = String(selectedOption.dataset.baseGp ?? "0");
  if (gpCostInput && (force || !String(gpCostInput.value ?? "").trim())) gpCostInput.value = String(selectedOption.dataset.baseCost ?? "0");
  if (rumorInput && (force || !String(rumorInput.value ?? "").trim())) rumorInput.value = String(selectedOption.dataset.baseRumors ?? "0");
  if (itemTextarea && (force || !String(itemTextarea.value ?? "").trim())) itemTextarea.value = String(selectedOption.dataset.baseItems ?? "");
  if (itemDropsInput && (force || !String(itemDropsInput.value ?? "").trim())) itemDropsInput.value = String(selectedOption.dataset.baseItemDrops ?? "[]");
  if (notesTextarea && (force || !String(notesTextarea.value ?? "").trim())) notesTextarea.value = String(selectedOption.dataset.baseNotes ?? "");
  if (contractSelect && (force || !String(contractSelect.value ?? "").trim())) contractSelect.value = String(selectedOption.dataset.baseContractKey ?? "");
  if (contractNotesTextarea && (force || !String(contractNotesTextarea.value ?? "").trim())) contractNotesTextarea.value = String(selectedOption.dataset.baseContractNotes ?? "");
  if (hintNode) hintNode.textContent = String(selectedOption.dataset.baseHint ?? DOWNTIME_RESOLVE_DEFAULT_HINT);
  renderDowntimeResolverItemDropList(root);
}

function readDowntimeResolutionFromUi(element) {
  const root = getDowntimeResolverRoot(element);
  if (!root) return null;
  const { actorId } = readDowntimeResolverSelection(root);
  const summary = String(root.querySelector("input[name='resolveDowntimeSummary']")?.value ?? "").trim();
  const gpAwardRaw = Number(root.querySelector("input[name='resolveDowntimeGp']")?.value ?? 0);
  const gpCostRaw = Number(root.querySelector("input[name='resolveDowntimeCost']")?.value ?? 0);
  const rumorRaw = Number(root.querySelector("input[name='resolveDowntimeRumors']")?.value ?? 0);
  const itemRewards = parseDowntimeItemRewardsText(root.querySelector("textarea[name='resolveDowntimeItems']")?.value ?? "");
  const itemRewardDrops = parseDowntimeItemRewardDrops(root.querySelector("input[name='resolveDowntimeItemDrops']")?.value ?? "[]");
  const gmNotes = String(root.querySelector("textarea[name='resolveDowntimeNotes']")?.value ?? "").trim();
  const contractKey = String(root.querySelector("select[name='resolveDowntimeContractKey']")?.value ?? "").trim();
  const contractNotes = String(root.querySelector("textarea[name='resolveDowntimeContractNotes']")?.value ?? "").trim();
  const selectedOption = root.querySelector("select[name='resolveDowntimeActorId']")?.selectedOptions?.[0];
  const actionKey = String(selectedOption?.dataset?.actionKey ?? "").trim();
  const normalizedItemRewardDrops = actionKey.toLowerCase() === "crafting" ? itemRewardDrops : [];
  return {
    actorId,
    summary,
    gpAward: Number.isFinite(gpAwardRaw) ? Math.max(0, Math.floor(gpAwardRaw)) : 0,
    gpCost: Number.isFinite(gpCostRaw) ? Math.max(0, Math.floor(gpCostRaw)) : 0,
    rumorCount: Number.isFinite(rumorRaw) ? Math.max(0, Math.floor(rumorRaw)) : 0,
    itemRewards,
    itemRewardDrops: normalizedItemRewardDrops,
    gmNotes,
    socialContract: normalizeDowntimeSocialContract({
      key: contractKey,
      notes: contractNotes
    }, actionKey)
  };
}

function getDowntimeActorName(actorId, fallbackName = "") {
  const id = String(actorId ?? "").trim();
  const actorName = String(game.actors.get(id)?.name ?? fallbackName ?? `Actor ${id}`).trim();
  return actorName || `Actor ${id}`;
}

function getDowntimeEntryResolvedHours(entry = {}, hoursGranted = 4) {
  return Math.max(1, Math.min(hoursGranted, Math.floor(Number(entry?.hours ?? hoursGranted) || hoursGranted)));
}

function buildDowntimePreResolvedDraftResult(rolledResult = {}, fallbackBase = {}) {
  const suggestedGp = Math.max(
    0,
    Math.floor(Number(rolledResult?.gpAward ?? Math.max(0, Number(rolledResult?.gpDelta ?? 0) || 0)) || 0),
    Math.floor(Number(fallbackBase?.gpAward ?? 0) || 0)
  );
  const suggestedCost = Math.max(
    0,
    Math.floor(Number(rolledResult?.gpCost ?? Math.max(0, -(Number(rolledResult?.gpDelta ?? 0) || 0))) || 0),
    Math.floor(Number(fallbackBase?.gpCost ?? 0) || 0)
  );
  const suggestedRumors = Math.max(
    0,
    Math.floor(Number(rolledResult?.rumorCount ?? 0) || 0),
    Math.floor(Number(fallbackBase?.rumorCount ?? 0) || 0)
  );
  return normalizeDowntimeResult({
    ...rolledResult,
    summary: String(rolledResult?.summary ?? fallbackBase.summary ?? "").trim() || String(fallbackBase.summary ?? ""),
    gpAward: suggestedGp,
    gpCost: suggestedCost,
    gpDelta: suggestedGp - suggestedCost,
    rumorCount: suggestedRumors,
    itemRewards: Array.isArray(fallbackBase?.itemRewards) ? fallbackBase.itemRewards : [],
    itemRewardDrops: normalizeDowntimeItemRewardDrops(rolledResult?.itemRewardDrops ?? fallbackBase?.itemRewardDrops ?? []),
    gmNotes: "",
    socialContract: normalizeDowntimeSocialContract(
      rolledResult?.socialContract ?? fallbackBase?.socialContract ?? {},
      rolledResult?.actionKey ?? fallbackBase?.actionKey ?? ""
    )
  });
}

function applyResolvedDowntimeToState(state, {
  actorId,
  actorName,
  actionKey,
  fallbackEntry = {},
  result
} = {}) {
  if (!state.entries || typeof state.entries !== "object") state.entries = {};
  if (!Array.isArray(state.logs)) state.logs = [];
  const current = state.entries[actorId] ?? {};
  const hours = getDowntimeEntryResolvedHours(
    { hours: current.hours ?? fallbackEntry?.hours ?? state.hoursGranted },
    state.hoursGranted
  );
  state.entries[actorId] = {
    ...current,
    actorId,
    actorName,
    actionKey,
    hours,
    pending: false,
    updatedAt: Date.now(),
    updatedBy: String(game.user?.name ?? "GM"),
    updatedByUserId: String(game.user?.id ?? ""),
    lastResult: result,
    stagedResult: null,
    stagedAt: 0,
    stagedBy: ""
  };
  state.logs.unshift({
    ...result,
    actorId,
    actorName,
    hours
  });
  state.logs = state.logs
    .sort((a, b) => Number(b.resolvedAt ?? 0) - Number(a.resolvedAt ?? 0))
    .slice(0, 80);
}

function buildDowntimeResolutionDetails({
  stagedResult = null,
  gpAward = 0,
  gpCost = 0,
  rumorCount = 0,
  itemRewards = [],
  itemRewardDrops = [],
  gmNotes = "",
  socialContract = null
} = {}) {
  const details = [];
  if (Array.isArray(stagedResult?.details) && stagedResult.details.length > 0) {
    details.push(...stagedResult.details);
  }
  if (gpAward > 0) details.push(`Awarded ${gpAward} gp.`);
  if (gpCost > 0) details.push(`Spent ${gpCost} gp on social costs and obligations.`);
  if (gpAward > 0 || gpCost > 0) details.push(`Net coin: ${(gpAward - gpCost) >= 0 ? "+" : ""}${gpAward - gpCost} gp.`);
  if (rumorCount > 0) details.push(`Rumor leads awarded: ${rumorCount}.`);
  if (itemRewards.length > 0) details.push(`Item rewards: ${itemRewards.join("; ")}.`);
  if (itemRewardDrops.length > 0) details.push(`Crafted item grants: ${itemRewardDrops.map((entry) => String(entry?.name ?? "Item")).join("; ")}.`);
  if (socialContract?.hasContract) {
    details.push(`Social contract established: ${socialContract.label}.`);
    if (socialContract.summary) details.push(`Connection scope: ${socialContract.summary}`);
    if (socialContract.limitations) details.push(`Connection limitations: ${socialContract.limitations}`);
    if (socialContract.notes) details.push(`Connection notes: ${socialContract.notes}`);
  }
  if (gmNotes) details.push(`GM Notes: ${gmNotes}`);
  return details;
}

function getPendingDowntimeResolutionTarget(element) {
  const resolution = readDowntimeResolutionFromUi(element);
  if (!resolution?.actorId) {
    ui.notifications?.warn(DOWNTIME_SELECT_PENDING_WARNING);
    return null;
  }
  const ledger = getOperationsLedger();
  const downtime = ensureDowntimeState(ledger);
  const entry = downtime.entries?.[resolution.actorId];
  if (!entry || entry.pending === false) {
    ui.notifications?.warn(DOWNTIME_STALE_PENDING_WARNING);
    return null;
  }
  return {
    resolution,
    downtime,
    entry
  };
}

async function preResolveSelectedDowntimeEntry(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn(DOWNTIME_GM_ONLY_PRERESOLVE_WARNING);
    return;
  }
  const target = getPendingDowntimeResolutionTarget(element);
  if (!target) return;
  const { resolution, downtime, entry } = target;

  const rolled = await generateDowntimeResult(entry, downtime);
  const fallback = getDowntimeResolutionBase(entry, downtime);
  const stagedResult = buildDowntimePreResolvedDraftResult(rolled, fallback);

  await updateOperationsLedger((nextLedger) => {
    const state = ensureDowntimeState(nextLedger);
    const current = state.entries?.[resolution.actorId];
    if (!current || current.pending === false) return;
    current.stagedResult = stagedResult;
    current.stagedAt = Date.now();
    current.stagedBy = String(game.user?.name ?? "GM");
  });

  const actorName = getDowntimeActorName(resolution.actorId, entry.actorName);
  ui.notifications?.info(`Pre-resolved downtime for ${actorName}. Edit fields, then Final Resolve.`);
}

async function resolveSelectedDowntimeEntry(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn(DOWNTIME_GM_ONLY_RESOLVE_WARNING);
    return;
  }
  const target = getPendingDowntimeResolutionTarget(element);
  if (!target) return;
  const { resolution, entry } = target;

  const stagedResult = entry?.stagedResult ? normalizeDowntimeResult(entry.stagedResult) : null;
  const actionDef = getDowntimeActionDefinition(entry.actionKey);
  const actorName = getDowntimeActorName(resolution.actorId, entry.actorName);
  const details = buildDowntimeResolutionDetails({
    stagedResult,
    gpAward: resolution.gpAward,
    gpCost: resolution.gpCost,
    rumorCount: resolution.rumorCount,
    itemRewards: resolution.itemRewards,
    itemRewardDrops: resolution.itemRewardDrops,
    gmNotes: resolution.gmNotes,
    socialContract: resolution.socialContract
  });

  const summary = resolution.summary
    || String(stagedResult?.summary ?? "").trim()
    || `${actionDef.label} resolved for ${actorName}.`;
  const result = normalizeDowntimeResult({
    id: foundry.utils.randomID(),
    actionKey: actionDef.key,
    actionLabel: actionDef.label,
    summary,
    details,
    rollTotal: Number(stagedResult?.rollTotal ?? 0) || 0,
    gpAward: resolution.gpAward,
    gpCost: resolution.gpCost,
    gpDelta: resolution.gpAward - resolution.gpCost,
    progress: Math.max(0, Math.floor(Number(stagedResult?.progress ?? 0) || 0)),
    complication: String(stagedResult?.complication ?? "").trim(),
    rumorCount: resolution.rumorCount,
    itemRewards: resolution.itemRewards,
    itemRewardDrops: resolution.itemRewardDrops,
    gmNotes: resolution.gmNotes,
    socialContract: resolution.socialContract,
    collected: false,
    resolvedAt: Date.now(),
    resolvedBy: String(game.user?.name ?? "GM")
  });

  await updateOperationsLedger((nextLedger) => {
    const state = ensureDowntimeState(nextLedger);
    applyResolvedDowntimeToState(state, {
      actorId: resolution.actorId,
      actorName,
      actionKey: actionDef.key,
      fallbackEntry: entry,
      result
    });
  });

  ui.notifications?.info(`Resolved downtime for ${actorName}.`);
}

async function editDowntimeResult(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can edit downtime results.");
    return;
  }
  const actorId = String(element?.dataset?.actorId ?? "").trim();
  if (!actorId) {
    ui.notifications?.warn("Select an actor with a resolved downtime result.");
    return;
  }

  const actorName = getDowntimeActorName(actorId);
  let edited = false;
  await updateOperationsLedger((ledger) => {
    const downtime = ensureDowntimeState(ledger);
    const entry = downtime.entries?.[actorId];
    if (!entry || entry.pending !== false || !entry.lastResult) return;
    const stagedResult = normalizeDowntimeResult(entry.lastResult);
    const stagedId = String(stagedResult?.id ?? "").trim();
    const stagedResolvedAt = Number(stagedResult?.resolvedAt ?? 0);

    entry.pending = true;
    entry.lastResult = null;
    entry.stagedResult = stagedResult;
    entry.stagedAt = Date.now();
    entry.stagedBy = String(game.user?.name ?? "GM");
    entry.updatedAt = Date.now();
    entry.updatedBy = String(game.user?.name ?? "GM");
    entry.updatedByUserId = String(game.user?.id ?? "");

    if (Array.isArray(downtime.logs)) {
      downtime.logs = downtime.logs.filter((log) => {
        if (String(log?.actorId ?? "").trim() !== actorId) return true;
        const logId = String(log?.id ?? "").trim();
        const logResolvedAt = Number(log?.resolvedAt ?? 0);
        if (stagedId && logId === stagedId) return false;
        if (Number.isFinite(stagedResolvedAt) && stagedResolvedAt > 0 && logResolvedAt === stagedResolvedAt) return false;
        return true;
      });
    }
    edited = true;
  });

  if (!edited) {
    ui.notifications?.warn(`No resolved downtime result found for ${actorName}.`);
    return;
  }
  ui.notifications?.info(`Moved ${actorName} back to pending for editing.`);
}

function getActorCurrentGp(actor) {
  return getActorCurrentCurrencyValue(actor, "gp");
}

async function setActorCurrentGp(actor, amount) {
  if (!actor) return 0;
  const next = Math.max(0, Math.floor(Number(amount ?? 0) || 0));
  if (typeof actor.system?.currency?.gp === "object") {
    await actor.update({ "system.currency.gp.value": next });
  } else {
    await actor.update({ "system.currency.gp": next });
  }
  return next;
}

function buildDowntimeSocialContractFeatureName(contract = {}) {
  const label = String(contract?.label ?? "").trim();
  return label ? `Connection: ${label}` : "Connection";
}

function buildDowntimeSocialContractFeatureDescription(contract = {}, result = {}) {
  const escape = foundry.utils.escapeHTML ?? ((value) => String(value ?? ""));
  const scope = String(contract?.summary ?? "").trim();
  const limitations = String(contract?.limitations ?? "").trim();
  const notes = String(contract?.notes ?? "").trim();
  const sourceAction = String(result?.actionLabel ?? "").trim();
  const sourceSummary = String(result?.summary ?? "").trim();
  const sourceBits = [sourceAction, sourceSummary].filter(Boolean).join(" - ");
  const lines = ["<p><strong>Downtime Connection</strong></p>"];
  if (scope) lines.push(`<p><strong>Scope:</strong> ${escape(scope)}</p>`);
  if (limitations) lines.push(`<p><strong>Limitations:</strong> ${escape(limitations)}</p>`);
  if (notes) lines.push(`<p><strong>Notes:</strong> ${escape(notes)}</p>`);
  if (sourceBits) lines.push(`<p><em>Source:</em> ${escape(sourceBits)}</p>`);
  return lines.join("");
}

function getDowntimeConnectionFeatureByResult(actor, resultId = "") {
  const id = String(resultId ?? "").trim();
  if (!actor || !id) return null;
  const items = actor.items?.contents ?? actor.items ?? [];
  return items.find((item) => {
    const connection = item?.flags?.[MODULE_ID]?.downtimeConnection;
    return String(connection?.resultId ?? "").trim() === id;
  }) ?? null;
}

function buildDowntimeSocialContractFeatureData(contract = {}, result = {}, options = {}) {
  const collectedAt = Number(options.collectedAt ?? Date.now());
  const description = buildDowntimeSocialContractFeatureDescription(contract, result);
  const resultId = String(result?.id ?? "").trim();
  const actionKey = String(result?.actionKey ?? "").trim().toLowerCase();
  return {
    name: buildDowntimeSocialContractFeatureName(contract),
    type: "feat",
    system: {
      description: {
        value: description
      }
    },
    flags: {
      [MODULE_ID]: {
        downtimeConnection: {
          resultId,
          actionKey,
          contractKey: String(contract?.key ?? "").trim().toLowerCase(),
          contractLabel: String(contract?.label ?? "").trim(),
          contractSummary: String(contract?.summary ?? "").trim(),
          contractLimitations: String(contract?.limitations ?? "").trim(),
          contractNotes: String(contract?.notes ?? "").trim(),
          collectedAt
        }
      }
    }
  };
}

async function createDowntimeSocialContractFeature(actor, result = {}, options = {}) {
  const normalizedResult = normalizeDowntimeResult(result);
  const contract = normalizeDowntimeSocialContract(normalizedResult.socialContract ?? {}, normalizedResult.actionKey);
  if (!actor || !contract.hasContract) {
    return { ok: true, created: false, item: null, contract };
  }

  const existingByResult = getDowntimeConnectionFeatureByResult(actor, normalizedResult.id);
  if (existingByResult) {
    return { ok: true, created: false, item: existingByResult, contract };
  }

  const hintedItemId = String(contract.featureItemId ?? "").trim();
  if (hintedItemId) {
    const existingById = actor.items?.get?.(hintedItemId) ?? null;
    if (existingById) {
      return { ok: true, created: false, item: existingById, contract };
    }
  }

  const itemData = buildDowntimeSocialContractFeatureData(contract, normalizedResult, options);
  try {
    const created = await actor.createEmbeddedDocuments("Item", [itemData]);
    const item = Array.isArray(created) ? (created[0] ?? null) : null;
    if (!item) return { ok: false, created: false, item: null, contract, message: "No feature was created for the social contract." };
    return { ok: true, created: true, item, contract };
  } catch (error) {
    console.warn(`${MODULE_ID}: failed to create downtime social contract feature`, error);
    return { ok: false, created: false, item: null, contract, message: "Failed to add social contract feature to actor." };
  }
}

function applyItemRewardDropQuantity(itemData = {}, quantity = 1) {
  const qty = Math.max(1, Math.floor(Number(quantity ?? 1) || 1));
  if (qty <= 1) return itemData;
  const next = foundry.utils.deepClone(itemData ?? {});
  if (!next.system || typeof next.system !== "object") next.system = {};
  if (next.system.quantity !== undefined && next.system.quantity !== null) {
    if (typeof next.system.quantity === "object") next.system.quantity.value = qty;
    else next.system.quantity = qty;
  } else {
    next.system.quantity = qty;
  }
  return next;
}

async function buildDowntimeItemRewardDropDocumentData(drop = {}) {
  const normalized = normalizeDowntimeItemRewardDrop(drop);
  let itemData = null;
  const uuid = String(normalized.uuid ?? "").trim();
  if (uuid) {
    const source = await resolveUuidDocument(uuid);
    if (source?.documentName === "Item" && typeof source.toObject === "function") {
      itemData = source.toObject();
    }
  }
  if (!itemData || typeof itemData !== "object") {
    itemData = {
      name: normalized.name,
      type: normalized.itemType || "loot",
      img: normalized.img || "icons/svg/item-bag.svg"
    };
  }
  if (Object.prototype.hasOwnProperty.call(itemData, "_id")) delete itemData._id;
  if (!itemData.name) itemData.name = normalized.name || "Crafted Item";
  if (!itemData.type) itemData.type = normalized.itemType || "loot";
  if (!itemData.img) itemData.img = normalized.img || "icons/svg/item-bag.svg";
  return applyItemRewardDropQuantity(itemData, normalized.quantity);
}

async function awardDowntimeItemRewardDropsToActor(actor, drops = []) {
  const normalizedDrops = normalizeDowntimeItemRewardDrops(drops);
  if (!actor || normalizedDrops.length === 0) {
    return { ok: true, createdItems: [], itemNames: [] };
  }
  const itemDataBatch = [];
  for (const drop of normalizedDrops) {
    const itemData = await buildDowntimeItemRewardDropDocumentData(drop);
    if (!itemData || typeof itemData !== "object") {
      return { ok: false, createdItems: [], itemNames: [], message: `Failed to build dropped item reward: ${String(drop?.name ?? "Item")}.` };
    }
    itemDataBatch.push(itemData);
  }
  try {
    const createdItems = await actor.createEmbeddedDocuments("Item", itemDataBatch);
    const itemNames = createdItems.map((entry) => String(entry?.name ?? "Item"));
    return { ok: true, createdItems, itemNames };
  } catch (error) {
    console.warn(`${MODULE_ID}: failed to grant downtime dropped item rewards`, error);
    return { ok: false, createdItems: [], itemNames: [], message: "Failed to add crafted item rewards to actor inventory." };
  }
}

async function applyDowntimeCollectionForUser(user, actorId) {
  const actor = game.actors.get(String(actorId ?? "").trim());
  if (!actor) return { ok: false, message: "Actor not found." };
  if (!canUserManageDowntimeActor(user, actor)) return { ok: false, message: "You cannot access this actor." };

  const ledger = getOperationsLedger();
  const downtime = ensureDowntimeState(ledger);
  const entry = downtime.entries?.[actor.id];
  const result = entry?.lastResult ? normalizeDowntimeResult(entry.lastResult) : null;
  if (!result) return { ok: false, message: "No resolved downtime result found." };
  if (entry?.pending !== false) return { ok: false, message: "This downtime result is still pending." };
  if (!result.hasClaimableRewards) return { ok: false, message: "No claimable rewards are attached to this result." };
  if (result.collected) return { ok: false, message: "This downtime reward was already collected." };

  const gpAward = Math.max(0, Math.floor(Number(result.gpAward ?? Math.max(0, Number(result.gpDelta ?? 0) || 0)) || 0));
  const gpCost = Math.max(0, Math.floor(Number(result.gpCost ?? Math.max(0, -(Number(result.gpDelta ?? 0) || 0))) || 0));
  const itemRewardDrops = normalizeDowntimeItemRewardDrops(result.itemRewardDrops ?? []);
  const gpBefore = getActorCurrentGp(actor);
  if (gpCost > gpBefore) {
    return {
      ok: false,
      message: `${actor.name} needs ${gpCost} gp to collect this result, but only has ${gpBefore} gp.`
    };
  }

  const socialContract = normalizeDowntimeSocialContract(result.socialContract ?? {}, result.actionKey);
  const now = Date.now();
  const collectorName = String(user?.name ?? "Player");
  const gpAfter = Math.max(0, gpBefore - gpCost + gpAward);
  let gpUpdated = false;
  let featureOutcome = { ok: true, created: false, item: null, contract: socialContract };
  let itemDropOutcome = { ok: true, createdItems: [], itemNames: [] };

  try {
    if (gpAfter !== gpBefore) {
      await setActorCurrentGp(actor, gpAfter);
      gpUpdated = true;
    }
    featureOutcome = socialContract.hasContract
      ? await createDowntimeSocialContractFeature(actor, result, { collectedAt: now })
      : { ok: true, created: false, item: null, contract: socialContract };
    if (!featureOutcome.ok) {
      throw new Error(featureOutcome.message ?? "Failed to create social contract feature.");
    }
    itemDropOutcome = await awardDowntimeItemRewardDropsToActor(actor, itemRewardDrops);
    if (!itemDropOutcome.ok) {
      throw new Error(itemDropOutcome.message ?? "Failed to add crafted item rewards to actor inventory.");
    }
  } catch (error) {
    const failureMessage = String(error?.message ?? "Failed to collect downtime result.");
    if (itemDropOutcome.createdItems.length > 0) {
      try {
        for (const item of itemDropOutcome.createdItems) {
          await item.delete();
        }
      } catch (rollbackError) {
        console.warn(`${MODULE_ID}: failed to rollback downtime crafted item rewards`, rollbackError);
      }
    }
    if (featureOutcome.created && featureOutcome.item) {
      try {
        await featureOutcome.item.delete();
      } catch (rollbackError) {
        console.warn(`${MODULE_ID}: failed to rollback downtime social contract feature`, rollbackError);
      }
    }
    if (gpUpdated) {
      try {
        await setActorCurrentGp(actor, gpBefore);
      } catch (rollbackError) {
        console.warn(`${MODULE_ID}: failed to rollback downtime GP transaction`, rollbackError);
      }
    }
    return { ok: false, message: failureMessage };
  }

  const connectionFeatureId = String(featureOutcome.item?.id ?? "").trim();
  const connectionFeatureName = String(featureOutcome.item?.name ?? "").trim();
  const craftedItemRewardNames = Array.isArray(itemDropOutcome.itemNames) ? itemDropOutcome.itemNames : [];
  await updateOperationsLedger((nextLedger) => {
    const state = ensureDowntimeState(nextLedger);
    const currentEntry = state.entries?.[actor.id];
    if (!currentEntry || !currentEntry.lastResult) return;
    const sourceResult = currentEntry.lastResult;
    const normalizedResult = normalizeDowntimeResult({
      ...sourceResult,
      gpAward,
      gpCost,
      gpDelta: gpAward - gpCost,
      socialContract: {
        ...(sourceResult?.socialContract ?? result.socialContract ?? {}),
        featureItemId: connectionFeatureId
      },
      collected: true,
      collectedAt: now,
      collectedBy: collectorName
    });
    delete state.entries[actor.id];
    if (Array.isArray(state.logs)) {
      let replaced = false;
      state.logs = state.logs.map((row) => {
        if (String(row?.id ?? "") !== String(normalizedResult.id ?? "")) return row;
        if (String(row?.actorId ?? "") !== String(actor.id)) return row;
        replaced = true;
        return normalizeDowntimeResult({
          ...row,
          gpAward,
          gpCost,
          gpDelta: gpAward - gpCost,
          socialContract: {
            ...(row?.socialContract ?? result.socialContract ?? {}),
            featureItemId: connectionFeatureId
          },
          collected: true,
          collectedAt: now,
          collectedBy: collectorName
        });
      });
      if (!replaced) {
        state.logs.unshift({
          ...normalizedResult,
          actorId: String(actor.id ?? ""),
          actorName: String(currentEntry.actorName ?? actor.name ?? "Actor"),
          hours: getDowntimeEntryResolvedHours(currentEntry, state.hoursGranted)
        });
      }
      state.logs = state.logs
        .sort((a, b) => Number(b.resolvedAt ?? 0) - Number(a.resolvedAt ?? 0))
        .slice(0, 80);
    }
  });

  return {
    ok: true,
    actorName: String(actor.name ?? "Actor"),
    gpAwarded: gpAward,
    gpSpent: gpCost,
    gpNet: gpAward - gpCost,
    gpBefore,
    gpAfter,
    rumorCount: Number(result.rumorCount ?? 0) || 0,
    itemRewards: Array.isArray(result.itemRewards) ? result.itemRewards : [],
    craftedItemRewardNames,
    craftedItemRewardCount: craftedItemRewardNames.length,
    gmNotes: String(result.gmNotes ?? "").trim(),
    socialContract: {
      hasContract: socialContract.hasContract,
      key: socialContract.key,
      label: socialContract.label,
      summary: socialContract.summary,
      limitations: socialContract.limitations,
      notes: socialContract.notes,
      featureItemId: connectionFeatureId,
      featureItemName: connectionFeatureName
    }
  };
}

function getDowntimeCollectionSummary(outcome = {}) {
  const parts = [];
  const gpAwarded = Math.max(0, Number(outcome?.gpAwarded ?? 0) || 0);
  const gpSpent = Math.max(0, Number(outcome?.gpSpent ?? 0) || 0);
  const gpNetRaw = Number(outcome?.gpNet);
  const gpNet = Number.isFinite(gpNetRaw) ? Math.floor(gpNetRaw) : (gpAwarded - gpSpent);
  const rumors = Math.max(0, Number(outcome?.rumorCount ?? 0) || 0);
  const items = Array.isArray(outcome?.itemRewards) ? outcome.itemRewards.filter(Boolean) : [];
  const craftedItems = Array.isArray(outcome?.craftedItemRewardNames) ? outcome.craftedItemRewardNames.filter(Boolean) : [];
  const hasNotes = String(outcome?.gmNotes ?? "").trim().length > 0;
  const socialContract = outcome?.socialContract && typeof outcome.socialContract === "object" ? outcome.socialContract : null;
  const socialContractLabel = String(socialContract?.label ?? "").trim();
  const socialContractFeatureName = String(socialContract?.featureItemName ?? "").trim();
  if (gpAwarded > 0) parts.push(`${gpAwarded} gp added`);
  if (gpSpent > 0) parts.push(`${gpSpent} gp spent`);
  if (gpAwarded > 0 || gpSpent > 0) parts.push(`net ${(gpNet >= 0 ? "+" : "") + gpNet} gp`);
  if (rumors > 0) parts.push(`${rumors} rumor/lead`);
  if (items.length > 0) parts.push(`${items.length} item reward(s)`);
  if (craftedItems.length > 0) parts.push(`${craftedItems.length} crafted item(s) added`);
  if (socialContract?.hasContract) parts.push(socialContractFeatureName || `connection added: ${socialContractLabel || "Social Contract"}`);
  if (hasNotes) parts.push("GM notes reviewed");
  if (parts.length === 0) return "Rewards marked as collected.";
  return parts.join(" | ");
}

async function collectDowntimeResult(element) {
  const actorId = String(element?.dataset?.actorId ?? "").trim();
  if (!actorId) return;

  if (canAccessAllPlayerOps()) {
    const outcome = await applyDowntimeCollectionForUser(game.user, actorId);
    if (!outcome.ok) {
      ui.notifications?.warn(outcome.message ?? "Failed to collect downtime rewards.");
      return;
    }
    ui.notifications?.info(`Collected downtime rewards for ${outcome.actorName}. ${getDowntimeCollectionSummary(outcome)}`);
    return;
  }

  const actor = game.actors.get(actorId);
  if (!actor || !canUserManageDowntimeActor(game.user, actor)) {
    ui.notifications?.warn("You can only collect downtime rewards for party characters you can access.");
    return;
  }
  game.socket.emit(SOCKET_CHANNEL, {
    type: "ops:downtime-collect",
    userId: game.user.id,
    actorId
  });
  ui.notifications?.info("Downtime collection request sent to GM.");
}

async function clearDowntimeResults() {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can clear downtime logs.");
    return;
  }
  const confirmed = await Dialog.confirm({
    title: "Clear Resolved Logs",
    content: "<p>Are you sure you want to clear all resolved logs?</p>"
  });
  if (!confirmed) return;

  let removedCount = 0;
  await updateOperationsLedger((ledger) => {
    const downtime = ensureDowntimeState(ledger);
    removedCount = Array.isArray(downtime.logs) ? downtime.logs.length : 0;
    downtime.logs = [];
  });
  if (removedCount <= 0) {
    ui.notifications?.info("No downtime logs to clear.");
    return;
  }
  ui.notifications?.info(`Cleared ${removedCount} resolved downtime log${removedCount === 1 ? "" : "s"}.`);
}

async function unarchiveDowntimeLogEntry(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can unarchive downtime logs.");
    return;
  }
  const logId = String(element?.dataset?.logId ?? "").trim();
  if (!logId) {
    ui.notifications?.warn("Downtime log entry not found.");
    return;
  }

  const ledger = getOperationsLedger();
  const downtime = ensureDowntimeState(ledger);
  const source = Array.isArray(downtime.logs)
    ? downtime.logs.find((entry) => String(entry?.id ?? "").trim() === logId)
    : null;
  if (!source) {
    ui.notifications?.warn("Downtime log entry not found.");
    return;
  }

  const actorId = String(source?.actorId ?? "").trim();
  if (!actorId) {
    ui.notifications?.warn("Cannot unarchive a log without a valid actor.");
    return;
  }
  const stagedResult = normalizeDowntimeResult(source);
  const actionDef = getDowntimeActionDefinition(source?.actionKey ?? stagedResult.actionKey);
  const actorName = getDowntimeActorName(actorId, String(source?.actorName ?? ""));
  const requestedHours = Math.max(1, Math.floor(Number(source?.hours ?? 4) || 4));
  let moved = false;

  await updateOperationsLedger((nextLedger) => {
    const state = ensureDowntimeState(nextLedger);
    const existingEntry = state.entries?.[actorId] ?? null;
    if (existingEntry) {
      return;
    }
    const hours = Math.max(1, Math.min(state.hoursGranted, requestedHours));
    state.entries[actorId] = {
      actorId,
      actorName,
      actionKey: actionDef.key,
      hours,
      note: "",
      pending: true,
      updatedAt: Date.now(),
      updatedBy: String(game.user?.name ?? "GM"),
      updatedByUserId: String(game.user?.id ?? ""),
      lastResult: null,
      stagedResult,
      stagedAt: Date.now(),
      stagedBy: String(game.user?.name ?? "GM")
    };
    if (Array.isArray(state.logs)) {
      state.logs = state.logs.filter((entry) => String(entry?.id ?? "").trim() !== logId);
    }
    moved = true;
  });

  if (!moved) {
    ui.notifications?.warn(`${actorName} already has an active downtime entry. Resolve/clear it first before unarchiving.`);
    return;
  }
  ui.notifications?.info(`Unarchived downtime log for ${actorName}. It is back in Pending Resolver for edits.`);
}

async function clearDowntimeLogEntry(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can clear downtime logs.");
    return;
  }
  const logId = String(element?.dataset?.logId ?? "").trim();
  if (!logId) {
    ui.notifications?.warn("Downtime log entry not found.");
    return;
  }
  let removed = false;
  await updateOperationsLedger((ledger) => {
    const downtime = ensureDowntimeState(ledger);
    const logs = Array.isArray(downtime.logs) ? downtime.logs : [];
    const nextLogs = logs.filter((entry) => String(entry?.id ?? "").trim() !== logId);
    removed = nextLogs.length !== logs.length;
    downtime.logs = nextLogs;
  });
  if (!removed) {
    ui.notifications?.warn("Downtime log entry not found.");
    return;
  }
  ui.notifications?.info("Resolved downtime log cleared.");
}

async function postDowntimeLogOutcome(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can post downtime outcomes.");
    return;
  }
  const logId = String(element?.dataset?.logId ?? "").trim();
  if (!logId) return;
  const ledger = getOperationsLedger();
  const downtime = ensureDowntimeState(ledger);
  const source = Array.isArray(downtime.logs)
    ? downtime.logs.find((entry) => String(entry?.id ?? "").trim() === logId)
    : null;
  if (!source) {
    ui.notifications?.warn("Downtime log entry not found.");
    return;
  }

  const result = normalizeDowntimeResult(source);
  const escape = foundry.utils.escapeHTML ?? ((value) => String(value ?? ""));
  const actorName = String(source.actorName ?? "Unknown Actor").trim() || "Unknown Actor";
  const actionLabel = String(result.actionLabel ?? getDowntimeActionDefinition(source.actionKey).label ?? "Downtime");
  const hours = Math.max(1, Math.floor(Number(source.hours ?? 4) || 4));
  const detailsHtml = (Array.isArray(result.details) ? result.details : [])
    .map((entry) => `<li>${escape(entry)}</li>`)
    .join("");
  const complication = String(result.complication ?? "").trim();
  const gpAward = Math.max(0, Math.floor(Number(result.gpAward ?? Math.max(0, Number(result.gpDelta ?? 0) || 0)) || 0));
  const gpCost = Math.max(0, Math.floor(Number(result.gpCost ?? Math.max(0, -(Number(result.gpDelta ?? 0) || 0))) || 0));
  const gpDelta = gpAward - gpCost;
  const rumorCount = Math.max(0, Number(result.rumorCount ?? 0) || 0);
  const itemRewards = Array.isArray(result.itemRewards) ? result.itemRewards : [];
  const itemRewardDrops = normalizeDowntimeItemRewardDrops(result.itemRewardDrops ?? []);
  const gmNotes = String(result.gmNotes ?? "").trim();
  const socialContract = normalizeDowntimeSocialContract(result.socialContract ?? {}, result.actionKey);
  const socialContractLabel = String(socialContract.label ?? "").trim();
  const socialContractSummary = String(socialContract.summary ?? "").trim();
  const socialContractLimitations = String(socialContract.limitations ?? "").trim();
  const socialContractNotes = String(socialContract.notes ?? "").trim();

  await ChatMessage.create({
    speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
    content: `
      <p><strong>Downtime Outcome</strong></p>
      <p><strong>${escape(actorName)}</strong> - ${escape(actionLabel)} (${hours} hour(s))</p>
      <p>${escape(result.summary || "No summary provided.")}</p>
      ${detailsHtml ? `<ul>${detailsHtml}</ul>` : ""}
      <p><strong>GP Award:</strong> +${gpAward}</p>
      <p><strong>GP Cost:</strong> -${gpCost}</p>
      <p><strong>GP Net:</strong> ${(gpDelta >= 0 ? "+" : "") + gpDelta}</p>
      ${rumorCount > 0 ? `<p><strong>Rumors/Leads:</strong> ${rumorCount}</p>` : ""}
      ${itemRewards.length > 0 ? `<p><strong>Item Rewards:</strong> ${escape(itemRewards.join("; "))}</p>` : ""}
      ${itemRewardDrops.length > 0 ? `<p><strong>Crafted Item Grants:</strong> ${escape(itemRewardDrops.map((entry) => entry.name).join("; "))}</p>` : ""}
      ${socialContract.hasContract ? `<p><strong>Connection:</strong> ${escape(socialContractLabel || "Social Contract")}</p>` : ""}
      ${socialContractSummary ? `<p><strong>Connection Scope:</strong> ${escape(socialContractSummary)}</p>` : ""}
      ${socialContractLimitations ? `<p><strong>Connection Limitations:</strong> ${escape(socialContractLimitations)}</p>` : ""}
      ${socialContractNotes ? `<p><strong>Connection Notes:</strong> ${escape(socialContractNotes)}</p>` : ""}
      ${gmNotes ? `<p><strong>GM Notes:</strong> ${escape(gmNotes)}</p>` : ""}
      ${complication ? `<p><strong>Complication:</strong> ${escape(complication)}</p>` : ""}
      <p><em>Resolved by ${escape(result.resolvedBy)} at ${escape(new Date(Number(result.resolvedAt)).toLocaleString())}</em></p>
    `
  });
  await createOperationsJournalEntry({
    category: "downtime",
    sensitivity: "gm",
    title: `Downtime Outcome - ${actorName}`,
    summary: `${actionLabel} (${hours} hour(s))`,
    redactedSummary: `${actionLabel} outcome logged.`,
    body: `
      <p><strong>Actor:</strong> ${buildUuidJournalLink(game.actors.get(String(source.actorId ?? "").trim())?.uuid ?? "", actorName)}</p>
      <p><strong>Summary:</strong> ${escape(result.summary || "No summary provided.")}</p>
      ${detailsHtml ? `<ul>${detailsHtml}</ul>` : ""}
      <p><strong>GP Award:</strong> +${gpAward}</p>
      <p><strong>GP Cost:</strong> -${gpCost}</p>
      <p><strong>GP Net:</strong> ${(gpDelta >= 0 ? "+" : "") + gpDelta}</p>
      ${rumorCount > 0 ? `<p><strong>Rumors/Leads:</strong> ${rumorCount}</p>` : ""}
      ${itemRewards.length > 0 ? `<p><strong>Item Rewards:</strong> ${escape(itemRewards.join("; "))}</p>` : ""}
      ${itemRewardDrops.length > 0 ? `<p><strong>Crafted Item Grants:</strong> ${escape(itemRewardDrops.map((entry) => entry.name).join("; "))}</p>` : ""}
      ${socialContract.hasContract ? `<p><strong>Connection:</strong> ${escape(socialContractLabel || "Social Contract")}</p>` : ""}
      ${socialContractSummary ? `<p><strong>Connection Scope:</strong> ${escape(socialContractSummary)}</p>` : ""}
      ${socialContractLimitations ? `<p><strong>Connection Limitations:</strong> ${escape(socialContractLimitations)}</p>` : ""}
      ${socialContractNotes ? `<p><strong>Connection Notes:</strong> ${escape(socialContractNotes)}</p>` : ""}
      ${gmNotes ? `<p><strong>GM Notes:</strong> ${escape(gmNotes)}</p>` : ""}
      ${complication ? `<p><strong>Complication:</strong> ${escape(complication)}</p>` : ""}
    `,
    redactedBody: `
      <p><strong>Actor:</strong> ${buildUuidJournalLink(game.actors.get(String(source.actorId ?? "").trim())?.uuid ?? "", actorName)}</p>
      <p><strong>Summary:</strong> ${escape(result.summary || "No summary provided.")}</p>
      <p><strong>GP Award:</strong> +${gpAward}</p>
      <p><strong>GP Cost:</strong> -${gpCost}</p>
      <p><strong>GP Net:</strong> ${(gpDelta >= 0 ? "+" : "") + gpDelta}</p>
      ${rumorCount > 0 ? `<p><strong>Rumors/Leads:</strong> ${rumorCount}</p>` : ""}
      ${itemRewards.length > 0 ? `<p><strong>Item Rewards:</strong> ${escape(itemRewards.join("; "))}</p>` : ""}
      ${itemRewardDrops.length > 0 ? `<p><strong>Crafted Item Grants:</strong> ${escape(itemRewardDrops.map((entry) => entry.name).join("; "))}</p>` : ""}
      ${socialContract.hasContract ? `<p><strong>Connection:</strong> ${escape(socialContractLabel || "Social Contract")}</p>` : ""}
      <p><em>Some GM details are redacted.</em></p>
    `
  });
  ui.notifications?.info(`Posted downtime outcome for ${actorName}.`);
}

async function setOperationalSopNote(element, options = {}) {
  const suppressUiWarning = Boolean(options?.suppressUiWarning);
  const notify = Boolean(options?.notify);
  const sopKey = String(element?.dataset?.sop ?? "").trim();
  if (!sopKey || !SOP_KEYS.includes(sopKey)) return false;
  try {
    const note = clampSocketText(element?.value, SOCKET_NOTE_MAX_LENGTH);
    const existing = clampSocketText(getOperationsLedger()?.sopNotes?.[sopKey] ?? "", SOCKET_NOTE_MAX_LENGTH);
    if (note === existing) {
      clearSopCachedNoteEntry(sopKey);
      if (notify) ui.notifications?.info("No note changes to save.");
      return false;
    }
    if (!game.user?.isGM) {
      // Always save locally first so players can save/edit SOP notes without an active GM.
      writeSopCachedNoteEntry(sopKey, note, { pendingSync: true });
      const activeGm = hasActiveGmClient();
      if (activeGm) {
        game.socket.emit(SOCKET_CHANNEL, {
          type: "ops:setSopNote",
          userId: game.user.id,
          sopKey,
          note
        });
        logUiDebug("operations-sop", "queued SOP note save via socket", {
          sopKey,
          noteLength: note.length,
          userId: String(game.user?.id ?? ""),
          userName: String(game.user?.name ?? "Unknown")
        });
      } else {
        logUiDebug("operations-sop", "saved SOP note locally (pending GM sync)", {
          sopKey,
          noteLength: note.length,
          userId: String(game.user?.id ?? ""),
          userName: String(game.user?.name ?? "Unknown")
        });
      }
      if (notify) {
        ui.notifications?.info(activeGm
          ? "Note saved."
          : "Note saved locally. It will sync when a GM reconnects.");
      }
      refreshOpenApps();
      schedulePendingSopNoteSync("player-save");
      return true;
    }
    await updateOperationsLedger((ledger) => {
      const sopNotes = ensureSopNotesState(ledger);
      sopNotes[sopKey] = note;
    });
    clearSopCachedNoteEntry(sopKey);
    logUiDebug("operations-sop", "saved SOP note on GM client", {
      sopKey,
      noteLength: note.length,
      userId: String(game.user?.id ?? ""),
      userName: String(game.user?.name ?? "Unknown")
    });
    if (notify) ui.notifications?.info("Note saved.");
    return true;
  } catch (error) {
    logUiFailure("operations", "set SOP note failed", error, {
      sopKey,
      isGM: Boolean(game.user?.isGM)
    });
    if (!suppressUiWarning) {
      ui.notifications?.warn("SOP note save failed. Please try again.");
    }
    return false;
  }
}

async function setOperationalEnvironmentPreset(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can change environment controls.");
    return;
  }
  const presetKey = getEnvironmentPresetByKey(String(element?.value ?? "none")).key;
  await updateOperationsLedger((ledger) => {
    const environment = ensureEnvironmentState(ledger);
    const preset = getEnvironmentPresetByKey(presetKey);
    environment.presetKey = presetKey;
    const defaultDc = Number(preset.defaultDc ?? 12);
    if (Number.isFinite(defaultDc) && defaultDc > 0) {
      environment.movementDc = Math.max(1, Math.min(30, Math.floor(defaultDc)));
    }
    if (presetKey === "none") environment.appliedActorIds = [];
  });
}

async function setOperationalEnvironmentDc(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can change environment controls.");
    return;
  }
  const raw = Number(element?.value ?? 12);
  const dc = Number.isFinite(raw) ? Math.max(1, Math.min(30, Math.floor(raw))) : 12;
  await updateOperationsLedger((ledger) => {
    const environment = ensureEnvironmentState(ledger);
    environment.movementDc = dc;
  });
}

async function setOperationalEnvironmentNote(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can change environment controls.");
    return;
  }
  const note = String(element?.value ?? "");
  await updateOperationsLedger((ledger) => {
    const environment = ensureEnvironmentState(ledger);
    environment.note = note;
  });
}

async function setOperationalEnvironmentSyncNonParty(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can change environment controls.");
    return;
  }
  const enabled = Boolean(element?.checked);
  await updateOperationsLedger((ledger) => {
    const environment = ensureEnvironmentState(ledger);
    environment.syncToSceneNonParty = enabled;
  });
}

async function setOperationalEnvironmentSuccessive(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can change environment controls.");
    return;
  }
  const field = String(element?.dataset?.field ?? "").trim();
  if (!field) return;

  await updateOperationsLedger((ledger) => {
    const environment = ensureEnvironmentState(ledger);
    const preset = getEnvironmentPresetByKey(environment.presetKey);
    if (preset.key === "none") return;
    if (!environment.successiveByPreset || typeof environment.successiveByPreset !== "object") {
      environment.successiveByPreset = {};
    }
    const existing = normalizeEnvironmentSuccessiveOverride(environment.successiveByPreset[preset.key] ?? {});

    if (field === "statusId") {
      existing.statusId = String(element?.value ?? "").trim();
    } else if (field === "slideFeet") {
      const value = Number(element?.value ?? 0);
      existing.slideFeet = Number.isFinite(value) ? Math.max(0, Math.min(500, Math.floor(value))) : 0;
    } else if (field === "exhaustion") {
      const value = Number(element?.value ?? 0);
      existing.exhaustion = Number.isFinite(value) ? Math.max(0, Math.min(6, Math.floor(value))) : 0;
    } else if (field === "damageFormula") {
      existing.damageFormula = String(element?.value ?? "").trim();
    } else if (field === "damageType") {
      existing.damageType = String(element?.value ?? "").trim();
    } else if (field === "maxHpReductionFormula") {
      existing.maxHpReductionFormula = String(element?.value ?? "").trim();
    } else if (field === "daeChangeKey") {
      existing.daeChangeKey = String(element?.value ?? "").trim();
    } else if (field === "daeChangeMode") {
      const rawMode = Math.floor(Number(element?.value ?? CONST.ACTIVE_EFFECT_MODES.ADD));
      const validModes = new Set(Object.values(CONST.ACTIVE_EFFECT_MODES ?? {}).map((value) => Number(value)));
      existing.daeChangeMode = validModes.has(rawMode) ? rawMode : Number(CONST.ACTIVE_EFFECT_MODES.ADD);
    } else if (field === "daeChangeValue") {
      existing.daeChangeValue = String(element?.value ?? "").trim();
    } else {
      return;
    }

    environment.successiveByPreset[preset.key] = existing;
  });
}

async function resetOperationalEnvironmentSuccessiveDefaults() {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can change environment controls.");
    return;
  }
  await updateOperationsLedger((ledger) => {
    const environment = ensureEnvironmentState(ledger);
    const preset = getEnvironmentPresetByKey(environment.presetKey);
    if (preset.key === "none") return;
    if (!environment.successiveByPreset || typeof environment.successiveByPreset !== "object") {
      environment.successiveByPreset = {};
    }
    delete environment.successiveByPreset[preset.key];
  });
}

async function toggleOperationalEnvironmentActor(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can assign environment effects.");
    return;
  }
  const actorId = String(element?.dataset?.actorId ?? "").trim();
  if (!actorId) return;
  const checked = Boolean(element?.checked);
  await updateOperationsLedger((ledger) => {
    const environment = ensureEnvironmentState(ledger);
    const set = new Set(environment.appliedActorIds ?? []);
    if (checked) set.add(actorId);
    else set.delete(actorId);
    environment.appliedActorIds = Array.from(set);
  });
}

async function addOperationalEnvironmentLog() {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can log environment presets.");
    return;
  }

  const current = buildOperationsContext().environment;
  if (current.presetKey === "none") {
    ui.notifications?.warn("Select an environment preset before logging.");
    return;
  }

  await updateOperationsLedger((ledger) => {
    const environment = ensureEnvironmentState(ledger);
    const preset = getEnvironmentPresetByKey(environment.presetKey);
    const check = getEnvironmentCheckMeta(preset);
    environment.logs.unshift({
      id: foundry.utils.randomID(),
      logType: "environment",
      presetKey: environment.presetKey,
      movementDc: environment.movementDc,
      actorIds: [...environment.appliedActorIds],
      syncToSceneNonParty: Boolean(environment.syncToSceneNonParty),
      note: String(environment.note ?? ""),
      checkType: check.checkType,
      checkKey: check.checkKey,
      checkLabel: check.checkLabel,
      createdAt: Date.now(),
      createdBy: String(game.user?.name ?? "GM")
    });
    if (environment.logs.length > 100) environment.logs = environment.logs.slice(0, 100);
  });

  const actorNames = Array.isArray(current.targets)
    ? current.targets
      .filter((row) => row?.selected)
      .map((row) => String(row.actorName ?? row.name ?? "").trim())
      .filter(Boolean)
    : [];
  await createOperationsJournalEntry({
    category: "environment",
    sensitivity: "gm",
    title: `Environment - ${String(current.preset?.label ?? "Preset")}`,
    summary: `${String(current.checkLabel ?? "Check")} DC ${Math.max(1, Math.floor(Number(current.movementDc ?? 12) || 12))}`,
    redactedSummary: `${String(current.preset?.label ?? "Environment")} update logged.`,
    body: `
      <p><strong>Preset:</strong> ${poEscapeHtml(String(current.preset?.label ?? "Unknown"))}</p>
      <p><strong>Check:</strong> ${poEscapeHtml(String(current.checkLabel ?? "Check"))}</p>
      <p><strong>DC:</strong> ${Math.max(1, Math.floor(Number(current.movementDc ?? 12) || 12))}</p>
      <p><strong>Targets:</strong> ${poEscapeHtml(actorNames.length > 0 ? actorNames.join(", ") : "No assigned actors")}</p>
      <p><strong>Sync Non-Party:</strong> ${current.syncToSceneNonParty ? "Yes" : "No"}</p>
      ${String(current.note ?? "").trim() ? `<p><strong>GM Note:</strong> ${poEscapeHtml(String(current.note ?? ""))}</p>` : ""}
    `,
    redactedBody: `
      <p><strong>Preset:</strong> ${poEscapeHtml(String(current.preset?.label ?? "Unknown"))}</p>
      <p><strong>Check:</strong> ${poEscapeHtml(String(current.checkLabel ?? "Check"))}</p>
      <p><strong>DC:</strong> ${Math.max(1, Math.floor(Number(current.movementDc ?? 12) || 12))}</p>
      <p><strong>Sync Non-Party:</strong> ${current.syncToSceneNonParty ? "Yes" : "No"}</p>
      <p><em>Some GM details are redacted.</em></p>
    `
  });
  ui.notifications?.info("Environment preset logged.");
}

async function editOperationalEnvironmentLog(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can edit environment logs.");
    return;
  }
  const logId = String(element?.dataset?.logId ?? "").trim();
  if (!logId) return;

  await updateOperationsLedger((ledger) => {
    const environment = ensureEnvironmentState(ledger);
    const entry = environment.logs.find((candidate) => candidate.id === logId && String(candidate.logType ?? "environment") !== "weather");
    if (!entry) return;
    environment.presetKey = getEnvironmentPresetByKey(entry.presetKey).key;
    environment.movementDc = Math.max(1, Math.min(30, Math.floor(Number(entry.movementDc ?? 12) || 12)));
    environment.appliedActorIds = [...(entry.actorIds ?? [])];
    environment.syncToSceneNonParty = entry.syncToSceneNonParty !== false;
    environment.note = String(entry.note ?? "");
  });

  ui.notifications?.info("Loaded environment log into current controls.");
}

async function editOperationalEnvironmentLogById(logId) {
  const id = String(logId ?? "").trim();
  if (!id) return false;
  await updateOperationsLedger((ledger) => {
    const environment = ensureEnvironmentState(ledger);
    const entry = environment.logs.find((candidate) => candidate.id === id && String(candidate.logType ?? "environment") !== "weather");
    if (!entry) return;
    environment.presetKey = getEnvironmentPresetByKey(entry.presetKey).key;
    environment.movementDc = Math.max(1, Math.min(30, Math.floor(Number(entry.movementDc ?? 12) || 12)));
    environment.appliedActorIds = [...(entry.actorIds ?? [])];
    environment.syncToSceneNonParty = entry.syncToSceneNonParty !== false;
    environment.note = String(entry.note ?? "");
  });
  return true;
}

async function removeOperationalEnvironmentLog(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can edit environment logs.");
    return;
  }
  const logId = String(element?.dataset?.logId ?? "").trim();
  if (!logId) return;

  await updateOperationsLedger((ledger) => {
    const environment = ensureEnvironmentState(ledger);
    environment.logs = environment.logs.filter((entry) => !(entry.id === logId && String(entry.logType ?? "environment") !== "weather"));
  });
}

async function removeOperationalEnvironmentLogById(logId) {
  const id = String(logId ?? "").trim();
  if (!id) return false;
  let removed = false;
  await updateOperationsLedger((ledger) => {
    const environment = ensureEnvironmentState(ledger);
    const before = environment.logs.length;
    environment.logs = environment.logs.filter((entry) => !(entry.id === id && String(entry.logType ?? "environment") !== "weather"));
    removed = environment.logs.length < before;
  });
  return removed;
}

async function clearOperationalEnvironmentEffects() {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can clear environment effects.");
    return;
  }
  await updateOperationsLedger((ledger) => {
    const environment = ensureEnvironmentState(ledger);
    environment.presetKey = "none";
    environment.appliedActorIds = [];
  });
  ui.notifications?.info("Active environment effects cleared.");
}

async function showOperationalEnvironmentBrief() {
  const environment = buildOperationsContext().environment;
  const selected = environment.targets.filter((target) => target.selected).map((target) => target.actorName);
  const alwaysStatusId = String(environment.preset?.alwaysStatusId ?? "").trim();
  const alwaysStatusLabel = alwaysStatusId ? getStatusLabelById(alwaysStatusId) : "-";
  const outcomes = environment.outcomes ?? {};
  const content = `
    <div class="po-help">
      <p><strong>Environment:</strong> ${environment.preset.label}</p>
      <p><strong>Description:</strong> ${environment.preset.description}</p>
      <p><strong>Movement Check:</strong> ${environment.preset.movementCheck ? "Enabled" : "Off"}</p>
      <p><strong>Check:</strong> ${environment.preset.movementCheck ? (environment.checkLabel || "-") : "-"}</p>
      <p><strong>On Success:</strong> ${String(outcomes.onSuccess ?? "-")}</p>
      <p><strong>On Fail:</strong> ${String(outcomes.onFail ?? "-")}</p>
      <p><strong>On Fail by 5+:</strong> ${String(outcomes.onFailBy5 ?? "-")}</p>
      <p><strong>On Successive Fail:</strong> ${String(outcomes.onSuccessiveFail ?? "-")}</p>
      <p><strong>Always-On Status:</strong> ${alwaysStatusLabel}</p>
      <p><strong>Movement DC (GM):</strong> ${environment.movementDc}</p>
      <p><strong>Scene Non-Party Sync:</strong> ${environment.syncToSceneNonParty ? "Enabled" : "Disabled"}</p>
      <p><strong>Applies To:</strong> ${selected.length > 0 ? selected.join(", ") : "No actors selected."}</p>
    </div>
  `;

  await Dialog.prompt({
    title: "Environment Brief",
    content,
    rejectClose: false,
    callback: () => {}
  });
}

function getDaeKeyLabel(key) {
  const target = String(key ?? "").trim();
  if (!target) return "";
  const match = getDaeModifierCatalog().find((entry) => entry.key === target);
  return String(match?.label ?? "").trim();
}

function getResourceSyncActors() {
  return getOwnedPcActors();
}

function getItemTrackedQuantity(item) {
  const quantity = Number(item.system?.quantity);
  if (Number.isFinite(quantity)) return quantity;
  const uses = Number(item.system?.uses?.value);
  if (Number.isFinite(uses)) return uses;
  return 0;
}

async function setItemTrackedQuantity(item, value) {
  const next = Math.max(0, Math.floor(Number(value) || 0));
  if (item.system?.quantity !== undefined) {
    await item.update({ "system.quantity": next });
    return;
  }
  if (item.system?.uses?.value !== undefined) {
    await item.update({ "system.uses.value": next });
  }
}

function isMonksTokenBarActive() {
  return Boolean(game.modules.get("monks-tokenbar")?.active);
}

function getMonksTokenBarApi() {
  return game.MonksTokenBar ?? globalThis.MonksTokenBar ?? game.modules.get("monks-tokenbar")?.api ?? null;
}

function extractRollTotalFromMonksResult(result, actorId) {
  if (!result) return null;
  const candidates = [];

  if (Array.isArray(result)) candidates.push(...result);
  if (Array.isArray(result?.results)) candidates.push(...result.results);
  if (Array.isArray(result?.rolls)) candidates.push(...result.rolls);
  candidates.push(result);

  for (const entry of candidates) {
    if (!entry) continue;
    const entryActorId = entry.actorId ?? entry.id ?? entry.actor?.id ?? entry.token?.actor?.id;
    if (actorId && entryActorId && entryActorId !== actorId) continue;
    const total = Number(entry.total ?? entry.result ?? entry.roll?.total ?? entry.rollTotal);
    if (Number.isFinite(total)) return total;
  }
  return null;
}

async function requestMonksActorCheck(actor, request, dc, flavor, options = {}) {
  if (!actor || !isMonksTokenBarActive()) return null;
  const api = getMonksTokenBarApi();
  if (!api || typeof api.requestRoll !== "function") return null;

  const requestType = String(request ?? "skill:sur").trim() || "skill:sur";
  const showDc = Boolean(options.showDc);
  const requestOptions = {
    request: requestType,
    dc,
    flavor,
    silent: false,
    fastForward: false,
    showdc: showDc,
    showDC: showDc,
    rollmode: "roll",
    rollMode: "roll"
  };

  const actorTargets = [actor];
  const tokenTargets = actor.getActiveTokens?.(true, true) ?? [];
  const firstToken = tokenTargets[0] ?? null;

  const extractCallbackResult = (result) => {
    const tokenResults = Array.isArray(result?.tokenresults) ? result.tokenresults : [];
    const fallbackEntry = tokenResults[0] ?? null;
    const entry = tokenResults.find((tokenResult) => {
      const resultActorId = tokenResult?.actor?.id ?? tokenResult?.actorId ?? tokenResult?.actorid;
      return String(resultActorId ?? "") === actor.id;
    }) ?? fallbackEntry;
    if (!entry) return null;

    const total = Number(entry?.roll?.total ?? entry?.total);
    let passed = entry?.passed;
    if (passed === "success") passed = true;
    if (passed === "failed") passed = false;
    if (typeof passed !== "boolean" && Number.isFinite(total)) passed = total >= dc;

    return {
      total: Number.isFinite(total) ? total : null,
      passed: typeof passed === "boolean" ? passed : null,
      result
    };
  };

  return await new Promise(async (resolve) => {
    let settled = false;
    const settle = (value) => {
      if (settled) return;
      settled = true;
      resolve(value);
    };

    requestOptions.callback = (result) => {
      const parsed = extractCallbackResult(result);
      if (parsed) {
        settle({ total: parsed.total, passed: parsed.passed, source: "monks", response: parsed.result });
        return;
      }
      settle({ total: null, passed: null, source: "monks", response: result });
    };

    const attempts = [
      () => api.requestRoll(actorTargets, requestOptions),
      () => api.requestRoll(firstToken ? [firstToken] : actorTargets, requestOptions),
      () => api.requestRoll(actorTargets, requestType, requestOptions)
    ];

    for (const attempt of attempts) {
      try {
        const response = await attempt();
        const total = extractRollTotalFromMonksResult(response, actor.id);
        if (Number.isFinite(total)) {
          settle({ total, passed: total >= dc, source: "monks", response });
          return;
        }
        if (response !== undefined) {
          setTimeout(() => {
            if (!settled) settle({ total: null, passed: null, source: "monks", response });
          }, 180000);
          return;
        }
      } catch (error) {
        console.warn("party-operations: monks-tokenbar requestRoll attempt failed", error);
      }
    }

    settle(null);
  });
}

async function requestMonksSurvivalRoll(actor, dc, flavor) {
  return requestMonksActorCheck(actor, "skill:sur", dc, flavor, { showDc: true });
}

async function consumeSelectedInventoryItem(selection, amount) {
  const needed = Math.max(0, Math.floor(Number(amount) || 0));
  const actorId = String(selection?.actorId ?? "");
  const itemId = String(selection?.itemId ?? "");
  if (needed <= 0) return { needed, consumed: 0, missing: 0, source: "" };
  if (!actorId || !itemId) return { needed, consumed: 0, missing: needed, source: "" };

  const actor = game.actors.get(actorId);
  const item = actor?.items?.get(itemId);
  if (!actor || !item) return { needed, consumed: 0, missing: needed, source: "" };

  const current = Math.max(0, Math.floor(getItemTrackedQuantity(item)));
  const consumed = Math.min(current, needed);
  if (consumed > 0) await setItemTrackedQuantity(item, current - consumed);

  return {
    needed,
    consumed,
    missing: Math.max(0, needed - consumed),
    source: `${actor.name} - ${item.name}`
  };
}

async function addToSelectedInventoryItem(selection, amount) {
  const gained = Math.max(0, Math.floor(Number(amount) || 0));
  const actorId = String(selection?.actorId ?? "");
  const itemId = String(selection?.itemId ?? "");
  if (gained <= 0) return { gained, added: 0, source: "" };
  if (!actorId || !itemId) return { gained, added: 0, source: "" };

  const actor = game.actors.get(actorId);
  const item = actor?.items?.get(itemId);
  if (!actor || !item) return { gained, added: 0, source: "" };

  const current = Math.max(0, Math.floor(getItemTrackedQuantity(item)));
  await setItemTrackedQuantity(item, current + gained);

  return {
    gained,
    added: gained,
    source: `${actor.name} - ${item.name}`
  };
}

async function depleteLinkedResourceItems(drains, itemSelections) {
  const results = [];
  const rows = [
    { key: "food", drain: Number(drains.foodDrain ?? 0) },
    { key: "water", drain: Number(drains.waterDrain ?? 0) },
    { key: "torches", drain: Number(drains.torchDrain ?? 0) }
  ];

  for (const row of rows) {
    const selectedResult = await consumeSelectedInventoryItem(itemSelections?.[row.key], row.drain);
    results.push({
      key: row.key,
      name: selectedResult.source || row.key,
      needed: row.drain,
      consumed: selectedResult.consumed,
      missing: Math.max(0, row.drain - selectedResult.consumed)
    });
  }

  return results;
}

function getGatherWeatherOptions(resourcesState = null) {
  const weatherMods = resourcesState?.gather?.weatherMods ?? {};
  const rows = [
    { value: "clear", label: "Clear / Calm", fallback: 0 },
    { value: "light-rain", label: "Light Rain or Snow", fallback: 2 },
    { value: "heavy-rain", label: "Heavy Rain or Snow", fallback: 5 },
    { value: "wind", label: "Strong Wind", fallback: 2 },
    { value: "fog", label: "Heavy Fog", fallback: 3 },
    { value: "extreme", label: "Extreme Heat or Cold", fallback: 5 }
  ];
  return rows.map((row) => {
    const configured = Number(weatherMods[row.value]);
    return {
      value: row.value,
      label: row.label,
      dcMod: Number.isFinite(configured) ? configured : row.fallback
    };
  });
}

function wireGatherDcPreview(dialog, config) {
  Hooks.once("renderDialog", (app, html) => {
    if (app !== dialog) return;
    const root = html;
    const environmentSelect = root.find("select[name=environment]");
    const seasonInput = root.find("input[name=seasonMod]");
    const weatherInput = root.find("input[name=weatherMod]");
    const corruptionInput = root.find("input[name=corruptionMod]");
    const previewTarget = root.find("[data-gather-dc-preview]");
    const baseDcByEnvironment = config?.baseDc ?? GATHER_DEFAULTS.baseDc;

    const refresh = () => {
      const environment = normalizeGatherEnvironmentKey(environmentSelect.val() ?? GATHER_ENVIRONMENT_KEYS[0]);
      const baseDc = Math.max(1, Math.floor(Number(baseDcByEnvironment?.[environment] ?? 10) || 10));
      const seasonMod = clampGatherModifier(seasonInput.val() ?? 0, 0);
      const weatherMod = clampGatherModifier(weatherInput.val() ?? 0, 0);
      const corruptionMod = clampGatherModifier(corruptionInput.val() ?? 0, 0);
      const finalDc = Math.max(1, baseDc + seasonMod + weatherMod + corruptionMod);
      previewTarget.text(`Base ${baseDc} + Season ${seasonMod} + Weather ${weatherMod} + Corruption ${corruptionMod} = DC ${finalDc}`);
    };

    environmentSelect.on("change", refresh);
    seasonInput.on("input change", refresh);
    weatherInput.on("input change", refresh);
    corruptionInput.on("input change", refresh);
    refresh();
  });
}

function extractGatherNaturalResult(rollLike) {
  const roll = rollLike?.roll ?? rollLike;
  const diceTerms = Array.isArray(roll?.dice)
    ? roll.dice
    : (Array.isArray(roll?.terms) ? roll.terms.filter((entry) => Number(entry?.faces ?? 0) === 20) : []);
  for (const term of diceTerms) {
    const results = Array.isArray(term?.results) ? term.results : [];
    if (!results.length) continue;
    const active = results.filter((entry) => entry?.active !== false);
    const source = active.length > 0 ? active : results;
    const values = source
      .map((entry) => Number(entry?.result))
      .filter((entry) => Number.isFinite(entry));
    if (!values.length) continue;
    return Math.max(...values);
  }
  return null;
}

async function rollWisdomSurvival(actor, options = {}) {
  const dc = Number(options?.dc);
  const flavor = String(options?.flavor ?? "Wisdom (Survival)");
  const rollMode = String(options?.rollMode ?? "prefer-monks");
  const advantage = Boolean(options?.advantage);
  const preferNative = Boolean(options?.preferNative || advantage);
  const canUseMonks = Number.isFinite(dc) && isMonksTokenBarActive() && !preferNative;

  if ((rollMode === "prefer-monks" || rollMode === "monks-only") && canUseMonks) {
    const monksResult = await requestMonksSurvivalRoll(actor, dc, flavor);
    if (monksResult && Number.isFinite(monksResult.total)) {
      return {
        total: Number(monksResult.total),
        source: "monks",
        roll: monksResult.response,
        natural: null,
        passed: typeof monksResult.passed === "boolean" ? monksResult.passed : (Number(monksResult.total) >= dc)
      };
    }
    if (monksResult) {
      ui.notifications?.warn("Monk's TokenBar roll request sent, but no roll total was returned to Party Operations. Falling back to direct roll.");
    }
    if (rollMode === "monks-only") {
      throw new Error("Monk's TokenBar did not return a usable roll total for this request.");
    }
  }

  if (rollMode === "monks-only" && !canUseMonks && !preferNative) {
    throw new Error("Monk's TokenBar is not available for a DC roll request.");
  }

  if (actor && typeof actor.rollSkill === "function") {
    try {
      const rollResult = await actor.rollSkill("sur", {
        fastForward: true,
        chatMessage: false,
        advantage,
        disadvantage: false
      });
      const total = Number(rollResult?.total ?? rollResult?.roll?.total);
      if (Number.isFinite(total)) {
        const natural = extractGatherNaturalResult(rollResult);
        return { total, source: "native", roll: rollResult, natural, passed: total >= dc };
      }
    } catch (error) {
      console.warn("party-operations: rollSkill(sur) failed, using fallback roll", error);
    }
  }

  const wisMod = Number(actor?.system?.abilities?.wis?.mod ?? 0);
  const formula = advantage ? "2d20kh + @mod" : "1d20 + @mod";
  const roll = await (new Roll(formula, { mod: wisMod })).evaluate();
  const natural = extractGatherNaturalResult(roll);
  await roll.toMessage({
    speaker: ChatMessage.getSpeaker({ actor }),
    flavor
  });
  return { total: Number(roll.total ?? 0), source: "native", roll, natural, passed: Number(roll.total ?? 0) >= dc };
}

async function rollConstitutionSaveForGather(actor, dc, flavor = "Gather Resources: Constitution Save") {
  const targetDc = Math.max(1, Math.floor(Number(dc ?? 10) || 10));
  if (actor && typeof actor.rollAbilitySave === "function") {
    try {
      const rollResult = await actor.rollAbilitySave("con", { fastForward: true, chatMessage: false });
      const total = Number(rollResult?.total ?? rollResult?.roll?.total);
      if (Number.isFinite(total)) return { total, passed: total >= targetDc, source: "native", roll: rollResult };
    } catch (error) {
      console.warn(`${MODULE_ID}: con save roll failed, using fallback`, error);
    }
  }

  const conMod = Number(actor?.system?.abilities?.con?.mod ?? 0);
  const roll = await (new Roll("1d20 + @mod", { mod: conMod })).evaluate();
  await roll.toMessage({
    speaker: ChatMessage.getSpeaker({ actor }),
    flavor
  });
  const total = Number(roll.total ?? 0);
  return { total, passed: total >= targetDc, source: "native", roll };
}

function formatGatherFlagLabel(flag) {
  switch (String(flag ?? "").trim()) {
    case "safe-campsite-found": return "Safe campsite found";
    case "encounter-check-flag": return "Encounter check flagged";
    case "water-contaminated": return "Water contaminated";
    case "travel-pace-reduced-one-step": return "Travel pace reduced by one step";
    case "travel-fell-behind": return "Actor fell behind";
    default: return String(flag ?? "").trim();
  }
}

function formatGatherComplicationLabel(flag) {
  switch (String(flag ?? "").trim()) {
    case "fail-by-5-complication": return "Fail by 5+ complication";
    case "natural-1-danger": return "Natural 1 danger complication";
    case "travel-con-save-failed": return "Travel Con save failed";
    case "contaminated-water-save-failed": return "Contaminated water Con save failed";
    default: return String(flag ?? "").trim();
  }
}

function buildGatherResourceChatCard(result) {
  const outcome = result?.outcome ?? {};
  const flags = Array.isArray(outcome.resultFlags) ? outcome.resultFlags : [];
  const complications = Array.isArray(outcome.complications) ? outcome.complications : [];
  const notes = Array.isArray(outcome.notes) ? outcome.notes : [];
  const flagText = flags.length > 0 ? flags.map((entry) => formatGatherFlagLabel(entry)).join(", ") : "None";
  const complicationText = complications.length > 0 ? complications.map((entry) => formatGatherComplicationLabel(entry)).join(", ") : "None";
  const noteText = notes.length > 0 ? notes.join(" | ") : "None";
  const saveRows = [];
  if (result?.corruptionSave && typeof result.corruptionSave === "object") {
    const total = Number(result?.corruptionSave?.total ?? 0);
    const passed = Boolean(result?.corruptionSave?.passed);
    const dc = Number(result?.corruptionSave?.dc ?? 0);
    saveRows.push(`<p><strong>Corruption Save:</strong> CON ${total} vs DC ${dc} (${passed ? "Pass" : "Fail"})</p>`);
  }
  if (result?.travelConSave && typeof result.travelConSave === "object") {
    const total = Number(result?.travelConSave?.total ?? 0);
    const passed = Boolean(result?.travelConSave?.passed);
    const dc = Number(result?.travelConSave?.dc ?? 0);
    saveRows.push(`<p><strong>Travel Save:</strong> CON ${total} vs DC ${dc} (${passed ? "Pass" : "Fail"})</p>`);
  }
  return `
    <div class="po-chat-card po-chat-card-gather">
      <p><strong>Gather Resources</strong></p>
      <p><strong>Actor:</strong> ${poEscapeHtml(String(result?.actorName ?? "Unknown Actor"))}</p>
      <p><strong>Check:</strong> Wisdom (Survival) ${Number(outcome.checkTotal ?? 0)} vs DC ${Number(outcome.dc ?? 0)} (${outcome.success ? "Success" : "Failure"})</p>
      <p><strong>Natural:</strong> ${Number(outcome.natural ?? 0) || "-"}</p>
      <p><strong>Environment:</strong> ${poEscapeHtml(String(result?.environmentLabel ?? "-"))}</p>
      <p><strong>Resource Type:</strong> ${poEscapeHtml(String(outcome.resourceType ?? "food"))}</p>
      <p><strong>Rations Gained:</strong> ${Number(outcome.finalRations ?? 0)}${result?.appliedToLedger ? " (Applied)" : " (Preview Only)"}</p>
      <p><strong>Flags:</strong> ${poEscapeHtml(flagText)}</p>
      <p><strong>Complications:</strong> ${poEscapeHtml(complicationText)}</p>
      <p><strong>Notes:</strong> ${poEscapeHtml(noteText)}</p>
      ${saveRows.join("")}
    </div>
  `;
}

function buildGatherHistoryEntryFromResult(result = {}) {
  const outcome = (result?.outcome && typeof result.outcome === "object")
    ? result.outcome
    : {};
  const actorId = String(result?.actorId ?? "").trim();
  const actorName = String(result?.actorName ?? "Unknown Actor").trim() || "Unknown Actor";
  if (!actorId) return null;
  return {
    id: foundry.utils.randomID(),
    timestamp: Date.now(),
    actorId,
    actorName,
    dayKey: String(result?.dayKey ?? getGatherDayKey(getCurrentWorldTimestamp())).trim(),
    result: outcome.success ? "success" : "fail",
    success: Boolean(outcome.success),
    resourceType: normalizeGatherResourceType(outcome.resourceType),
    rations: Math.max(0, Number(outcome.finalRations ?? 0) || 0),
    checkTotal: Math.floor(Number(outcome.checkTotal ?? 0) || 0),
    dc: Math.max(1, Math.floor(Number(outcome.dc ?? result?.effectiveDc ?? 1) || 1)),
    environment: normalizeGatherEnvironmentKey(result?.environment),
    flags: Array.isArray(outcome.resultFlags) ? [...outcome.resultFlags] : [],
    complications: Array.isArray(outcome.complications) ? [...outcome.complications] : [],
    notes: Array.isArray(outcome.notes) ? [...outcome.notes] : [],
    gatherMode: String(result?.gatherMode ?? "standard").trim().toLowerCase() === "plant" ? "plant" : "standard",
    appliedToLedger: Boolean(result?.appliedToLedger),
    inventoryGainSource: String(result?.inventoryGainSource ?? "").trim(),
    inventoryGainAmount: Math.max(0, Number(result?.inventoryGainAmount ?? 0) || 0),
    createdBy: String(game.user?.name ?? "GM").trim() || "GM"
  };
}

async function ensureGatherHistoryRecorded(result = {}) {
  if (!result?.ok || result?.historyRecorded) return Boolean(result?.historyRecorded);
  if (!canAccessAllPlayerOps()) return false;
  const entry = buildGatherHistoryEntryFromResult(result);
  if (!entry) return false;

  let recorded = false;
  let duplicate = false;
  await updateOperationsLedger((ledger) => {
    if (!ledger.resources) ledger.resources = {};
    ensureOperationalResourceConfig(ledger.resources);
    const history = Array.isArray(ledger.resources.gather?.history)
      ? ledger.resources.gather.history
      : [];
    duplicate = history.some((existing) => {
      const existingTs = Number(existing?.timestamp ?? 0) || 0;
      const nearSameTime = Math.abs(existingTs - entry.timestamp) <= 5000;
      if (!nearSameTime) return false;
      return String(existing?.actorId ?? "").trim() === entry.actorId
        && String(existing?.dayKey ?? "").trim() === entry.dayKey
        && normalizeGatherResourceType(existing?.resourceType) === entry.resourceType
        && Math.floor(Number(existing?.checkTotal ?? 0) || 0) === entry.checkTotal
        && Math.max(1, Math.floor(Number(existing?.dc ?? 1) || 1)) === entry.dc;
    });
    if (duplicate) return;
    history.unshift(entry);
    ledger.resources.gather.history = history;
    recorded = true;
  });
  return recorded || duplicate;
}

async function executeGatherResourcesAction(options = {}) {
  const config = getGatherResourceConfig();
  if (!config.enabled) {
    return { ok: false, blocked: true, reason: "Gather resources is disabled in module settings." };
  }

  const actorId = String(options?.actorId ?? options?.actor?.id ?? "").trim();
  const actor = options?.actor ?? (actorId ? game.actors.get(actorId) : null);
  if (!actor) return { ok: false, blocked: true, reason: "Actor not found." };

  if (config.disallowCombat && isActorInImmediateDanger(actor)) {
    return { ok: false, blocked: true, reason: "Gathering is blocked while the actor is in immediate danger/combat." };
  }

  const minimumHours = Math.max(1, Number(config.minimumHours ?? 4) || 4);
  const hoursSpent = Math.max(0, Number(options?.hoursSpent ?? minimumHours) || 0);
  if (hoursSpent < minimumHours) {
    return { ok: false, blocked: true, reason: `Gathering requires at least ${minimumHours} hour(s).` };
  }

  const environment = normalizeGatherEnvironmentKey(options?.environment ?? GATHER_ENVIRONMENT_KEYS[0]);
  const resourceType = normalizeGatherResourceType(options?.resourceType);
  const seasonMod = clampGatherModifier(options?.seasonMod ?? config.seasonMod, config.seasonMod);
  const weatherMod = clampGatherModifier(options?.weatherMod ?? config.weatherMod, config.weatherMod);
  const corruptionMod = clampGatherModifier(options?.corruptionMod ?? config.corruptionMod, config.corruptionMod);
  const dayKey = getGatherDayKey(getCurrentWorldTimestamp());
  const environmentSignature = buildGatherEnvironmentSignature({
    environment,
    seasonMod,
    weatherMod,
    corruptionMod,
    hostileTerrain: Boolean(options?.hostileTerrain),
    isCorruptedRegion: Boolean(options?.isCorruptedRegion)
  });
  const ignoreDailyLimit = options?.ignoreDailyLimit === true;
  if (!ignoreDailyLimit && !canAttemptGatherForDay(actor, dayKey, environmentSignature)) {
    return {
      ok: false,
      blocked: true,
      reason: "This actor already attempted gathering today in this environment."
    };
  }

  const baseDc = Math.max(1, Math.floor(Number(config.baseDc?.[environment] ?? 10) || 10));
  const effectiveDc = Math.max(1, baseDc + seasonMod + weatherMod + corruptionMod);
  const gatherMode = String(options?.gatherMode ?? "standard").trim().toLowerCase();
  const herbalismAdvantage = Boolean(config.herbalismAdvantageEnabled && gatherMode === "plant" && options?.enableHerbalismAdvantage !== false);
  const rollMode = String(options?.rollMode ?? getGatherRollModeSetting() ?? "prefer-monks");
  const survival = await rollWisdomSurvival(actor, {
    dc: effectiveDc,
    flavor: "Gather Resources: Wisdom (Survival)",
    rollMode,
    advantage: herbalismAdvantage,
    preferNative: false
  });
  const checkTotal = Math.floor(Number(survival?.total ?? 0) || 0);
  const natural = clampGatherInteger(survival?.natural, 0, 20, 0);

  let rationDieTotal = null;
  let nat20BonusDieTotal = null;
  const waterAutoFound = Boolean(config.waterAutoFoundEnabled && options?.waterAutoFound && resourceType === "water");
  const success = checkTotal >= effectiveDc;
  if (success && !waterAutoFound) {
    const rationRoll = await (new Roll("1d6")).evaluate();
    rationDieTotal = clampGatherInteger(rationRoll.total, 1, 6, 1);
  }
  if (success && config.nat20BonusEnabled && natural === 20) {
    const nat20Roll = await (new Roll("1d4")).evaluate();
    nat20BonusDieTotal = clampGatherInteger(nat20Roll.total, 1, 4, 1);
  }

  let contaminationRollTotal = null;
  let corruptionSave = null;
  if (success && resourceType === "water" && config.corruptionWaterCheckEnabled && options?.isCorruptedRegion) {
    const contaminationRoll = await (new Roll("1d6")).evaluate();
    contaminationRollTotal = clampGatherInteger(contaminationRoll.total, 1, 6, 1);
    if (contaminationRollTotal === 1) {
      corruptionSave = await rollConstitutionSaveForGather(actor, config.corruptionConSaveDc, "Gather Resources: Corrupted Water CON Save");
      corruptionSave.dc = config.corruptionConSaveDc;
    }
  }

  let travelConSave = null;
  const duringTravel = Boolean(options?.duringTravel);
  const travelTradeoff = normalizeGatherTravelTradeoff(options?.travelTradeoff ?? config.travelTradeoffDefault);
  if (duringTravel && config.travelTradeoffEnabled && travelTradeoff === GATHER_TRAVEL_CHOICES.FELL_BEHIND) {
    travelConSave = await rollConstitutionSaveForGather(actor, config.travelConSaveDc, "Gather Resources: Fell Behind CON Save");
    travelConSave.dc = config.travelConSaveDc;
  }

  const outcome = resolveGatherResourceOutcome({
    resourceType,
    checkTotal,
    dc: effectiveDc,
    natural,
    rationDieTotal,
    nat20BonusDieTotal,
    waterAutoFound,
    successBy5DoubleEnabled: config.successBy5DoubleEnabled,
    nat20BonusEnabled: config.nat20BonusEnabled,
    nat1ComplicationEnabled: config.nat1ComplicationEnabled,
    hostileEncounterFlagEnabled: config.hostileEncounterFlagEnabled,
    failBy5ComplicationEnabled: config.failBy5ComplicationEnabled,
    hostileTerrain: Boolean(options?.hostileTerrain),
    corruptionWaterCheckEnabled: config.corruptionWaterCheckEnabled,
    isCorruptedRegion: Boolean(options?.isCorruptedRegion),
    contaminationRollTotal,
    corruptionSavePassed: corruptionSave ? Boolean(corruptionSave.passed) : true,
    travelTradeoffEnabled: config.travelTradeoffEnabled,
    duringTravel,
    travelTradeoff,
    travelConSavePassed: travelConSave ? Boolean(travelConSave.passed) : true
  });
  if (herbalismAdvantage) outcome.notes.push("Herbalism advantage applied for plant gathering mode.");

  const applyToLedgerRequested = options?.applyToLedger !== false;
  const canWriteLedger = canAccessAllPlayerOps();
  const applyToLedger = Boolean(applyToLedgerRequested && canWriteLedger);
  if (applyToLedgerRequested && !applyToLedger) {
    outcome.notes.push("Rations not applied to party pools (GM permission required).");
  }
  let appliedToLedger = false;
  let historyRecorded = false;
  let inventoryGainSource = "";
  let inventoryGainAmount = 0;
  if (outcome.success && outcome.finalRations > 0 && applyToLedger) {
    const ledger = getOperationsLedger();
    const resources = foundry.utils.deepClone(ledger.resources ?? {});
    ensureOperationalResourceConfig(resources);
    const selection = resourceType === "water" ? resources.itemSelections?.water : resources.itemSelections?.food;
    const inventoryGain = await addToSelectedInventoryItem(selection, outcome.finalRations);
    inventoryGainSource = String(inventoryGain?.source ?? "").trim();
    inventoryGainAmount = Math.max(0, Number(inventoryGain?.added ?? 0) || 0);
  }

  const historyEntryBase = {
    id: foundry.utils.randomID(),
    timestamp: Date.now(),
    actorId: actor.id,
    actorName: String(actor.name ?? "").trim() || "Unknown Actor",
    dayKey,
    result: outcome.success ? "success" : "fail",
    success: Boolean(outcome.success),
    resourceType,
    rations: Math.max(0, Number(outcome.finalRations ?? 0) || 0),
    checkTotal: checkTotal,
    dc: effectiveDc,
    environment,
    flags: Array.isArray(outcome.resultFlags) ? [...outcome.resultFlags] : [],
    complications: Array.isArray(outcome.complications) ? [...outcome.complications] : [],
    notes: Array.isArray(outcome.notes) ? [...outcome.notes] : [],
    gatherMode,
    createdBy: String(game.user?.name ?? "GM").trim() || "GM"
  };

  if (canWriteLedger) {
    const nextCoverageDueKey = getNextUpkeepDueKey(getCurrentWorldTimestamp());
    await updateOperationsLedger((nextLedger) => {
      if (!nextLedger.resources) nextLedger.resources = {};
      ensureOperationalResourceConfig(nextLedger.resources);
      if (outcome.success && outcome.finalRations > 0 && applyToLedger) {
        if (resourceType === "water") {
          const waterPool = getStewardPoolEntry(nextLedger.resources, "water");
          if (normalizeStewardPoolMode(waterPool.mode) !== STEWARD_POOL_MODES.INFINITE) {
            waterPool.mode = STEWARD_POOL_MODES.FINITE;
            waterPool.amount = Math.max(0, Number(waterPool.amount ?? 0) + outcome.finalRations);
            nextLedger.resources.stewardPools.water = waterPool;
            ensureStewardPoolsState(nextLedger.resources);
          }
          nextLedger.resources.gather.waterCoverageDueKey = nextCoverageDueKey;
          nextLedger.resources.gather.waterCoveredNextUpkeep = true;
        } else {
          const foodPool = getStewardPoolEntry(nextLedger.resources, "food");
          if (normalizeStewardPoolMode(foodPool.mode) !== STEWARD_POOL_MODES.INFINITE) {
            foodPool.mode = STEWARD_POOL_MODES.FINITE;
            foodPool.amount = Math.max(0, Number(foodPool.amount ?? 0) + outcome.finalRations);
            nextLedger.resources.stewardPools.food = foodPool;
            ensureStewardPoolsState(nextLedger.resources);
          }
          nextLedger.resources.gather.foodCoverageDueKey = nextCoverageDueKey;
          nextLedger.resources.gather.foodCoveredNextUpkeep = true;
        }
        appliedToLedger = true;
      }

      nextLedger.resources.gather.history.unshift({
        ...historyEntryBase,
        appliedToLedger,
        inventoryGainSource,
        inventoryGainAmount
      });
    });
    historyRecorded = true;
  }

  await setGatherAttemptState(actor, dayKey, environmentSignature);

  const result = {
    ok: true,
    blocked: false,
    actorId: actor.id,
    actorName: String(actor.name ?? "").trim() || "Unknown Actor",
    environment,
    environmentLabel: GATHER_ENVIRONMENT_LABELS[environment] ?? environment,
    baseDc,
    effectiveDc,
    seasonMod,
    weatherMod,
    corruptionMod,
    dayKey,
    environmentSignature,
    gatherMode,
    herbalismAdvantage,
    outcome,
    corruptionSave,
    travelConSave,
    appliedToLedger,
    applyToLedgerRequested,
    historyRecorded,
    inventoryGainSource,
    inventoryGainAmount
  };

  if (options?.suppressChat !== true) {
    await ChatMessage.create({
      speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
      content: buildGatherResourceChatCard(result)
    });
  }
  return result;
}

function getActorEnvironmentAssignment(actorId) {
  const ledger = getOperationsLedger();
  const environment = ensureEnvironmentState(ledger);
  const presetBase = getEnvironmentPresetByKey(environment.presetKey);
  const preset = applyEnvironmentSuccessiveConfigToPreset(presetBase, environment);
  const applies = preset.key !== "none" && environment.appliedActorIds.includes(String(actorId ?? ""));
  if (!applies) return null;
  return {
    preset,
    movementDc: Number(environment.movementDc ?? 12),
    failStatusId: String(preset.failStatusId ?? "").trim(),
    failBy5StatusId: String(preset.failBy5StatusId ?? "").trim(),
    failSlideFeet: Math.max(0, Number(preset.failSlideFeet ?? 0) || 0),
    failBy5SlideFeet: Math.max(0, Number(preset.failBy5SlideFeet ?? 0) || 0),
    failSpeedZeroTurns: Math.max(0, Number(preset.failSpeedZeroTurns ?? 0) || 0),
    failDamageFormula: String(preset.failDamageFormula ?? "").trim(),
    failDamageType: String(preset.failDamageType ?? "").trim(),
    failBy5DamageFormula: String(preset.failBy5DamageFormula ?? "").trim(),
    failBy5DamageType: String(preset.failBy5DamageType ?? "").trim(),
    failExhaustion: Math.max(0, Number(preset.failExhaustion ?? 0) || 0),
    failBy5MaxHpReductionFormula: String(preset.failBy5MaxHpReductionFormula ?? "").trim(),
    successiveFailStatusId: String(preset.successiveFailStatusId ?? "").trim(),
    successiveFailSlideFeet: Math.max(0, Number(preset.successiveFailSlideFeet ?? 0) || 0),
    successiveFailExhaustion: Math.max(0, Number(preset.successiveFailExhaustion ?? (preset.movementCheck ? 1 : 0)) || 0),
    successiveFailDamageFormula: String(preset.successiveFailDamageFormula ?? "").trim(),
    successiveFailDamageType: String(preset.successiveFailDamageType ?? "").trim(),
    successiveFailMaxHpReductionFormula: String(preset.successiveFailMaxHpReductionFormula ?? "").trim(),
    successiveFailDaeChangeKey: String(preset.successiveFailDaeChangeKey ?? "").trim(),
    successiveFailDaeChangeMode: Math.floor(Number(preset.successiveFailDaeChangeMode ?? CONST.ACTIVE_EFFECT_MODES.ADD)),
    successiveFailDaeChangeValue: String(preset.successiveFailDaeChangeValue ?? "").trim()
  };
}

async function recordEnvironmentCheckResult(actor, assignment, movementContext = {}) {
  const actorId = String(actor?.id ?? "").trim();
  if (!actorId) return { previous: 0, next: 0 };

  const failed = Boolean(movementContext?.failed);
  const rollTotalRaw = Number(movementContext?.rollTotal);
  const dcRaw = Number(movementContext?.dc);
  const rollTotal = Number.isFinite(rollTotalRaw) ? Math.floor(rollTotalRaw) : null;
  const dc = Number.isFinite(dcRaw) ? Math.floor(dcRaw) : null;
  const outcomeSummary = String(movementContext?.outcomeSummary ?? "").trim();
  const presetKey = getEnvironmentPresetByKey(String(assignment?.preset?.key ?? "none")).key;

  let previous = 0;
  let next = 0;
  await updateOperationsLedger((ledger) => {
    const environment = ensureEnvironmentState(ledger);
    const current = Math.max(0, Number(environment.failureStreaks?.[actorId] ?? 0) || 0);
    previous = current;
    next = failed ? Math.max(1, Math.min(99, current + 1)) : 0;

    if (next > 0) environment.failureStreaks[actorId] = next;
    else delete environment.failureStreaks[actorId];

    environment.checkResults.unshift({
      id: foundry.utils.randomID(),
      actorId,
      actorName: String(actor?.name ?? "").trim(),
      presetKey,
      result: failed ? "fail" : "pass",
      rollTotal,
      dc,
      streak: next,
      outcomeSummary,
      createdAt: Date.now(),
      createdBy: String(game.user?.name ?? "GM")
    });
    if (environment.checkResults.length > 100) {
      environment.checkResults = environment.checkResults.slice(0, 100);
    }
  });

  return { previous, next };
}

async function applyEnvironmentFailureConsequences(tokenDoc, assignment, movementContext = null) {
  if (!canAccessAllPlayerOps() || !tokenDoc || !assignment) return { summary: "" };

  const rollTotal = Number(movementContext?.rollTotal ?? NaN);
  const dc = Number(movementContext?.dc ?? NaN);
  const failedBy = Number.isFinite(rollTotal) && Number.isFinite(dc) ? Math.max(0, dc - rollTotal) : 0;
  const failedByFive = failedBy >= 5;
  const failStreak = Math.max(0, Number(movementContext?.failStreak ?? 0) || 0);
  const successiveFailure = failStreak >= 2;
  const summaryParts = [];

  const getStatusEffectById = (statusId) => CONFIG.statusEffects?.find((entry) => String(entry?.id ?? "") === statusId) ?? statusId;

  const toggleStatusOn = async (statusId) => {
    const id = String(statusId ?? "").trim();
    if (!id) return;
    try {
      if (typeof tokenDoc.actor?.toggleStatusEffect === "function") {
        await tokenDoc.actor.toggleStatusEffect(id, { active: true, overlay: false });
      } else if (tokenDoc.object && typeof tokenDoc.object.toggleEffect === "function") {
        await tokenDoc.object.toggleEffect(getStatusEffectById(id), { active: true });
      }
      const statusLabel = getStatusLabelById(id);
      summaryParts.push(`Status: ${statusLabel || id}`);
    } catch (error) {
      console.warn(`${MODULE_ID}: failed to apply environment status '${id}'`, error);
    }
  };

  const getFeetToPixels = (feet) => {
    const gridSize = Number(canvas?.scene?.grid?.size ?? canvas?.grid?.size ?? 0);
    const gridDistance = Number(canvas?.scene?.grid?.distance ?? canvas?.grid?.distance ?? 5);
    if (!Number.isFinite(gridSize) || gridSize <= 0) return 0;
    if (!Number.isFinite(gridDistance) || gridDistance <= 0) return gridSize;
    return (Number(feet || 0) / gridDistance) * gridSize;
  };

  const slideTokenByFeet = async (feet) => {
    const distancePixels = getFeetToPixels(feet);
    if (!Number.isFinite(distancePixels) || distancePixels <= 0) return;
    const origin = movementContext?.origin;
    const destination = movementContext?.destination;
    if (!origin || !destination) return;

    const dx = Number(destination.x ?? 0) - Number(origin.x ?? 0);
    const dy = Number(destination.y ?? 0) - Number(origin.y ?? 0);
    const magnitude = Math.hypot(dx, dy);
    if (!Number.isFinite(magnitude) || magnitude <= 0) return;

    const ux = dx / magnitude;
    const uy = dy / magnitude;
    const nextX = Math.round(Number(destination.x ?? 0) + (ux * distancePixels));
    const nextY = Math.round(Number(destination.y ?? 0) + (uy * distancePixels));
    await tokenDoc.update({ x: nextX, y: nextY }, { poEnvironmentClamp: true });
  };

  const applyDamageFormula = async (formula, damageType = "") => {
    const text = String(formula ?? "").trim();
    if (!text) return null;
    try {
      const roll = await (new Roll(text)).evaluate();
      const amount = Math.max(0, Math.floor(Number(roll.total ?? 0)));
      if (amount <= 0) return { amount: 0 };
      const hpPath = "system.attributes.hp.value";
      const hpValue = Number(foundry.utils.getProperty(tokenDoc.actor, hpPath) ?? 0);
      if (Number.isFinite(hpValue)) {
        await tokenDoc.actor.update({ [hpPath]: Math.max(0, hpValue - amount) });
      }
      return { amount, damageType: String(damageType ?? "").trim() };
    } catch (error) {
      console.warn(`${MODULE_ID}: failed to evaluate damage formula '${text}'`, error);
      return null;
    }
  };

  const applyExhaustionLevels = async (levels) => {
    const amount = Math.max(0, Math.floor(Number(levels ?? 0)));
    if (amount <= 0) return;
    const path = "system.attributes.exhaustion";
    const current = Number(foundry.utils.getProperty(tokenDoc.actor, path) ?? 0);
    if (!Number.isFinite(current)) return;
    await tokenDoc.actor.update({ [path]: Math.max(0, Math.min(6, current + amount)) });
  };

  const applyTemporarySpeedZero = async (turns = 1) => {
    const durationRounds = Math.max(1, Math.floor(Number(turns ?? 1) || 1));
    const combat = game.combat;
    const duration = combat
      ? { rounds: durationRounds, startRound: Number(combat.round ?? 0), startTurn: Number(combat.turn ?? 0) }
      : { seconds: 6 * durationRounds, startTime: Number(game.time?.worldTime ?? 0) };
    const effectData = {
      name: "Environment: Unstable Footing (Speed 0)",
      img: assignment?.preset?.icon ?? "icons/svg/hazard.svg",
      origin: `${ENVIRONMENT_EFFECT_ORIGIN}.failure`,
      disabled: false,
      transfer: false,
      duration,
      changes: [
        {
          key: "system.attributes.movement.walk",
          mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
          value: "0",
          priority: 20
        }
      ],
      flags: {
        [MODULE_ID]: {
          environmentFailure: true,
          speedZero: true
        }
      }
    };
    await tokenDoc.actor.createEmbeddedDocuments("ActiveEffect", [effectData]);
  };

  const applyMaxHpReductionFormula = async (formula) => {
    const text = String(formula ?? "").trim();
    if (!text) return null;
    try {
      const roll = await (new Roll(text)).evaluate();
      const reduction = Math.max(0, Math.floor(Number(roll.total ?? 0)));
      if (reduction <= 0) return { reduction: 0 };
      const effectData = {
        name: "Environment: Max HP Reduction",
        img: assignment?.preset?.icon ?? "icons/svg/skull.svg",
        origin: `${ENVIRONMENT_EFFECT_ORIGIN}.failure`,
        disabled: false,
        transfer: false,
        duration: {
          seconds: 86400,
          startTime: Number(game.time?.worldTime ?? 0)
        },
        changes: [
          {
            key: "system.attributes.hp.max",
            mode: CONST.ACTIVE_EFFECT_MODES.ADD,
            value: String(-reduction),
            priority: 20
          }
        ],
        flags: {
          [MODULE_ID]: {
            environmentFailure: true,
            maxHpReduction: reduction
          }
        }
      };
      await tokenDoc.actor.createEmbeddedDocuments("ActiveEffect", [effectData]);
      return { reduction };
    } catch (error) {
      console.warn(`${MODULE_ID}: failed to apply max HP reduction formula '${text}'`, error);
      return null;
    }
  };

  const applyCustomDaeChange = async (changeKey, changeMode, changeValue) => {
    const key = String(changeKey ?? "").trim();
    const value = String(changeValue ?? "").trim();
    if (!key || !value) return;
    const rawMode = Math.floor(Number(changeMode ?? CONST.ACTIVE_EFFECT_MODES.ADD));
    const validModes = new Set(Object.values(CONST.ACTIVE_EFFECT_MODES ?? {}).map((entry) => Number(entry)));
    const mode = validModes.has(rawMode) ? rawMode : Number(CONST.ACTIVE_EFFECT_MODES.ADD);
    const effectData = {
      name: "Environment: Successive Failure DAE",
      img: assignment?.preset?.icon ?? "icons/svg/aura.svg",
      origin: `${ENVIRONMENT_EFFECT_ORIGIN}.successive`,
      disabled: false,
      transfer: false,
      duration: {
        seconds: 86400,
        startTime: Number(game.time?.worldTime ?? 0)
      },
      changes: [
        {
          key,
          mode,
          value,
          priority: 20
        }
      ],
      flags: {
        [MODULE_ID]: {
          environmentFailure: true,
          successiveFailure: true,
          daeChange: true
        }
      }
    };
    await tokenDoc.actor.createEmbeddedDocuments("ActiveEffect", [effectData]);
  };

  const statusId = String(assignment.failStatusId ?? "").trim();
  if (statusId) await toggleStatusOn(statusId);
  if (failedByFive) {
    const failBy5StatusId = String(assignment.failBy5StatusId ?? "").trim();
    if (failBy5StatusId) await toggleStatusOn(failBy5StatusId);
  }

  const slideFeet = failedByFive
    ? Math.max(0, Number(assignment.failBy5SlideFeet ?? assignment.failSlideFeet ?? 0) || 0)
    : Math.max(0, Number(assignment.failSlideFeet ?? 0) || 0);
  if (slideFeet > 0) await slideTokenByFeet(slideFeet);
  if (slideFeet > 0) summaryParts.push(`Slide ${slideFeet} ft`);

  const speedZeroTurns = Math.max(0, Number(assignment.failSpeedZeroTurns ?? 0) || 0);
  if (speedZeroTurns > 0) await applyTemporarySpeedZero(speedZeroTurns);
  if (speedZeroTurns > 0) summaryParts.push(`Speed 0 for ${speedZeroTurns} turn(s)`);

  await applyExhaustionLevels(Number(assignment.failExhaustion ?? 0));
  if (Number(assignment.failExhaustion ?? 0) > 0) summaryParts.push(`Exhaustion +${Number(assignment.failExhaustion ?? 0)}`);

  const damageFormula = failedByFive
    ? String(assignment.failBy5DamageFormula ?? assignment.failDamageFormula ?? "")
    : String(assignment.failDamageFormula ?? "");
  const damageType = failedByFive
    ? String(assignment.failBy5DamageType ?? assignment.failDamageType ?? "")
    : String(assignment.failDamageType ?? "");
  const damageResult = await applyDamageFormula(damageFormula, damageType);

  if (failedByFive) {
    await applyMaxHpReductionFormula(String(assignment.failBy5MaxHpReductionFormula ?? ""));
    if (String(assignment.failBy5MaxHpReductionFormula ?? "").trim()) {
      summaryParts.push(`Max HP reduction: ${String(assignment.failBy5MaxHpReductionFormula ?? "").trim()}`);
    }
  }

  if (successiveFailure) {
    const successiveFailStatusId = String(assignment.successiveFailStatusId ?? "").trim();
    if (successiveFailStatusId) await toggleStatusOn(successiveFailStatusId);

    const successiveSlideFeet = Math.max(0, Number(assignment.successiveFailSlideFeet ?? 0) || 0);
    if (successiveSlideFeet > 0) await slideTokenByFeet(successiveSlideFeet);
    if (successiveSlideFeet > 0) summaryParts.push(`Successive slide ${successiveSlideFeet} ft`);

    await applyExhaustionLevels(Number(assignment.successiveFailExhaustion ?? 0));
    if (Number(assignment.successiveFailExhaustion ?? 0) > 0) {
      summaryParts.push(`Successive exhaustion +${Number(assignment.successiveFailExhaustion ?? 0)}`);
    }

    const successiveDamageResult = await applyDamageFormula(
      String(assignment.successiveFailDamageFormula ?? ""),
      String(assignment.successiveFailDamageType ?? "")
    );
    if (successiveDamageResult?.amount > 0) {
      const gmIds = ChatMessage.getWhisperRecipients("GM").map((user) => user.id);
      const typed = successiveDamageResult.damageType ? ` ${successiveDamageResult.damageType}` : "";
      await ChatMessage.create({
        speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
        whisper: gmIds,
        content: `<p><strong>${tokenDoc.actor?.name ?? "Actor"}</strong> suffers ${successiveDamageResult.amount}${typed} damage from successive ${assignment?.preset?.label ?? "environment"} failure (streak ${failStreak}).</p>`
      });
    }

    await applyMaxHpReductionFormula(String(assignment.successiveFailMaxHpReductionFormula ?? ""));
    if (String(assignment.successiveFailMaxHpReductionFormula ?? "").trim()) {
      summaryParts.push(`Successive max HP reduction: ${String(assignment.successiveFailMaxHpReductionFormula ?? "").trim()}`);
    }
    await applyCustomDaeChange(
      assignment.successiveFailDaeChangeKey,
      assignment.successiveFailDaeChangeMode,
      assignment.successiveFailDaeChangeValue
    );
    if (String(assignment.successiveFailDaeChangeKey ?? "").trim() && String(assignment.successiveFailDaeChangeValue ?? "").trim()) {
      summaryParts.push(`DAE ${String(assignment.successiveFailDaeChangeKey ?? "").trim()} ${getActiveEffectModeLabel(assignment.successiveFailDaeChangeMode)} ${String(assignment.successiveFailDaeChangeValue ?? "").trim()}`);
    }
  }

  if (damageResult?.amount > 0) {
    const gmIds = ChatMessage.getWhisperRecipients("GM").map((user) => user.id);
    const typed = damageResult.damageType ? ` ${damageResult.damageType}` : "";
    await ChatMessage.create({
      speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
      whisper: gmIds,
      content: `<p><strong>${tokenDoc.actor?.name ?? "Actor"}</strong> suffers ${damageResult.amount}${typed} damage from ${assignment?.preset?.label ?? "environment"}.</p>`
    });
    summaryParts.push(`Damage ${damageResult.amount}${damageResult.damageType ? ` ${damageResult.damageType}` : ""}`);
  }

  return { summary: summaryParts.join(" - ") };
}

async function promptEnvironmentMovementCheck(tokenDoc, actor, assignment, movementContext = null) {
  if (!canAccessAllPlayerOps() || !actor || !assignment?.preset?.movementCheck) return;
  const preset = assignment.preset;
  const dc = Math.max(1, Math.floor(Number(assignment.movementDc ?? 12) || 12));
  const check = getEnvironmentCheckMeta(preset);
  const request = `${check.checkType}:${check.checkKey}`;
  const flavor = `${preset.label} movement ${check.checkType === "save" ? "save" : "check"} (${check.checkLabel})`;

  let total = null;
  let passed = null;

  if (isMonksTokenBarActive()) {
    try {
      const monksResult = await requestMonksActorCheck(actor, request, dc, flavor, { showDc: false });
      total = Number(monksResult?.total);
      if (Number.isFinite(total)) passed = total >= dc;
      else if (typeof monksResult?.passed === "boolean") passed = monksResult.passed;
    } catch (error) {
      console.warn(`${MODULE_ID}: monks movement check request failed`, error);
    }
  }

  if (!Number.isFinite(total) && check.checkType === "save" && typeof actor.rollAbilitySave === "function") {
    try {
      const roll = await actor.rollAbilitySave(check.checkKey, { fastForward: true, chatMessage: false });
      total = Number(roll?.total ?? roll?.roll?.total);
      if (Number.isFinite(total)) passed = total >= dc;
    } catch (error) {
      console.warn(`${MODULE_ID}: native movement save failed`, error);
    }
  } else if (!Number.isFinite(total) && typeof actor.rollSkill === "function") {
    try {
      const roll = await actor.rollSkill(check.checkKey, { fastForward: true, chatMessage: false });
      total = Number(roll?.total ?? roll?.roll?.total);
      if (Number.isFinite(total)) passed = total >= dc;
    } catch (error) {
      console.warn(`${MODULE_ID}: native movement check failed`, error);
    }
  }

  if (!Number.isFinite(total) && typeof passed !== "boolean") return;
  const failed = typeof passed === "boolean" ? !passed : (Number.isFinite(total) ? total < dc : false);

  let failureSummary = "";
  let predictedStreak = 0;
  if (failed) {
    const ledger = getOperationsLedger();
    const environment = ensureEnvironmentState(ledger);
    predictedStreak = Math.max(1, Math.max(0, Number(environment.failureStreaks?.[actor.id] ?? 0) || 0) + 1);
    const consequence = await applyEnvironmentFailureConsequences(tokenDoc, assignment, {
      ...(movementContext ?? {}),
      rollTotal: Number.isFinite(total) ? total : null,
      dc,
      failStreak: predictedStreak
    });
    failureSummary = String(consequence?.summary ?? "").trim();
  }

  const streakState = await recordEnvironmentCheckResult(actor, assignment, {
    failed,
    rollTotal: Number.isFinite(total) ? total : null,
    dc,
    outcomeSummary: failed ? (failureSummary || `Failed by ${Math.max(0, dc - Number(total || 0))}`) : "Success"
  });

  const gmIds = ChatMessage.getWhisperRecipients("GM").map((user) => user.id);
  const resultText = failed ? "Fail" : "Success";
  const totalText = Number.isFinite(total) ? ` (${total})` : "";
  const streakText = failed
    ? ` - Fail Streak ${streakState.next}`
    : (streakState.previous > 0 ? " - Fail Streak Reset" : "");
  await ChatMessage.create({
    speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
    whisper: gmIds,
    content: `<p><strong>${actor.name}</strong> ${flavor}: ${resultText}${totalText}${streakText}</p>`
  });
}

async function maybePromptEnvironmentMovementCheck(tokenDoc, changed, options = {}) {
  if (!canAccessAllPlayerOps()) return;
  if (options?.poEnvironmentClamp) return;
  if (!changed || (changed.x === undefined && changed.y === undefined)) return;
  const actor = tokenDoc?.actor;
  if (!actor) return;

  const assignment = getActorEnvironmentAssignment(actor.id);
  if (!assignment?.preset?.movementCheck) return;

  const now = Date.now();
  const last = Number(environmentMovePromptByActor.get(actor.id) ?? 0);
  if (now - last < ENVIRONMENT_MOVE_PROMPT_COOLDOWN_MS) return;
  environmentMovePromptByActor.set(actor.id, now);

  const origin = environmentMoveOriginByToken.get(tokenDoc.id) ?? { x: Number(tokenDoc.x ?? 0), y: Number(tokenDoc.y ?? 0) };
  environmentMoveOriginByToken.delete(tokenDoc.id);
  const destination = {
    x: Number(changed.x ?? tokenDoc.x ?? 0),
    y: Number(changed.y ?? tokenDoc.y ?? 0)
  };

  await promptEnvironmentMovementCheck(tokenDoc, actor, assignment, { origin, destination });
}

function triggerGatherResourceButtonAnimation(element) {
  const button = element?.closest?.("[data-action='gather-resource-check']");
  if (!(button instanceof HTMLElement)) return;
  button.classList.remove("is-firing");
  void button.offsetWidth;
  button.classList.add("is-firing");
  window.setTimeout(() => {
    button.classList.remove("is-firing");
  }, 520);
}

async function runGatherResourceCheck() {
  return runGatherResourcesAction({ showDialog: true });
}

async function runGatherPresetAction(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can run gather resource presets.");
    return { ok: false, blocked: true, reason: "GM only." };
  }
  const presetId = String(element?.dataset?.presetId ?? "").trim();
  const preset = getGatherQuickPresetById(presetId);
  if (!preset) {
    ui.notifications?.warn("Gather preset not found.");
    return { ok: false, blocked: true, reason: "Preset not found." };
  }
  return runGatherResourcesAction({
    showDialog: true,
    ...foundry.utils.deepClone(preset.options ?? {}),
    applyToLedger: true
  });
}

function setGatherHistoryViewFromElement(element) {
  const filterKey = String(element?.dataset?.filterKey ?? "").trim().toLowerCase();
  if (!filterKey) return getGatherHistoryViewState();
  const value = String(element?.value ?? "");
  switch (filterKey) {
    case "search":
      return setGatherHistoryViewState({ search: value });
    case "result":
      return setGatherHistoryViewState({ result: value });
    case "resource":
      return setGatherHistoryViewState({ resource: value });
    case "environment":
      return setGatherHistoryViewState({ environment: value });
    case "actor":
      return setGatherHistoryViewState({ actor: value });
    case "sort":
      return setGatherHistoryViewState({ sort: value });
    default:
      return getGatherHistoryViewState();
  }
}

function clearGatherHistoryFilters() {
  return setGatherHistoryViewState({
    search: "",
    result: "all",
    resource: "all",
    environment: "all",
    actor: "all",
    sort: "newest"
  });
}

async function clearGatherHistoryAction() {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can clear gather history.");
    return false;
  }
  const ledger = getOperationsLedger();
  const resources = foundry.utils.deepClone(ledger.resources ?? {});
  ensureOperationalResourceConfig(resources);
  const count = Array.isArray(resources.gather?.history) ? resources.gather.history.length : 0;
  if (count <= 0) {
    ui.notifications?.info("No gather history to clear.");
    return false;
  }
  const confirmed = await Dialog.confirm({
    title: "Clear Gather History",
    content: "<p>Are you sure you want to delete all the history?</p>"
  });
  if (!confirmed) return false;
  await updateOperationsLedger((ledger) => {
    if (!ledger.resources) ledger.resources = {};
    ensureOperationalResourceConfig(ledger.resources);
    ledger.resources.gather.history = [];
  });
  ui.notifications?.info(`Cleared ${count} gather history entr${count === 1 ? "y" : "ies"}.`);
  return true;
}

async function removeGatherHistoryEntryAction(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can remove gather history entries.");
    return false;
  }
  const historyId = String(element?.dataset?.historyId ?? "").trim();
  if (!historyId) {
    ui.notifications?.warn("Gather history entry not found.");
    return false;
  }
  let removed = false;
  await updateOperationsLedger((ledger) => {
    if (!ledger.resources) ledger.resources = {};
    ensureOperationalResourceConfig(ledger.resources);
    const history = Array.isArray(ledger.resources.gather?.history) ? ledger.resources.gather.history : [];
    const nextHistory = history.filter((entry) => String(entry?.id ?? "").trim() !== historyId);
    removed = nextHistory.length !== history.length;
    ledger.resources.gather.history = nextHistory;
  });
  if (!removed) {
    ui.notifications?.warn("Gather history entry not found.");
    return false;
  }
  ui.notifications?.info("Gather history entry removed.");
  return true;
}

async function runGatherResourcesAction(options = {}) {
  const hasActorSelection = Boolean(options?.actorId || options?.actor?.id);
  const showDialog = options?.showDialog === true || !hasActorSelection;
  if (showDialog) {
    return promptGatherResourceDialog(options);
  }

  const result = await executeGatherResourcesAction(options);
  if (result?.ok && !result?.historyRecorded) {
    const historyRecorded = await ensureGatherHistoryRecorded(result);
    result.historyRecorded = historyRecorded;
    if (!historyRecorded && options?.silent !== true) {
      ui.notifications?.warn("Gather check resolved, but the history entry could not be recorded.");
    }
  }
  if (result?.ok) refreshOpenApps();
  if (!result?.ok && result?.blocked && options?.silent !== true) {
    ui.notifications?.warn(String(result?.reason ?? "Gather attempt blocked."));
  }
  return result;
}

async function promptGatherResourceDialog(options = {}) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can run gather resource checks.");
    return { ok: false, blocked: true, reason: "GM only." };
  }

  const actors = getResourceSyncActors().sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""));
  if (actors.length === 0) {
    ui.notifications?.warn("No eligible party actors found for gather checks.");
    return { ok: false, blocked: true, reason: "No eligible actors." };
  }

  const config = getGatherResourceConfig();
  if (!config.enabled) {
    ui.notifications?.warn("Gather resources is disabled in module settings.");
    return { ok: false, blocked: true, reason: "Gather resources disabled." };
  }

  const actorOptions = actors
    .map((actor) => `<option value="${actor.id}" ${String(options?.actorId ?? "") === String(actor.id) ? "selected" : ""}>${poEscapeHtml(actor.name)}</option>`)
    .join("");
  const environmentOptions = getGatherEnvironmentChoices(config)
    .map((entry) => `<option value="${entry.value}" ${normalizeGatherEnvironmentKey(options?.environment ?? GATHER_ENVIRONMENT_KEYS[0]) === entry.value ? "selected" : ""}>${poEscapeHtml(entry.label)}</option>`)
    .join("");

  const resourceType = normalizeGatherResourceType(options?.resourceType);
  const travelTradeoff = normalizeGatherTravelTradeoff(options?.travelTradeoff ?? config.travelTradeoffDefault);
  const gatherMode = String(options?.gatherMode ?? "standard").trim().toLowerCase() === "plant" ? "plant" : "standard";
  const content = `
    <div class="form-group">
      <label>Gathering Actor</label>
      <select name="actorId">${actorOptions}</select>
    </div>
    <div class="form-group">
      <label>Resource Type</label>
      <select name="resourceType">
        <option value="food" ${resourceType === "food" ? "selected" : ""}>Food</option>
        <option value="water" ${resourceType === "water" ? "selected" : ""}>Water</option>
      </select>
    </div>
    <div class="form-group">
      <label>Gather Environment</label>
      <select name="environment">${environmentOptions}</select>
    </div>
    <div class="form-group">
      <label>Gather Mode</label>
      <select name="gatherMode">
        <option value="standard" ${gatherMode === "standard" ? "selected" : ""}>Standard Search</option>
        <option value="plant" ${gatherMode === "plant" ? "selected" : ""}>Plant Gathering</option>
      </select>
    </div>
    <div class="form-group">
      <label>Hours Spent</label>
      <input type="number" name="hoursSpent" value="${Math.max(1, Number(options?.hoursSpent ?? config.minimumHours) || config.minimumHours)}" min="1" max="24" step="1" />
    </div>
    <div class="form-group">
      <label>Season Modifier</label>
      <input type="number" name="seasonMod" value="${clampGatherModifier(options?.seasonMod ?? config.seasonMod, config.seasonMod)}" min="-10" max="10" step="1" />
    </div>
    <div class="form-group">
      <label>Weather Modifier</label>
      <input type="number" name="weatherMod" value="${clampGatherModifier(options?.weatherMod ?? config.weatherMod, config.weatherMod)}" min="-10" max="10" step="1" />
    </div>
    <div class="form-group">
      <label>Corruption Modifier</label>
      <input type="number" name="corruptionMod" value="${clampGatherModifier(options?.corruptionMod ?? config.corruptionMod, config.corruptionMod)}" min="-10" max="10" step="1" />
    </div>
    <div class="form-group">
      <label><input type="checkbox" name="isCorruptedRegion" ${options?.isCorruptedRegion ? "checked" : ""} /> Corrupted Region</label>
      <label><input type="checkbox" name="hostileTerrain" ${options?.hostileTerrain ? "checked" : ""} /> Hostile Terrain</label>
      <label><input type="checkbox" name="waterAutoFound" ${(options?.waterAutoFound ?? config.waterAutoFoundEnabled) ? "checked" : ""} ${config.waterAutoFoundEnabled ? "" : "disabled"} /> Obvious Water Source (auto-found)</label>
      <label><input type="checkbox" name="duringTravel" ${options?.duringTravel ? "checked" : ""} /> Gather During Travel</label>
      <label><input type="checkbox" name="applyToLedger" ${(options?.applyToLedger ?? true) ? "checked" : ""} /> Apply Rations To Party Pools</label>
    </div>
    <div class="form-group">
      <label>Travel Tradeoff</label>
      <select name="travelTradeoff">
        <option value="${GATHER_TRAVEL_CHOICES.PACE}" ${travelTradeoff === GATHER_TRAVEL_CHOICES.PACE ? "selected" : ""}>Reduce pace by one step</option>
        <option value="${GATHER_TRAVEL_CHOICES.FELL_BEHIND}" ${travelTradeoff === GATHER_TRAVEL_CHOICES.FELL_BEHIND ? "selected" : ""}>Fell behind + Con save</option>
      </select>
    </div>
    <div class="form-group">
      <label>Effective DC Preview</label>
      <div><strong data-gather-dc-preview>-</strong></div>
    </div>
  `;

  const dialog = new Dialog({
    title: "Gather Resources",
    content,
    buttons: {
      roll: {
        label: "Run Gather Check",
        callback: async (html) => {
          const actorId = String(html.find("select[name=actorId]").val() ?? "").trim();
          const payload = {
            actorId,
            resourceType: String(html.find("select[name=resourceType]").val() ?? "food"),
            environment: String(html.find("select[name=environment]").val() ?? GATHER_ENVIRONMENT_KEYS[0]),
            gatherMode: String(html.find("select[name=gatherMode]").val() ?? "standard"),
            hoursSpent: Number(html.find("input[name=hoursSpent]").val() ?? config.minimumHours),
            seasonMod: Number(html.find("input[name=seasonMod]").val() ?? config.seasonMod),
            weatherMod: Number(html.find("input[name=weatherMod]").val() ?? config.weatherMod),
            corruptionMod: Number(html.find("input[name=corruptionMod]").val() ?? config.corruptionMod),
            isCorruptedRegion: Boolean(html.find("input[name=isCorruptedRegion]").is(":checked")),
            hostileTerrain: Boolean(html.find("input[name=hostileTerrain]").is(":checked")),
            waterAutoFound: Boolean(html.find("input[name=waterAutoFound]").is(":checked")),
            duringTravel: Boolean(html.find("input[name=duringTravel]").is(":checked")),
            travelTradeoff: String(html.find("select[name=travelTradeoff]").val() ?? config.travelTradeoffDefault),
            applyToLedger: Boolean(html.find("input[name=applyToLedger]").is(":checked"))
          };
          const result = await runGatherResourcesAction(payload);
          if (!result?.ok && result?.blocked) {
            ui.notifications?.warn(String(result?.reason ?? "Gather attempt blocked."));
            return;
          }
          ui.notifications?.info(`Gather check resolved for ${result?.actorName ?? "actor"}.`);
        }
      },
      cancel: { label: "Cancel" }
    },
    default: "roll"
  });
  wireGatherDcPreview(dialog, config);
  dialog.render(true);
  return { ok: true, blocked: false, prompted: true };
}

async function setReconField(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update recon planning.");
    return;
  }
  const field = String(element?.dataset?.reconField ?? "").trim();
  if (!field) return;

  await updateOperationsLedger((ledger) => {
    const recon = ensureReconState(ledger);
    if (field === "objective" || field === "region" || field === "intelSource" || field === "recentFindings") {
      recon[field] = String(element?.value ?? "");
      return;
    }
    if (field === "heatLevel") {
      const value = String(element?.value ?? "moderate").trim().toLowerCase();
      recon.heatLevel = ["low", "moderate", "high"].includes(value) ? value : "moderate";
      return;
    }
    if (field === "network") {
      const value = String(element?.value ?? "limited").trim().toLowerCase();
      recon.network = ["limited", "established", "deep"].includes(value) ? value : "limited";
      return;
    }
    if (field === "rumorReliability") {
      const value = Number(element?.value ?? 50);
      recon.rumorReliability = Number.isFinite(value) ? Math.max(0, Math.min(100, Math.floor(value))) : 50;
      return;
    }
    if (field === "bribeBudget") {
      const value = Number(element?.value ?? 0);
      recon.bribeBudget = Number.isFinite(value) ? Math.max(0, Math.floor(value)) : 0;
      return;
    }
    if (field === "spySlots") {
      const value = Number(element?.value ?? 0);
      recon.spySlots = Number.isFinite(value) ? Math.max(0, Math.floor(value)) : 0;
    }
  });
}

async function runReconCheck() {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can run recon checks.");
    return;
  }

  const ledger = getOperationsLedger();
  const recon = buildReconContext(ensureReconState(ledger));
  const fallbackActor = getOwnedPcActors()
    .sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""))[0];
  const reconActor = game.actors.get(String(ledger.roles?.cartographer ?? "")) ?? fallbackActor;
  if (!reconActor) {
    ui.notifications?.warn("No eligible actor found for recon check.");
    return;
  }

  const dc = recon.suggestedDc;
  let total = 0;
  try {
    if (typeof reconActor.rollSkill === "function") {
      const roll = await reconActor.rollSkill("inv", { fastForward: true, chatMessage: false });
      total = Number(roll?.total ?? roll?.roll?.total ?? 0);
    } else {
      const intMod = Number(reconActor.system?.abilities?.int?.mod ?? 0);
      const roll = await (new Roll("1d20 + @mod", { mod: intMod })).evaluate();
      total = Number(roll.total ?? 0);
    }
  } catch (error) {
    console.warn(`${MODULE_ID}: recon check failed`, error);
    ui.notifications?.warn("Recon check failed to resolve.");
    return;
  }

  const passed = Number.isFinite(total) && total >= dc;
  const summary = `${reconActor.name}: ${passed ? "Success" : "Fail"} (${Math.floor(Number(total) || 0)} vs DC ${dc})`;
  const insight = passed
    ? "Recon success: lower entry uncertainty before first contact."
    : "Recon miss: proceed with increased unknowns and tighter fallback planning.";
  const stamp = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });

  await updateOperationsLedger((nextLedger) => {
    const nextRecon = ensureReconState(nextLedger);
    const nextFindings = `${stamp} ${summary}`;
    nextRecon.recentFindings = nextFindings;
    nextRecon.lastBriefAt = stamp;
    nextRecon.lastBriefBy = String(game.user?.name ?? "GM");
  });

  await ChatMessage.create({
    speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
    content: `<p><strong>Recon Check</strong></p><p><strong>Actor:</strong> ${poEscapeHtml(reconActor.name)}</p><p><strong>Result:</strong> ${passed ? "Success" : "Failure"} (${Math.floor(Number(total) || 0)} vs DC ${dc})</p><p>${poEscapeHtml(insight)}</p>`
  });
}

async function showReconBrief() {
  const recon = buildOperationsContext().recon;
  const recommendationRows = recon.recommendations.map((entry) => `<li>${poEscapeHtml(entry)}</li>`).join("");
  const content = `
    <div class="po-help">
      <p><strong>Readiness:</strong> ${poEscapeHtml(recon.readinessLabel)} (score ${recon.readinessScore})</p>
      <p><strong>Suggested Recon DC:</strong> ${recon.suggestedDc}</p>
      <p><strong>Objective:</strong> ${poEscapeHtml(recon.objective || "-")}</p>
      <p><strong>Region:</strong> ${poEscapeHtml(recon.region || "-")}</p>
      <p><strong>Source:</strong> ${poEscapeHtml(recon.intelSource || "-")}</p>
      <p><strong>Recent Findings:</strong> ${poEscapeHtml(recon.recentFindings || "-")}</p>
      <ul>${recommendationRows || "<li>No recommendations.</li>"}</ul>
    </div>
  `;
  await Dialog.prompt({
    title: "Recon Brief",
    content,
    rejectClose: false,
    callback: () => {}
  });
}

async function setCommunicationToggle(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update communication discipline.");
    return;
  }
  const key = element?.dataset?.comm;
  if (!key) return;
  await updateOperationsLedger((ledger) => {
    if (!ledger.communication) ledger.communication = {};
    ledger.communication[key] = Boolean(element?.checked);
  });
}

async function setCommunicationText(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update communication discipline.");
    return;
  }
  const key = element?.dataset?.commText;
  if (!key) return;
  const value = String(element?.value ?? "").trim();
  await updateOperationsLedger((ledger) => {
    if (!ledger.communication) ledger.communication = {};
    ledger.communication[key] = value;
  });
}

async function showCommunicationBrief() {
  const context = buildOperationsContext();
  const comm = context.communication;
  const readiness = comm.readiness;
  const content = `
    <div class="po-help">
      <p><strong>Communication Discipline:</strong> ${readiness.statusText}</p>
      <p><strong>Silent Signals:</strong> ${readiness.hasSignals ? "Set" : "Missing"}</p>
      <p><strong>Code Phrase:</strong> ${readiness.hasCodePhrase ? "Set" : "Missing"}</p>
      <p><strong>Alert Channels:</strong> ${readiness.enabledCount} enabled</p>
      <p><strong>Flare Plan:</strong> ${comm.signalFlare ? "Enabled" : "Off"}</p>
      <p><strong>Bell Plan:</strong> ${comm.signalBell ? "Enabled" : "Off"}</p>
      <p><strong>Pre-Combat Plan:</strong> ${comm.preCombatPlan ? "Enabled" : "Off"}</p>
      <p><strong>Signal Set:</strong> ${comm.silentSignals || "-"}</p>
      <p><strong>Code Phrase:</strong> ${comm.codePhrase || "-"}</p>
    </div>
  `;
  await Dialog.prompt({
    title: "Communication Brief",
    content,
    rejectClose: false,
    callback: () => {}
  });
}

async function setReputationScore(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update reputation.");
    return;
  }
  const faction = String(element?.dataset?.faction ?? "").trim();
  if (!faction) return;
  const raw = Number(element?.value ?? 0);
  const score = Number.isFinite(raw) ? Math.max(-5, Math.min(5, Math.floor(raw))) : 0;
  await updateOperationsLedger((ledger) => {
    const reputation = ensureReputationState(ledger);
    const entry = reputation.factions.find((row) => row.id === faction);
    if (!entry) return;
    entry.score = score;
  });
}

async function adjustReputationScore(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update reputation.");
    return;
  }
  const faction = String(element?.dataset?.faction ?? "").trim();
  if (!faction) return;
  const deltaRaw = Number(element?.dataset?.delta ?? 0);
  const delta = Number.isFinite(deltaRaw) ? Math.floor(deltaRaw) : 0;
  if (!delta) return;
  await updateOperationsLedger((ledger) => {
    const reputation = ensureReputationState(ledger);
    const entry = reputation.factions.find((row) => row.id === faction);
    if (!entry) return;
    entry.score = Math.max(-5, Math.min(5, Number(entry.score ?? 0) + delta));
  });
}

async function setReputationNote(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update reputation.");
    return;
  }
  const faction = String(element?.dataset?.faction ?? "").trim();
  if (!faction) return;
  const note = String(element?.value ?? "");
  await updateOperationsLedger((ledger) => {
    const reputation = ensureReputationState(ledger);
    const entry = reputation.factions.find((row) => row.id === faction);
    if (!entry) return;
    entry.note = note;
  });
}

function buildReputationCalendarPayload(faction, logEntry) {
  const now = Number(logEntry?.loggedAt ?? getCurrentWorldTimestamp());
  const score = Number(logEntry?.score ?? 0);
  const signedScore = score > 0 ? `+${score}` : String(score);
  const title = `Reputation Update: ${String(faction?.label ?? "Faction")}`;
  const body = [
    `<p><strong>Faction:</strong> ${poEscapeHtml(String(faction?.label ?? "Faction"))}</p>`,
    `<p><strong>Reputation:</strong> ${signedScore} (${poEscapeHtml(getReputationAccessLabel(score))})</p>`,
    `<p><strong>Logged:</strong> ${poEscapeHtml(String(logEntry?.dayLabel ?? formatRecoveryDueLabel(now)))}</p>`,
    `<p><strong>Note:</strong> ${poEscapeHtml(String(logEntry?.note ?? ""))}</p>`
  ].join("");
  return {
    title,
    name: title,
    description: body,
    content: body,
    startTime: now,
    endTime: now + 60,
    timestamp: now,
    allDay: false,
    playerVisible: true,
    public: true
  };
}

async function syncReputationLogToSimpleCalendar(faction, logEntry) {
  if (!canAccessAllPlayerOps() || !isSimpleCalendarActive()) return "";
  const api = getSimpleCalendarMutationApi();
  if (!api) return "";
  const created = await createSimpleCalendarEntry(api, buildReputationCalendarPayload(faction, logEntry));
  return created?.success ? String(created.id ?? "") : "";
}

async function logReputationNote(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update reputation.");
    return;
  }
  const factionId = String(element?.dataset?.faction ?? "").trim();
  if (!factionId) return;
  const root = element?.closest(".po-op-role-row[data-faction]") ?? element?.closest(".po-op-role-row");
  const note = String(root?.querySelector("textarea[data-action='set-reputation-note']")?.value ?? "").trim();
  if (!note) {
    ui.notifications?.warn("Add a note before logging reputation history.");
    return;
  }

  const loggedAt = Date.now();
  const dayLabel = formatRecoveryDueLabel(loggedAt);
  const clock = getClockContext();
  let createdLog = null;
  let factionLabel = "Faction";

  await updateOperationsLedger((ledger) => {
    const reputation = ensureReputationState(ledger);
    const entry = reputation.factions.find((row) => row.id === factionId);
    if (!entry) return;
    factionLabel = String(entry.label ?? "Faction");
    if (!Array.isArray(entry.noteLogs)) entry.noteLogs = [];
    const logEntry = normalizeReputationNoteLog({
      id: foundry.utils.randomID(),
      note,
      score: Number(entry.score ?? 0),
      loggedAt,
      loggedBy: String(game.user?.name ?? "GM"),
      dayLabel,
      clockLabel: String(clock?.label ?? "")
    });
    entry.noteLogs.unshift(logEntry);
    if (entry.noteLogs.length > 100) entry.noteLogs = entry.noteLogs.slice(0, 100);
    entry.note = "";
    createdLog = logEntry;
  });

  if (!createdLog) return;
  setReputationNoteLogSelection(factionId, "");
  const calendarEntryId = await syncReputationLogToSimpleCalendar({ label: factionLabel }, createdLog);
  if (calendarEntryId) {
    await updateOperationsLedger((ledger) => {
      const reputation = ensureReputationState(ledger);
      const entry = reputation.factions.find((row) => row.id === factionId);
      if (!entry || !Array.isArray(entry.noteLogs)) return;
      const logRow = entry.noteLogs.find((row) => String(row.id ?? "") === String(createdLog.id ?? ""));
      if (!logRow) return;
      logRow.calendarEntryId = String(calendarEntryId);
    });
  }

  ui.notifications?.info(`Logged reputation note for ${factionLabel}.`);
  const signedScore = Number(createdLog.score ?? 0) > 0 ? `+${Number(createdLog.score)}` : String(Number(createdLog.score ?? 0));
  await ChatMessage.create({
    speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
    content: `<p><strong>Reputation Log:</strong> ${poEscapeHtml(factionLabel)} - ${signedScore}</p><p>${poEscapeHtml(String(createdLog.dayLabel ?? ""))}</p><p>${poEscapeHtml(String(createdLog.note ?? ""))}</p>`
  });
  await createOperationsJournalEntry({
    category: "reputation",
    sensitivity: "gm",
    title: `Reputation - ${factionLabel}`,
    summary: `Score ${signedScore} (${String(createdLog.dayLabel ?? "").trim() || "No date"})`,
    redactedSummary: `Reputation update logged for ${factionLabel}.`,
    body: `
      <p><strong>Faction:</strong> ${poEscapeHtml(factionLabel)}</p>
      <p><strong>Score:</strong> ${poEscapeHtml(signedScore)}</p>
      <p><strong>Day:</strong> ${poEscapeHtml(String(createdLog.dayLabel ?? ""))}</p>
      <p><strong>Note:</strong> ${poEscapeHtml(String(createdLog.note ?? ""))}</p>
    `,
    redactedBody: `
      <p><strong>Faction:</strong> ${poEscapeHtml(factionLabel)}</p>
      <p><strong>Score:</strong> ${poEscapeHtml(signedScore)}</p>
      <p><strong>Day:</strong> ${poEscapeHtml(String(createdLog.dayLabel ?? ""))}</p>
      <p><em>Detailed notes are redacted.</em></p>
    `
  });
}

async function loadReputationNoteLog(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update reputation.");
    return;
  }
  const factionId = String(element?.dataset?.faction ?? "").trim();
  const logId = String(element?.value ?? "").trim();
  if (!factionId) return;

  if (!logId) {
    setReputationNoteLogSelection(factionId, "");
    await updateOperationsLedger((ledger) => {
      const reputation = ensureReputationState(ledger);
      const entry = reputation.factions.find((row) => row.id === factionId);
      if (!entry) return;
      entry.note = "";
    });
    return;
  }

  let loaded = false;
  await updateOperationsLedger((ledger) => {
    const reputation = ensureReputationState(ledger);
    const entry = reputation.factions.find((row) => row.id === factionId);
    if (!entry || !Array.isArray(entry.noteLogs)) return;
    const logRow = entry.noteLogs.find((row) => String(row.id ?? "") === logId);
    if (!logRow) return;
    entry.note = String(logRow.note ?? "");
    loaded = true;
  });
  if (loaded) setReputationNoteLogSelection(factionId, logId);
  if (loaded) ui.notifications?.info("Loaded historical reputation note into editor.");
}

async function clearReputationNote(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update reputation.");
    return;
  }
  const factionId = String(element?.dataset?.faction ?? "").trim();
  if (!factionId) return;
  let cleared = false;
  await updateOperationsLedger((ledger) => {
    const reputation = ensureReputationState(ledger);
    const entry = reputation.factions.find((row) => row.id === factionId);
    if (!entry) return;
    if (!String(entry.note ?? "").length) return;
    entry.note = "";
    cleared = true;
  });
  if (cleared) ui.notifications?.info("Current faction note cleared.");
}

async function removeReputationNoteLog(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update reputation.");
    return;
  }
  const factionId = String(element?.dataset?.faction ?? "").trim();
  if (!factionId) return;
  const root = element?.closest(".po-op-role-row[data-faction]") ?? element?.closest(".po-op-role-row");
  const logSelect = root?.querySelector(`select[data-action='load-reputation-note-log'][data-faction='${factionId}']`)
    ?? root?.querySelector("select[data-action='load-reputation-note-log']");
  const selectedFromUi = String(logSelect?.value ?? "").trim();
  const selectedFromState = getReputationNoteLogSelection(factionId);
  const logId = selectedFromUi || selectedFromState;
  if (!logId) {
    ui.notifications?.warn("Select a logged note to delete.");
    return;
  }

  let removed = false;
  let removedCalendarEntryId = "";
  await updateOperationsLedger((ledger) => {
    const reputation = ensureReputationState(ledger);
    const entry = reputation.factions.find((row) => row.id === factionId);
    if (!entry || !Array.isArray(entry.noteLogs)) return;
    const target = entry.noteLogs.find((row) => String(row.id ?? "") === logId);
    if (!target) return;
    removedCalendarEntryId = String(target.calendarEntryId ?? "").trim();
    entry.noteLogs = entry.noteLogs.filter((row) => String(row.id ?? "") !== logId);
    removed = true;
  });

  if (removed && removedCalendarEntryId && isSimpleCalendarActive()) {
    const api = getSimpleCalendarMutationApi();
    if (api) {
      await removeSimpleCalendarEntry(api, removedCalendarEntryId);
    }
  }
  if (removed) setReputationNoteLogSelection(factionId, "");
  if (removed) ui.notifications?.info("Logged reputation note deleted.");
}

async function postReputationNoteLog(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can post reputation notes.");
    return;
  }
  const factionId = String(element?.dataset?.faction ?? "").trim();
  if (!factionId) return;
  const root = element?.closest(".po-op-role-row[data-faction]") ?? element?.closest(".po-op-role-row");
  const logSelect = root?.querySelector(`select[data-action='load-reputation-note-log'][data-faction='${factionId}']`)
    ?? root?.querySelector("select[data-action='load-reputation-note-log']");
  const selectedFromUi = String(logSelect?.value ?? "").trim();
  const selectedFromState = getReputationNoteLogSelection(factionId);
  const logId = selectedFromUi || selectedFromState;
  if (!logId) {
    ui.notifications?.warn("Select a logged note to post.");
    return;
  }

  const ledger = getOperationsLedger();
  const reputation = ensureReputationState(ledger);
  const entry = reputation.factions.find((row) => String(row?.id ?? "").trim() === factionId);
  if (!entry || !Array.isArray(entry.noteLogs)) {
    ui.notifications?.warn("Faction note log not found.");
    return;
  }
  const logRowRaw = entry.noteLogs.find((row) => String(row?.id ?? "").trim() === logId);
  if (!logRowRaw) {
    ui.notifications?.warn("Select a logged note to post.");
    return;
  }

  const logRow = normalizeReputationNoteLog(logRowRaw);
  setReputationNoteLogSelection(factionId, logId);
  const factionLabel = String(entry.label ?? "Faction").trim() || "Faction";
  const score = Math.max(-5, Math.min(5, Math.floor(Number(logRow.score ?? 0) || 0)));
  const scoreLabel = score > 0 ? `+${score}` : String(score);
  const dayLabel = String(logRow.dayLabel ?? "").trim() || formatRecoveryDueLabel(Number(logRow.loggedAt ?? Date.now()));
  const postedBy = String(game.user?.name ?? "GM").trim() || "GM";

  await ChatMessage.create({
    speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
    content: `
      <p><strong>Faction Update:</strong> ${poEscapeHtml(factionLabel)} - Rep ${poEscapeHtml(scoreLabel)} (${poEscapeHtml(getReputationAccessLabel(score))})</p>
      <p><strong>Logged:</strong> ${poEscapeHtml(dayLabel)}</p>
      <p>${poEscapeHtml(String(logRow.note ?? ""))}</p>
      <p><em>Posted by ${poEscapeHtml(postedBy)}</em></p>
    `
  });

  await createOperationsJournalEntry({
    category: "reputation",
    sensitivity: "player",
    title: `Faction Update - ${factionLabel}`,
    summary: `${factionLabel}: Rep ${scoreLabel} (${dayLabel})`,
    redactedSummary: `${factionLabel} reputation update posted.`,
    body: `
      <p><strong>Faction:</strong> ${poEscapeHtml(factionLabel)}</p>
      <p><strong>Score:</strong> ${poEscapeHtml(scoreLabel)} (${poEscapeHtml(getReputationAccessLabel(score))})</p>
      <p><strong>Logged:</strong> ${poEscapeHtml(dayLabel)}</p>
      <p><strong>Note:</strong> ${poEscapeHtml(String(logRow.note ?? ""))}</p>
      <p><strong>Posted by:</strong> ${poEscapeHtml(postedBy)}</p>
    `,
    redactedBody: `
      <p><strong>Faction:</strong> ${poEscapeHtml(factionLabel)}</p>
      <p><strong>Score:</strong> ${poEscapeHtml(scoreLabel)} (${poEscapeHtml(getReputationAccessLabel(score))})</p>
      <p><strong>Logged:</strong> ${poEscapeHtml(dayLabel)}</p>
      <p><strong>Posted by:</strong> ${poEscapeHtml(postedBy)}</p>
    `
  });

  ui.notifications?.info(`Posted selected note for ${factionLabel}.`);
}

async function setReputationLabel(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update reputation.");
    return;
  }
  const faction = String(element?.dataset?.faction ?? "").trim();
  if (!faction) return;
  const label = String(element?.value ?? "").trim();
  await updateOperationsLedger((ledger) => {
    const reputation = ensureReputationState(ledger);
    const entry = reputation.factions.find((row) => row.id === faction);
    if (!entry || entry.isCore) return;
    entry.label = label || "Faction";
  });
}

async function addReputationFaction(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update reputation.");
    return;
  }
  const root = element?.closest(".po-reputation-gm-tools") ?? element?.closest(".po-gm-section");
  const label = String(root?.querySelector("input[name='repFactionName']")?.value ?? "").trim();
  if (!label) {
    ui.notifications?.warn("Faction name is required.");
    return;
  }
  await updateOperationsLedger((ledger) => {
    const reputation = ensureReputationState(ledger);
    reputation.factions.push(normalizeReputationFaction({
      id: foundry.utils.randomID(),
      label,
      score: 0,
      note: "",
      noteLogs: [],
      isCore: false
    }));
  });
}

async function removeReputationFaction(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update reputation.");
    return;
  }
  const faction = String(element?.dataset?.faction ?? "").trim();
  if (!faction) return;
  await updateOperationsLedger((ledger) => {
    const reputation = ensureReputationState(ledger);
    const entry = reputation.factions.find((row) => row.id === faction);
    if (!entry || entry.isCore) return;
    reputation.factions = reputation.factions.filter((row) => row.id !== faction);
  });
  setReputationNoteLogSelection(faction, "");
}

async function showReputationBrief() {
  const reputation = buildOperationsContext().reputation;
  const rows = reputation.factions
    .map((faction) => `<li>${faction.label}: ${faction.score} (${faction.band}) - Access ${faction.access}${faction.note ? ` - ${faction.note}` : ""}</li>`)
    .join("");

  const content = `
    <div class="po-help">
      <p><strong>High Standing Factions:</strong> ${reputation.highStandingCount}</p>
      <p><strong>Hostile Factions:</strong> ${reputation.hostileCount}</p>
      <ul>${rows || "<li>No faction data.</li>"}</ul>
    </div>
  `;
  await Dialog.prompt({
    title: "Reputation & Faction Brief",
    content,
    rejectClose: false,
    callback: () => {}
  });
}

function getLootPackSourceMetaById(packId) {
  const id = String(packId ?? "").trim();
  if (!id) return null;
  return getAvailableLootItemPackSources().find((entry) => entry.id === id) ?? null;
}

function getLootTableSourceMetaById(tableId) {
  const id = String(tableId ?? "").trim();
  if (!id) return null;
  return getAvailableLootTableSources().find((entry) => entry.id === id) ?? null;
}

async function setLootManifestPack(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can configure loot sources.");
    return;
  }
  const packId = String(element?.value ?? "").trim();
  const validPackIds = new Set(getAvailableLootItemPackSources().map((entry) => String(entry?.id ?? "").trim()).filter(Boolean));
  const nextPackId = packId && validPackIds.has(packId) ? packId : "";
  await updateLootSourceConfig((config) => {
    if (!config.filters || typeof config.filters !== "object") config.filters = {};
    config.filters.manifestPackId = nextPackId;
  });
}

async function setLootKeywordIncludeTags(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can configure loot sources.");
    return;
  }
  const next = parseLootKeywordTagListFromInput(element?.value ?? "");
  await updateLootSourceConfig((config) => {
    if (!config.filters || typeof config.filters !== "object") config.filters = {};
    config.filters.keywordIncludeTags = next;
  });
}

async function setLootKeywordExcludeTags(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can configure loot sources.");
    return;
  }
  const next = parseLootKeywordTagListFromInput(element?.value ?? "");
  await updateLootSourceConfig((config) => {
    if (!config.filters || typeof config.filters !== "object") config.filters = {};
    config.filters.keywordExcludeTags = next;
  });
}

async function toggleLootPackSource(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can configure loot sources.");
    return;
  }
  const packId = String(element?.dataset?.packId ?? "").trim();
  if (!packId) return;
  const enabled = Boolean(element?.checked);
  const meta = getLootPackSourceMetaById(packId);

  await updateLootSourceConfig((config) => {
    if (!Array.isArray(config.packs)) config.packs = [];
    let row = config.packs.find((entry) => String(entry?.id ?? "") === packId);
    if (!row) {
      row = normalizeLootSourcePackEntry({
        id: packId,
        label: String(meta?.label ?? packId),
        sourceKind: String(meta?.sourceKind ?? "compendium-pack"),
        enabled,
        weight: 1
      });
      if (row) config.packs.push(row);
      return;
    }
    row.enabled = enabled;
    row.label = String(meta?.label ?? row.label ?? packId);
    row.sourceKind = String(meta?.sourceKind ?? row.sourceKind ?? "compendium-pack");
    row.weight = Math.max(1, Math.floor(Number(row.weight ?? 1) || 1));
  });
}

async function setLootPackWeight(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can configure loot sources.");
    return;
  }
  const packId = String(element?.dataset?.packId ?? "").trim();
  if (!packId) return;
  const weightRaw = Number(element?.value ?? 1);
  const weight = Number.isFinite(weightRaw) ? Math.max(1, Math.floor(weightRaw)) : 1;
  const meta = getLootPackSourceMetaById(packId);

  await updateLootSourceConfig((config) => {
    if (!Array.isArray(config.packs)) config.packs = [];
    let row = config.packs.find((entry) => String(entry?.id ?? "") === packId);
    if (!row) {
      row = normalizeLootSourcePackEntry({
        id: packId,
        label: String(meta?.label ?? packId),
        sourceKind: String(meta?.sourceKind ?? "compendium-pack"),
        enabled: false,
        weight
      });
      if (row) config.packs.push(row);
      return;
    }
    row.weight = weight;
    row.label = String(meta?.label ?? row.label ?? packId);
    row.sourceKind = String(meta?.sourceKind ?? row.sourceKind ?? "compendium-pack");
  });
}

async function toggleLootTableSource(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can configure loot sources.");
    return;
  }
  const tableId = String(element?.dataset?.tableId ?? "").trim();
  if (!tableId) return;
  const enabled = Boolean(element?.checked);
  const meta = getLootTableSourceMetaById(tableId);

  await updateLootSourceConfig((config) => {
    if (!Array.isArray(config.tables)) config.tables = [];
    let row = config.tables.find((entry) => String(entry?.id ?? "") === tableId);
    if (!row) {
      row = normalizeLootSourceTableEntry({
        id: tableId,
        label: String(meta?.label ?? tableId),
        sourceKind: String(meta?.sourceKind ?? "table-pack"),
        enabled,
        tableType: "currency"
      });
      if (row) config.tables.push(row);
      return;
    }
    row.enabled = enabled;
    row.label = String(meta?.label ?? row.label ?? tableId);
    row.sourceKind = String(meta?.sourceKind ?? row.sourceKind ?? "table-pack");
    if (!row.tableType) row.tableType = "currency";
  });
}

async function setLootTableType(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can configure loot sources.");
    return;
  }
  const tableId = String(element?.dataset?.tableId ?? "").trim();
  if (!tableId) return;
  const tableType = String(element?.value ?? "currency").trim().toLowerCase();
  const validTypes = new Set(LOOT_TABLE_TYPE_OPTIONS.map((entry) => entry.value));
  const nextType = validTypes.has(tableType) ? tableType : "currency";
  const meta = getLootTableSourceMetaById(tableId);

  await updateLootSourceConfig((config) => {
    if (!Array.isArray(config.tables)) config.tables = [];
    let row = config.tables.find((entry) => String(entry?.id ?? "") === tableId);
    if (!row) {
      row = normalizeLootSourceTableEntry({
        id: tableId,
        label: String(meta?.label ?? tableId),
        sourceKind: String(meta?.sourceKind ?? "table-pack"),
        enabled: false,
        tableType: nextType
      });
      if (row) config.tables.push(row);
      return;
    }
    row.tableType = nextType;
    row.label = String(meta?.label ?? row.label ?? tableId);
    row.sourceKind = String(meta?.sourceKind ?? row.sourceKind ?? "table-pack");
  });
}

async function toggleLootItemType(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can configure loot sources.");
    return;
  }
  const itemType = String(element?.dataset?.itemType ?? "").trim();
  if (!itemType) return;
  const enabled = Boolean(element?.checked);
  const validTypes = new Set(buildLootItemTypeCatalog().map((entry) => entry.value));
  if (!validTypes.has(itemType)) return;

  await updateLootSourceConfig((config) => {
    if (!config.filters || typeof config.filters !== "object") config.filters = {};
    const current = new Set(Array.isArray(config.filters.allowedTypes) ? config.filters.allowedTypes.map((entry) => String(entry ?? "").trim()) : []);
    if (enabled) current.add(itemType);
    else current.delete(itemType);
    config.filters.allowedTypes = Array.from(current).filter((entry) => validTypes.has(entry));
  });
}

async function setLootRarityFloor(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can configure loot sources.");
    return;
  }
  const rarityFloor = normalizeLootRarityValue(element?.value);
  await updateLootSourceConfig((config) => {
    if (!config.filters || typeof config.filters !== "object") config.filters = {};
    config.filters.rarityFloor = rarityFloor;
  });
}

async function setLootRarityCeiling(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can configure loot sources.");
    return;
  }
  const rarityCeiling = normalizeLootRarityValue(element?.value);
  await updateLootSourceConfig((config) => {
    if (!config.filters || typeof config.filters !== "object") config.filters = {};
    config.filters.rarityCeiling = rarityCeiling;
  });
}

async function resetLootSourceConfig() {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can configure loot sources.");
    return;
  }
  const defaults = buildDefaultLootSourceConfig();
  await updateLootSourceConfig((config) => {
    config.packs = foundry.utils.deepClone(defaults.packs);
    config.tables = foundry.utils.deepClone(defaults.tables);
    config.filters = foundry.utils.deepClone(defaults.filters);
  });
  ui.notifications?.info("Loot source configuration reset to defaults.");
}

function setLootPreviewField(element) {
  if (!canAccessAllPlayerOps()) return;
  const field = String(element?.dataset?.field ?? "").trim();
  if (!field) return;
  const normalizedField = field === "actorCount" ? "creatures" : field;
  const current = getLootPreviewDraft();
  const numericFields = new Set([
    "creatures",
    "actorCount",
    "currencyScalar",
    "itemScalar",
    "tableScalar",
    "valueBudgetScalar",
    "valueStrictness",
    "maxItemValueGp",
    "targetItemsValueGp"
  ]);
  const next = {
    ...current,
    [normalizedField]: (numericFields.has(normalizedField))
      ? Number(element?.value ?? current.creatures ?? current.actorCount ?? 1)
      : String(element?.value ?? current[normalizedField] ?? "")
  };
  setLootPreviewDraft(next);
}

function getActorCurrentCurrencyValue(actor, denom) {
  const key = String(denom ?? "").trim().toLowerCase();
  if (!actor || !["pp", "gp", "sp", "cp"].includes(key)) return 0;
  const node = actor.system?.currency?.[key];
  const raw = typeof node === "object" ? Number(node?.value) : Number(node);
  return Number.isFinite(raw) ? Math.max(0, Math.floor(raw)) : 0;
}

async function awardCurrencyBundleToActor(actor, bundle = {}) {
  if (!actor) return { pp: 0, gp: 0, sp: 0, cp: 0 };
  const awarded = {
    pp: Math.max(0, Math.floor(Number(bundle?.pp ?? 0) || 0)),
    gp: Math.max(0, Math.floor(Number(bundle?.gp ?? 0) || 0)),
    sp: Math.max(0, Math.floor(Number(bundle?.sp ?? 0) || 0)),
    cp: Math.max(0, Math.floor(Number(bundle?.cp ?? 0) || 0))
  };
  if (awarded.pp <= 0 && awarded.gp <= 0 && awarded.sp <= 0 && awarded.cp <= 0) return awarded;
  const next = {
    pp: getActorCurrentCurrencyValue(actor, "pp") + awarded.pp,
    gp: getActorCurrentCurrencyValue(actor, "gp") + awarded.gp,
    sp: getActorCurrentCurrencyValue(actor, "sp") + awarded.sp,
    cp: getActorCurrentCurrencyValue(actor, "cp") + awarded.cp
  };
  const updates = {};
  for (const denom of ["pp", "gp", "sp", "cp"]) {
    if (typeof actor.system?.currency?.[denom] === "object") updates[`system.currency.${denom}.value`] = next[denom];
    else updates[`system.currency.${denom}`] = next[denom];
  }
  await actor.update(updates);
  return awarded;
}

function readLootPreviewDraftFromUi(element) {
  const root = element?.closest(".po-loot-preview-panel");
  if (!root) return null;
  return normalizeLootPreviewDraft({
    mode: root.querySelector("select[name='lootPreviewMode']")?.value ?? "",
    profile: root.querySelector("select[name='lootPreviewProfile']")?.value ?? "",
    challenge: root.querySelector("select[name='lootPreviewChallenge']")?.value ?? "",
    scale: root.querySelector("select[name='lootPreviewScale']")?.value ?? "",
    creatures: root.querySelector("input[name='lootPreviewCreatures']")?.value ?? 1,
    currencyScalar: root.querySelector("input[name='lootPreviewCurrencyScalar']")?.value ?? 100,
    itemScalar: root.querySelector("input[name='lootPreviewItemScalar']")?.value ?? 100,
    tableScalar: root.querySelector("input[name='lootPreviewTableScalar']")?.value ?? 100,
    valueBudgetScalar: root.querySelector("input[name='lootPreviewValueBudgetScalar']")?.value ?? LOOT_PREVIEW_DEFAULT_VALUE_BUDGET_SCALAR,
    valueStrictness: root.querySelector("input[name='lootPreviewValueStrictness']")?.value ?? LOOT_PREVIEW_DEFAULT_VALUE_STRICTNESS,
    maxItemValueGp: root.querySelector("input[name='lootPreviewMaxItemValueGp']")?.value ?? 0,
    targetItemsValueGp: root.querySelector("input[name='lootPreviewTargetItemsValueGp']")?.value ?? 0
  });
}

async function rollLootPreview(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can generate loot builder output.");
    return;
  }
  const draft = readLootPreviewDraftFromUi(element) ?? getLootPreviewDraft();
  setLootPreviewDraft(draft);
  const payload = await generateLootPreviewPayload(draft);
  setLootPreviewResult(payload);
  ui.notifications?.info(`Loot builder generated (${payload.items.length} item(s), ${Math.round(Number(payload.currency?.gpEquivalent ?? 0))} gp equivalent).`);
}

function clearLootPreviewResult() {
  if (!canAccessAllPlayerOps()) return;
  setLootPreviewResult(null);
}

async function openLootItemFromElement(element) {
  const uuid = String(element?.dataset?.uuid ?? "").trim();
  if (!uuid) return;
  const document = await resolveUuidDocument(uuid);
  if (!document) {
    ui.notifications?.warn("That item source could not be found.");
    return;
  }
  const sheet = document.sheet ?? document._sheet ?? null;
  if (sheet?.render) {
    sheet.render(true);
    return;
  }
  ui.notifications?.warn("No sheet is available for that item.");
}

function buildLootPreviewResultSkeleton() {
  const draft = getLootPreviewDraft();
  const sourceConfig = getLootSourceConfig();
  return {
    generatedAt: Date.now(),
    generatedBy: String(game.user?.name ?? "GM"),
    draft,
    currency: {
      pp: 0,
      gp: 0,
      sp: 0,
      cp: 0,
      gpEquivalent: 0,
      formula: ""
    },
    items: [],
    tableRolls: [],
    stats: {
      candidateCount: 0,
      itemCountTarget: 0,
      itemCountGenerated: 0,
      tableRollCount: 0,
      enabledItemSources: (sourceConfig.packs ?? []).filter((entry) => entry?.enabled !== false).length,
      enabledTableSources: (sourceConfig.tables ?? []).filter((entry) => entry?.enabled !== false).length
    },
    warnings: []
  };
}

function getMutableLootPreviewResult() {
  const current = getLootPreviewResult();
  if (current && typeof current === "object") return foundry.utils.deepClone(current);
  return buildLootPreviewResultSkeleton();
}

function refreshLootPreviewResultStats(result) {
  const sourceConfig = getLootSourceConfig();
  const itemCountGenerated = Array.isArray(result?.items) ? result.items.length : 0;
  const tableRollCount = Array.isArray(result?.tableRolls) ? result.tableRolls.length : 0;
  const currentTarget = Math.max(0, Number(result?.stats?.itemCountTarget ?? 0) || 0);
  result.stats = {
    candidateCount: Math.max(0, Number(result?.stats?.candidateCount ?? 0) || 0),
    itemCountTarget: Math.max(currentTarget, itemCountGenerated),
    itemCountGenerated,
    tableRollCount,
    enabledItemSources: (sourceConfig.packs ?? []).filter((entry) => entry?.enabled !== false).length,
    enabledTableSources: (sourceConfig.tables ?? []).filter((entry) => entry?.enabled !== false).length
  };
}

function buildLootPreviewSourceLabel(documentRef, fallback = "Manual") {
  const uuid = String(documentRef?.uuid ?? "").trim();
  if (uuid.startsWith("Compendium.")) {
    const parts = uuid.split(".");
    if (parts.length >= 3) return `${parts[1]}.${parts[2]}`;
    return "Compendium";
  }
  if (uuid.startsWith("Item.")) return "World Item Directory";
  return String(fallback ?? "Manual").trim() || "Manual";
}

function buildLootPreviewItemFromDocument(documentRef, options = {}) {
  const data = (documentRef && typeof documentRef?.toObject === "function") ? documentRef.toObject() : documentRef;
  const uuid = String(documentRef?.uuid ?? data?.uuid ?? "").trim();
  const rarity = getLootRarityFromData(data);
  return {
    id: foundry.utils.randomID(),
    uuid,
    name: String(data?.name ?? "Item").trim() || "Item",
    img: String(data?.img ?? "icons/svg/item-bag.svg").trim() || "icons/svg/item-bag.svg",
    itemType: String(data?.type ?? "").trim(),
    rarity,
    sourceLabel: buildLootPreviewSourceLabel(documentRef, options?.sourceLabel ?? "Manual Add")
  };
}

async function resolveLootItemDocumentFromDropData(data = {}) {
  const uuid = String(data?.uuid ?? "").trim();
  if (uuid) {
    const document = await resolveUuidDocument(uuid);
    if (document?.documentName === "Item") return document;
  }

  const type = String(data?.type ?? "").trim();
  if (type !== "Item") return null;
  const worldId = String(data?.id ?? data?._id ?? "").trim();
  const packId = String(data?.pack ?? data?.collection ?? data?.compendium ?? "").trim();
  if (packId && worldId) {
    const pack = game.packs?.get(packId);
    if (!pack) return null;
    const document = await pack.getDocument(worldId);
    return document?.documentName === "Item" ? document : null;
  }
  if (worldId) {
    const worldItem = game.items?.get(worldId);
    return worldItem?.documentName === "Item" ? worldItem : null;
  }
  return null;
}

function addItemToLootPreviewResult(itemEntry) {
  const result = getMutableLootPreviewResult();
  if (!Array.isArray(result.items)) result.items = [];
  result.items.push(itemEntry);
  result.generatedAt = Date.now();
  result.generatedBy = String(game.user?.name ?? "GM");
  refreshLootPreviewResultStats(result);
  setLootPreviewResult(result);
}

async function addLootPreviewItemByUuid(uuidInput = "") {
  const uuid = String(uuidInput ?? "").trim();
  if (!uuid) return false;
  const document = await resolveUuidDocument(uuid);
  if (!document || document.documentName !== "Item") return false;
  addItemToLootPreviewResult(buildLootPreviewItemFromDocument(document, { sourceLabel: "Manual Add" }));
  return true;
}

async function addLootPreviewItemByPicker() {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can curate loot builder items.");
    return false;
  }
  const worldItems = [...(game.items?.contents ?? [])]
    .filter((entry) => entry?.documentName === "Item")
    .sort((a, b) => String(a?.name ?? "").localeCompare(String(b?.name ?? "")));

  const optionsHtml = worldItems.map((item) => `<option value="${poEscapeHtml(String(item.id))}">${poEscapeHtml(String(item.name ?? item.id))}</option>`).join("");
  const canPickWorld = optionsHtml.length > 0;

  const choice = await new Promise((resolve) => {
    const dialog = new Dialog({
      title: "Add Item To Loot Builder",
      content: `
        <div class="po-help">
          <div class="form-group">
            <label>World Item</label>
            <select name="lootPreviewAddWorldItem" ${canPickWorld ? "" : "disabled"}>
              ${canPickWorld ? optionsHtml : "<option value=''>No world items available</option>"}
            </select>
          </div>
          <div class="form-group">
            <label>Or Item UUID</label>
            <input type="text" name="lootPreviewAddUuid" placeholder="Compendium.package.collection.ItemId or Item.worldId" />
          </div>
        </div>
      `,
      buttons: {
        add: {
          label: "Add Item",
          callback: (html) => {
            resolve({
              worldItemId: String(html.find("select[name='lootPreviewAddWorldItem']").val() ?? "").trim(),
              uuid: String(html.find("input[name='lootPreviewAddUuid']").val() ?? "").trim()
            });
          }
        },
        cancel: {
          label: "Cancel",
          callback: () => resolve(null)
        }
      },
      default: "add"
    });
    dialog.render(true);
  });

  if (!choice) return false;
  const uuid = String(choice.uuid ?? "").trim();
  if (uuid) {
    const addedByUuid = await addLootPreviewItemByUuid(uuid);
    if (!addedByUuid) ui.notifications?.warn("Could not resolve Item UUID.");
    return addedByUuid;
  }

  const worldItemId = String(choice.worldItemId ?? "").trim();
  if (!worldItemId) return false;
  const worldItem = game.items?.get(worldItemId);
  if (!worldItem || worldItem.documentName !== "Item") {
    ui.notifications?.warn("Selected world item was not found.");
    return false;
  }
  addItemToLootPreviewResult(buildLootPreviewItemFromDocument(worldItem, { sourceLabel: "World Item Directory" }));
  return true;
}

async function addLootPreviewItemFromDropEvent(event) {
  if (!canAccessAllPlayerOps()) return false;
  let data = null;
  try {
    data = TextEditor.getDragEventData(event);
  } catch {
    data = null;
  }
  if (!data || typeof data !== "object") return false;
  const document = await resolveLootItemDocumentFromDropData(data);
  if (!document) {
    ui.notifications?.warn("Drop an Item from the sidebar or compendium.");
    return false;
  }
  addItemToLootPreviewResult(buildLootPreviewItemFromDocument(document, { sourceLabel: "Drag Drop" }));
  return true;
}

async function removeLootPreviewItem(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can curate loot builder items.");
    return false;
  }
  const itemId = String(element?.dataset?.itemId ?? "").trim();
  const itemUuid = String(element?.dataset?.itemUuid ?? "").trim();
  if (!itemId && !itemUuid) return false;
  const result = getMutableLootPreviewResult();
  const currentItems = Array.isArray(result.items) ? result.items : [];
  const nextItems = currentItems.filter((entry) => {
    const entryId = String(entry?.id ?? "").trim();
    const entryUuid = String(entry?.uuid ?? "").trim();
    if (itemId && entryId === itemId) return false;
    if (!itemId && itemUuid && entryUuid === itemUuid) return false;
    return true;
  });
  if (nextItems.length === currentItems.length) return false;
  result.items = nextItems;
  result.generatedAt = Date.now();
  result.generatedBy = String(game.user?.name ?? "GM");
  refreshLootPreviewResultStats(result);
  setLootPreviewResult(result);
  return true;
}

function getLootPreviewCurrencyGpEquivalent(currency = {}) {
  const pp = Math.max(0, Math.floor(Number(currency?.pp ?? 0) || 0));
  const gp = Math.max(0, Math.floor(Number(currency?.gp ?? 0) || 0));
  const sp = Math.max(0, Math.floor(Number(currency?.sp ?? 0) || 0));
  const cp = Math.max(0, Math.floor(Number(currency?.cp ?? 0) || 0));
  return Math.max(0, Number(((pp * 10) + gp + (sp * 0.1) + (cp * 0.01)).toFixed(2)));
}

function adjustLootPreviewCurrency(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can curate loot builder currency.");
    return false;
  }
  const result = getLootPreviewResult();
  if (!result || typeof result !== "object") {
    ui.notifications?.warn("Generate loot builder output first.");
    return false;
  }

  const root = element?.closest(".po-loot-preview-panel");
  if (!root) return false;
  const denom = String(root.querySelector("select[name='lootPreviewCurrencyAdjustDenom']")?.value ?? "gp").trim().toLowerCase();
  const qtyOverrideRaw = Number(element?.dataset?.qty ?? NaN);
  const qtyRaw = Number(root.querySelector("input[name='lootPreviewCurrencyAdjustQty']")?.value ?? 1);
  const qty = Number.isFinite(qtyOverrideRaw) && qtyOverrideRaw > 0
    ? Math.max(1, Math.floor(qtyOverrideRaw))
    : (Number.isFinite(qtyRaw) ? Math.max(1, Math.floor(qtyRaw)) : 1);
  const direction = String(element?.dataset?.direction ?? "add").trim().toLowerCase();
  if (!["pp", "gp", "sp", "cp"].includes(denom)) return false;

  const next = foundry.utils.deepClone(result);
  if (!next.currency || typeof next.currency !== "object") {
    next.currency = { pp: 0, gp: 0, sp: 0, cp: 0, gpEquivalent: 0, formula: "" };
  }
  const current = Math.max(0, Math.floor(Number(next.currency[denom] ?? 0) || 0));
  next.currency[denom] = direction === "subtract"
    ? Math.max(0, current - qty)
    : current + qty;
  next.currency.gpEquivalent = getLootPreviewCurrencyGpEquivalent(next.currency);
  next.generatedAt = Date.now();
  next.generatedBy = String(game.user?.name ?? "GM");
  setLootPreviewResult(next);
  return true;
}

function getConnectedNonGmUsers() {
  return (game.users?.contents ?? [])
    .filter((user) => Boolean(user?.active) && !Boolean(user?.isGM));
}

function formatLootCurrencyRemainingLabel(currency = {}) {
  const pp = Math.max(0, Math.floor(Number(currency?.pp ?? 0) || 0));
  const gp = Math.max(0, Math.floor(Number(currency?.gp ?? 0) || 0));
  const sp = Math.max(0, Math.floor(Number(currency?.sp ?? 0) || 0));
  const cp = Math.max(0, Math.floor(Number(currency?.cp ?? 0) || 0));
  return `${pp} pp - ${gp} gp - ${sp} sp - ${cp} cp`;
}

function openOperationsLootClaimsTabForPlayer(options = {}) {
  setActiveOperationsPage("planning");
  setActiveOperationsPlanningTab("loot");
  const app = openMainTab("operations", {
    force: options?.force !== false,
    suppressHistory: Boolean(options?.suppressHistory)
  });
  app?.render?.({ force: true, parts: ["main"], focus: true });
  app?.bringToTop?.();
  return app;
}

async function promptLootClaimsDialogForPlayer(options = {}) {
  if (game.user?.isGM) return true;
  const lootClaims = options?.lootClaims && typeof options.lootClaims === "object"
    ? options.lootClaims
    : buildLootClaimsContext(game.user);
  const itemCount = Math.max(0, Number(options?.itemCount ?? lootClaims?.itemCount ?? 0) || 0);
  const currencyRemaining = options?.currencyRemaining && typeof options.currencyRemaining === "object"
    ? options.currencyRemaining
    : (lootClaims?.currencyRemaining ?? {});
  const publishedBy = String(options?.publishedBy ?? lootClaims?.publishedBy ?? "GM").trim() || "GM";
  const publishedAt = Math.max(0, Number(options?.publishedAt ?? 0) || 0);
  const publishedAtLabel = publishedAt > 0
    ? new Date(publishedAt).toLocaleString()
    : String(lootClaims?.publishedAtLabel ?? "-");
  const content = `
    <div class="po-help">
      <p><strong>New loot is ready to claim.</strong></p>
      <p><strong>Published:</strong> ${poEscapeHtml(publishedAtLabel)} by ${poEscapeHtml(publishedBy)}</p>
      <p><strong>Items:</strong> ${itemCount}</p>
      <p><strong>Currency:</strong> ${poEscapeHtml(formatLootCurrencyRemainingLabel(currencyRemaining))}</p>
      <p>Open the Planning <strong>Loot</strong> tab now?</p>
    </div>
  `;
  return await new Promise((resolve) => {
    let settled = false;
    const finish = (value) => {
      if (settled) return;
      settled = true;
      resolve(Boolean(value));
    };
    const dialog = new Dialog({
      title: "Loot Ready To Claim",
      content,
      buttons: {
        open: {
          label: "Open Loot Claims",
          callback: () => finish(true)
        },
        later: {
          label: "Later",
          callback: () => finish(false)
        }
      },
      default: "open",
      close: () => finish(false)
    });
    dialog.render(true);
  });
}

async function waitForLootClaimsPublished(expectedPublishedAtInput, timeoutMs = 1800) {
  const expectedPublishedAt = Math.max(0, Number(expectedPublishedAtInput ?? 0) || 0);
  if (expectedPublishedAt <= 0) return;
  const timeout = Math.max(100, Math.floor(Number(timeoutMs) || 1800));
  const startedAt = Date.now();
  while ((Date.now() - startedAt) < timeout) {
    const ledger = getOperationsLedger();
    const claims = ensureLootClaimsState(ledger);
    const publishedAt = Math.max(0, Number(claims?.publishedAt ?? 0) || 0);
    if (publishedAt >= expectedPublishedAt) return;
    const boardMatch = Array.isArray(claims?.boards)
      && claims.boards.some((board) => Math.max(0, Number(board?.publishedAt ?? 0) || 0) >= expectedPublishedAt);
    if (boardMatch) return;
    await new Promise((resolve) => setTimeout(resolve, 75));
  }
  logUiDebug("loot-claims", "timed out waiting for published loot claims sync", {
    expectedPublishedAt,
    observedPublishedAt: Math.max(0, Number(getOperationsLedger()?.lootClaims?.publishedAt ?? 0) || 0)
  });
}

async function publishLootPreviewToClaims() {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can publish loot claims.");
    return;
  }
  const result = getLootPreviewResult();
  if (!result || typeof result !== "object") {
    ui.notifications?.warn("Run loot builder first.");
    return;
  }
  const items = Array.isArray(result.items) ? result.items : [];
  if (items.length === 0) {
    ui.notifications?.warn("The builder has no items to publish.");
    return;
  }

  let publishedAt = 0;
  let publishedRunId = "";
  const publishedCurrency = {
    pp: Math.max(0, Math.floor(Number(result?.currency?.pp ?? 0) || 0)),
    gp: Math.max(0, Math.floor(Number(result?.currency?.gp ?? 0) || 0)),
    sp: Math.max(0, Math.floor(Number(result?.currency?.sp ?? 0) || 0)),
    cp: Math.max(0, Math.floor(Number(result?.currency?.cp ?? 0) || 0)),
    gpEquivalent: Math.max(0, Number(result?.currency?.gpEquivalent ?? 0) || 0)
  };
  const publishedTableRolls = Array.isArray(result?.tableRolls)
    ? result.tableRolls.map((entry) => ({
      sourceLabel: String(entry?.sourceLabel ?? "Source").trim() || "Source",
      sourceType: String(entry?.sourceType ?? "currency").trim() || "currency",
      tableName: String(entry?.tableName ?? "Roll Table").trim() || "Roll Table",
      formula: String(entry?.formula ?? "").trim(),
      total: Math.max(0, Math.floor(Number(entry?.total ?? 0) || 0)),
      result: String(entry?.result ?? "No result").trim() || "No result"
    }))
    : [];

  await updateOperationsLedger((ledger) => {
    const claims = ensureLootClaimsState(ledger);
    const nextPublishedAt = Date.now();
    const board = normalizeLootClaimBoardRecord({
      id: foundry.utils.randomID(),
      status: "open",
      publishedAt: nextPublishedAt,
      publishedBy: String(game.user?.name ?? "GM"),
      currency: publishedCurrency,
      currencyRemaining: publishedCurrency,
      currencyClaimedActorIds: [],
      items: items.map((entry) => ({
        id: foundry.utils.randomID(),
        uuid: String(entry?.uuid ?? "").trim(),
        name: String(entry?.name ?? "Item").trim() || "Item",
        img: String(entry?.img ?? "icons/svg/item-bag.svg").trim() || "icons/svg/item-bag.svg",
        itemType: String(entry?.itemType ?? "").trim(),
        rarity: String(entry?.rarity ?? "").trim(),
        sourceLabel: String(entry?.sourceLabel ?? "").trim(),
        majorItem: isLootItemLikelyMajor(entry),
        vouchedByActorIds: []
      })),
      tableRolls: publishedTableRolls,
      claimsLog: []
    });
    if (!Array.isArray(claims.boards)) claims.boards = [];
    claims.boards.unshift(board);
    claims.activeBoardId = String(board.id ?? "");
    publishedAt = nextPublishedAt;
    publishedRunId = String(board.id ?? "");
  });
  if (publishedRunId) setLootClaimRunSelection(publishedRunId);
  const playerUsers = getConnectedNonGmUsers();
  if (playerUsers.length === 0) {
    ui.notifications?.warn("No active non-GM players are connected to receive the loot claims popup.");
  }
  logUiDebug("loot-claims", "publishing loot claims to players", {
    publishedAt,
    runId: publishedRunId,
    itemCount: items.length,
    recipients: playerUsers.map((user) => ({
      id: String(user?.id ?? ""),
      name: String(user?.name ?? "Player"),
      actorId: String(user?.character?.id ?? "").trim()
    }))
  });
  for (const user of playerUsers) {
    const actorId = String(user?.character?.id ?? "").trim();
    game.socket.emit(SOCKET_CHANNEL, {
      type: "players:openLootClaims",
      userId: String(user?.id ?? ""),
      actorId,
      runId: publishedRunId,
      publishedAt,
      publishedBy: String(game.user?.name ?? "GM"),
      itemCount: items.length,
      currencyRemaining: {
        pp: publishedCurrency.pp,
        gp: publishedCurrency.gp,
        sp: publishedCurrency.sp,
        cp: publishedCurrency.cp
      }
    });
  }
  if (canAccessAllPlayerOps()) openGmLootClaimsBoard({ force: true, runId: publishedRunId });
  ui.notifications?.info(
    `Published ${items.length} loot item(s) to player claims${playerUsers.length > 0 ? ` and prompted ${playerUsers.length} player(s).` : "."}`
  );
}

function getLootClaimBoardFromState(claims, runIdInput = "", options = {}) {
  const boards = Array.isArray(claims?.boards) ? claims.boards : [];
  if (boards.length === 0) return null;
  const requestedRunId = normalizeLootClaimRunId(runIdInput);
  let board = requestedRunId ? boards.find((entry) => String(entry?.id ?? "") === requestedRunId) : null;
  if (!board) {
    const storedRunId = normalizeLootClaimRunId(options?.storedRunId ?? getLootClaimRunSelection());
    if (storedRunId) board = boards.find((entry) => String(entry?.id ?? "") === storedRunId) ?? null;
  }
  if (!board) {
    const activeBoardId = normalizeLootClaimRunId(claims?.activeBoardId);
    if (activeBoardId) board = boards.find((entry) => String(entry?.id ?? "") === activeBoardId) ?? null;
  }
  if (!board) board = boards.find((entry) => String(entry?.status ?? "open") !== "archived") ?? null;
  if (!board) board = boards[0] ?? null;
  const requireOpen = Boolean(options?.requireOpen);
  if (requireOpen && String(board?.status ?? "open") === "archived") return null;
  return board;
}

async function clearLootClaimsPool(runIdInput = "") {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can clear loot claims.");
    return;
  }
  const runId = normalizeLootClaimRunId(runIdInput);
  let archivedBoardId = "";
  let archivedItemCount = 0;
  await updateOperationsLedger((ledger) => {
    const claims = ensureLootClaimsState(ledger);
    const board = getLootClaimBoardFromState(claims, runId, { requireOpen: true });
    if (!board) return;
    board.status = "archived";
    board.archivedAt = Date.now();
    board.archivedBy = String(game.user?.name ?? "GM");
    archivedBoardId = String(board.id ?? "");
    archivedItemCount = Array.isArray(board.items) ? board.items.length : 0;
    if (String(claims.activeBoardId ?? "") === archivedBoardId) {
      const nextOpenBoard = claims.boards.find((entry) => String(entry?.status ?? "open") !== "archived");
      claims.activeBoardId = String(nextOpenBoard?.id ?? "");
    }
  });
  if (!archivedBoardId) {
    ui.notifications?.warn("No open loot claim board is available to archive.");
    return;
  }
  const refreshedClaims = ensureLootClaimsState(getOperationsLedger());
  const nextSelection = normalizeLootClaimRunId(refreshedClaims.activeBoardId) || normalizeLootClaimRunId(refreshedClaims.boards?.[0]?.id);
  setLootClaimRunSelection(nextSelection);
  ui.notifications?.info(`Archived loot claim board (${archivedItemCount} item(s)).`);
}

function getLootClaimActorIdFromElement(element) {
  const root = element?.closest(".po-loot-claims-panel");
  const actorId = normalizeLootClaimActorId(root?.querySelector("select[name='lootClaimActorId']")?.value);
  if (actorId) {
    setLootClaimActorSelection(actorId);
    return actorId;
  }
  return getLootClaimActorSelection();
}

function getLootClaimRunIdFromElement(element) {
  const explicitRunId = normalizeLootClaimRunId(element?.dataset?.claimRunId);
  if (explicitRunId) {
    setLootClaimRunSelection(explicitRunId);
    return explicitRunId;
  }
  const root = element?.closest(".po-loot-claims-panel");
  const selectedRunId = normalizeLootClaimRunId(root?.querySelector("select[name='lootClaimRunId']")?.value);
  if (selectedRunId) {
    setLootClaimRunSelection(selectedRunId);
    return selectedRunId;
  }
  return getLootClaimRunSelection();
}

function getLootClaimVouchIntentFromElement(element) {
  const explicit = String(element?.dataset?.shouldVouch ?? "").trim().toLowerCase();
  if (explicit === "true") return true;
  if (explicit === "false") return false;
  return true;
}

async function setLootClaimItemMajor(itemIdInput, majorItemInput, runIdInput = "") {
  const itemId = String(itemIdInput ?? "").trim();
  if (!itemId) return { ok: false, message: "Missing item id." };
  if (!canAccessAllPlayerOps()) return { ok: false, message: "Only the GM can update major-item status." };
  const runId = normalizeLootClaimRunId(runIdInput);
  const majorItem = Boolean(majorItemInput);
  let updated = false;
  await updateOperationsLedger((ledger) => {
    const claims = ensureLootClaimsState(ledger);
    const board = getLootClaimBoardFromState(claims, runId, { requireOpen: true });
    if (!board) return;
    const item = Array.isArray(board.items)
      ? board.items.find((entry) => String(entry?.id ?? "") === itemId)
      : null;
    if (!item) return;
    item.majorItem = majorItem;
    updated = true;
  });
  if (!updated) return { ok: false, message: "Loot item no longer exists." };
  return { ok: true };
}

async function applyLootVouchForUser(user, actorIdInput, itemIdInput, shouldVouchInput = true, runIdInput = "") {
  const actorId = String(actorIdInput ?? "").trim();
  const itemId = String(itemIdInput ?? "").trim();
  const runId = normalizeLootClaimRunId(runIdInput);
  const shouldVouch = Boolean(shouldVouchInput);
  const actor = game.actors.get(actorId);
  if (!actor) return { ok: false, message: "Actor not found." };
  if (!canUserManageDowntimeActor(user, actor)) return { ok: false, message: "You cannot access that actor." };
  const eligibleActorIds = new Set(getOwnedPcActors().map((entry) => String(entry?.id ?? "").trim()).filter(Boolean));
  if (!eligibleActorIds.has(actorId)) return { ok: false, message: "Actor is not eligible for claim vouchers." };

  const ledger = getOperationsLedger();
  const claims = ensureLootClaimsState(ledger);
  const board = getLootClaimBoardFromState(claims, runId, { requireOpen: true });
  if (!board) return { ok: false, message: "No open loot claim board is selected." };
  const claimItem = Array.isArray(board.items)
    ? board.items.find((entry) => String(entry?.id ?? "") === itemId)
    : null;
  if (!claimItem) return { ok: false, message: "That loot item is no longer available." };

  await updateOperationsLedger((nextLedger) => {
    const nextClaims = ensureLootClaimsState(nextLedger);
    const nextBoard = getLootClaimBoardFromState(nextClaims, board.id, { requireOpen: true });
    const nextItem = Array.isArray(nextBoard?.items)
      ? nextBoard.items.find((entry) => String(entry?.id ?? "") === itemId)
      : null;
    if (!nextItem) return;
    if (!Array.isArray(nextItem.vouchedByActorIds)) nextItem.vouchedByActorIds = [];
    const filtered = nextItem.vouchedByActorIds.map((entry) => String(entry ?? "").trim()).filter(Boolean);
    const hasActor = filtered.includes(actorId);
    if (shouldVouch && !hasActor) filtered.push(actorId);
    if (!shouldVouch && hasActor) {
      const index = filtered.indexOf(actorId);
      if (index >= 0) filtered.splice(index, 1);
    }
    nextItem.vouchedByActorIds = filtered;
  });

  return {
    ok: true,
    actorName: String(actor.name ?? "Actor"),
    itemName: String(claimItem.name ?? "Item"),
    runId: String(board.id ?? ""),
    shouldVouch
  };
}

async function postLootRollOffToChat(itemName, winnerActorName, rollRows = [], tieNote = "") {
  const rows = Array.isArray(rollRows) ? rollRows : [];
  const rowsHtml = rows.map((row) => {
    const actorName = poEscapeHtml(String(row?.actorName ?? "Actor"));
    const total = Number.isFinite(Number(row?.total)) ? Math.floor(Number(row.total)) : 0;
    return `<li><strong>${actorName}</strong>: ${total}</li>`;
  }).join("");
  const tieHtml = tieNote ? `<p><em>${poEscapeHtml(String(tieNote))}</em></p>` : "";
  await ChatMessage.create({
    speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
    content: `
      <div class="po-chat-claim">
        <p><strong>Loot Roll-Off</strong></p>
        <p><strong>${poEscapeHtml(String(itemName ?? "Item"))}</strong> winner: ${poEscapeHtml(String(winnerActorName ?? "Actor"))}</p>
        <ul>${rowsHtml}</ul>
        ${tieHtml}
      </div>
    `
  });
}

async function runLootItemRollOff(itemIdInput, runIdInput = "") {
  const itemId = String(itemIdInput ?? "").trim();
  const runId = normalizeLootClaimRunId(runIdInput);
  if (!itemId) return { ok: false, message: "Missing item id." };
  if (!canAccessAllPlayerOps()) return { ok: false, message: "Only the GM can run roll-offs." };
  const ledger = getOperationsLedger();
  const claims = ensureLootClaimsState(ledger);
  const board = getLootClaimBoardFromState(claims, runId, { requireOpen: true });
  if (!board) return { ok: false, message: "No open loot claim board is selected." };
  const item = Array.isArray(board.items)
    ? board.items.find((entry) => String(entry?.id ?? "") === itemId)
    : null;
  if (!item) return { ok: false, message: "Loot item no longer exists." };
  const voucherActorIds = Array.isArray(item.vouchedByActorIds)
    ? item.vouchedByActorIds.map((entry) => String(entry ?? "").trim()).filter(Boolean)
    : [];
  const contenders = voucherActorIds
    .map((actorId) => game.actors.get(actorId))
    .filter((actor) => actor && actor.type === "character");
  if (contenders.length < 2) return { ok: false, message: "At least two vouchers are required for a roll-off." };

  const rollRows = [];
  for (const actor of contenders) {
    const roll = await (new Roll("1d100")).evaluate({ async: true });
    rollRows.push({ actorId: String(actor.id), actorName: String(actor.name ?? `Actor ${actor.id}`), total: Number(roll?.total ?? 0) });
  }

  const sorted = [...rollRows].sort((a, b) => Number(b.total ?? 0) - Number(a.total ?? 0));
  const topTotal = Number(sorted[0]?.total ?? 0);
  const tiedTop = sorted.filter((entry) => Number(entry.total ?? 0) === topTotal);
  const winner = tiedTop.length > 1
    ? tiedTop[Math.floor(Math.random() * tiedTop.length)]
    : sorted[0];
  const tieNote = tiedTop.length > 1
    ? `Tie at ${topTotal}; winner selected by tiebreak among tied contenders.`
    : "";

  const claimOutcome = await applyLootClaimForUser(game.user, winner.actorId, itemId, board.id);
  if (!claimOutcome.ok) return { ok: false, message: claimOutcome.message ?? "Failed to apply roll-off claim." };

  await postLootRollOffToChat(item.name, winner.actorName, rollRows, tieNote);
  await postLootItemClaimToChat({ ...claimOutcome, claimedByName: "Roll-Off" });
  return {
    ok: true,
    itemName: String(item.name ?? "Item"),
    winnerName: String(winner.actorName ?? "Actor")
  };
}

function getJournalFolderParentId(folder) {
  return String(folder?.folder?.id ?? folder?.folder ?? folder?.parent?.id ?? "").trim();
}

function findJournalFolderByName(name, parentId = "") {
  const targetName = String(name ?? "").trim().toLowerCase();
  const targetParentId = String(parentId ?? "").trim();
  return (game.folders?.contents ?? []).find((folder) => {
    if (!folder || String(folder.type ?? "") !== "JournalEntry") return false;
    if (String(folder.name ?? "").trim().toLowerCase() !== targetName) return false;
    return getJournalFolderParentId(folder) === targetParentId;
  }) ?? null;
}

function findOperationsJournalRootFolder() {
  const preferred = findJournalFolderByName(OPERATIONS_JOURNAL_ROOT_NAME, "");
  if (preferred) return preferred;
  for (const legacyName of OPERATIONS_JOURNAL_ROOT_NAME_LEGACY) {
    const legacy = findJournalFolderByName(legacyName, "");
    if (legacy) return legacy;
  }
  return null;
}

async function ensureOperationsJournalRootFolder() {
  const existing = findOperationsJournalRootFolder();
  if (existing) {
    const existingName = String(existing.name ?? "").trim();
    if (existingName !== OPERATIONS_JOURNAL_ROOT_NAME && canAccessAllPlayerOps()) {
      try {
        await existing.update({ name: OPERATIONS_JOURNAL_ROOT_NAME });
      } catch {
        // Non-fatal; continue using existing folder.
      }
    }
    return existing;
  }
  return ensureJournalFolderByName(OPERATIONS_JOURNAL_ROOT_NAME, "");
}

function getJournalFolderCacheState() {
  const raw = game.settings.get(MODULE_ID, SETTINGS.JOURNAL_FOLDER_CACHE);
  if (!raw || typeof raw !== "object") return {};
  return raw;
}

async function setJournalFolderCacheState(patch = {}) {
  const current = getJournalFolderCacheState();
  const next = foundry.utils.mergeObject(current, patch, {
    inplace: false,
    insertKeys: true,
    insertValues: true
  });
  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.JOURNAL_FOLDER_CACHE, next);
}

async function ensureJournalFolderByName(name, parentId = "") {
  const normalizedName = String(name ?? "").trim();
  const normalizedParentId = String(parentId ?? "").trim();
  const key = `${normalizedParentId}::${normalizedName.toLowerCase()}`;

  const cache = getJournalFolderCacheState();
  const cachedId = String(cache?.folders?.[key] ?? "").trim();
  if (cachedId) {
    const cachedFolder = game.folders?.get(cachedId) ?? null;
    if (cachedFolder && String(cachedFolder.type ?? "") === "JournalEntry") {
      const cachedName = String(cachedFolder.name ?? "").trim().toLowerCase();
      const cachedParentId = getJournalFolderParentId(cachedFolder);
      if (cachedName === normalizedName.toLowerCase() && cachedParentId === normalizedParentId) return cachedFolder;
    }
    if (canAccessAllPlayerOps()) {
      await setJournalFolderCacheState({ folders: { [key]: "" } });
    }
  }

  const existing = findJournalFolderByName(normalizedName, normalizedParentId);
  if (existing) {
    if (canAccessAllPlayerOps()) {
      await setJournalFolderCacheState({ folders: { [key]: String(existing.id ?? "") } });
    }
    return existing;
  }

  const activePromise = journalFolderEnsurePromises.get(key);
  if (activePromise) return activePromise;

  const createPromise = (async () => {
    const created = await Folder.create({
      name: normalizedName || "Folder",
      type: "JournalEntry",
      folder: normalizedParentId || null
    });
    if (canAccessAllPlayerOps() && created?.id) {
      await setJournalFolderCacheState({ folders: { [key]: String(created.id) } });
    }
    return created;
  })();

  journalFolderEnsurePromises.set(key, createPromise);
  try {
    return await createPromise;
  } finally {
    journalFolderEnsurePromises.delete(key);
  }
}

async function ensureOperationsJournalFolder(categoryKey = "session") {
  const normalized = Object.prototype.hasOwnProperty.call(OPERATIONS_JOURNAL_CATEGORIES, categoryKey)
    ? categoryKey
    : "session";
  const root = await ensureOperationsJournalRootFolder();
  const categoryLabel = OPERATIONS_JOURNAL_CATEGORIES[normalized];
  const categoryFolder = await ensureJournalFolderByName(categoryLabel, root?.id ?? "");
  return { root, categoryFolder, categoryKey: normalized, categoryLabel };
}

async function ensureOperationsJournalFolderTree() {
  if (!canAccessAllPlayerOps()) return null;
  const root = await ensureOperationsJournalRootFolder();
  const categories = [];
  for (const [categoryKey, categoryLabel] of Object.entries(OPERATIONS_JOURNAL_CATEGORIES)) {
    const categoryFolder = await ensureJournalFolderByName(categoryLabel, root?.id ?? "");
    categories.push({ categoryKey, categoryLabel, categoryFolder });
  }
  return { root, categories };
}

function journalFolderIsUnderRoot(folderId, rootId) {
  const start = String(folderId ?? "").trim();
  const root = String(rootId ?? "").trim();
  if (!start || !root) return false;
  let currentId = start;
  let guard = 0;
  while (currentId && guard < 40) {
    if (currentId === root) return true;
    const folder = game.folders?.get(currentId);
    currentId = getJournalFolderParentId(folder);
    guard += 1;
  }
  return false;
}

async function createOperationsJournalEntry(options = {}) {
  if (!canAccessAllPlayerOps()) return null;

  const categoryRaw = String(options?.category ?? options?.categoryKey ?? "session").trim().toLowerCase();
  const categoryKey = Object.prototype.hasOwnProperty.call(OPERATIONS_JOURNAL_CATEGORIES, categoryRaw)
    ? categoryRaw
    : "session";
  const title = String(options?.title ?? "Operations Log").trim() || "Operations Log";
  const summary = String(options?.summary ?? "").trim();
  const redactedSummary = String(options?.redactedSummary ?? "").trim();
  const body = String(options?.body ?? "").trim() || "<p>No details provided.</p>";
  const redactedBody = String(options?.redactedBody ?? "").trim();
  const sensitivity = String(options?.sensitivity ?? "public").trim().toLowerCase();

  const visibility = getJournalVisibilityMode();
  let effectiveSummary = summary;
  let effectiveBody = body;

  if (sensitivity === "gm" && visibility === JOURNAL_VISIBILITY_MODES.REDACTED) {
    effectiveSummary = redactedSummary || summary;
    effectiveBody = redactedBody || body;
  }

  const gmOnly = sensitivity === "gm" && visibility === JOURNAL_VISIBILITY_MODES.GM_PRIVATE;
  const ownership = gmOnly
    ? (() => {
      const next = { default: CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE };
      for (const user of game.users?.contents ?? []) {
        if (!user) continue;
        if (user.isGM) next[String(user.id)] = CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER;
      }
      return next;
    })()
    : { default: CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER };

  const escape = foundry.utils.escapeHTML ?? ((value) => String(value ?? ""));
  const stamp = new Date().toLocaleString();
  const safeStamp = escape(stamp);
  const safeEffectiveSummary = escape(effectiveSummary);
  const finalBody = `
    <p><em>${safeStamp}</em></p>
    ${safeEffectiveSummary ? `<p>${safeEffectiveSummary}</p>` : ""}
    ${effectiveBody}
  `;

  try {
    const { categoryFolder } = await ensureOperationsJournalFolder(categoryKey);
    const htmlFormat = Number(CONST?.JOURNAL_ENTRY_PAGE_FORMATS?.HTML ?? 1);
    const entry = await JournalEntry.create({
      name: `${title} - ${stamp}`,
      folder: categoryFolder?.id ?? null,
      ownership,
      pages: [{
        name: "Log",
        type: "text",
        text: {
          format: htmlFormat,
          content: finalBody
        }
      }]
    });
    return entry ?? null;
  } catch (error) {
    console.warn(`${MODULE_ID}: failed creating operations journal entry`, error);
    ui.notifications?.warn(`Party Operations journal write failed: ${title}`);
    return null;
  }
}

async function openJournalEntryFromElement(element) {
  const entryId = String(element?.dataset?.journalId ?? "").trim();
  if (!entryId) return;
  const entry = game.journal?.get(entryId);
  if (!entry) {
    ui.notifications?.warn("Journal entry not found.");
    return;
  }
  entry.sheet?.render(true);
}

async function buildLootClaimItemDocumentData(itemEntry = {}) {
  const uuid = String(itemEntry?.uuid ?? "").trim();
  if (!uuid) return null;
  const source = await resolveUuidDocument(uuid);
  if (!source || source.documentName !== "Item") return null;
  const data = source.toObject();
  if (data && typeof data === "object" && Object.prototype.hasOwnProperty.call(data, "_id")) delete data._id;
  return data;
}

async function applyLootClaimForUser(user, actorIdInput, itemIdInput, runIdInput = "") {
  const actorId = String(actorIdInput ?? "").trim();
  const itemId = String(itemIdInput ?? "").trim();
  const runId = normalizeLootClaimRunId(runIdInput);
  const actor = game.actors.get(actorId);
  if (!actor) return { ok: false, message: "Actor not found." };
  if (!canUserManageDowntimeActor(user, actor)) return { ok: false, message: "You cannot access that actor." };

  const ledger = getOperationsLedger();
  const claims = ensureLootClaimsState(ledger);
  const board = getLootClaimBoardFromState(claims, runId, { requireOpen: true });
  if (!board) return { ok: false, message: "No open loot claim board is selected." };
  const claimItem = Array.isArray(board.items)
    ? board.items.find((entry) => String(entry?.id ?? "") === itemId)
    : null;
  if (!claimItem) return { ok: false, message: "That loot item is no longer available." };
  const voucherActorIds = Array.isArray(claimItem.vouchedByActorIds)
    ? claimItem.vouchedByActorIds.map((entry) => String(entry ?? "").trim()).filter(Boolean)
    : [];
  if (voucherActorIds.length > 1) {
    return { ok: false, message: "This item has multiple vouchers. Run a roll-off first." };
  }
  const itemData = await buildLootClaimItemDocumentData(claimItem);
  if (!itemData) return { ok: false, message: "The source item could not be resolved. Ask GM to reroll/publish again." };

  try {
    await actor.createEmbeddedDocuments("Item", [itemData]);
  } catch (error) {
    console.warn(`${MODULE_ID}: failed to grant claimed loot`, error);
    return { ok: false, message: "Failed to add the item to actor inventory." };
  }

  await updateOperationsLedger((nextLedger) => {
    const nextClaims = ensureLootClaimsState(nextLedger);
    const nextBoard = getLootClaimBoardFromState(nextClaims, board.id, { requireOpen: true });
    if (!nextBoard) return;
    const index = Array.isArray(nextBoard.items)
      ? nextBoard.items.findIndex((entry) => String(entry?.id ?? "") === itemId)
      : -1;
    if (index >= 0) nextBoard.items.splice(index, 1);
    if (!Array.isArray(nextBoard.claimsLog)) nextBoard.claimsLog = [];
    nextBoard.claimsLog.unshift({
      id: foundry.utils.randomID(),
      itemId,
      itemName: String(claimItem.name ?? "Item"),
      actorId: String(actor.id),
      actorName: String(actor.name ?? "Actor"),
      claimedByUserId: String(user?.id ?? ""),
      claimedByName: String(user?.name ?? "Player"),
      claimedAt: Date.now()
    });
    nextBoard.claimsLog = nextBoard.claimsLog
      .sort((a, b) => Number(b.claimedAt ?? 0) - Number(a.claimedAt ?? 0))
      .slice(0, 120);
  });

  return {
    ok: true,
    runId: String(board.id ?? ""),
    actorName: String(actor.name ?? "Actor"),
    itemName: String(claimItem.name ?? "Item"),
    actorId: String(actor.id ?? ""),
    actorUuid: String(actor.uuid ?? ""),
    itemUuid: String(claimItem.uuid ?? ""),
    claimedByName: String(user?.name ?? "Player"),
    claimedByUserId: String(user?.id ?? "")
  };
}

function computeCurrencyShareForActor(remaining = {}, actorId = "", unclaimedActorIds = []) {
  const ids = Array.isArray(unclaimedActorIds)
    ? unclaimedActorIds.map((entry) => String(entry ?? "").trim()).filter(Boolean).sort((a, b) => a.localeCompare(b))
    : [];
  const targetId = String(actorId ?? "").trim();
  if (!targetId || ids.length === 0 || !ids.includes(targetId)) {
    return { pp: 0, gp: 0, sp: 0, cp: 0, gpEquivalent: 0 };
  }
  const index = ids.indexOf(targetId);
  const share = {};
  for (const denom of ["pp", "gp", "sp", "cp"]) {
    const total = Math.max(0, Math.floor(Number(remaining?.[denom] ?? 0) || 0));
    const base = Math.floor(total / ids.length);
    const remainder = total % ids.length;
    share[denom] = base + (index < remainder ? 1 : 0);
  }
  const gpEquivalent = (share.pp * 10) + share.gp + (share.sp * 0.1) + (share.cp * 0.01);
  return { ...share, gpEquivalent };
}

async function applyLootCurrencyClaimForUser(user, actorIdInput, runIdInput = "") {
  const actorId = String(actorIdInput ?? "").trim();
  const runId = normalizeLootClaimRunId(runIdInput);
  const actor = game.actors.get(actorId);
  if (!actor) return { ok: false, message: "Actor not found." };
  if (!canUserManageDowntimeActor(user, actor)) return { ok: false, message: "You cannot access that actor." };
  const eligibleActorIds = getOwnedPcActors().map((entry) => String(entry?.id ?? "").trim()).filter(Boolean);
  if (!eligibleActorIds.includes(actorId)) return { ok: false, message: "Actor is not in the player-character claim pool." };

  const ledger = getOperationsLedger();
  const claims = ensureLootClaimsState(ledger);
  const board = getLootClaimBoardFromState(claims, runId, { requireOpen: true });
  if (!board) return { ok: false, message: "No open loot claim board is selected." };
  const claimedSet = new Set((board.currencyClaimedActorIds ?? []).map((entry) => String(entry ?? "").trim()).filter(Boolean));
  if (claimedSet.has(actorId)) return { ok: false, message: "This actor already claimed a currency share from this board." };
  const remaining = board.currencyRemaining ?? board.currency ?? {};
  const hasRemaining = ["pp", "gp", "sp", "cp"].some((denom) => Math.max(0, Math.floor(Number(remaining?.[denom] ?? 0) || 0)) > 0);
  if (!hasRemaining) return { ok: false, message: "No currency remains to claim." };
  const unclaimed = eligibleActorIds.filter((id) => !claimedSet.has(id));
  if (unclaimed.length <= 0) return { ok: false, message: "No claim slots remain." };
  if (!unclaimed.includes(actorId)) return { ok: false, message: "Actor cannot claim from remaining slots." };
  const share = computeCurrencyShareForActor(remaining, actorId, unclaimed);
  if (share.pp <= 0 && share.gp <= 0 && share.sp <= 0 && share.cp <= 0) {
    return { ok: false, message: "No currency share is available for this actor." };
  }

  try {
    await awardCurrencyBundleToActor(actor, share);
  } catch (error) {
    console.warn(`${MODULE_ID}: failed to grant claimed loot currency`, error);
    return { ok: false, message: "Failed to add currency to actor." };
  }

  await updateOperationsLedger((nextLedger) => {
    const nextClaims = ensureLootClaimsState(nextLedger);
    const nextBoard = getLootClaimBoardFromState(nextClaims, board.id, { requireOpen: true });
    if (!nextBoard) return;
    const currentRemaining = nextBoard.currencyRemaining ?? nextBoard.currency ?? {};
    const nextRemaining = {
      pp: Math.max(0, Math.floor(Number(currentRemaining.pp ?? 0) || 0) - share.pp),
      gp: Math.max(0, Math.floor(Number(currentRemaining.gp ?? 0) || 0) - share.gp),
      sp: Math.max(0, Math.floor(Number(currentRemaining.sp ?? 0) || 0) - share.sp),
      cp: Math.max(0, Math.floor(Number(currentRemaining.cp ?? 0) || 0) - share.cp),
      gpEquivalent: Math.max(0, Number(currentRemaining.gpEquivalent ?? 0) - Number(share.gpEquivalent ?? 0))
    };
    nextBoard.currencyRemaining = nextRemaining;
    if (!Array.isArray(nextBoard.currencyClaimedActorIds)) nextBoard.currencyClaimedActorIds = [];
    if (!nextBoard.currencyClaimedActorIds.includes(actorId)) nextBoard.currencyClaimedActorIds.push(actorId);
    if (!Array.isArray(nextBoard.claimsLog)) nextBoard.claimsLog = [];
    nextBoard.claimsLog.unshift({
      id: foundry.utils.randomID(),
      itemId: `currency:${Date.now()}`,
      itemName: `Currency Share (${share.pp}pp ${share.gp}gp ${share.sp}sp ${share.cp}cp)`,
      actorId: String(actor.id),
      actorName: String(actor.name ?? "Actor"),
      claimedByUserId: String(user?.id ?? ""),
      claimedByName: String(user?.name ?? "Player"),
      claimedAt: Date.now()
    });
    nextBoard.claimsLog = nextBoard.claimsLog
      .sort((a, b) => Number(b.claimedAt ?? 0) - Number(a.claimedAt ?? 0))
      .slice(0, 120);
  });

  return {
    ok: true,
    runId: String(board.id ?? ""),
    actorName: String(actor.name ?? "Actor"),
    actorId: String(actor.id ?? ""),
    actorUuid: String(actor.uuid ?? ""),
    claimedByName: String(user?.name ?? "Player"),
    claimedByUserId: String(user?.id ?? ""),
    share
  };
}

async function claimLootItemForPlayer(element) {
  const itemId = String(element?.dataset?.itemId ?? "").trim();
  const runId = getLootClaimRunIdFromElement(element);
  if (!itemId) return;
  const actorId = getLootClaimActorIdFromElement(element);
  if (!actorId) {
    ui.notifications?.warn("Select a character to receive the claimed item.");
    return;
  }

  if (canAccessAllPlayerOps()) {
    const outcome = await applyLootClaimForUser(game.user, actorId, itemId, runId);
    if (!outcome.ok) {
      ui.notifications?.warn(outcome.message ?? "Loot claim failed.");
      return;
    }
    await postLootItemClaimToChat(outcome);
    ui.notifications?.info(`${outcome.itemName} added to ${outcome.actorName}.`);
    return;
  }

  game.socket.emit(SOCKET_CHANNEL, {
    type: "ops:loot-claim",
    userId: game.user.id,
    actorId,
    itemId,
    runId
  });
  ui.notifications?.info("Loot claim request sent to GM.");
}

async function toggleLootItemVouchForPlayer(element) {
  const itemId = String(element?.dataset?.itemId ?? "").trim();
  const runId = getLootClaimRunIdFromElement(element);
  if (!itemId) return;
  const actorId = getLootClaimActorIdFromElement(element);
  if (!actorId) {
    ui.notifications?.warn("Select a character first.");
    return;
  }
  const shouldVouch = getLootClaimVouchIntentFromElement(element);

  if (canAccessAllPlayerOps()) {
    const outcome = await applyLootVouchForUser(game.user, actorId, itemId, shouldVouch, runId);
    if (!outcome.ok) {
      ui.notifications?.warn(outcome.message ?? "Vouch update failed.");
      return;
    }
    ui.notifications?.info(`${outcome.actorName} ${shouldVouch ? "vouched for" : "removed voucher from"} ${outcome.itemName}.`);
    return;
  }

  game.socket.emit(SOCKET_CHANNEL, {
    type: "ops:loot-vouch",
    userId: game.user.id,
    actorId,
    itemId,
    runId,
    shouldVouch
  });
  ui.notifications?.info(shouldVouch ? "Voucher request sent to GM." : "Voucher removal request sent to GM.");
}

async function setLootItemMajorFromElement(element) {
  if (!canAccessAllPlayerOps()) return;
  const itemId = String(element?.dataset?.itemId ?? "").trim();
  const runId = getLootClaimRunIdFromElement(element);
  if (!itemId) return;
  const outcome = await setLootClaimItemMajor(itemId, Boolean(element?.checked), runId);
  if (!outcome.ok) ui.notifications?.warn(outcome.message ?? "Unable to update major-item status.");
}

async function runLootRollOffFromElement(element) {
  if (!canAccessAllPlayerOps()) return;
  const itemId = String(element?.dataset?.itemId ?? "").trim();
  const runId = getLootClaimRunIdFromElement(element);
  if (!itemId) return;
  const outcome = await runLootItemRollOff(itemId, runId);
  if (!outcome.ok) {
    ui.notifications?.warn(outcome.message ?? "Roll-off failed.");
    return;
  }
  ui.notifications?.info(`Roll-off resolved: ${outcome.winnerName} receives ${outcome.itemName}.`);
}

async function claimLootCurrencyForPlayer(element) {
  const runId = getLootClaimRunIdFromElement(element);
  const actorId = getLootClaimActorIdFromElement(element);
  if (!actorId) {
    ui.notifications?.warn("Select a character to receive currency.");
    return;
  }
  if (canAccessAllPlayerOps()) {
    const outcome = await applyLootCurrencyClaimForUser(game.user, actorId, runId);
    if (!outcome.ok) {
      ui.notifications?.warn(outcome.message ?? "Currency claim failed.");
      return;
    }
    await postLootCurrencyClaimToChat(outcome);
    const s = outcome.share ?? { pp: 0, gp: 0, sp: 0, cp: 0 };
    ui.notifications?.info(`${outcome.actorName} claimed ${s.pp}pp ${s.gp}gp ${s.sp}sp ${s.cp}cp.`);
    return;
  }
  game.socket.emit(SOCKET_CHANNEL, {
    type: "ops:loot-claim-currency",
    userId: game.user.id,
    actorId,
    runId
  });
  ui.notifications?.info("Currency claim request sent to GM.");
}

function formatLootCurrencyBundleLabel(bundle = {}) {
  const pp = Math.max(0, Math.floor(Number(bundle?.pp ?? 0) || 0));
  const gp = Math.max(0, Math.floor(Number(bundle?.gp ?? 0) || 0));
  const sp = Math.max(0, Math.floor(Number(bundle?.sp ?? 0) || 0));
  const cp = Math.max(0, Math.floor(Number(bundle?.cp ?? 0) || 0));
  return `${pp}pp ${gp}gp ${sp}sp ${cp}cp`;
}

async function postLootItemClaimToChat(outcome = {}) {
  const actorName = String(outcome?.actorName ?? "Actor").trim() || "Actor";
  const actorId = String(outcome?.actorId ?? "").trim();
  const actorUuid = String(outcome?.actorUuid ?? "").trim();
  const itemName = String(outcome?.itemName ?? "Item").trim() || "Item";
  const itemUuid = String(outcome?.itemUuid ?? "").trim();
  const claimedBy = String(outcome?.claimedByName ?? "Player").trim() || "Player";
  const actor = actorId ? game.actors.get(actorId) : null;
  const actorImg = String(actor?.img ?? "icons/svg/item-bag.svg");
  await ChatMessage.create({
    speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
    content: `
      <div class="po-chat-claim">
        <p><strong>Loot Claimed</strong></p>
        <p><img src="${actorImg}" width="24" height="24" style="vertical-align:middle; margin-right:6px;" />${poEscapeHtml(actorName)} received <strong>${poEscapeHtml(itemName)}</strong>.</p>
        <p><em>Claimed by ${poEscapeHtml(claimedBy)}</em></p>
      </div>
    `
  });
  await createOperationsJournalEntry({
    category: "loot-claims",
    title: `Loot Claimed - ${actorName}`,
    summary: `${actorName} received ${itemName}`,
    body: `
      <p><strong>Actor:</strong> ${buildUuidJournalLink(actorUuid, actorName)}</p>
      <p><strong>Item:</strong> ${buildUuidJournalLink(itemUuid, itemName)}</p>
      <p><strong>Claimed By:</strong> ${poEscapeHtml(claimedBy)}</p>
    `
  });
}

async function postLootCurrencyClaimToChat(outcome = {}) {
  const actorName = String(outcome?.actorName ?? "Actor").trim() || "Actor";
  const actorId = String(outcome?.actorId ?? "").trim();
  const actorUuid = String(outcome?.actorUuid ?? "").trim();
  const claimedBy = String(outcome?.claimedByName ?? "Player").trim() || "Player";
  const shareLabel = formatLootCurrencyBundleLabel(outcome?.share ?? {});
  const actor = actorId ? game.actors.get(actorId) : null;
  const actorImg = String(actor?.img ?? "icons/svg/coins.svg");
  await ChatMessage.create({
    speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
    content: `
      <div class="po-chat-claim">
        <p><strong>Currency Claimed</strong></p>
        <p><img src="${actorImg}" width="24" height="24" style="vertical-align:middle; margin-right:6px;" />${poEscapeHtml(actorName)} received <strong>${poEscapeHtml(shareLabel)}</strong>.</p>
        <p><em>Claimed by ${poEscapeHtml(claimedBy)}</em></p>
      </div>
    `
  });
  await createOperationsJournalEntry({
    category: "loot-claims",
    title: `Currency Claimed - ${actorName}`,
    summary: `${actorName} received ${shareLabel}`,
    body: `
      <p><strong>Actor:</strong> ${buildUuidJournalLink(actorUuid, actorName)}</p>
      <p><strong>Currency:</strong> ${poEscapeHtml(shareLabel)}</p>
      <p><strong>Claimed By:</strong> ${poEscapeHtml(claimedBy)}</p>
    `
  });
}

async function gmQuickAddFaction() {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update reputation.");
    return;
  }
  const content = `
    <div class="form-group">
      <label>Faction Name</label>
      <input type="text" name="quickFactionName" placeholder="e.g., Black Salt Consortium" />
    </div>
  `;
  const dialog = new Dialog({
    title: "Quick Add Faction",
    content,
    buttons: {
      add: {
        label: "Add Faction",
        callback: async (html) => {
          const label = String(html.find("input[name='quickFactionName']").val() ?? "").trim();
          if (!label) {
            ui.notifications?.warn("Faction name is required.");
            return;
          }
          await updateOperationsLedger((ledger) => {
            const reputation = ensureReputationState(ledger);
            reputation.factions.push(normalizeReputationFaction({
              id: foundry.utils.randomID(),
              label,
              score: 0,
              note: "",
              isCore: false
            }));
          });
          setActiveGmQuickPanel("none");
          ui.notifications?.info(`Faction added: ${label}.`);
        }
      },
      cancel: { label: "Cancel" }
    },
    default: "add"
  });
  dialog.render(true);
}

async function gmQuickSubmitFaction(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update reputation.");
    return;
  }
  const root = element?.closest(".po-gm-quick-actions") ?? element?.closest(".po-gm-section");
  const label = String(root?.querySelector("input[name='quickFactionName']")?.value ?? "").trim();
  if (!label) {
    ui.notifications?.warn("Faction name is required.");
    return;
  }
  await updateOperationsLedger((ledger) => {
    const reputation = ensureReputationState(ledger);
    reputation.factions.push(normalizeReputationFaction({
      id: foundry.utils.randomID(),
      label,
      score: 0,
      note: "",
      isCore: false
    }));
  });
  setActiveGmQuickPanel("none");
}

function getDaeModifierCategoryOptions() {
  return [
    { value: "all", label: "All Modifiers", test: () => true },
    { value: "movement", label: "Movement", test: (key) => key.includes("movement") },
    { value: "defense", label: "Defense (AC/HP)", test: (key) => key.includes("ac") || key.includes("hp") },
    { value: "initiative", label: "Initiative", test: (key) => key.includes("init") },
    { value: "checks", label: "Ability Checks", test: (key) => key.includes("abilities.check") },
    { value: "saves", label: "Saving Throws", test: (key) => key.includes("abilities.save") || key.includes(".save") },
    { value: "attacks", label: "Attacks", test: (key) => key.includes(".attack") },
    { value: "skills", label: "Skills", test: (key) => key.includes("skills.") },
    { value: "other", label: "Other", test: (key) => !(
      key.includes("movement")
      || key.includes("ac")
      || key.includes("hp")
      || key.includes("init")
      || key.includes("abilities.check")
      || key.includes("abilities.save")
      || key.includes(".save")
      || key.includes(".attack")
      || key.includes("skills.")
    ) }
  ];
}

async function gmQuickAddModifier() {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can edit Party Health modifiers.");
    return;
  }
  const current = getActiveGmQuickPanel();
  setActiveGmQuickPanel(current === "modifier" ? "none" : "modifier");
}

async function gmQuickSubmitModifier(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can edit Party Health modifiers.");
    return;
  }
  const root = element?.closest(".po-gm-quick-actions") ?? element?.closest(".po-gm-section");
  const payload = readQuickModifierDraftFromRoot(root);
  if (!payload) return;
  const { label, key, value, note, mode } = payload;

  if (!key || !value) {
    ui.notifications?.warn("Select a key preset and provide a value to add a drafted modifier.");
    return;
  }

  await updateOperationsLedger((ledger) => {
    const partyHealth = ensurePartyHealthState(ledger);
    partyHealth.stagedModifierQueue.unshift({
      id: foundry.utils.randomID(),
      label,
      key,
      mode,
      value,
      note,
      createdAt: Date.now(),
      createdBy: String(game.user?.name ?? "GM").trim() || "GM"
    });
    partyHealth.stagedModifierQueue = partyHealth.stagedModifierQueue.slice(0, 24);
  });
}

function readQuickModifierDraftFromRoot(root) {
  if (!root) return null;
  const label = String(root.querySelector("input[name='quickGlobalModifierLabel']")?.value ?? "").trim() || "Custom Modifier";
  const key = String(root.querySelector("select[name='quickGlobalModifierKey']")?.value ?? "").trim();
  const value = String(root.querySelector("input[name='quickGlobalModifierValue']")?.value ?? "").trim();
  const note = String(root.querySelector("textarea[name='quickGlobalModifierNote']")?.value ?? "");
  const rawMode = Math.floor(Number(root.querySelector("select[name='quickGlobalModifierMode']")?.value ?? CONST.ACTIVE_EFFECT_MODES.ADD));
  const validModes = new Set(Object.values(CONST.ACTIVE_EFFECT_MODES ?? {}).map((entry) => Number(entry)));
  const mode = validModes.has(rawMode) ? rawMode : Number(CONST.ACTIVE_EFFECT_MODES.ADD);
  return { label, key, value, note, mode };
}

async function gmQuickSaveModifier(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can edit Party Health modifiers.");
    return;
  }
  const root = element?.closest(".po-gm-quick-actions") ?? element?.closest(".po-gm-section");
  const groupedEntries = new Map();
  let publishedCount = 0;
  let skippedCount = 0;

  await updateOperationsLedger((ledger) => {
    const partyHealth = ensurePartyHealthState(ledger);
    const stagedQueue = Array.isArray(partyHealth.stagedModifierQueue) ? partyHealth.stagedModifierQueue : [];
    if (stagedQueue.length === 0) return;

    for (const row of stagedQueue) {
      const stagedId = String(row?.id ?? "").trim();
      const key = String(row?.key ?? "").trim();
      const value = String(row?.value ?? "").trim();
      const mode = Math.floor(Number(row?.mode ?? CONST.ACTIVE_EFFECT_MODES.ADD));
      if (!stagedId || !key || !value) continue;
      const groupKey = `${key}::${mode}`;
      if (!groupedEntries.has(groupKey)) groupedEntries.set(groupKey, []);
      groupedEntries.get(groupKey).push({
        stagedId,
        key,
        mode,
        label: String(row?.label ?? "Custom Modifier").trim() || "Custom Modifier",
        value,
        note: String(row?.note ?? "")
      });
    }

    const consumedIds = new Set();
    for (const rows of groupedEntries.values()) {
      if (!Array.isArray(rows) || rows.length === 0) continue;
      const numericValues = rows.map((row) => Number(row.value));
      const hasNonNumeric = numericValues.some((value) => !Number.isFinite(value));
      if (hasNonNumeric && rows.length > 1) {
        skippedCount += rows.length;
        continue;
      }

      const key = rows[0].key;
      const mode = rows[0].mode;
      const mergedValue = hasNonNumeric
        ? rows[0].value
        : String(numericValues.reduce((total, entry) => total + entry, 0));
      const labels = [...new Set(rows.map((row) => String(row.label ?? "").trim()).filter(Boolean))];
      const baseLabel = labels[0] || getDaeKeyLabel(key) || "Custom Modifier";
      const mergedLabel = labels.length <= 1 ? baseLabel : `${baseLabel} (Stacked ${rows.length})`;
      const noteParts = rows.map((row) => String(row.note ?? "").trim()).filter(Boolean);
      const mergedNote = noteParts.join(" | ");

      const customModifierId = foundry.utils.randomID();
      partyHealth.customModifiers.push({
        id: customModifierId,
        label: mergedLabel,
        key,
        mode,
        value: mergedValue,
        note: mergedNote,
        enabled: true
      });
      logAddedPartyHealthModifier(partyHealth, {
        customModifierId,
        origin: "quick",
        label: mergedLabel,
        key,
        mode,
        value: mergedValue,
        note: mergedNote
      });
      rows.forEach((row) => consumedIds.add(row.stagedId));
      publishedCount += 1;
    }

    partyHealth.stagedModifierQueue = stagedQueue
      .filter((row) => !consumedIds.has(String(row?.id ?? "").trim()));
  });

  if (groupedEntries.size === 0) {
    ui.notifications?.warn("Draft stack is empty. Add at least one modifier before saving.");
    return;
  }
  if (publishedCount === 0) {
    ui.notifications?.warn("No drafted modifiers were published. Check drafted values and try again.");
    return;
  }

  resetQuickModifierForm(root);
  if (skippedCount > 0) {
    ui.notifications?.info(`Published ${publishedCount} modifier group(s); ${skippedCount} drafted entr${skippedCount === 1 ? "y was" : "ies were"} skipped for manual cleanup.`);
    return;
  }
  ui.notifications?.info(`Published ${publishedCount} modifier group${publishedCount === 1 ? "" : "s"} from the draft stack.`);
}

async function gmQuickSetStagedModifierField(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can edit Party Health modifiers.");
    return;
  }
  const stagedId = String(element?.dataset?.stagedId ?? "").trim();
  const field = String(element?.dataset?.stagedField ?? "").trim();
  if (!stagedId || !field) return;
  const editableFields = new Set(["label", "key", "mode", "value", "note"]);
  if (!editableFields.has(field)) return;

  const rawValue = String(element?.value ?? "");
  await updateOperationsLedger((ledger) => {
    const partyHealth = ensurePartyHealthState(ledger);
    const stagedEntry = (partyHealth.stagedModifierQueue ?? [])
      .find((entry) => String(entry?.id ?? "").trim() === stagedId);
    if (!stagedEntry) return;

    if (field === "label") {
      stagedEntry.label = String(rawValue).trim() || "Custom Modifier";
      return;
    }
    if (field === "key") {
      stagedEntry.key = String(rawValue).trim();
      return;
    }
    if (field === "mode") {
      const rawMode = Math.floor(Number(rawValue ?? CONST.ACTIVE_EFFECT_MODES.ADD));
      const validModes = new Set(Object.values(CONST.ACTIVE_EFFECT_MODES ?? {}).map((entry) => Number(entry)));
      stagedEntry.mode = validModes.has(rawMode) ? rawMode : Number(CONST.ACTIVE_EFFECT_MODES.ADD);
      return;
    }
    if (field === "value") {
      stagedEntry.value = String(rawValue).trim();
      return;
    }
    if (field === "note") {
      stagedEntry.note = String(rawValue ?? "");
    }
  });
}

async function gmQuickDeleteStagedModifier(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can edit Party Health modifiers.");
    return;
  }
  const stagedId = String(element?.dataset?.stagedId ?? "").trim();
  if (!stagedId) {
    ui.notifications?.warn("No queued modifier id was provided.");
    return;
  }

  let removed = false;
  await updateOperationsLedger((ledger) => {
    const partyHealth = ensurePartyHealthState(ledger);
    const before = partyHealth.stagedModifierQueue.length;
    partyHealth.stagedModifierQueue = partyHealth.stagedModifierQueue
      .filter((entry) => String(entry?.id ?? "").trim() !== stagedId);
    removed = partyHealth.stagedModifierQueue.length < before;
  });

  if (!removed) ui.notifications?.warn("Queued modifier was already removed.");
}

async function gmQuickDeleteSavedModifier(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can edit Party Health modifiers.");
    return;
  }
  const customIdRaw = String(element?.dataset?.customId ?? "").trim();
  const logId = String(element?.dataset?.logId ?? "").trim();
  if (!customIdRaw && !logId) {
    ui.notifications?.warn("No saved modifier id was provided.");
    return;
  }

  let removedCustom = false;
  let removedLog = false;

  await updateOperationsLedger((ledger) => {
    const partyHealth = ensurePartyHealthState(ledger);
    const logEntry = logId
      ? partyHealth.modifierAddLog.find((entry) => String(entry?.id ?? "").trim() === logId)
      : null;
    let customId = customIdRaw || String(logEntry?.customModifierId ?? "").trim();
    if (!customId && logEntry) {
      const logLabel = String(logEntry?.label ?? "").trim();
      const logKey = String(logEntry?.key ?? "").trim();
      const logValue = String(logEntry?.value ?? "").trim();
      const logNote = String(logEntry?.note ?? "");
      const logMode = Math.floor(Number(logEntry?.mode ?? CONST.ACTIVE_EFFECT_MODES.ADD));
      const matchedEntry = partyHealth.customModifiers.find((entry) =>
        String(entry?.key ?? "").trim() === logKey
        && String(entry?.value ?? "").trim() === logValue
        && Math.floor(Number(entry?.mode ?? CONST.ACTIVE_EFFECT_MODES.ADD)) === logMode
        && (!logLabel || String(entry?.label ?? "").trim() === logLabel)
        && (!logNote || String(entry?.note ?? "") === logNote)
      );
      customId = String(matchedEntry?.id ?? "").trim();
    }

    if (customId) {
      const beforeCustomCount = partyHealth.customModifiers.length;
      partyHealth.customModifiers = partyHealth.customModifiers
        .filter((entry) => String(entry?.id ?? "").trim() !== customId);
      removedCustom = partyHealth.customModifiers.length < beforeCustomCount;
      if (partyHealth.modifierEnabled && typeof partyHealth.modifierEnabled === "object") {
        delete partyHealth.modifierEnabled[`custom:${customId}`];
      }
    }

    const beforeLogCount = partyHealth.modifierAddLog.length;
    if (logId) {
      partyHealth.modifierAddLog = partyHealth.modifierAddLog
        .filter((entry) => String(entry?.id ?? "").trim() !== logId);
    } else if (customId) {
      partyHealth.modifierAddLog = partyHealth.modifierAddLog
        .filter((entry) => String(entry?.customModifierId ?? "").trim() !== customId);
    }
    removedLog = partyHealth.modifierAddLog.length < beforeLogCount;
  });

  if (!removedCustom && !removedLog) {
    ui.notifications?.warn("Saved modifier was already removed.");
  }
}

function gmQuickApplyModifierKeyPreset(element) {
  const root = element?.closest(".po-op-role-row") ?? element?.closest(".po-gm-quick-actions") ?? element?.closest(".po-gm-section");
  if (!root) return;
  const selectedKey = String(element?.value ?? "").trim();
  const input = root.querySelector("input[name='quickGlobalModifierKeyFilter']");
  if (!input) return;
  input.value = selectedKey;
}

function buildWeatherDraftFromPreset(preset, sceneSnapshot, previousDraft = {}) {
  const presetChanges = Array.isArray(preset?.daeChanges)
    ? preset.daeChanges.map((entry) => normalizeWeatherDaeChange(entry)).filter((entry) => entry.key && entry.value)
    : [];
  const previousChanges = Array.isArray(previousDraft?.daeChanges)
    ? previousDraft.daeChanges.map((entry) => normalizeWeatherDaeChange(entry)).filter((entry) => entry.key && entry.value)
    : null;
  return {
    selectedKey: String(preset?.key ?? ""),
    darkness: Number.isFinite(Number(previousDraft?.darkness))
      ? Math.max(0, Math.min(1, Number(previousDraft.darkness)))
      : Math.max(0, Math.min(1, Number(preset?.darkness ?? sceneSnapshot?.darkness ?? 0))),
    visibilityModifier: Number.isFinite(Number(previousDraft?.visibilityModifier))
      ? Math.max(-5, Math.min(5, Math.floor(Number(previousDraft.visibilityModifier))))
      : Math.max(-5, Math.min(5, Math.floor(Number(preset?.visibilityModifier ?? 0) || 0))),
    note: String(previousDraft?.note ?? preset?.note ?? sceneSnapshot?.note ?? ""),
    presetName: String(previousDraft?.presetName ?? preset?.label ?? ""),
    daeChanges: previousChanges ?? presetChanges
  };
}

function getWeatherPresetByKey(weatherState, sceneSnapshot, key) {
  const options = buildWeatherSelectionCatalog(weatherState, sceneSnapshot);
  const selectedKey = String(key ?? "").trim();
  return options.find((entry) => entry.key === selectedKey) ?? options[0] ?? null;
}

async function gmQuickLogCurrentWeather() {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can log weather.");
    return;
  }
  const ledger = getOperationsLedger();
  const weatherState = ensureWeatherState(ledger);
  const sceneSnapshot = resolveCurrentSceneWeatherSnapshot();
  const defaultPreset = getWeatherPresetByKey(weatherState, sceneSnapshot, "clear")
    ?? buildWeatherSelectionCatalog(weatherState, sceneSnapshot)[0]
    ?? null;
  setGmQuickWeatherDraft(buildWeatherDraftFromPreset(defaultPreset, sceneSnapshot));
  const current = getActiveGmQuickPanel();
  setActiveGmQuickPanel(current === "weather" ? "none" : "weather");
}

async function gmQuickSelectWeatherPreset(element) {
  const selectedKey = String(element?.value ?? "").trim();
  const ledger = getOperationsLedger();
  const weatherState = ensureWeatherState(ledger);
  const sceneSnapshot = resolveCurrentSceneWeatherSnapshot();
  const selectedPreset = getWeatherPresetByKey(weatherState, sceneSnapshot, selectedKey);
  if (!selectedPreset) return;
  setGmQuickWeatherDraft(buildWeatherDraftFromPreset(selectedPreset, sceneSnapshot, { selectedKey }));
}

function gmQuickUpdateWeatherDraftField(element) {
  const field = String(element?.dataset?.field ?? "").trim();
  if (!field) return;
  const draft = getGmQuickWeatherDraft() ?? {};
  if (field === "darkness") {
    const value = Number(element?.value ?? 0);
    draft.darkness = Number.isFinite(value) ? Math.max(0, Math.min(1, value)) : 0;
  } else if (field === "visibilityModifier") {
    const value = Number(element?.value ?? 0);
    draft.visibilityModifier = Number.isFinite(value) ? Math.max(-5, Math.min(5, Math.floor(value))) : 0;
  } else if (field === "note") {
    draft.note = String(element?.value ?? "");
  } else if (field === "presetName") {
    draft.presetName = String(element?.value ?? "");
  }
  setGmQuickWeatherDraft(draft);
}

function gmQuickApplyWeatherDaeKeyPreset(element) {
  const root = element?.closest(".po-gm-quick-actions") ?? element?.closest(".po-gm-section");
  if (!root) return;
  const selectedKey = String(element?.value ?? "").trim();
  if (!selectedKey) return;
  const input = root.querySelector("input[name='quickWeatherDaeKeyInput']");
  if (!input) return;
  input.value = selectedKey;
}

async function gmQuickAddWeatherDaeChange(element) {
  const root = element?.closest(".po-gm-quick-actions") ?? element?.closest(".po-gm-section");
  const key = String(root?.querySelector("input[name='quickWeatherDaeKeyInput']")?.value ?? root?.querySelector("select[name='quickWeatherDaeKey']")?.value ?? "").trim();
  const value = String(root?.querySelector("input[name='quickWeatherDaeValue']")?.value ?? "").trim();
  const note = String(root?.querySelector("input[name='quickWeatherDaeNote']")?.value ?? "").trim();
  const rawMode = Math.floor(Number(root?.querySelector("select[name='quickWeatherDaeMode']")?.value ?? CONST.ACTIVE_EFFECT_MODES.ADD));
  if (!key || !value) {
    ui.notifications?.warn("DAE change requires key and value.");
    return;
  }
  const draft = getGmQuickWeatherDraft() ?? {};
  draft.daeChanges = [
    ...(Array.isArray(draft.daeChanges) ? draft.daeChanges : []),
    normalizeWeatherDaeChange({
      id: foundry.utils.randomID(),
      key,
      mode: rawMode,
      value,
      label: getDaeKeyLabel(key),
      note
    })
  ];
  setGmQuickWeatherDraft(draft);
}

async function gmQuickRemoveWeatherDaeChange(element) {
  const changeId = String(element?.dataset?.changeId ?? "").trim();
  if (!changeId) return;
  const draft = getGmQuickWeatherDraft() ?? {};
  draft.daeChanges = (Array.isArray(draft.daeChanges) ? draft.daeChanges : []).filter((entry) => String(entry?.id ?? "") !== changeId);
  setGmQuickWeatherDraft(draft);
}

async function gmQuickSaveWeatherPreset(element) {
  const root = element?.closest(".po-gm-quick-actions") ?? element?.closest(".po-gm-section");
  const draft = getGmQuickWeatherDraft() ?? {};
  const presetName = String(root?.querySelector("input[name='quickWeatherPresetName']")?.value ?? draft.presetName ?? "").trim();
  if (!presetName) {
    ui.notifications?.warn("Custom preset name is required.");
    return;
  }
  const presetId = `custom-${foundry.utils.randomID()}`;
  await updateOperationsLedger((ledger) => {
    const weather = ensureWeatherState(ledger);
    weather.customPresets.push(normalizeWeatherPreset({
      id: presetId,
      label: presetName,
      visibilityModifier: Number(draft.visibilityModifier ?? 0),
      darkness: Number(draft.darkness ?? 0),
      note: String(draft.note ?? ""),
      daeChanges: Array.isArray(draft.daeChanges) ? draft.daeChanges : [],
      isBuiltIn: false
    }));
  });
  setGmQuickWeatherDraft({
    ...draft,
    selectedKey: presetId,
    presetName
  });
  ui.notifications?.info(`Saved custom weather preset: ${presetName}.`);
}

async function gmQuickDeleteWeatherPreset(element) {
  const root = element?.closest(".po-gm-quick-actions") ?? element?.closest(".po-gm-section");
  const selectedKey = String(root?.querySelector("select[name='quickWeatherProfile']")?.value ?? getGmQuickWeatherDraft()?.selectedKey ?? "").trim();
  if (!selectedKey.startsWith("custom-")) {
    ui.notifications?.warn("Only custom presets can be removed.");
    return;
  }
  await updateOperationsLedger((ledger) => {
    const weather = ensureWeatherState(ledger);
    weather.customPresets = weather.customPresets.filter((entry) => String(entry?.id ?? "") !== selectedKey);
  });
  const ledger = getOperationsLedger();
  const weatherState = ensureWeatherState(ledger);
  const sceneSnapshot = resolveCurrentSceneWeatherSnapshot();
  const fallbackPreset = getWeatherPresetByKey(weatherState, sceneSnapshot, "clear");
  setGmQuickWeatherDraft(buildWeatherDraftFromPreset(fallbackPreset, sceneSnapshot));
  ui.notifications?.info("Removed custom weather preset.");
}

async function commitWeatherSnapshot(snapshot, options = {}) {
  if (!snapshot || typeof snapshot !== "object") return null;
  const silent = Boolean(options?.silent);
  const suppressChat = Boolean(options?.suppressChat);
  await updateOperationsLedger((ledger) => {
    const weather = ensureWeatherState(ledger);
    const environment = ensureEnvironmentState(ledger);
    weather.current = snapshot;
    weather.logs.unshift(snapshot);
    if (weather.logs.length > 100) weather.logs = weather.logs.slice(0, 100);
    environment.logs.unshift({
      id: snapshot.id,
      logType: "weather",
      label: snapshot.label,
      weatherId: snapshot.weatherId,
      darkness: snapshot.darkness,
      visibilityModifier: snapshot.visibilityModifier,
      note: snapshot.note,
      daeChanges: snapshot.daeChanges,
      createdAt: snapshot.loggedAt,
      createdBy: snapshot.loggedBy
    });
    if (environment.logs.length > 100) environment.logs = environment.logs.slice(0, 100);
  });

  if (options?.preset) await applyWeatherSceneFxForPreset(options.preset);

  const signedModifier = Number(snapshot.visibilityModifier ?? 0) > 0
    ? `+${Number(snapshot.visibilityModifier ?? 0)}`
    : String(Number(snapshot.visibilityModifier ?? 0));
  if (!silent) {
    ui.notifications?.info(`Weather logged: ${snapshot.label} (visibility modifier ${signedModifier}).`);
  }
  if (!suppressChat) {
    await ChatMessage.create({
      speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
      content: `<p><strong>Weather Logged:</strong> ${poEscapeHtml(snapshot.label)}</p><p><strong>Visibility Modifier:</strong> ${signedModifier}</p><p><strong>Effect:</strong> ${poEscapeHtml(getWeatherEffectSummary(snapshot.visibilityModifier))}</p><p><strong>DAE Changes:</strong> ${poEscapeHtml(describeWeatherDaeChanges(snapshot.daeChanges))}</p><p><strong>Darkness:</strong> ${snapshot.darkness.toFixed(2)}</p>`
    });
  }
  return {
    logged: true,
    label: String(snapshot.label ?? "Weather"),
    visibilityModifier: Number(snapshot.visibilityModifier ?? 0),
    darkness: Number(snapshot.darkness ?? 0)
  };
}

async function gmQuickSubmitWeather(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can log weather.");
    return;
  }
  const root = element?.closest(".po-gm-quick-actions") ?? element?.closest(".po-gm-section");
  const sceneSnapshot = resolveCurrentSceneWeatherSnapshot();
  const ledger = getOperationsLedger();
  const weatherState = ensureWeatherState(ledger);
  const selectedKey = String(root?.querySelector("select[name='quickWeatherProfile']")?.value ?? "").trim();
  const selectedPreset = getWeatherPresetByKey(weatherState, sceneSnapshot, selectedKey) ?? {
    key: "clear",
    label: "Clear",
    weatherId: "clear",
    darkness: sceneSnapshot.darkness,
    visibilityModifier: sceneSnapshot.visibilityModifier,
    daeChanges: []
  };
  const draft = getGmQuickWeatherDraft() ?? buildWeatherDraftFromPreset(selectedPreset, sceneSnapshot);
  const rawDarkness = Number(root?.querySelector("input[name='quickWeatherDarkness']")?.value ?? draft.darkness ?? selectedPreset.darkness ?? sceneSnapshot.darkness ?? 0);
  const darkness = Number.isFinite(rawDarkness) ? Math.max(0, Math.min(1, rawDarkness)) : 0;
  const rawVisibility = Number(root?.querySelector("input[name='quickWeatherVisibility']")?.value ?? draft.visibilityModifier ?? selectedPreset.visibilityModifier ?? 0);
  const visibilityModifier = Number.isFinite(rawVisibility) ? Math.max(-5, Math.min(5, Math.floor(rawVisibility))) : 0;
  const note = String(root?.querySelector("textarea[name='quickWeatherNote']")?.value ?? draft.note ?? "").trim();
  const daeChanges = (Array.isArray(draft.daeChanges) ? draft.daeChanges : selectedPreset.daeChanges ?? [])
    .map((entry) => normalizeWeatherDaeChange(entry))
    .filter((entry) => entry.key && entry.value);

  const snapshot = {
    id: foundry.utils.randomID(),
    label: String(selectedPreset.label ?? "Weather").trim() || "Weather",
    weatherId: String(selectedPreset.weatherId ?? selectedPreset.key ?? "").trim(),
    darkness,
    visibilityModifier,
    note: note || `Weather profile logged - darkness ${darkness.toFixed(2)}`,
    daeChanges,
    loggedAt: Date.now(),
    loggedBy: String(game.user?.name ?? "GM")
  };

  await commitWeatherSnapshot(snapshot, { preset: selectedPreset });

  setGmQuickWeatherDraft({
    selectedKey,
    darkness,
    visibilityModifier,
    note,
    presetName: String(selectedPreset.label ?? ""),
    daeChanges
  });
  setActiveGmQuickPanel("none");
}

async function loadWeatherLogToQuickPanel(logId) {
  const id = String(logId ?? "").trim();
  if (!id) return false;
  const ledger = getOperationsLedger();
  const weather = ensureWeatherState(ledger);
  const entry = weather.logs.find((row) => String(row?.id ?? "") === id);
  if (!entry) return false;

  const sceneSnapshot = resolveCurrentSceneWeatherSnapshot();
  const selectedPreset = getWeatherPresetByKey(weather, sceneSnapshot, entry.weatherId);
  setGmQuickWeatherDraft({
    ...buildWeatherDraftFromPreset(selectedPreset, sceneSnapshot),
    selectedKey: String(selectedPreset?.key ?? entry.weatherId ?? ""),
    darkness: Number(entry.darkness ?? 0),
    visibilityModifier: Number(entry.visibilityModifier ?? 0),
    note: String(entry.note ?? ""),
    daeChanges: Array.isArray(entry.daeChanges) ? entry.daeChanges : []
  });
  setActiveGmQuickPanel("weather");
  return true;
}

async function removeWeatherLogById(logId) {
  const id = String(logId ?? "").trim();
  if (!id) return false;
  let removed = false;
  await updateOperationsLedger((ledger) => {
    const weather = ensureWeatherState(ledger);
    const environment = ensureEnvironmentState(ledger);
    const before = weather.logs.length;
    weather.logs = weather.logs.filter((entry) => String(entry?.id ?? "") !== id);
    environment.logs = environment.logs.filter((entry) => !(String(entry?.id ?? "") === id && String(entry?.logType ?? "") === "weather"));
    if (weather.current && String(weather.current.id ?? "") === id) {
      weather.current = weather.logs[0] ?? null;
    }
    removed = weather.logs.length < before;
  });
  return removed;
}

async function setBaseOperationsConfig(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can manage base operations.");
    return;
  }
  const key = element?.dataset?.baseConfig;
  if (!key) return;
  await updateOperationsLedger((ledger) => {
    const baseOperations = ensureBaseOperationsState(ledger);
    if (key === "maintenanceRisk") {
      baseOperations.maintenanceRisk = String(element?.value ?? "moderate");
    }
  });
}

async function upsertBaseOperationsSite(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can manage base operations.");
    return;
  }
  const root = element?.closest(".po-base-site-editor");
  if (!root) return;
  const type = String(root.querySelector("select[name='baseSiteType']")?.value ?? "safehouse");
  const name = String(root.querySelector("input[name='baseSiteName']")?.value ?? "").trim();
  const status = String(root.querySelector("select[name='baseSiteStatus']")?.value ?? "secure");
  const pressureRaw = Number(root.querySelector("input[name='baseSitePressure']")?.value ?? 0);
  const risk = String(root.querySelector("select[name='baseSiteRisk']")?.value ?? "moderate");
  const note = String(root.querySelector("input[name='baseSiteNote']")?.value ?? "").trim();
  const maxWeightRaw = Number(root.querySelector("input[name='baseSiteMaxWeight']")?.value ?? 0);
  const maxSpaceRaw = Number(root.querySelector("input[name='baseSiteMaxSpace']")?.value ?? 0);
  if (!name) {
    ui.notifications?.warn("Base site name is required.");
    return;
  }
  const pressure = Number.isFinite(pressureRaw) ? Math.max(0, Math.floor(pressureRaw)) : 0;
  const maxWeight = Number.isFinite(maxWeightRaw) ? Math.max(0, maxWeightRaw) : 0;
  const maxSpace = Number.isFinite(maxSpaceRaw) ? Math.max(0, Math.floor(maxSpaceRaw)) : 0;

  await updateOperationsLedger((ledger) => {
    const baseOperations = ensureBaseOperationsState(ledger);
    const existing = baseOperations.sites.find((site) => {
      const siteName = String(site?.name ?? "").trim().toLowerCase();
      const siteType = String(site?.type ?? "").trim().toLowerCase();
      return siteName === name.toLowerCase() && siteType === type.toLowerCase();
    });
    if (existing) {
      existing.status = status;
      existing.pressure = pressure;
      existing.risk = risk;
      existing.note = note;
      if (!existing.storage || typeof existing.storage !== "object") existing.storage = { maxWeight: 0, maxSpace: 0, items: [] };
      existing.storage.maxWeight = maxWeight;
      existing.storage.maxSpace = maxSpace;
      if (!Array.isArray(existing.storage.items)) existing.storage.items = [];
      if (!existing.id) existing.id = foundry.utils.randomID();
      return;
    }
    baseOperations.sites.push({
      id: foundry.utils.randomID(),
      type,
      name,
      status,
      pressure,
      risk,
      note,
      storage: {
        maxWeight,
        maxSpace,
        items: []
      }
    });
  });
}

async function clearBaseOperationsSite(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can manage base operations.");
    return;
  }
  const id = element?.dataset?.baseSiteId;
  if (!id) return;
  await updateOperationsLedger((ledger) => {
    const baseOperations = ensureBaseOperationsState(ledger);
    if (id.startsWith("legacy-base-site-")) {
      const index = Number(id.replace("legacy-base-site-", ""));
      if (Number.isInteger(index) && index >= 0 && index < baseOperations.sites.length) {
        baseOperations.sites.splice(index, 1);
      }
      return;
    }
    baseOperations.sites = baseOperations.sites.filter((site) => site.id !== id);
  });
}

function buildBaseSiteStorageDialogContent(site) {
  const storage = site?.storage ?? { maxWeight: 0, maxSpace: 0, items: [] };
  const items = Array.isArray(storage.items) ? storage.items : [];
  const weightUsed = items.reduce((sum, entry) => {
    const quantity = Math.max(0, Number(entry.quantity ?? 0) || 0);
    const weight = Math.max(0, Number(entry.weight ?? 0) || 0);
    return sum + (quantity * weight);
  }, 0);
  const spaceUsed = items.reduce((sum, entry) => sum + Math.max(0, Number(entry.quantity ?? 0) || 0), 0);

  const itemRows = items.map((entry) => {
    const icon = poEscapeHtml(String(entry.img ?? "icons/svg/item-bag.svg"));
    const name = poEscapeHtml(String(entry.name ?? "Stored Item"));
    const note = poEscapeHtml(String(entry.note ?? ""));
    const qty = Math.max(1, Number(entry.quantity ?? 1) || 1);
    const weight = Math.max(0, Number(entry.weight ?? 0) || 0);
    return `
      <div class="po-op-role-row" data-storage-item-id="${poEscapeHtml(entry.id)}">
        <div class="po-op-role-head">
          <div class="po-op-role-name"><img src="${icon}" width="18" height="18" /> ${name}</div>
          <div class="po-op-role-status">Qty ${qty} - ${weight.toFixed(1)} wt each</div>
        </div>
        ${note ? `<div class="po-op-summary">${note}</div>` : ""}
        <div class="po-op-action-row">
          <button type="button" class="po-btn po-btn-sm" data-storage-action="dec" data-item-id="${poEscapeHtml(entry.id)}">-1</button>
          <button type="button" class="po-btn po-btn-sm" data-storage-action="inc" data-item-id="${poEscapeHtml(entry.id)}">+1</button>
          <button type="button" class="po-btn po-btn-sm is-danger" data-storage-action="remove" data-item-id="${poEscapeHtml(entry.id)}">Remove</button>
        </div>
      </div>
    `;
  }).join("");

  return `
    <div class="po-help po-base-storage-dialog">
      <div class="po-op-summary"><strong>${poEscapeHtml(String(site.name ?? "Storage Site"))}</strong> - ${poEscapeHtml(getBaseSiteTypeLabel(String(site.type ?? "safehouse")))}</div>
      <div class="po-op-summary">Weight: ${weightUsed.toFixed(1)} / ${Math.max(0, Number(storage.maxWeight ?? 0) || 0).toFixed(1)} - Space: ${spaceUsed} / ${Math.max(0, Number(storage.maxSpace ?? 0) || 0)}</div>

      <label class="po-resource-row">
        <span>Max Weight Capacity</span>
        <input type="number" min="0" step="0.1" class="po-input" data-storage-config="maxWeight" value="${Math.max(0, Number(storage.maxWeight ?? 0) || 0)}" />
      </label>
      <label class="po-resource-row">
        <span>Max Space Capacity</span>
        <input type="number" min="0" step="1" class="po-input" data-storage-config="maxSpace" value="${Math.max(0, Number(storage.maxSpace ?? 0) || 0)}" />
      </label>

      <div class="po-op-divider"></div>
      <div class="po-section-title">Add Item</div>
      <div class="po-hint">Drag and drop an Item onto this window or add manually below.</div>
      <div class="po-op-role-row">
        <label class="po-resource-row"><span>Name</span><input type="text" class="po-input" data-storage-add="name" placeholder="e.g. Healing Potion" /></label>
        <label class="po-resource-row"><span>Qty</span><input type="number" min="1" step="1" class="po-input" data-storage-add="quantity" value="1" /></label>
        <label class="po-resource-row"><span>Weight Each</span><input type="number" min="0" step="0.1" class="po-input" data-storage-add="weight" value="0" /></label>
        <label class="po-resource-row"><span>Notes</span><input type="text" class="po-input" data-storage-add="note" placeholder="optional" /></label>
        <button type="button" class="po-btn po-btn-sm" data-storage-action="add-manual">Add Item</button>
      </div>

      <div class="po-op-divider"></div>
      <div class="po-section-title">Stored Inventory</div>
      <div class="po-storage-drop-zone" data-storage-drop-zone>
        ${itemRows || '<div class="po-op-summary">No stored items yet.</div>'}
      </div>
    </div>
  `;
}

async function updateBaseSiteStorage(siteId, mutator) {
  const id = String(siteId ?? "").trim();
  if (!id || typeof mutator !== "function") return;
  await updateOperationsLedger((ledger) => {
    const baseOperations = ensureBaseOperationsState(ledger);
    const site = baseOperations.sites.find((entry) => entry.id === id);
    if (!site) return;
    if (!site.storage || typeof site.storage !== "object") site.storage = { maxWeight: 0, maxSpace: 0, items: [] };
    if (!Array.isArray(site.storage.items)) site.storage.items = [];
    mutator(site);
    site.storage.items = site.storage.items.map((entry) => normalizeBaseSiteStorageItem(entry));
  });
}

function buildStorageItemFromDocument(itemDoc, quantity = 1) {
  const qty = Math.max(1, Math.floor(Number(quantity) || 1));
  const weight = Math.max(0, Number(getItemWeightValue(itemDoc) || 0));
  return {
    id: foundry.utils.randomID(),
    name: String(itemDoc?.name ?? "Stored Item").trim() || "Stored Item",
    type: String(itemDoc?.type ?? "item").trim() || "item",
    quantity: qty,
    weight,
    note: "",
    img: String(itemDoc?.img ?? "icons/svg/item-bag.svg"),
    uuid: String(itemDoc?.uuid ?? "")
  };
}

async function showBaseSiteStorageManager(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can manage base site storage.");
    return;
  }
  const siteId = String(element?.dataset?.baseSiteId ?? "").trim();
  if (!siteId) return;

  const getCurrentSite = () => {
    const ledger = getOperationsLedger();
    const baseOperations = ensureBaseOperationsState(ledger);
    return baseOperations.sites.find((site) => site.id === siteId) ?? null;
  };

  let site = getCurrentSite();
  if (!site) {
    ui.notifications?.warn("Base site not found.");
    return;
  }

  const dialog = new Dialog({
    title: `Storage Inventory - ${String(site.name ?? "Site")}`,
    content: buildBaseSiteStorageDialogContent(site),
    buttons: {
      close: {
        label: "Close"
      }
    },
    render: (html) => {
      const root = html?.[0] ?? html;
      if (!root) return;

      const rerenderStorage = () => {
        site = getCurrentSite();
        if (!site) return;
        const contentRoot = root.querySelector(".po-base-storage-dialog");
        if (!contentRoot) return;
        contentRoot.outerHTML = buildBaseSiteStorageDialogContent(site);
      };

      const onStorageClick = async (event) => {
        const actionEl = event.target.closest("[data-storage-action]");
        if (!actionEl) return;
        const action = String(actionEl.dataset.storageAction ?? "").trim();
        const itemId = String(actionEl.dataset.itemId ?? "").trim();

        if (action === "add-manual") {
          const name = String(root.querySelector("[data-storage-add='name']")?.value ?? "").trim();
          const quantityRaw = Number(root.querySelector("[data-storage-add='quantity']")?.value ?? 1);
          const quantity = Number.isFinite(quantityRaw) ? Math.max(1, Math.floor(quantityRaw)) : 1;
          const weightRaw = Number(root.querySelector("[data-storage-add='weight']")?.value ?? 0);
          const weight = Number.isFinite(weightRaw) ? Math.max(0, weightRaw) : 0;
          const note = String(root.querySelector("[data-storage-add='note']")?.value ?? "");
          if (!name) {
            ui.notifications?.warn("Item name is required.");
            return;
          }
          await updateBaseSiteStorage(siteId, (targetSite) => {
            targetSite.storage.items.push(normalizeBaseSiteStorageItem({
              id: foundry.utils.randomID(),
              name,
              quantity,
              weight,
              note,
              img: "icons/svg/item-bag.svg",
              type: "item"
            }));
          });
          rerenderStorage();
          return;
        }

        if (!itemId) return;
        if (action === "remove") {
          await updateBaseSiteStorage(siteId, (targetSite) => {
            targetSite.storage.items = targetSite.storage.items.filter((entry) => entry.id !== itemId);
          });
          rerenderStorage();
          return;
        }

        if (action === "inc" || action === "dec") {
          await updateBaseSiteStorage(siteId, (targetSite) => {
            const row = targetSite.storage.items.find((entry) => entry.id === itemId);
            if (!row) return;
            const delta = action === "inc" ? 1 : -1;
            row.quantity = Math.max(0, Math.floor(Number(row.quantity ?? 0) || 0) + delta);
            if (row.quantity <= 0) {
              targetSite.storage.items = targetSite.storage.items.filter((entry) => entry.id !== itemId);
            }
          });
          rerenderStorage();
        }
      };

      const onStorageChange = async (event) => {
        const configEl = event.target.closest("[data-storage-config]");
        if (!configEl) return;
        const configKey = String(configEl.dataset.storageConfig ?? "").trim();
        if (!configKey) return;
        await updateBaseSiteStorage(siteId, (targetSite) => {
          if (configKey === "maxWeight") {
            const raw = Number(configEl.value ?? 0);
            targetSite.storage.maxWeight = Number.isFinite(raw) ? Math.max(0, raw) : 0;
          }
          if (configKey === "maxSpace") {
            const raw = Number(configEl.value ?? 0);
            targetSite.storage.maxSpace = Number.isFinite(raw) ? Math.max(0, Math.floor(raw)) : 0;
          }
        });
        rerenderStorage();
      };

      const onStorageDrop = async (event) => {
        const dropZone = event.target.closest("[data-storage-drop-zone]");
        if (!dropZone) return;
        event.preventDefault();

        let itemDoc = null;
        const data = TextEditor.getDragEventData(event);
        if (data?.uuid && typeof fromUuid === "function") {
          itemDoc = await fromUuid(data.uuid);
        } else if (data?.type === "Item" && data?.data) {
          itemDoc = data.data;
        }

        if (!itemDoc) {
          ui.notifications?.warn("Could not read dropped item data.");
          return;
        }

        const nextItem = buildStorageItemFromDocument(itemDoc, 1);
        await updateBaseSiteStorage(siteId, (targetSite) => {
          const same = targetSite.storage.items.find((entry) => {
            const entryUuid = String(entry.uuid ?? "").trim();
            const nextUuid = String(nextItem.uuid ?? "").trim();
            if (entryUuid && nextUuid) return entryUuid === nextUuid;
            return String(entry.name ?? "").trim().toLowerCase() === String(nextItem.name ?? "").trim().toLowerCase()
              && Number(entry.weight ?? 0) === Number(nextItem.weight ?? 0);
          });
          if (same) same.quantity = Math.max(1, Math.floor(Number(same.quantity ?? 0) || 0) + 1);
          else targetSite.storage.items.push(normalizeBaseSiteStorageItem(nextItem));
        });
        rerenderStorage();
      };

      root.addEventListener("click", onStorageClick);
      root.addEventListener("change", onStorageChange);
      root.addEventListener("drop", onStorageDrop);
      root.addEventListener("dragover", (event) => {
        if (event.target.closest("[data-storage-drop-zone]")) event.preventDefault();
      });
    }
  });

  dialog.render(true);
}

async function showBaseOperationsBrief() {
  const baseOperations = buildOperationsContext().baseOperations;
  const sites = baseOperations.sites
    .map((site) => `<li>${site.typeLabel}: ${site.name} - ${site.statusLabel} - Pressure ${site.pressure} - Risk ${site.risk} - Storage ${site.storageItemCount} items (${site.storageWeightSummary} wt, ${site.storageSpaceSummary} space)${site.note ? ` - ${site.note}` : ""}</li>`)
    .join("");

  const content = `
    <div class="po-help">
      <p><strong>Maintenance Risk:</strong> ${baseOperations.maintenanceRisk}</p>
      <p><strong>Active Sites:</strong> ${baseOperations.activeSites}</p>
      <p><strong>Contested Sites:</strong> ${baseOperations.contestedSites}</p>
      <p><strong>Pressure Pool:</strong> ${baseOperations.pressureSum}</p>
      <p><strong>Maintenance Pressure:</strong> ${baseOperations.maintenancePressure}</p>
      <p><strong>Network Readiness:</strong> ${baseOperations.readiness ? "Stable" : "At Risk"}</p>
      <p><strong>Sites</strong></p>
      <ul>${sites || "<li>No base sites tracked.</li>"}</ul>
    </div>
  `;

  await Dialog.prompt({
    title: "Base of Operations Brief",
    content,
    rejectClose: false,
    callback: () => {}
  });
}

async function applyOperationalUpkeep(options = {}) {
  const before = getOperationsLedger();
  if (!before.resources) before.resources = {};
  ensureOperationalResourceConfig(before.resources);
  const currentTimestamp = getCurrentWorldTimestamp();
  const upkeep = before.resources?.upkeep ?? {};
  const isAutomatic = Boolean(options?.automatic);
  const silent = Boolean(options?.silent);
  const suppressChat = Boolean(options?.suppressChat);
  const beforeFoodPoolMode = normalizeStewardPoolMode(before.resources?.stewardPools?.food?.mode);
  const beforeWaterPoolMode = normalizeStewardPoolMode(before.resources?.stewardPools?.water?.mode);
  const beforeTorchPoolMode = normalizeStewardPoolMode(before.resources?.stewardPools?.torches?.mode);

  if (isAutomatic && !Number.isFinite(Number(before.resources?.upkeepLastAppliedTs))) {
    await updateOperationsLedger((ledger) => {
      if (!ledger.resources) ledger.resources = {};
      ensureOperationalResourceConfig(ledger.resources);
      ledger.resources.upkeepLastAppliedTs = currentTimestamp;
    }, { skipLocalRefresh: true });
    return { applied: false, initializedClock: true, upkeepDays: 0, summary: "Initialized upkeep clock." };
  }

  const partySize = Math.max(0, Number(upkeep.partySize ?? 0));
  const foodPerMember = Math.max(0, Number(upkeep.foodPerMember ?? 0));
  const waterPerMember = Math.max(0, Number(upkeep.waterPerMember ?? 0));
  const foodMultiplier = Math.max(0, Number(upkeep.foodMultiplier ?? 1));
  const waterMultiplier = Math.max(0, Number(upkeep.waterMultiplier ?? 1));
  const torchPerRest = Math.max(0, Number(upkeep.torchPerRest ?? 0));

  const upkeepDays = getUpkeepDaysFromCalendar(before.resources?.upkeepLastAppliedTs, currentTimestamp);
  if (upkeepDays <= 0) {
    if (!isAutomatic && !silent) ui.notifications?.info("No upkeep is due yet (next deduction occurs at 20:00 world time).");
    return { applied: false, upkeepDays: 0, summary: "No upkeep due yet." };
  }

  const foodDrainPerDay = Math.ceil(partySize * foodPerMember * foodMultiplier);
  const waterDrainPerDay = Math.ceil(partySize * waterPerMember * waterMultiplier);
  const torchDrainPerDay = Math.ceil(torchPerRest);
  const foodDrain = foodDrainPerDay * upkeepDays;
  const waterDrain = waterDrainPerDay * upkeepDays;
  const torchDrain = torchDrainPerDay * upkeepDays;

  const lastDueCount = Number.isFinite(Number(before.resources?.upkeepLastAppliedTs))
    ? getUpkeepDueCount(Number(before.resources?.upkeepLastAppliedTs))
    : getUpkeepDueCount(currentTimestamp) - upkeepDays;
  const currentDueCount = getUpkeepDueCount(currentTimestamp);
  const foodCoverageDueKey = Number(before.resources?.gather?.foodCoverageDueKey);
  const waterCoverageDueKey = Number(before.resources?.gather?.waterCoverageDueKey);
  const foodCoveredDays = Number.isFinite(foodCoverageDueKey) && foodCoverageDueKey > lastDueCount && foodCoverageDueKey <= currentDueCount ? 1 : 0;
  const waterCoveredDays = Number.isFinite(waterCoverageDueKey) && waterCoverageDueKey > lastDueCount && waterCoverageDueKey <= currentDueCount ? 1 : 0;
  const effectiveFoodDrain = Math.max(0, foodDrain - (foodCoveredDays * foodDrainPerDay));
  const effectiveWaterDrain = Math.max(0, waterDrain - (waterCoveredDays * waterDrainPerDay));
  const itemSelections = foundry.utils.deepClone(before.resources?.itemSelections ?? {});

  let afterPartyFoodRations = 0;
  let afterWater = 0;
  let afterPartyWaterRations = 0;
  let afterTorches = 0;
  let foodRationUsed = 0;
  let foodTargetedUsed = 0;
  let waterRationUsed = 0;
  let waterStoreUsed = 0;
  let waterTargetedUsed = 0;
  let torchPoolUsed = 0;
  let torchTargetedUsed = 0;
  let unmetFoodDrain = 0;
  let unmetWaterDrain = 0;
  let unmetTorchDrain = 0;

  await updateOperationsLedger((ledger) => {
    if (!ledger.resources) ledger.resources = {};
    ensureOperationalResourceConfig(ledger.resources);
    const foodPool = getStewardPoolEntry(ledger.resources, "food");
    const waterPool = getStewardPoolEntry(ledger.resources, "water");
    const torchPool = getStewardPoolEntry(ledger.resources, "torches");
    const foodPoolMode = normalizeStewardPoolMode(foodPool.mode);
    const waterPoolMode = normalizeStewardPoolMode(waterPool.mode);
    const torchPoolMode = normalizeStewardPoolMode(torchPool.mode);
    const currentPartyFoodRations = Math.max(0, Number(foodPool.amount ?? 0));
    const currentWater = Math.max(0, Number(ledger.resources.water ?? 0));
    const currentPartyWaterRations = Math.max(0, Number(waterPool.amount ?? 0));
    const currentTorches = Math.max(0, Number(torchPool.amount ?? 0));

    let remainingFoodDrain = effectiveFoodDrain;
    if (foodPoolMode === STEWARD_POOL_MODES.INFINITE) {
      foodRationUsed = remainingFoodDrain;
      remainingFoodDrain = 0;
    } else {
      foodRationUsed = Math.min(currentPartyFoodRations, remainingFoodDrain);
      remainingFoodDrain -= foodRationUsed;
    }
    unmetFoodDrain = Math.max(0, remainingFoodDrain);

    let remainingWaterDrain = effectiveWaterDrain;
    if (waterPoolMode === STEWARD_POOL_MODES.INFINITE) {
      waterRationUsed = remainingWaterDrain;
      remainingWaterDrain = 0;
    } else {
      waterRationUsed = Math.min(currentPartyWaterRations, remainingWaterDrain);
      remainingWaterDrain -= waterRationUsed;
    }
    waterStoreUsed = Math.min(currentWater, remainingWaterDrain);
    remainingWaterDrain -= waterStoreUsed;
    unmetWaterDrain = Math.max(0, remainingWaterDrain);

    if (torchPoolMode === STEWARD_POOL_MODES.INFINITE) {
      torchPoolUsed = torchDrain;
      unmetTorchDrain = 0;
    } else {
      torchPoolUsed = Math.min(currentTorches, torchDrain);
      unmetTorchDrain = Math.max(0, torchDrain - torchPoolUsed);
    }

    afterPartyFoodRations = Math.max(0, currentPartyFoodRations - foodRationUsed);
    afterPartyWaterRations = Math.max(0, currentPartyWaterRations - waterRationUsed);
    afterWater = Math.max(0, currentWater - waterStoreUsed);
    afterTorches = Math.max(0, currentTorches - torchPoolUsed);

    if (foodPoolMode === STEWARD_POOL_MODES.FINITE) foodPool.amount = afterPartyFoodRations;
    if (waterPoolMode === STEWARD_POOL_MODES.FINITE) waterPool.amount = afterPartyWaterRations;
    if (torchPoolMode === STEWARD_POOL_MODES.FINITE) torchPool.amount = afterTorches;
    ledger.resources.stewardPools.food = foodPool;
    ledger.resources.stewardPools.water = waterPool;
    ledger.resources.stewardPools.torches = torchPool;
    ensureStewardPoolsState(ledger.resources);
    ledger.resources.water = afterWater;
    ledger.resources.gather.foodCoveredNextUpkeep = false;
    ledger.resources.gather.waterCoveredNextUpkeep = false;
    if (Number.isFinite(foodCoverageDueKey) && foodCoverageDueKey <= currentDueCount) ledger.resources.gather.foodCoverageDueKey = null;
    if (Number.isFinite(waterCoverageDueKey) && waterCoverageDueKey <= currentDueCount) ledger.resources.gather.waterCoverageDueKey = null;
    ledger.resources.upkeepLastAppliedTs = currentTimestamp;
  });

  let itemResults = [];
  try {
    itemResults = await depleteLinkedResourceItems({
      foodDrain: unmetFoodDrain,
      waterDrain: unmetWaterDrain,
      torchDrain: unmetTorchDrain
    }, itemSelections);
  } catch (error) {
    logUiFailure("resources", "linked resource depletion failed during upkeep", error, {
      foodDrain: unmetFoodDrain,
      waterDrain: unmetWaterDrain,
      torchDrain: unmetTorchDrain
    });
    throw error;
  }
  const foodItemResult = itemResults.find((entry) => entry.key === "food");
  const waterItemResult = itemResults.find((entry) => entry.key === "water");
  const torchItemResult = itemResults.find((entry) => entry.key === "torches");
  foodTargetedUsed = Math.max(0, Number(foodItemResult?.consumed ?? 0));
  waterTargetedUsed = Math.max(0, Number(waterItemResult?.consumed ?? 0));
  torchTargetedUsed = Math.max(0, Number(torchItemResult?.consumed ?? 0));
  unmetFoodDrain = Math.max(0, unmetFoodDrain - foodTargetedUsed);
  unmetWaterDrain = Math.max(0, unmetWaterDrain - waterTargetedUsed);
  unmetTorchDrain = Math.max(0, unmetTorchDrain - torchTargetedUsed);

  const shortages = [];
  if (unmetFoodDrain > 0) shortages.push(`food short by ${unmetFoodDrain}`);
  if (unmetWaterDrain > 0) shortages.push(`water short by ${unmetWaterDrain}`);
  if (unmetTorchDrain > 0) shortages.push(`torches short by ${unmetTorchDrain}`);
  if (beforeTorchPoolMode !== STEWARD_POOL_MODES.INFINITE && afterTorches === 0 && torchPoolUsed > 0) shortages.push("torches depleted");

  const foodPoolLabel = beforeFoodPoolMode === STEWARD_POOL_MODES.INFINITE ? "Steward Food Surplus" : "Steward Food Stock";
  const waterPoolLabel = beforeWaterPoolMode === STEWARD_POOL_MODES.INFINITE ? "Steward Water Surplus" : "Steward Water Stock";
  const torchPoolLabel = beforeTorchPoolMode === STEWARD_POOL_MODES.INFINITE ? "Steward Torch Surplus" : "Steward Torch Stock";
  const foodSummary = foodCoveredDays > 0
    ? `Food -${effectiveFoodDrain} (${foodCoveredDays} day covered by successful gather check; ${foodPoolLabel} -${foodRationUsed}, Targeted Food Item -${foodTargetedUsed})`
    : `Food -${effectiveFoodDrain} (${foodPoolLabel} -${foodRationUsed}, Targeted Food Item -${foodTargetedUsed})`;
  const waterSummary = waterCoveredDays > 0
    ? `Water -${effectiveWaterDrain} (${waterCoveredDays} day covered by successful gather check; ${waterPoolLabel} -${waterRationUsed}, Water Stores -${waterStoreUsed}, Targeted Water Item -${waterTargetedUsed})`
    : `Water -${effectiveWaterDrain} (${waterPoolLabel} -${waterRationUsed}, Water Stores -${waterStoreUsed}, Targeted Water Item -${waterTargetedUsed})`;
  const torchSummary = `Torches -${torchDrain} (${torchPoolLabel} -${torchPoolUsed}, Targeted Torch Item -${torchTargetedUsed})`;
  const summary = `Daily upkeep applied for ${upkeepDays} day(s): ${foodSummary}, ${waterSummary}, ${torchSummary}.`;
  const itemSummary = itemResults
    .filter((entry) => entry.needed > 0)
    .map((entry) => `${entry.name}: ${entry.consumed}/${entry.needed}${entry.missing > 0 ? ` (missing ${entry.missing})` : ""}`)
    .join(" | ");

  if (!silent && shortages.length > 0) {
    ui.notifications?.warn(`${summary} Shortages: ${shortages.join(", ")}.`);
  } else if (!isAutomatic && !silent) {
    ui.notifications?.info(summary);
  }

  const context = buildOperationsContext();
  const effects = context.summary.effects;
  const riskLine = effects.riskTier === "high"
    ? "Operational risk is HIGH: apply one complication roll this cycle."
    : effects.riskTier === "moderate"
      ? "Operational risk is MODERATE: keep one risk trigger in reserve."
      : "Operational risk is LOW.";

  if (!suppressChat && (!isAutomatic || shortages.length > 0)) {
    await ChatMessage.create({
      speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
      content: `<p><strong>Daily Upkeep</strong></p><p>${summary}</p>${itemSummary ? `<p><strong>Actor Item Depletion:</strong> ${itemSummary}</p>` : ""}<p>${riskLine}</p>`
    });
  }

  return {
    applied: true,
    upkeepDays,
    summary,
    shortages,
    itemSummary,
    riskLine
  };
}

function getSessionAutopilotSnapshot() {
  const raw = game.settings.get(MODULE_ID, SETTINGS.SESSION_AUTOPILOT_SNAPSHOT);
  return raw && typeof raw === "object" ? raw : {};
}

function buildSessionAutopilotSnapshot() {
  return {
    id: foundry.utils.randomID(),
    createdAt: Date.now(),
    createdBy: String(game.user?.name ?? "GM"),
    restState: foundry.utils.deepClone(getRestWatchState()),
    marchState: foundry.utils.deepClone(getMarchingOrderState()),
    restActivities: foundry.utils.deepClone(getRestActivities()),
    operationsLedger: foundry.utils.deepClone(getOperationsLedger()),
    injuryRecovery: foundry.utils.deepClone(getInjuryRecoveryState())
  };
}

async function logCurrentSceneWeatherSnapshot(options = {}) {
  if (!canAccessAllPlayerOps()) return { logged: false, reason: "gm-only" };
  const sceneSnapshot = resolveCurrentSceneWeatherSnapshot();
  const weatherState = ensureWeatherState(getOperationsLedger());
  const previous = weatherState.current ?? null;
  const previousDae = Array.isArray(previous?.daeChanges)
    ? previous.daeChanges.map((entry) => normalizeWeatherDaeChange(entry)).filter((entry) => entry.key && entry.value)
    : [];
  const snapshot = {
    id: foundry.utils.randomID(),
    label: String(sceneSnapshot.label ?? previous?.label ?? "Weather").trim() || "Weather",
    weatherId: String(sceneSnapshot.weatherId ?? previous?.weatherId ?? "").trim(),
    darkness: Number.isFinite(Number(sceneSnapshot.darkness)) ? Math.max(0, Math.min(1, Number(sceneSnapshot.darkness))) : 0,
    visibilityModifier: Number.isFinite(Number(sceneSnapshot.visibilityModifier)) ? Math.max(-5, Math.min(5, Math.floor(Number(sceneSnapshot.visibilityModifier)))) : 0,
    note: String(sceneSnapshot.note ?? previous?.note ?? "").trim() || `Scene weather snapshot logged at darkness ${Number(sceneSnapshot.darkness ?? 0).toFixed(2)}`,
    daeChanges: previousDae,
    loggedAt: Date.now(),
    loggedBy: String(game.user?.name ?? "GM")
  };
  const selectedPreset = getWeatherPresetByKey(weatherState, sceneSnapshot, snapshot.weatherId);
  return commitWeatherSnapshot(snapshot, {
    preset: selectedPreset,
    silent: Boolean(options?.silent),
    suppressChat: Boolean(options?.suppressChat)
  });
}

async function runSessionAutopilot(options = {}) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can run session autopilot.");
    return null;
  }
  const requireConfirm = options.confirm !== false;
  if (requireConfirm) {
    const confirmed = await Dialog.confirm({
      title: "Run Session Autopilot?",
      content: `
        <p>This will run the automated session cycle:</p>
        <ul>
          <li>Apply daily upkeep (if due)</li>
          <li>Run injury recovery cycle</li>
          <li>Log current scene weather snapshot</li>
          <li>Run integration sync (effects/flags)</li>
          <li>Sync injuries to Simple Calendar</li>
        </ul>
        <p>A full snapshot is saved first so you can use <strong>Undo Autopilot</strong>.</p>
      `
    });
    if (!confirmed) return null;
  }

  const snapshot = buildSessionAutopilotSnapshot();
  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.SESSION_AUTOPILOT_SNAPSHOT, snapshot);

  const notes = [];
  const upkeepResult = await applyOperationalUpkeep({ silent: true, suppressChat: true });
  if (upkeepResult?.applied) notes.push(`Upkeep applied (${upkeepResult.upkeepDays} day(s)).`);
  else if (upkeepResult?.upkeepDays === 0) notes.push("Upkeep skipped (not due).");
  else if (upkeepResult?.initializedClock) notes.push("Upkeep clock initialized.");

  const recoveryResult = await applyRecoveryCycle({ silent: true, suppressChat: true });
  if (recoveryResult?.applied) {
    notes.push(`Recovery cycle processed (${recoveryResult.total} tracked injuries, ${recoveryResult.syncedActors} synced).`);
  } else {
    notes.push("Recovery cycle skipped (no tracked injuries).");
  }

  const weatherResult = await logCurrentSceneWeatherSnapshot({ silent: true, suppressChat: true });
  if (weatherResult?.logged) {
    notes.push(`Weather logged (${weatherResult.label}, visibility ${formatSignedModifier(weatherResult.visibilityModifier)}).`);
  }

  await flushIntegrationSyncQueue("session-autopilot");
  notes.push("Integration sync completed.");

  const calendarResult = await syncAllInjuriesToSimpleCalendar();
  notes.push(`Injury calendar sync ${calendarResult.synced}/${calendarResult.total}.`);

  const context = buildOperationsContext();
  const nonPartyGlobal = Boolean(context.partyHealth?.syncToSceneNonParty);
  const nonPartyEnvironment = Boolean(context.environment?.syncToSceneNonParty && String(context.environment?.presetKey ?? "none") !== "none");
  const nonPartyScopeLabel = getNonPartySyncScopeLabel(getNonPartySyncScope(context.partyHealth?.nonPartySyncScope));
  const nonPartyLine = `Non-party sync (${nonPartyScopeLabel}): modifiers ${nonPartyGlobal ? "ON" : "OFF"} | environment ${nonPartyEnvironment ? "ON" : "OFF"}.`;
  notes.push(nonPartyLine);

  const stamp = new Date().toLocaleString();
  await ChatMessage.create({
    speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
    content: `<p><strong>Session Autopilot</strong></p><p>${notes.map((line) => poEscapeHtml(line)).join("<br>")}</p><p><em>${poEscapeHtml(stamp)}</em></p>`
  });
  ui.notifications?.info("Session Autopilot complete. Snapshot saved for undo.");
  return {
    ok: true,
    notes,
    snapshotId: snapshot.id
  };
}

async function undoLastSessionAutopilot(options = {}) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can undo session autopilot.");
    return false;
  }
  const snapshot = getSessionAutopilotSnapshot();
  if (!snapshot || !snapshot.createdAt) {
    ui.notifications?.warn("No saved session autopilot snapshot found.");
    return false;
  }
  const requireConfirm = options.confirm !== false;
  if (requireConfirm) {
    const createdAt = new Date(Number(snapshot.createdAt)).toLocaleString();
    const confirmed = await Dialog.confirm({
      title: "Undo Session Autopilot?",
      content: `
        <p>This restores the snapshot saved before the last autopilot run.</p>
        <p><strong>Snapshot:</strong> ${poEscapeHtml(createdAt)} by ${poEscapeHtml(String(snapshot.createdBy ?? "GM"))}</p>
        <p>It will restore Rest Watch, Marching Order, Activities, Operations, and Injury Recovery states.</p>
      `
    });
    if (!confirmed) return false;
  }

  const writes = [
    [SETTINGS.REST_STATE, foundry.utils.deepClone(snapshot.restState ?? buildDefaultRestWatchState())],
    [SETTINGS.MARCH_STATE, foundry.utils.deepClone(snapshot.marchState ?? buildDefaultMarchingOrderState())],
    [SETTINGS.REST_ACTIVITIES, foundry.utils.deepClone(snapshot.restActivities ?? buildDefaultActivityState())],
    [SETTINGS.OPS_LEDGER, foundry.utils.deepClone(snapshot.operationsLedger ?? buildDefaultOperationsLedger())],
    [SETTINGS.INJURY_RECOVERY, foundry.utils.deepClone(snapshot.injuryRecovery ?? buildDefaultInjuryRecoveryState())]
  ];

  for (const [settingKey, value] of writes) {
    await setModuleSettingWithLocalRefreshSuppressed(settingKey, value);
  }

  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.SESSION_AUTOPILOT_SNAPSHOT, {
    ...snapshot,
    undoneAt: Date.now(),
    undoneBy: String(game.user?.name ?? "GM")
  });

  scheduleIntegrationSync("session-autopilot-undo");
  refreshOpenApps();
  emitSocketRefresh();
  await ChatMessage.create({
    speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
    content: `<p><strong>Session Autopilot Undo</strong></p><p>Restored snapshot from ${poEscapeHtml(new Date(Number(snapshot.createdAt)).toLocaleString())}.</p>`
  });
  ui.notifications?.info("Session Autopilot snapshot restored.");
  return true;
}

async function showOperationalBrief() {
  const context = buildOperationsContext();
  const bonusItems = context.summary.effects.bonuses.map((item) => `<li>${item}</li>`).join("");
  const globalMinorBonusItems = context.summary.effects.globalMinorBonuses.map((item) => `<li>${item}</li>`).join("");
  const globalModifierItems = (context.summary.effects.globalModifierRows ?? [])
    .map((item) => `<li>${item.label}: ${item.formatted} - applies to ${item.appliesTo}${item.enabled ? "" : " - OFF"}</li>`)
    .join("");
  const riskItems = context.summary.effects.risks.map((item) => `<li>${item}</li>`).join("");
  const missingRoles = context.diagnostics.missingRoles.length
    ? context.diagnostics.missingRoles.join(", ")
    : "None";
  const inactiveSops = context.diagnostics.inactiveSops.length
    ? context.diagnostics.inactiveSops.join(", ")
    : "None";

  const content = `
    <div class="po-help">
      <p><strong>Preparation Edge:</strong> ${context.summary.effects.prepEdge ? "Active" : "Inactive"}</p>
      <p><strong>Risk Tier:</strong> ${context.summary.effects.riskTier.toUpperCase()}</p>
      <p><strong>Missing Roles:</strong> ${missingRoles}</p>
      <p><strong>Inactive SOPs:</strong> ${inactiveSops}</p>
      <p><strong>Bonuses</strong></p>
      <ul>${bonusItems || "<li>None active.</li>"}</ul>
      <p><strong>Party Health Global Modifiers (DAE Synced)</strong></p>
      <ul>${globalModifierItems || "<li>No active Party Health global modifiers.</li>"}</ul>
      <p><strong>Active Positive Effects</strong></p>
      <ul>${globalMinorBonusItems || "<li>No active global minor bonuses.</li>"}</ul>
      <p><strong>Risks</strong></p>
      <ul>${riskItems || "<li>No immediate penalties.</li>"}</ul>
    </div>
  `;

  await Dialog.prompt({
    title: "Operational Brief",
    content,
    rejectClose: false,
    callback: () => {}
  });
}

const INJURY_TABLE = [
  { key: "lost-limb", min: 1, max: 5, label: "Lost Limb", effect: "Lose an arm or leg (1d4). Limb is unusable. Movement halved if leg, no weapons/shields if arm.", recovery: "Permanent. Only Regenerate or divine magic can restore.", permanent: true, kitCharges: 0 },
  { key: "crippling-injury", min: 6, max: 10, label: "Crippling Injury", effect: "Disadvantage on actions with that limb. Halved speed if leg. Shield bonus halved if arm.", recovery: "1d4 days or 2 kit charges + DC 12 Medicine.", dayMin: 1, dayMax: 4, kitCharges: 2, treatmentDc: 12, treatmentSkill: "med" },
  { key: "concussion", min: 11, max: 15, label: "Concussion", effect: "Disadvantage on INT/WIS checks and saves. -5 Passive Perception.", recovery: "1d4 days or 1 kit charge.", dayMin: 1, dayMax: 4, kitCharges: 1 },
  { key: "broken-arm", min: 16, max: 20, label: "Broken Arm", effect: "Cannot use that arm for weapons, shields, or somatic spells.", recovery: "2d4 days or 2 kit charges to downgrade to Crippling (half days).", dayMin: 2, dayMax: 8, kitCharges: 2, downgradeTo: "crippling-injury", downgradeHalfDays: true },
  { key: "fractured-ribs", min: 21, max: 25, label: "Fractured Ribs", effect: "Disadvantage on DEX saves and CON checks. Dash causes 1d4 damage.", recovery: "1d4+1 days or 2 kit charges.", dayMin: 2, dayMax: 5, kitCharges: 2 },
  { key: "internal-bleeding", min: 26, max: 30, label: "Internal Bleeding", effect: "At start of combat, roll 1d6. On a 1, take 1d4 damage.", recovery: "3 kit charges + DC 15 Medicine or magic healing.", dayMin: 3, dayMax: 3, kitCharges: 3, treatmentDc: 15, treatmentSkill: "med" },
  { key: "deep-cut", min: 31, max: 35, label: "Deep Cut", effect: "Lose 1d6 max HP. Cannot regain until treated.", recovery: "1 kit charge or 1 hour rest + DC 13 Medicine.", dayMin: 1, dayMax: 1, kitCharges: 1, treatmentDc: 13, treatmentSkill: "med" },
  { key: "loss-of-eye", min: 36, max: 40, label: "Loss of Eye", effect: "Disadvantage on Perception and ranged attacks.", recovery: "Permanent unless magically restored.", permanent: true, kitCharges: 0 },
  { key: "loss-of-hearing", min: 41, max: 45, label: "Loss of Hearing", effect: "Disadvantage on sound-based Perception.", recovery: "Permanent unless magically restored.", permanent: true, kitCharges: 0 },
  { key: "shattered-knee", min: 46, max: 50, label: "Shattered Knee", effect: "No Dash. Speed halved. Painful to move.", recovery: "1 week or 3 kit charges. Becomes permanent if untreated.", dayMin: 7, dayMax: 7, kitCharges: 3, canBecomePermanent: true },
  { key: "dislocated-shoulder", min: 51, max: 55, label: "Dislocated Shoulder", effect: "Disadvantage on STR checks and melee attacks.", recovery: "1d6 days of rest.", dayMin: 1, dayMax: 6, kitCharges: 0 },
  { key: "infection", min: 56, max: 60, label: "Infection", effect: "Lose 1 max HP after each long rest. DC 15 CON to resist.", recovery: "2 kit charges.", dayMin: 3, dayMax: 3, kitCharges: 2 },
  { key: "minor-injury", min: 61, max: 70, label: "Minor Injury", effect: "No combat effect. Bloodied, limping, or visibly bruised.", recovery: "1 kit charge or 1d3 days rest.", dayMin: 1, dayMax: 3, kitCharges: 1 },
  { key: "deep-scar", min: 71, max: 80, label: "Deep Scar", effect: "+1 Intimidation, -1 Persuasion (if visible).", recovery: "Permanent.", permanent: true, kitCharges: 0 },
  { key: "psychic-trauma", min: 81, max: 90, label: "Psychic Trauma", effect: "Disadvantage on saves vs fear or charm.", recovery: "1 week or 2 kit charges + DC 13 Insight (once).", dayMin: 7, dayMax: 7, kitCharges: 2, treatmentDc: 13, treatmentSkill: "ins" },
  { key: "nerve-damage", min: 91, max: 95, label: "Nerve Damage", effect: "1 ability score (roll 1d6) suffers -1 temporarily.", recovery: "1 week or 2 kit charges. Permanent on failed DC 13 CON.", dayMin: 7, dayMax: 7, kitCharges: 2, treatmentDc: 13, treatmentSkill: "con", canBecomePermanent: true },
  { key: "nightmares", min: 96, max: 99, label: "Nightmares", effect: "Disadvantage on first initiative roll daily. Long rests do not remove exhaustion.", recovery: "Remove Curse or 4 kit charges to ease mental symptoms.", dayMin: 7, dayMax: 7, kitCharges: 4 },
  { key: "soul-shaken", min: 100, max: 100, label: "Soul-Shaken", effect: "Permanent -1 to Wisdom saves. Shadows cling to your soul.", recovery: "Permanent unless resolved through divine magic or narrative quest.", permanent: true, kitCharges: 0 }
];

function getInjuryDefinitionByKey(key) {
  return INJURY_TABLE.find((entry) => entry.key === key) ?? null;
}

function findInjuryDefinitionByRoll(roll) {
  const value = Math.max(1, Math.min(100, Number(roll) || 1));
  return INJURY_TABLE.find((entry) => value >= entry.min && value <= entry.max) ?? INJURY_TABLE[0];
}

function rollInjuryDefinition() {
  const roll = Math.floor(Math.random() * 100) + 1;
  const injury = findInjuryDefinitionByRoll(roll);
  return { roll, injury };
}

function rollInjuryRecoveryDays(definition, fallback = 3) {
  const min = Number(definition?.dayMin ?? fallback);
  const max = Number(definition?.dayMax ?? min);
  if (!Number.isFinite(min) || !Number.isFinite(max)) return Math.max(1, Math.floor(fallback));
  const low = Math.max(1, Math.floor(Math.min(min, max)));
  const high = Math.max(low, Math.floor(Math.max(min, max)));
  return low + Math.floor(Math.random() * (high - low + 1));
}

function getInjuryRecoveryFormula(definition, fallback = 3) {
  if (definition?.permanent) return "Permanent";
  const min = Number(definition?.dayMin ?? fallback);
  const max = Number(definition?.dayMax ?? min);
  if (!Number.isFinite(min) || !Number.isFinite(max)) return String(Math.max(1, Math.floor(fallback)));
  const low = Math.max(1, Math.floor(Math.min(min, max)));
  const high = Math.max(low, Math.floor(Math.max(min, max)));
  if (low === high) return String(low);
  const span = high - low + 1;
  if (low === 1) return `1d${span}`;
  return `1d${span}+${low - 1}`;
}

function buildInjuryTableHtml() {
  const rows = INJURY_TABLE.map((entry) => `
    <tr>
      <td>${entry.min}-${entry.max}</td>
      <td>${entry.label}</td>
      <td>${entry.effect}</td>
      <td>${entry.recovery}</td>
    </tr>
  `).join("");
  return `
    <div class="po-help">
      <p><strong>Healer's Kit:</strong> Charges are consumed from the selected healer's kit item in Injury & Recovery.</p>
      <table style="width:100%; border-collapse:collapse;">
        <thead><tr><th style="text-align:left;">d100</th><th style="text-align:left;">Injury</th><th style="text-align:left;">Effect</th><th style="text-align:left;">Recovery</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
    </div>
  `;
}

function buildDefaultInjuryRecoveryState() {
  return {
    supplies: {
      healersKitCharges: 10,
      healersKitActorId: "",
      healersKitItemId: ""
    },
    config: {
      baseRecoveryDays: 3
    },
    injuries: {},
    lastCycleAt: "-",
    lastCycleSummary: "-"
  };
}

function getInjuryRecoveryState() {
  const stored = game.settings.get(MODULE_ID, SETTINGS.INJURY_RECOVERY);
  return foundry.utils.mergeObject(buildDefaultInjuryRecoveryState(), stored ?? {}, {
    inplace: false,
    insertKeys: true,
    insertValues: true
  });
}

async function updateInjuryRecoveryState(mutator) {
  if (typeof mutator !== "function") return;
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can update injury recovery.");
    return;
  }
  const state = getInjuryRecoveryState();
  mutator(state);

  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.INJURY_RECOVERY, state);
  if (game.user?.isGM) scheduleIntegrationSync("injury-recovery");
  refreshOpenApps();
  if (game.user?.isGM) emitSocketRefresh();
}

function buildInjuryActorOptions(selectedActorId = "") {
  const actorId = selectedActorId || resolveDefaultInjuryActorId();
  return getOwnedPcActors()
    .sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""))
    .map((actor) => ({
      id: actor.id,
      name: actor.name,
      selected: actor.id === actorId
    }));
}

function resolveDefaultInjuryActorId() {
  const activeId = String(getActiveActorForUser()?.id ?? "");
  if (activeId && getOwnedPcActors().some((actor) => actor.id === activeId)) return activeId;
  return String(getOwnedPcActors()[0]?.id ?? "");
}

function normalizeHealersKitText(value) {
  return String(value ?? "")
    .toLowerCase()
    .replace(/['`]/g, "")
    .replace(/[^a-z0-9]+/g, " ")
    .trim();
}

function isHealersKitItem(item) {
  if (!item) return false;
  const nameText = normalizeHealersKitText(item.name);
  const idText = normalizeHealersKitText(item.system?.identifier ?? item.system?.slug ?? item.id);
  const combined = `${nameText} ${idText}`.trim();
  if (!combined) return false;
  if (combined.includes("healers kit") || combined.includes("healer kit")) return true;
  return combined.includes("healer") && combined.includes("kit");
}

function getHealersKitTrackedCharges(item) {
  const uses = Number(item?.system?.uses?.value);
  if (Number.isFinite(uses)) return Math.max(0, Math.floor(uses));
  const quantity = Number(item?.system?.quantity);
  if (Number.isFinite(quantity)) return Math.max(0, Math.floor(quantity));
  return 0;
}

async function setHealersKitTrackedCharges(item, value) {
  const next = Math.max(0, Math.floor(Number(value) || 0));
  if (item?.system?.uses?.value !== undefined) {
    await item.update({ "system.uses.value": next });
    return;
  }
  if (item?.system?.quantity !== undefined) {
    await item.update({ "system.quantity": next });
  }
}

function getHealersKitOwnerActors() {
  return getOwnedPcActors()
    .sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""));
}

function getHealersKitItems(actor, options = {}) {
  if (!actor?.items?.contents) return [];
  const includeDepleted = options?.includeDepleted === true;
  return actor.items.contents
    .filter((item) => isHealersKitItem(item))
    .map((item) => ({
      id: item.id,
      name: String(item.name ?? "Healer's Kit").trim() || "Healer's Kit",
      charges: getHealersKitTrackedCharges(item)
    }))
    .filter((item) => includeDepleted || item.charges > 0)
    .sort((a, b) => {
      const chargeDelta = Number(b.charges ?? 0) - Number(a.charges ?? 0);
      if (chargeDelta !== 0) return chargeDelta;
      return String(a.name ?? "").localeCompare(String(b.name ?? ""));
    });
}

function normalizeHealersKitSelection(supplies = {}) {
  return {
    actorId: String(supplies?.healersKitActorId ?? "").trim(),
    itemId: String(supplies?.healersKitItemId ?? "").trim()
  };
}

function getAllHealersKitEntries(options = {}) {
  const includeDepleted = options?.includeDepleted === true;
  const entries = [];
  for (const actor of getHealersKitOwnerActors()) {
    const items = getHealersKitItems(actor, { includeDepleted });
    for (const item of items) {
      entries.push({
        actorId: actor.id,
        actorName: String(actor.name ?? "Unknown Actor").trim() || "Unknown Actor",
        itemId: item.id,
        itemName: item.name,
        charges: item.charges
      });
    }
  }
  return entries;
}

function buildHealersKitSelectionContext(state) {
  const supplies = state?.supplies ?? {};
  const selected = normalizeHealersKitSelection(supplies);
  const actorRows = getHealersKitOwnerActors()
    .map((actor) => {
      const items = getHealersKitItems(actor, { includeDepleted: true });
      if (items.length === 0) return null;
      const totalCharges = items.reduce((sum, item) => sum + Math.max(0, Number(item.charges ?? 0)), 0);
      return { actor, items, totalCharges };
    })
    .filter(Boolean);

  const actorFallback = actorRows[0]?.actor.id ?? "";
  const selectedActorId = actorRows.some((entry) => entry.actor.id === selected.actorId)
    ? selected.actorId
    : actorFallback;
  const activeActorRow = actorRows.find((entry) => entry.actor.id === selectedActorId) ?? null;

  let selectedItemId = selected.itemId;
  const activeItems = activeActorRow?.items ?? [];
  if (!activeItems.some((item) => item.id === selectedItemId && item.charges > 0)) {
    selectedItemId = activeItems.find((item) => item.charges > 0)?.id ?? activeItems[0]?.id ?? "";
  }

  const actorOptions = [
    { id: "", name: "None", selected: !selectedActorId },
    ...actorRows.map((entry) => ({
      id: entry.actor.id,
      name: `${entry.actor.name} (${entry.totalCharges})`,
      selected: entry.actor.id === selectedActorId
    }))
  ];
  const itemOptions = [
    { id: "", name: "None", selected: !selectedItemId },
    ...activeItems.map((item) => ({
      id: item.id,
      name: `${item.name} (${item.charges})`,
      selected: item.id === selectedItemId
    }))
  ];

  const selectedItem = activeItems.find((item) => item.id === selectedItemId) ?? null;
  const allEntries = getAllHealersKitEntries({ includeDepleted: false });
  const totalCharges = allEntries.reduce((sum, entry) => sum + Math.max(0, Number(entry.charges ?? 0)), 0);
  const chargeSourceMap = new Map();
  for (const entry of allEntries) {
    const actorId = String(entry.actorId ?? "").trim();
    if (!actorId) continue;
    if (!chargeSourceMap.has(actorId)) {
      chargeSourceMap.set(actorId, {
        actorId,
        actorName: String(entry.actorName ?? "Unknown Actor").trim() || "Unknown Actor",
        totalCharges: 0,
        itemRows: []
      });
    }
    const row = chargeSourceMap.get(actorId);
    const charges = Math.max(0, Number(entry.charges ?? 0));
    row.totalCharges += charges;
    row.itemRows.push(`${String(entry.itemName ?? "Healer's Kit").trim() || "Healer's Kit"} (${charges})`);
  }
  const actorChargeSources = Array.from(chargeSourceMap.values())
    .sort((a, b) => {
      const delta = Number(b.totalCharges ?? 0) - Number(a.totalCharges ?? 0);
      if (delta !== 0) return delta;
      return String(a.actorName ?? "").localeCompare(String(b.actorName ?? ""));
    })
    .map((row) => ({
      actorId: row.actorId,
      actorName: row.actorName,
      totalCharges: row.totalCharges,
      itemSummary: row.itemRows.join(", ")
    }));
  const chargeSourcesTooltip = actorChargeSources.length > 0
    ? actorChargeSources.map((row) => `${row.actorName}: ${row.totalCharges} (${row.itemSummary})`).join("\n")
    : "No active Healer's Kit charges found on player character actors.";

  return {
    actorOptions,
    itemOptions,
    selectedActorId,
    selectedItemId,
    hasActor: Boolean(activeActorRow),
    hasItem: Boolean(selectedItem),
    selectedCharges: Math.max(0, Number(selectedItem?.charges ?? 0)),
    selectedLabel: selectedItem
      ? `${String(activeActorRow?.actor?.name ?? "")} - ${selectedItem.name}`
      : "None",
    totalCharges,
    chargeSourcesTooltip,
    actorChargeSources,
    hasChargeSources: actorChargeSources.length > 0
  };
}

function getOrderedHealersKitCandidates(state) {
  const selected = normalizeHealersKitSelection(state?.supplies ?? {});
  const allEntries = getAllHealersKitEntries({ includeDepleted: false });
  if (allEntries.length === 0) return [];

  const prioritized = [];
  const pushEntry = (entry) => {
    if (!entry) return;
    const key = `${entry.actorId}:${entry.itemId}`;
    if (prioritized.some((candidate) => `${candidate.actorId}:${candidate.itemId}` === key)) return;
    prioritized.push(entry);
  };

  if (selected.actorId && selected.itemId) {
    pushEntry(allEntries.find((entry) => entry.actorId === selected.actorId && entry.itemId === selected.itemId));
  }
  if (selected.actorId) {
    for (const entry of allEntries.filter((candidate) => candidate.actorId === selected.actorId)) pushEntry(entry);
  }
  for (const entry of allEntries) pushEntry(entry);
  return prioritized;
}

async function consumeHealersKitCharges(requiredCharges, state = null) {
  const needed = Math.max(0, Math.floor(Number(requiredCharges) || 0));
  if (needed <= 0) {
    const context = buildHealersKitSelectionContext(state ?? getInjuryRecoveryState());
    return {
      ok: true,
      needed: 0,
      consumed: 0,
      missing: 0,
      details: [],
      nextSelection: {
        actorId: context.selectedActorId,
        itemId: context.selectedItemId
      },
      totalCharges: context.totalCharges
    };
  }

  const currentState = state ?? getInjuryRecoveryState();
  const candidates = getOrderedHealersKitCandidates(currentState);
  if (candidates.length === 0) {
    return {
      ok: false,
      needed,
      consumed: 0,
      missing: needed,
      details: [],
      nextSelection: { actorId: "", itemId: "" },
      totalCharges: 0
    };
  }
  const availableCharges = candidates.reduce((sum, entry) => sum + Math.max(0, Number(entry.charges ?? 0)), 0);
  if (availableCharges < needed) {
    const context = buildHealersKitSelectionContext(currentState);
    return {
      ok: false,
      needed,
      consumed: 0,
      missing: needed,
      details: [],
      nextSelection: {
        actorId: context.selectedActorId,
        itemId: context.selectedItemId
      },
      totalCharges: context.totalCharges
    };
  }

  let remaining = needed;
  const details = [];
  for (const candidate of candidates) {
    if (remaining <= 0) break;
    const actor = game.actors.get(candidate.actorId);
    const item = actor?.items?.get(candidate.itemId);
    if (!actor || !item) continue;
    const available = getHealersKitTrackedCharges(item);
    if (available <= 0) continue;
    const spent = Math.min(available, remaining);
    await setHealersKitTrackedCharges(item, available - spent);
    remaining -= spent;
    details.push({
      actorId: actor.id,
      actorName: String(actor.name ?? "Unknown Actor").trim() || "Unknown Actor",
      itemId: item.id,
      itemName: String(item.name ?? "Healer's Kit").trim() || "Healer's Kit",
      spent,
      remainingCharges: Math.max(0, available - spent)
    });
  }

  const nextContext = buildHealersKitSelectionContext(currentState);
  return {
    ok: remaining <= 0,
    needed,
    consumed: needed - remaining,
    missing: Math.max(0, remaining),
    details,
    nextSelection: {
      actorId: nextContext.selectedActorId,
      itemId: nextContext.selectedItemId
    },
    totalCharges: nextContext.totalCharges
  };
}

function buildInjuryRecoveryContext() {
  const state = getInjuryRecoveryState();
  const config = state.config ?? {};
  const defaultActorId = resolveDefaultInjuryActorId();
  const healerKitSelection = buildHealersKitSelectionContext(state);
  const entries = Object.entries(state.injuries ?? {})
    .map(([actorId, entry]) => {
      const actor = game.actors.get(actorId);
      if (!actor) return null;
      const definition = getInjuryDefinitionByKey(entry.injuryKey);
      const isPermanent = Boolean(entry.permanent || definition?.permanent);
      const status = buildInjuryStatusSummary({
        effect: String(entry.effect ?? definition?.effect ?? ""),
        notes: String(entry.notes ?? ""),
        stabilized: Boolean(entry.stabilized),
        permanent: isPermanent,
        recoveryDays: Number(entry.recoveryDays ?? 0)
      });
      return {
        actorId,
        actorName: actor.name,
        injuryKey: String(entry.injuryKey ?? ""),
        injuryName: String(entry.injuryName ?? definition?.label ?? "Injury"),
        effect: status.effectText,
        effectSummary: status.summary,
        statusLabel: status.stateLabel,
        recoveryDetailLabel: status.recoveryLabel,
        recoveryRule: String(entry.recoveryRule ?? definition?.recovery ?? ""),
        injuryRoll: Number(entry.injuryRoll ?? 0),
        permanent: isPermanent,
        stabilized: Boolean(entry.stabilized),
        recoveryDays: Number(entry.recoveryDays ?? 0),
        kitCharges: Math.max(0, Number(entry.kitCharges ?? definition?.kitCharges ?? 0)),
        treatmentDc: Number(entry.treatmentDc ?? definition?.treatmentDc ?? 0),
        treatmentSkill: String(entry.treatmentSkill ?? definition?.treatmentSkill ?? ""),
        notes: entry.notes ?? "",
        recoveryDueLabel: formatRecoveryDueLabel(entry.recoveryDueTs)
      };
    })
    .filter(Boolean)
    .sort((a, b) => a.actorName.localeCompare(b.actorName));

  const unstableCount = entries.filter((entry) => !entry.stabilized && !entry.permanent).length;
  const permanentCount = entries.filter((entry) => entry.permanent).length;

  return {
    supplies: {
      healersKitCharges: Number(healerKitSelection.totalCharges ?? 0),
      kitSelection: healerKitSelection
    },
    config: {
      baseRecoveryDays: Number(config.baseRecoveryDays ?? 3)
    },
    actorOptions: buildInjuryActorOptions(defaultActorId),
    defaultActorId,
    injuryOptions: INJURY_TABLE.map((entry) => ({
      key: entry.key,
      value: entry.key,
      label: `${entry.min}-${entry.max} ${entry.label}`,
      selected: entry.key === INJURY_TABLE[0]?.key
    })),
    defaultRecoveryFormula: getInjuryRecoveryFormula(INJURY_TABLE[0], Number(config.baseRecoveryDays ?? 3)),
    entries,
    summary: {
      activeInjuries: entries.length,
      unstableCount,
      permanentCount,
      lastCycleAt: state.lastCycleAt ?? "-",
      lastCycleSummary: state.lastCycleSummary ?? "-"
    }
  };
}

function buildInjuryCalendarPayload(actor, entry) {
  const worldNow = getCurrentWorldTimestamp();
  const recoveryDays = Math.max(0, Number(entry?.recoveryDays ?? 0));
  const rawDueTimestamp = Number(entry?.recoveryDueTs);
  const fallbackDueTimestamp = worldNow + (recoveryDays * 86400);
  const dueTimestamp = Number.isFinite(rawDueTimestamp) ? rawDueTimestamp : fallbackDueTimestamp;
  const startTimestamp = Math.floor(dueTimestamp);
  const endTimestamp = startTimestamp + 60;
  const injuryName = String(entry?.injuryName ?? "Injury");
  const stabilized = Boolean(entry?.stabilized);
  const permanent = Boolean(entry?.permanent);
  const note = String(entry?.notes ?? "").trim();
  const title = permanent
    ? `${injuryName} - Permanent`
    : `${injuryName} - ${recoveryDays} day(s) left`;
  const description = `${actor?.name ?? "Unknown"} | ${injuryName} | ${stabilized ? "Stabilized" : "Unstable"}${permanent ? " | Permanent" : ` | ${recoveryDays} day(s) remaining`}${note ? ` | ${note}` : ""}`;
  return {
    title,
    name: title,
    description,
    content: description,
    startTime: startTimestamp,
    endTime: endTimestamp,
    timestamp: startTimestamp,
    startTimestamp,
    endTimestamp,
    allDay: true,
    playerVisible: true,
    public: true,
    flags: {
      [MODULE_ID]: {
        injuryActorId: actor?.id ?? "",
        gmCreated: true
      }
    }
  };
}

async function persistInjuryCalendarMetadata(actorId, fields) {
  const state = getInjuryRecoveryState();
  if (!state.injuries?.[actorId]) return;
  state.injuries[actorId] = {
    ...state.injuries[actorId],
    ...fields
  };
  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.INJURY_RECOVERY, state);
}

async function syncInjuryWithSimpleCalendar(actorId) {
  if (!canAccessAllPlayerOps() || !isSimpleCalendarActive()) return { synced: false, reason: "Simple Calendar inactive or user is not GM.", entryId: "" };
  const api = getSimpleCalendarMutationApi();
  if (!api) {
    logSimpleCalendarSyncDebug("Simple Calendar API missing during injury sync", { actorId });
    return { synced: false, reason: "Simple Calendar mutation API not found.", entryId: "" };
  }
  const state = getInjuryRecoveryState();
  const entry = state.injuries?.[actorId];
  const actor = game.actors.get(actorId);
  if (!entry || !actor) {
    logSimpleCalendarSyncDebug("Injury sync skipped due to missing actor or entry", {
      actorId,
      hasEntry: Boolean(entry),
      hasActor: Boolean(actor)
    });
    return { synced: false, reason: "Missing actor or injury entry.", entryId: "" };
  }

  const payload = buildInjuryCalendarPayload(actor, entry);
  const existingId = String(entry.calendarEntryId ?? "");
  let syncedId = existingId;
  let synced = false;
  let failureReason = "";

  if (existingId) {
    synced = await updateSimpleCalendarEntry(api, existingId, payload);
    if (!synced) failureReason = `Update failed for calendar entry ${existingId}.`;
  }

  if (!synced) {
    const created = await createSimpleCalendarEntry(api, payload);
    if (created.success) {
      synced = true;
      if (created.id) syncedId = created.id;
    } else {
      failureReason = String(created.reason ?? "Create fallback failed.");
      logSimpleCalendarSyncDebug("Create fallback failed for injury sync", {
        actorId,
        actorName: actor.name,
        reason: String(created.reason ?? "unknown")
      });
    }
  }

  if (syncedId && syncedId !== existingId) {
    await persistInjuryCalendarMetadata(actorId, { calendarEntryId: syncedId });
  }

  if (!synced) {
    logSimpleCalendarSyncDebug("Injury sync failed after update/create attempts", {
      actorId,
      actorName: actor.name,
      existingEntryId: existingId || "(none)",
      reason: failureReason || "unknown"
    });
  }

  return { synced, reason: synced ? "" : (failureReason || "unknown"), entryId: syncedId };
}

async function clearInjuryFromSimpleCalendar(entryId) {
  if (!canAccessAllPlayerOps() || !isSimpleCalendarActive() || !entryId) return false;
  const api = getSimpleCalendarMutationApi();
  if (!api) return false;
  return removeSimpleCalendarEntry(api, entryId);
}

async function syncAllInjuriesToSimpleCalendar() {
  if (!canAccessAllPlayerOps()) return { synced: 0, total: 0 };
  const injuries = Object.keys(getInjuryRecoveryState().injuries ?? {});
  let synced = 0;
  for (const actorId of injuries) {
    if ((await syncInjuryWithSimpleCalendar(actorId)).synced) synced += 1;
  }
  return { synced, total: injuries.length };
}

async function setInjuryRecoveryConfig(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can manage injury recovery.");
    return;
  }
  const key = element?.dataset?.injuryConfig;
  if (!key) return;
  await updateInjuryRecoveryState((state) => {
    if (!state.config) state.config = {};
    if (!state.supplies) state.supplies = {};
    const stringValue = String(element?.value ?? "").trim();

    if (key === "healersKitActorId") {
      state.supplies.healersKitActorId = stringValue;
      if (!stringValue) {
        state.supplies.healersKitItemId = "";
      } else {
        const actor = game.actors.get(stringValue);
        const items = getHealersKitItems(actor, { includeDepleted: true });
        const currentItemId = String(state.supplies.healersKitItemId ?? "").trim();
        if (!items.some((item) => item.id === currentItemId && item.charges > 0)) {
          state.supplies.healersKitItemId = items.find((item) => item.charges > 0)?.id ?? items[0]?.id ?? "";
        }
      }
      state.supplies.healersKitCharges = getAllHealersKitEntries({ includeDepleted: false })
        .reduce((sum, entry) => sum + Math.max(0, Number(entry.charges ?? 0)), 0);
      return;
    }

    if (key === "healersKitItemId") {
      state.supplies.healersKitItemId = stringValue;
      state.supplies.healersKitCharges = getAllHealersKitEntries({ includeDepleted: false })
        .reduce((sum, entry) => sum + Math.max(0, Number(entry.charges ?? 0)), 0);
      return;
    }

    const raw = Number(element?.value ?? 0);
    const value = Number.isFinite(raw) ? Math.max(0, raw) : 0;
    if (key === "healersKitCharges" || key === "stabilizationKits") {
      state.supplies.healersKitCharges = Math.floor(value);
      return;
    }
    if (key === "baseRecoveryDays") {
      state.config.baseRecoveryDays = Math.max(1, Math.floor(value));
    }
  });
}

async function showInjuryTable() {
  await Dialog.prompt({
    title: "Injury Table (d100)",
    content: buildInjuryTableHtml(),
    rejectClose: false,
    callback: () => {}
  });
}

async function rollInjuryTableForEditor(element) {
  const root = element?.closest(".po-injury-editor");
  if (!root) return;
  const rollResult = await (new Roll("1d100")).evaluate();
  try {
    if (game.dice3d?.showForRoll) {
      await game.dice3d.showForRoll(rollResult, game.user, true);
    }
  } catch {
    // Dice So Nice is optional.
  }
  await rollResult.toMessage({
    speaker: ChatMessage.getSpeaker({ alias: game.user?.name ?? "Party Operations" }),
    flavor: "Injury Table Roll (d100)"
  });

  const roll = Math.max(1, Math.min(100, Number(rollResult.total ?? 1)));
  const injury = findInjuryDefinitionByRoll(roll);
  const injurySelect = root.querySelector("select[name='injuryKey']");
  if (injurySelect) injurySelect.value = injury.key;
  const rollInput = root.querySelector("input[name='injuryRoll']");
  if (rollInput) rollInput.value = String(roll);
  const formulaTarget = root.querySelector("[data-injury-recovery-formula]");
  if (formulaTarget) {
    formulaTarget.textContent = `Recovery Formula: ${getInjuryRecoveryFormula(injury, Math.max(1, Number(getInjuryRecoveryState().config?.baseRecoveryDays ?? 3)))}`;
  }
  const recoveryInput = root.querySelector("input[name='recoveryDays']");
  if (recoveryInput) recoveryInput.value = String(rollInjuryRecoveryDays(injury, Math.max(1, Number(getInjuryRecoveryState().config?.baseRecoveryDays ?? 3))));
  const notesInput = root.querySelector("input[name='notes']");
  if (notesInput && !String(notesInput.value ?? "").trim()) notesInput.value = injury.effect;
  ui.notifications?.info(`d100 ${roll}: ${injury.label}`);
}

function syncInjuryEditorFromSelection(element) {
  const root = element?.closest(".po-injury-editor");
  if (!root) return;
  const injuryKey = String(root.querySelector("select[name='injuryKey']")?.value ?? "");
  const injury = getInjuryDefinitionByKey(injuryKey);
  if (!injury) return;
  const fallbackDays = Math.max(1, Number(getInjuryRecoveryState().config?.baseRecoveryDays ?? 3));
  const formulaTarget = root.querySelector("[data-injury-recovery-formula]");
  if (formulaTarget) formulaTarget.textContent = `Recovery Formula: ${getInjuryRecoveryFormula(injury, fallbackDays)}`;
  const recoveryInput = root.querySelector("input[name='recoveryDays']");
  if (recoveryInput) recoveryInput.value = String(rollInjuryRecoveryDays(injury, fallbackDays));
}

async function rollTreatmentCheck(injuredActorId, treatmentSkill, dc) {
  const dcValue = Math.max(1, Math.floor(Number(dc) || 0));
  if (!dcValue || !treatmentSkill) return true;

  if (treatmentSkill === "con") {
    const actor = game.actors.get(injuredActorId);
    if (!actor) return false;
    const conMod = Number(actor.system?.abilities?.con?.mod ?? 0);
    const roll = await (new Roll("1d20 + @mod", { mod: conMod })).evaluate();
    await roll.toMessage({
      speaker: ChatMessage.getSpeaker({ actor }),
      flavor: `Treatment Check: CON vs DC ${dcValue}`
    });
    return Number(roll.total ?? 0) >= dcValue;
  }

  const options = buildInjuryActorOptions();
  const selectHtml = options.map((opt) => `<option value="${opt.id}">${opt.name}</option>`).join("");
  const healerActorId = await Dialog.wait({
    title: "Select Treating Actor",
    content: `<div class="form-group"><label>Healer</label><select name="healerActorId">${selectHtml}</select></div>`,
    buttons: {
      ok: {
        label: "Roll Check",
        callback: (html) => String(html.find("select[name=healerActorId]").val() ?? "")
      },
      cancel: { label: "Cancel", callback: () => "" }
    },
    default: "ok",
    close: () => ""
  });

  if (!healerActorId) return false;
  const healer = game.actors.get(healerActorId);
  if (!healer) return false;
  const skill = treatmentSkill === "ins" ? "ins" : "med";
  const rollResult = await healer.rollSkill(skill, { fastForward: true, chatMessage: false });
  const total = Number(rollResult?.total ?? rollResult?.roll?.total ?? 0);
  return total >= dcValue;
}

async function upsertInjuryEntry(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can manage injury recovery.");
    return;
  }
  const root = element?.closest(".po-injury-editor");
  if (!root) return;
  const actorId = root.querySelector("select[name='actorId']")?.value ?? "";
  if (!actorId) {
    ui.notifications?.warn("Select an actor for injury tracking.");
    return;
  }
  const injuryKey = String(root.querySelector("select[name='injuryKey']")?.value ?? "");
  const injuryDef = getInjuryDefinitionByKey(injuryKey);
  if (!injuryDef) {
    ui.notifications?.warn("Select an injury result from the table.");
    return;
  }
  const injuryRollRaw = Number(root.querySelector("input[name='injuryRoll']")?.value ?? 0);
  const injuryRoll = Number.isFinite(injuryRollRaw) ? Math.max(0, Math.floor(injuryRollRaw)) : 0;
  const stabilized = Boolean(root.querySelector("input[name='stabilized']")?.checked);
  const recoveryDaysRaw = Number(root.querySelector("input[name='recoveryDays']")?.value ?? 0);
  const notes = root.querySelector("input[name='notes']")?.value ?? "";
  let savedRecoveryDays = 0;

  await updateInjuryRecoveryState((state) => {
    if (!state.injuries) state.injuries = {};
    const fallbackDays = Math.max(1, Number(state.config?.baseRecoveryDays ?? 3));
    const rolledDays = rollInjuryRecoveryDays(injuryDef, fallbackDays);
    const recoveryDays = injuryDef.permanent
      ? 0
      : (Number.isFinite(recoveryDaysRaw) && recoveryDaysRaw > 0 ? Math.floor(recoveryDaysRaw) : rolledDays);
    savedRecoveryDays = recoveryDays;
    const existing = state.injuries[actorId] ?? {};
    state.injuries[actorId] = {
      ...existing,
      injuryKey: injuryDef.key,
      injuryName: injuryDef.label,
      injuryRoll,
      effect: injuryDef.effect,
      recoveryRule: injuryDef.recovery,
      permanent: Boolean(injuryDef.permanent),
      kitCharges: Math.max(0, Number(injuryDef.kitCharges ?? 0)),
      treatmentDc: Math.max(0, Number(injuryDef.treatmentDc ?? 0)),
      treatmentSkill: String(injuryDef.treatmentSkill ?? ""),
      canBecomePermanent: Boolean(injuryDef.canBecomePermanent),
      downgradeTo: String(injuryDef.downgradeTo ?? ""),
      downgradeHalfDays: Boolean(injuryDef.downgradeHalfDays),
      stabilized,
      recoveryDays,
      notes,
      recoveryDueTs: getCurrentWorldTimestamp() + (recoveryDays * 86400)
    };
  });

  if (canAccessAllPlayerOps()) {
    const hasMutationApi = Boolean(getSimpleCalendarMutationApi());
    const syncResult = await syncInjuryWithSimpleCalendar(actorId);
    if (isSimpleCalendarActive() && hasMutationApi && !syncResult.synced) {
      const reason = String(syncResult.reason ?? "").trim();
      const detail = reason ? ` (${reason.length > 120 ? `${reason.slice(0, 117)}...` : reason})` : "";
      ui.notifications?.warn(`Injury saved, but Simple Calendar sync was unavailable for ${game.actors.get(actorId)?.name ?? "actor"}${detail}.`);
    } else if (isSimpleCalendarActive() && !hasMutationApi) {
      ui.notifications?.info("Injury saved. Simple Calendar API is not currently available in this session.");
    } else if (syncResult.synced) {
      ui.notifications?.info(`Injury saved and scheduled in Simple Calendar (${savedRecoveryDays} day recovery window).`);
    }
  } else {
    ui.notifications?.info("Injury saved. Calendar sync will be applied by the GM session.");
  }
}

function getInjuryReminderDayKey(timestamp = getCurrentWorldTimestamp()) {
  const api = getSimpleCalendarApi();
  if (isSimpleCalendarActive() && api?.timestampToDate) {
    try {
      const date = api.timestampToDate(timestamp);
      return `Y${Number(date?.year ?? 0)}-M${Number(date?.month ?? 0)}-D${Number(date?.day ?? 0)}`;
    } catch {
      // Fall through.
    }
  }
  return `D${Math.floor(Number(timestamp ?? 0) / 86400)}`;
}

async function notifyDailyInjuryReminders() {
  const dayKey = getInjuryReminderDayKey();
  const lastKey = String(game.settings.get(MODULE_ID, SETTINGS.INJURY_REMINDER_DAY) ?? "");
  if (dayKey === lastKey) return;

  const context = buildInjuryRecoveryContext();
  if (context.entries.length > 0) {
    const summary = context.entries
      .slice(0, 4)
      .map((entry) => `${entry.actorName}: ${entry.injuryName}${entry.permanent ? " (Permanent)" : ` (${entry.recoveryDays}d left)`}`)
      .join(" | ");
    const suffix = context.entries.length > 4 ? ` +${context.entries.length - 4} more` : "";
    ui.notifications?.warn(`Injury Reminder: ${summary}${suffix}`);
  }

  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.INJURY_REMINDER_DAY, dayKey);
}

async function stabilizeInjuryEntry(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can manage injury recovery.");
    return;
  }
  const actorId = element?.dataset?.actorId;
  if (!actorId) return;
  const recoveryState = getInjuryRecoveryState();
  const initial = recoveryState.injuries?.[actorId];
  if (!initial) return;
  if (initial.permanent) {
    ui.notifications?.warn("This injury is permanent and cannot be stabilized by kit treatment.");
    return;
  }

  const requiredCharges = Math.max(0, Number(initial.kitCharges ?? 1));
  const treatmentDc = Math.max(0, Number(initial.treatmentDc ?? 0));
  const treatmentSkill = String(initial.treatmentSkill ?? "");

  const kitResult = await consumeHealersKitCharges(requiredCharges, recoveryState);
  await updateInjuryRecoveryState((state) => {
    if (!state.supplies) state.supplies = {};
    state.supplies.healersKitActorId = String(kitResult.nextSelection?.actorId ?? "");
    state.supplies.healersKitItemId = String(kitResult.nextSelection?.itemId ?? "");
    state.supplies.healersKitCharges = Math.max(0, Number(kitResult.totalCharges ?? 0));
  });

  const consumedSummary = kitResult.details
    .map((entry) => `${entry.actorName} - ${entry.itemName} (-${entry.spent})`)
    .join(", ");

  if (!kitResult.ok) {
    if (kitResult.consumed > 0) {
      ui.notifications?.warn(`Healer's Kit partially consumed (${consumedSummary || `${kitResult.consumed} charge(s)`}), but ${kitResult.missing} additional charge(s) are required.`);
      return;
    }
    ui.notifications?.warn("No usable Healer's Kit charges are available for this treatment.");
    return;
  }

  const passedCheck = await rollTreatmentCheck(actorId, treatmentSkill, treatmentDc);
  if (!passedCheck) {
    if (kitResult.consumed > 0) ui.notifications?.warn(`Treatment attempt failed after consuming ${kitResult.consumed} Healer's Kit charge(s).`);
    await updateInjuryRecoveryState((state) => {
      const entry = state.injuries?.[actorId];
      if (!entry) return;
      if (entry.canBecomePermanent && entry.injuryKey === "nerve-damage") {
        entry.permanent = true;
      }
    });
    await syncInjuryWithSimpleCalendar(actorId);
    return;
  }

  await updateInjuryRecoveryState((state) => {
    const entry = state.injuries?.[actorId];
    if (!entry) return;
    entry.stabilized = true;
    if (entry.injuryKey === "broken-arm" && entry.downgradeTo) {
      const nextDef = getInjuryDefinitionByKey(entry.downgradeTo);
      if (nextDef) {
        entry.injuryKey = nextDef.key;
        entry.injuryName = nextDef.label;
        entry.effect = nextDef.effect;
        entry.recoveryRule = nextDef.recovery;
        entry.kitCharges = Number(nextDef.kitCharges ?? 0);
        entry.treatmentDc = Number(nextDef.treatmentDc ?? 0);
        entry.treatmentSkill = String(nextDef.treatmentSkill ?? "");
      }
      entry.recoveryDays = Math.max(1, Math.ceil(Number(entry.recoveryDays ?? 0) / 2));
    }
  });

  const consumedLabel = consumedSummary || `${kitResult.consumed} charge(s)`;
  ui.notifications?.info(`Treatment succeeded. Consumed ${consumedLabel}.`);
  await syncInjuryWithSimpleCalendar(actorId);
}

async function clearInjuryEntry(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can manage injury recovery.");
    return;
  }
  const actorId = element?.dataset?.actorId;
  if (!actorId) return;
  const state = getInjuryRecoveryState();
  const calendarEntryId = String(state.injuries?.[actorId]?.calendarEntryId ?? "");
  await updateInjuryRecoveryState((state) => {
    if (!state.injuries) return;
    delete state.injuries[actorId];
  });
  if (calendarEntryId) {
    await clearInjuryFromSimpleCalendar(calendarEntryId);
  }
}

async function applyRecoveryCycle(options = {}) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can manage injury recovery.");
    return { applied: false, total: 0, reason: "gm-only" };
  }
  const silent = Boolean(options?.silent);
  const suppressChat = Boolean(options?.suppressChat);
  const state = getInjuryRecoveryState();

  const entries = Object.entries(state.injuries ?? {});
  if (entries.length === 0) {
    if (!silent) ui.notifications?.info("No tracked injuries to process.");
    return { applied: false, total: 0, reason: "no-entries" };
  }

  const lines = [];
  const actorsToSync = new Set();
  const calendarEntriesToClear = [];

  await updateInjuryRecoveryState((mutable) => {
    if (!mutable.injuries) mutable.injuries = {};
    for (const [actorId, entry] of Object.entries(mutable.injuries)) {
      if (entry.permanent) {
        lines.push(`${game.actors.get(actorId)?.name ?? "Unknown"}: permanent condition`);
        continue;
      }

      const progress = entry.stabilized ? 2 : 1;
      const before = Math.max(0, Number(entry.recoveryDays ?? 0));
      const after = Math.max(0, before - progress);
      entry.recoveryDays = after;
      const actorName = game.actors.get(actorId)?.name ?? "Unknown";
      lines.push(`${actorName}: ${before}->${after} days (progress ${progress})`);

      if (after === 0 && entry.canBecomePermanent && !entry.stabilized) {
        entry.permanent = true;
        lines.push(`${actorName}: untreated condition became permanent.`);
      }

      if (after === 0) {
        if (entry.permanent) {
          entry.recoveryDueTs = getCurrentWorldTimestamp();
          actorsToSync.add(actorId);
          continue;
        }
        const calendarEntryId = String(entry.calendarEntryId ?? "");
        if (calendarEntryId) calendarEntriesToClear.push(calendarEntryId);
        delete mutable.injuries[actorId];
      } else {
        entry.recoveryDueTs = getCurrentWorldTimestamp() + (after * 86400);
        actorsToSync.add(actorId);
      }
    }
    mutable.lastCycleAt = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    mutable.lastCycleSummary = "Table-based recovery cycle applied";
  });

  const summary = lines.join("<br>");
  if (!suppressChat) {
    await ChatMessage.create({
      speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
      content: `<p><strong>Recovery Cycle</strong></p><p>${summary}</p>`
    });
  }

  for (const entryId of calendarEntriesToClear) {
    await clearInjuryFromSimpleCalendar(entryId);
  }
  for (const actorId of actorsToSync) {
    await syncInjuryWithSimpleCalendar(actorId);
  }
  return {
    applied: true,
    total: entries.length,
    summary,
    syncedActors: actorsToSync.size,
    clearedCalendarEntries: calendarEntriesToClear.length
  };
}

async function showRecoveryBrief() {
  const context = buildInjuryRecoveryContext();
  const entryLines = context.entries
    .map((entry) => `<li>${entry.actorName}: ${entry.injuryName}${entry.injuryRoll ? ` (d100 ${entry.injuryRoll})` : ""} - ${entry.permanent ? "permanent" : `${entry.recoveryDays} day(s)`} - ${entry.stabilized ? "stabilized" : "unstable"}${entry.treatmentDc ? ` - DC ${entry.treatmentDc} ${entry.treatmentSkill === "ins" ? "Insight" : entry.treatmentSkill === "con" ? "CON" : "Medicine"}` : ""} - due ${entry.recoveryDueLabel}</li>`)
    .join("");
  const content = `
    <div class="po-help">
      <p><strong>Active Injuries:</strong> ${context.summary.activeInjuries}</p>
      <p><strong>Unstable:</strong> ${context.summary.unstableCount}</p>
      <p><strong>Permanent:</strong> ${context.summary.permanentCount}</p>
      <p><strong>Selected Healer's Kit:</strong> ${context.supplies.kitSelection.selectedLabel} (${context.supplies.kitSelection.selectedCharges})</p>
      <p><strong>Total Healer's Kit Charges:</strong> ${context.supplies.kitSelection.totalCharges}</p>
      <p><strong>Last Cycle:</strong> ${context.summary.lastCycleAt} (${context.summary.lastCycleSummary})</p>
      <ul>${entryLines || "<li>No active injuries.</li>"}</ul>
    </div>
  `;
  await Dialog.prompt({
    title: "Injury & Recovery Brief",
    content,
    rejectClose: false,
    callback: () => {}
  });
}

function getRestActivities() {
  const stored = game.settings.get(MODULE_ID, SETTINGS.REST_ACTIVITIES);
  return foundry.utils.mergeObject(buildDefaultActivityState(), stored ?? {}, {
    inplace: false,
    insertKeys: true,
    insertValues: true
  });
}

function buildActivityView(actor, activityState) {
  if (!activityState) activityState = {};
  const exhaustion = activityState.exhaustion ?? 0;
  const activity = activityState.activity ?? "rested";
  const spellSlots = activityState.spellSlots ?? {};
  const hitDice = activityState.hitDice ?? {};
  const activityOptions = [
    { value: "rested", label: "Rested" },
    { value: "light", label: "Light Activity" },
    { value: "heavy", label: "Heavy Activity" },
    { value: "strenuous", label: "Strenuous" }
  ].map((option) => ({
    ...option,
    selected: option.value === activity
  }));

  return {
    exhaustion,
    exhaustionLabel: getExhaustionLabel(exhaustion),
    activity,
    activityOptions,
    spellSlots,
    hitDice,
    maxExhaustion: 6
  };
}

function getExhaustionLabel(level) {
  const labels = ["Fine", "Disadvantage", "Half Speed", "No Action", "1 Action", "Unconscious"];
  return labels[Math.min(level, 6)] || "Fine";
}

function calculateLightSources(slots, campfire) {
  // Only campfire affects rest-watch visibility.
  if (!campfire) {
    return {
      hasTorch: false,
      hasLantern: false,
      hasCampfire: false,
      brightDistance: 0,
      dimDistance: 0
    };
  }

  return {
    hasTorch: false,
    hasLantern: false,
    hasCampfire: true,
    brightDistance: 20,
    dimDistance: 40
  };
}


function buildDefaultMarchingOrderState() {
  return {
    locked: false,
    lockedBy: "",
    lastUpdatedAt: "-",
    lastUpdatedBy: "-",
    formation: "default",
    ranks: {
      front: [],
      middle: [],
      rear: []
    },
    notes: {},
    gmNotes: "",
    light: {},
    lightRanges: {},
    doctrineTracker: {
      lastCheckAt: "-",
      lastCheckNote: "-"
    }
  };
}

function normalizeLightDistance(value, fallback) {
  const raw = Number(value);
  if (!Number.isFinite(raw)) return fallback;
  return Math.max(0, Math.min(999, Math.floor(raw)));
}

function getMarchLightRange(state, actorId) {
  const fallbackBright = DEFAULT_MARCH_LIGHT_BRIGHT;
  const fallbackDim = DEFAULT_MARCH_LIGHT_DIM;
  const source = state?.lightRanges?.[actorId] ?? {};
  const bright = normalizeLightDistance(source.bright, fallbackBright);
  const dimRaw = normalizeLightDistance(source.dim, fallbackDim);
  const dim = Math.max(bright, dimRaw);
  return { bright, dim };
}

function ensureDoctrineTracker(state) {
  if (!state.doctrineTracker || typeof state.doctrineTracker !== "object") {
    state.doctrineTracker = {
      lastCheckAt: "-",
      lastCheckNote: "-"
    };
  }
  if (typeof state.doctrineTracker.lastCheckAt !== "string") {
    state.doctrineTracker.lastCheckAt = "-";
  }
  if (typeof state.doctrineTracker.lastCheckNote !== "string") {
    state.doctrineTracker.lastCheckNote = "-";
  }
  return state.doctrineTracker;
}

function normalizeMarchingFormation(type) {
  const value = type ?? "default";
  const map = {
    standard: "default",
    "two-wide": "tight-corridor",
    "single-file": "low-visibility",
    wedge: "combat-ready",
    default: "default",
    "combat-ready": "combat-ready",
    "tight-corridor": "tight-corridor",
    "low-visibility": "low-visibility"
  };
  return map[value] ?? "default";
}

function getDoctrineEffects(formation) {
  const normalized = normalizeMarchingFormation(formation);
  switch (normalized) {
    case "combat-ready":
      return {
        surprise: "Improved first-contact readiness",
        ambush: "Reduced frontal ambush vulnerability"
      };
    case "tight-corridor":
      return {
        surprise: "Neutral surprise posture",
        ambush: "Reduced flank exposure in confined spaces"
      };
    case "low-visibility":
      return {
        surprise: "Improved stealth approach",
        ambush: "Higher rear compression risk if detected"
      };
    default:
      return {
        surprise: "Balanced readiness",
        ambush: "Balanced vulnerability"
      };
  }
}

function getDoctrineCheckPrompt(formation) {
  const normalized = normalizeMarchingFormation(formation);
  switch (normalized) {
    case "combat-ready":
      return "Combat-ready: grant advantage on first readiness check; reduce frontal ambush impact by one step.";
    case "tight-corridor":
      return "Tight corridor: reduce flank/split ambush exposure by one step in confined spaces.";
    case "low-visibility":
      return "Low-visibility: grant advantage on stealthy approach; if detected, increase rear-pressure risk by one step.";
    default:
      return "Default: no modifier by doctrine alone; resolve surprise and ambush from encounter context.";
  }
}

function getActiveActorForUser() {
  return game.user?.character ?? null;
}

function getOrderedMarchingActors(state) {
  const ordered = [
    ...(state.ranks?.front ?? []),
    ...(state.ranks?.middle ?? []),
    ...(state.ranks?.rear ?? [])
  ];
  return Array.from(new Set(ordered));
}

async function applyMarchingFormation({ front, middle, type }) {
  const state = getMarchingOrderState();
  if (isLockedForUser(state, canAccessAllPlayerOps())) {
    ui.notifications?.warn("Marching order is locked by the GM.");
    return;
  }
  const ordered = getOrderedMarchingActors(state);
  const frontCount = Math.max(0, front ?? 0);
  const middleCount = Math.max(0, middle ?? 0);
  const frontActors = ordered.slice(0, frontCount);
  const middleActors = ordered.slice(frontCount, frontCount + middleCount);
  const rearActors = ordered.slice(frontCount + middleCount);
  const nextFormation = normalizeMarchingFormation(type ?? state.formation ?? "default");

  await updateMarchingOrderState((state) => {
    state.formation = nextFormation;
    state.ranks = {
      front: frontActors,
      middle: middleActors,
      rear: rearActors
    };
  });
}

async function updateRestWatchState(mutatorOrRequest, options = {}) {
  if (!canAccessAllPlayerOps()) {
    const normalizedRequest = normalizeSocketRestRequest(mutatorOrRequest);
    if (!normalizedRequest) return;
    game.socket.emit(SOCKET_CHANNEL, {
      type: "rest:mutate",
      userId: game.user.id,
      request: normalizedRequest
    });
    // Refresh immediately for player to avoid stale lag
    refreshOpenApps();
    return;
  }
  const state = getRestWatchState();
  if (typeof mutatorOrRequest === "function") {
    mutatorOrRequest(state);
  } else {
    await applyRestRequest(mutatorOrRequest, game.user.id);
    return;
  }
  stampUpdate(state);
  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.REST_STATE, state);
  if (game.user?.isGM) scheduleIntegrationSync("rest-watch");
  if (!options.skipLocalRefresh) refreshOpenApps();
  if (game.user?.isGM) emitSocketRefresh();
}

async function updateMarchingOrderState(mutatorOrRequest, options = {}) {
  if (!canAccessAllPlayerOps()) {
    const normalizedRequest = normalizeSocketMarchRequest(mutatorOrRequest);
    if (!normalizedRequest) return;
    game.socket.emit(SOCKET_CHANNEL, {
      type: "march:mutate",
      userId: game.user.id,
      request: normalizedRequest
    });
    if (!options.skipLocalRefresh) {
      // Refresh immediately for player to avoid stale lag
      refreshOpenApps();
    }
    return;
  }
  const state = getMarchingOrderState();
  if (typeof mutatorOrRequest === "function") {
    mutatorOrRequest(state);
  } else {
    await applyMarchRequest(mutatorOrRequest, game.user.id);
    return;
  }
  stampUpdate(state);
  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.MARCH_STATE, state);
  if (game.user?.isGM) scheduleIntegrationSync("marching-order");
  if (!options.skipLocalRefresh) refreshOpenApps();
  if (game.user?.isGM) emitSocketRefresh();
}

function stampUpdate(state, user = game.user) {
  state.lastUpdatedAt = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  state.lastUpdatedBy = user?.name ?? "-";
}

async function assignSlotToUser(element) {
  const state = getRestWatchState();
  if (isLockedForUser(state, canAccessAllPlayerOps())) {
    ui.notifications?.warn("Rest watch is locked by the GM.");
    return;
  }
  const actor = getActiveActorForUser();
  if (!actor) {
    ui.notifications?.warn("No assigned character for this user.");
    return;
  }
  
  if (!canAccessAllPlayerOps()) {
    const slotId = element?.closest(".po-card")?.dataset?.slotId;
    const clicked = state.slots.find((s) => s.id === slotId);
    const clickedHasEntries = (clicked?.entries?.length ?? 0) > 0 || Boolean(clicked?.actorId);
    const targetSlotId = (clicked && !clickedHasEntries)
      ? clicked.id
      : state.slots.find((s) => (s.entries?.length ?? 0) === 0 && !s.actorId)?.id;
    if (!targetSlotId) {
      ui.notifications?.warn("All rest watch slots are full.");
      return;
    }
    // Warn if we're redirecting from a filled slot
    if (clicked && clickedHasEntries && targetSlotId !== clicked.id) {
      ui.notifications?.info("That slot is already taken; assigning you to the next available slot.");
    }
    await updateRestWatchState({ op: "assignMe", slotId: targetSlotId, actorId: actor.id });
    return;
  }
  const slotId = element?.closest(".po-card")?.dataset?.slotId;
  if (!slotId) return;
  await updateRestWatchState((state) => {
    const slot = state.slots.find((entry) => entry.id === slotId);
    if (!slot) return;
    if (!slot.entries && slot.actorId) {
      slot.entries = [{ actorId: slot.actorId, notes: slot.notes ?? "" }];
      slot.actorId = null;
      slot.notes = "";
    }
    slot.entries = [{ actorId: actor.id, notes: "" }];
    slot.actorId = null;
    slot.notes = "";
  });
}

async function assignSlotByPicker(element, config = {}) {
  const slotIdFromCard = element?.closest(".po-card")?.dataset?.slotId;
  const source = config?.source === "all"
    ? "all"
    : (config?.source === "neutral-friendly" ? "neutral-friendly" : "pc");
  const actors = source === "pc"
    ? getOwnedPcActors().sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""))
    : source === "all"
      ? game.actors.contents.slice().sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""))
      : getNeutralFriendlyActors();
  if (!actors.length) {
    const message = source === "pc"
      ? "No player characters are available to assign."
      : source === "all"
        ? "No actors are available to assign."
        : "No neutral or friendly actors are available to assign.";
    ui.notifications?.warn(message);
    return;
  }
  const state = getRestWatchState();
  const slotOptions = (state.slots ?? []).map((slot) => {
    const suffix = String(slot?.timeRange ?? "").trim();
    const label = `Watch ${String(slot?.id ?? "").replace("watch-", "")}${suffix ? ` (${suffix})` : ""}`;
    return `<option value="${slot.id}" ${slot.id === slotIdFromCard ? "selected" : ""}>${label}</option>`;
  });
  const actorOptions = actors.map((actor) =>
    `<option value="${actor.id}">${actor.name}</option>`
  );
  const actorLabel = source === "pc" ? "Character" : "Actor";
  const needsSlotSelection = !slotIdFromCard;
  const slotField = needsSlotSelection
    ? `<div class="form-group"><label>Watch</label><select name="slotId">${slotOptions.join("")}</select></div>`
    : "";
  const content = `${slotField}<div class="form-group"><label>${actorLabel}</label><select name="actorId">${actorOptions.join("")}</select></div>`;
  const dialog = new Dialog({
    title: source === "pc" ? "Assign Character" : "Assign Actor",
    content,
    buttons: {
      assign: {
        label: "Assign",
        callback: async (html) => {
          const targetSlotId = String(slotIdFromCard ?? html.find("select[name=slotId]").val() ?? "").trim();
          const actorId = html.find("select[name=actorId]").val();
          if (!targetSlotId || !actorId) return;
          await updateRestWatchState((state) => {
            const slot = state.slots.find((entry) => entry.id === targetSlotId);
            if (!slot) return;
            // Migrate old format
            if (!slot.entries && slot.actorId) {
              slot.entries = [{ actorId: slot.actorId, notes: slot.notes ?? "" }];
              slot.actorId = null;
              slot.notes = "";
            }
            if (!slot.entries) slot.entries = [];
            // Add new entry
            slot.entries.push({ actorId, notes: "" });
            slot.actorId = null;
            slot.notes = "";
          });
          if (canAccessAllPlayerOps()) refreshOpenApps();
        }
      },
      cancel: { label: "Cancel" }
    },
    default: "assign"
  });
  dialog.render(true);
}

async function clearSlotEntry(element) {
  const state = getRestWatchState();
  if (isLockedForUser(state, canAccessAllPlayerOps())) {
    ui.notifications?.warn("Rest watch is locked by the GM.");
    return;
  }
  const card = element?.closest(".po-card");
  const slotId = card?.dataset?.slotId;
  const actorId = element?.closest(".po-watch-entry")?.dataset?.actorId;
  if (!slotId || !actorId) return;
  const cacheKey = getRestWatchNoteCacheKey(slotId, actorId);
  
  if (!canAccessAllPlayerOps()) {
    await updateRestWatchState({ op: "clearEntry", slotId, actorId });
    clearNoteDraftCacheValue(cacheKey);
    return;
  }
  
  await updateRestWatchState((state) => {
    const slot = state.slots.find((entry) => entry.id === slotId);
    if (!slot) return;
    // Migrate old format
    if (!slot.entries && slot.actorId) {
      slot.entries = [];
      slot.actorId = null;
      slot.notes = "";
      return;
    }
    if (!slot.entries) slot.entries = [];
    slot.entries = slot.entries.filter((entry) => entry.actorId !== actorId);
    if (slot.entries.length === 0) {
      slot.actorId = null;
      slot.notes = "";
    }
  });
  clearNoteDraftCacheValue(cacheKey);
}

async function swapSlots(element) {
  const state = getRestWatchState();
  if (isLockedForUser(state, canAccessAllPlayerOps())) {
    ui.notifications?.warn("Rest watch is locked by the GM.");
    return;
  }
  const slotId = element?.closest(".po-card")?.dataset?.slotId;
  if (!slotId) return;

  const otherOptions = state.slots
    .filter((s) => s.id !== slotId)
    .map((s) => {
      const entryCount = s.entries?.length ?? 0;
      const label = entryCount > 0 ? ` (${entryCount} assigned)` : "";
      return `<option value="${s.id}">Slot ${s.id.replace("watch-", "")}${label}</option>`;
    })
    .join("");

  const content = `<div class="form-group"><label>Swap with:</label><select name="targetSlotId">${otherOptions}</select></div>`;
  const dialog = new Dialog({
    title: "Swap Slots",
    content,
    buttons: {
      swap: {
        label: "Swap",
        callback: async (html) => {
          const targetSlotId = html.find("select[name=targetSlotId]").val();
          if (!targetSlotId) return;
          await updateRestWatchState((state) => {
            const slot1 = state.slots.find((s) => s.id === slotId);
            const slot2 = state.slots.find((s) => s.id === targetSlotId);
            if (!slot1 || !slot2) return;
            // Migrate old format for both slots
            if (!slot1.entries && slot1.actorId) {
              slot1.entries = [{ actorId: slot1.actorId, notes: slot1.notes ?? "" }];
              slot1.actorId = null;
              slot1.notes = "";
            }
            if (!slot2.entries && slot2.actorId) {
              slot2.entries = [{ actorId: slot2.actorId, notes: slot2.notes ?? "" }];
              slot2.actorId = null;
              slot2.notes = "";
            }
            if (!slot1.entries) slot1.entries = [];
            if (!slot2.entries) slot2.entries = [];
            [slot1.entries, slot2.entries] = [slot2.entries, slot1.entries];
          });
        }
      },
      cancel: { label: "Cancel" }
    },
    default: "swap"
  });
  dialog.render(true);
}

async function updateVisibility(element) {
  const value = element?.value ?? element?.querySelector?.("select")?.value;
  if (!value) return;
  await updateRestWatchState((state) => {
    state.visibility = value;
  });
}

async function updateTimeRange(element) {
  if (!canAccessAllPlayerOps()) return; // GM only
  const slotId = element?.dataset?.slotId;
  const timeRange = element?.value ?? "";
  if (!slotId) return;
  await updateRestWatchState((state) => {
    const slot = state.slots.find((s) => s.id === slotId);
    if (!slot) return;
    slot.timeRange = timeRange;
  });
}

async function autofillFromParty() {
  const state = getRestWatchState();
  if (isLockedForUser(state, canAccessAllPlayerOps())) {
    ui.notifications?.warn("Rest watch is locked by the GM.");
    return;
  }
  const actors = game.actors.contents.filter((actor) => {
    if (actor.hasPlayerOwner) return true;
    const folderName = actor.folder?.name ?? "";
    return folderName.toLowerCase().includes("hireling");
  });
  await updateRestWatchState((state) => {
    // Distribute actors among slots, one per slot
    state.slots.forEach((slot, index) => {
      // Migrate old format
      if (!slot.entries && slot.actorId) {
        slot.entries = [{ actorId: slot.actorId, notes: slot.notes ?? "" }];
        slot.actorId = null;
        slot.notes = "";
      }
      if (!slot.entries) slot.entries = [];
      // Assign one actor per slot
      if (actors[index]) {
        slot.entries = [{ actorId: actors[index].id, notes: "" }];
      } else {
        slot.entries = [];
      }
    });
  });
}

async function restoreRestCommitted() {
  const committed = game.settings.get(MODULE_ID, SETTINGS.REST_COMMITTED) ?? buildDefaultRestWatchState();
  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.REST_STATE, foundry.utils.deepClone(committed));
  scheduleIntegrationSync("rest-watch-restore");
  refreshOpenApps();        // ensures local refresh even if socket doesn't echo back
  emitSocketRefresh();
}

async function commitRestWatchState() {
  const state = getRestWatchState();
  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.REST_COMMITTED, foundry.utils.deepClone(state));
  ui.notifications?.info("Rest watch snapshot saved.");
}

async function writeClipboardText(text) {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch (err) {
    if (foundry?.utils?.copyToClipboard) {
      foundry.utils.copyToClipboard(text);
      return true;
    }
    throw err;
  }
}

async function copyRestWatchText(asMarkdown) {
  const state = getRestWatchState();
  const isGM = canAccessAllPlayerOps();
  let text = "";

  if (asMarkdown && isGM) {
    const rows = [];
    state.slots.forEach((slot, index) => {
      const entries = slot.entries ?? [];
      const timeRange = slot.timeRange || "-";
      if (entries.length === 0) {
        rows.push(`| ${index + 1} | (empty) | - | ${timeRange} | - |`);
      } else {
        entries.forEach((entry) => {
          const actor = game.actors.get(entry.actorId);
          const name = actor?.name ?? "(unknown)";
          const pp = actor ? getPassive(actor, "prc") ?? "-" : "-";
          const notes = entry.notes ? `${entry.notes.substring(0, 30)}...` : "-";
          rows.push(`| ${index + 1} | ${name} | ${pp} | ${timeRange} | ${notes} |`);
        });
      }
    });
    text = `| Watch | Actor | PP | Time | Notes |\n| --- | --- | --- | --- | --- |\n${rows.join("\n")}`;
  } else {
    const lines = [];
    state.slots.forEach((slot, index) => {
      const entries = slot.entries ?? [];
      const label = `Watch ${index + 1}`;
      if (entries.length === 0) {
        lines.push(asMarkdown ? `| ${label} | (empty) |` : `${label}: (empty)`);
      } else {
        entries.forEach((entry) => {
          const actor = game.actors.get(entry.actorId);
          const name = actor?.name ?? "(unknown)";
          lines.push(asMarkdown ? `| ${label} | ${name} |` : `${label}: ${name}`);
        });
      }
    });
    text = asMarkdown
      ? `| Slot | Actor |\n| --- | --- |\n${lines.join("\n")}`
      : lines.join("\n");
  }

  try {
    await writeClipboardText(text);
    ui.notifications?.info("Copied to clipboard.");
  } catch (err) {
    console.warn("Clipboard write failed:", err);
    ui.notifications?.warn("Failed to copy to clipboard. Check browser permissions.");
  }
}

async function clearRestWatchAll() {
  const state = getRestWatchState();
  if (isLockedForUser(state, canAccessAllPlayerOps())) {
    ui.notifications?.warn("Rest watch is locked by the GM.");
    return;
  }
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can clear all.");
    return;
  }
  const confirmed = await Dialog.confirm({
    title: "Clear Rest Watch",
    content: "<p>Clear all rest watch slots?</p>"
  });
  if (!confirmed) return;
  await updateRestWatchState((state) => {
    state.slots = buildStoredWatchSlots();
  });
}

async function runDoctrineCheckPrompt() {
  if (!canAccessAllPlayerOps()) return;
  const state = getMarchingOrderState();
  const formation = normalizeMarchingFormation(state.formation ?? "default");
  const effects = getDoctrineEffects(formation);
  const note = getDoctrineCheckPrompt(formation);
  const rankLabels = {
    front: "Front",
    middle: "Middle",
    rear: "Rear"
  };
  const orderedRankIds = ["front", "middle", "rear"];
  const escape = foundry.utils.escapeHTML ?? ((value) => String(value ?? ""));
  const seenActors = new Set();
  const doctrinePartyRows = [];
  for (const rankId of orderedRankIds) {
    for (const actorId of state.ranks?.[rankId] ?? []) {
      if (!actorId || seenActors.has(actorId)) continue;
      seenActors.add(actorId);
      const actor = game.actors.get(actorId);
      if (!actor) continue;
      const range = getMarchLightRange(state, actorId);
      doctrinePartyRows.push(
        `<li><strong>${escape(actor.name)}</strong> (${escape(rankLabels[rankId] ?? rankId)}) - ${state.light?.[actorId] ? `Torch active (Bright ${range.bright} ft / Dim ${range.dim} ft)` : "No torch"}</li>`
      );
    }
  }
  const doctrinePartySummary = doctrinePartyRows.length > 0
    ? `<ul>${doctrinePartyRows.join("")}</ul>`
    : "<p><em>No actors currently assigned to marching order.</em></p>";

  await updateMarchingOrderState((state) => {
    const tracker = ensureDoctrineTracker(state);
    tracker.lastCheckAt = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    tracker.lastCheckNote = note;
  });

  const labelMap = {
    default: "Default Formation",
    "combat-ready": "Combat-Ready Formation",
    "tight-corridor": "Tight Corridor Formation",
    "low-visibility": "Low-Visibility Formation"
  };

  await ChatMessage.create({
    speaker: ChatMessage.getSpeaker({ alias: "Party Operations" }),
    content: `
      <p><strong>Doctrine Check Prompt</strong></p>
      <p><strong>Formation:</strong> ${labelMap[formation] ?? labelMap.default}</p>
      <p><strong>Surprise Posture:</strong> ${effects.surprise}</p>
      <p><strong>Ambush Exposure:</strong> ${effects.ambush}</p>
      <p><strong>Marching Panel:</strong></p>
      ${doctrinePartySummary}
      <p><em>${escape(note)}</em></p>
    `
  });
}

function refreshSingleAppPreservingView(app) {
  if (!app?.render) return;
  const windowState = captureWindowState(app);
  if (windowState) pendingWindowRestore.set(app, windowState);
  renderAppWithPreservedState(app, { force: true, parts: ["main"], focus: false }, {
    action: "refresh-single-app",
    eventType: "refresh"
  });
}

function moveActorEntryToRankDom(rankId, actorId) {
  const root = getAppRootElement(marchingOrderAppInstance);
  if (!root) return false;
  const targetEntries = root.querySelector(`.po-rank-col[data-rank-id="${rankId}"] .po-rank-entries`);
  if (!targetEntries) return false;

  const entry = root.querySelector(`.po-entry[data-actor-id="${actorId}"]`);
  if (!entry) return false;

  targetEntries.appendChild(entry);

  root.querySelectorAll(".po-rank-col .po-rank-entries").forEach((container) => {
    const hasEntries = Boolean(container.querySelector(".po-entry"));
    const emptyState = container.querySelector(".po-rank-empty");
    if (!emptyState) return;
    emptyState.style.display = hasEntries ? "none" : "";
  });

  return true;
}

async function assignActorToRank(element) {
  if (!canAccessAllPlayerOps()) return;
  const state = getMarchingOrderState();
  if (isLockedForUser(state, true)) {
    ui.notifications?.warn("Marching order is locked by the GM.");
    return;
  }
  const rankId = element?.dataset?.rankId;
  if (!rankId) return;

  const actors = game.actors.contents.filter((actor) => actor.hasPlayerOwner);
  const options = actors.map((actor) =>
    `<option value="${actor.id}">${actor.name}</option>`
  );
  const content = `<div class="form-group"><label>Actor</label><select name="actorId">${options.join("")}</select></div>`;
  const dialog = new Dialog({
    title: `Assign Actor - ${rankId}`,
    content,
    buttons: {
      assign: {
        label: "Assign",
        callback: async (html) => {
          const actorId = html.find("select[name=actorId]").val();
          if (!actorId) return;
          await updateMarchingOrderState((state) => {
            for (const key of Object.keys(state.ranks)) {
              state.ranks[key] = (state.ranks[key] ?? []).filter((entryId) => entryId !== actorId);
            }
            if (!state.ranks[rankId]) state.ranks[rankId] = [];
            state.ranks[rankId].push(actorId);
          }, { skipLocalRefresh: true });

          const moved = moveActorEntryToRankDom(rankId, actorId);
          if (!moved) {
            refreshSingleAppPreservingView(marchingOrderAppInstance);
          }
        }
      },
      cancel: { label: "Cancel" }
    },
    default: "assign"
  });
  dialog.render(true);
}

async function removeActorFromRanks(element) {
  if (!canAccessAllPlayerOps()) return;
  const state = getMarchingOrderState();
  if (isLockedForUser(state, true)) {
    ui.notifications?.warn("Marching order is locked by the GM.");
    return;
  }
  const actorId = element?.dataset?.actorId;
  if (!actorId) return;

  await updateMarchingOrderState((state) => {
    for (const key of Object.keys(state.ranks)) {
      state.ranks[key] = (state.ranks[key] ?? []).filter((entryId) => entryId !== actorId);
    }
    if (state.notes) delete state.notes[actorId];
    if (state.light) delete state.light[actorId];
    if (state.lightRanges) delete state.lightRanges[actorId];
  });
  clearNoteDraftCacheValue(getMarchingNoteCacheKey(actorId));
}

async function joinRank(element) {
  const state = getMarchingOrderState();
  if (isLockedForUser(state, canAccessAllPlayerOps())) {
    ui.notifications?.warn("Marching order is locked by the GM.");
    return;
  }
  let rankId = element?.closest(".po-rank-col")?.dataset?.rankId;
  
  // If not clicked on a rank, default to middle
  if (!rankId) {
    rankId = "middle";
  }
  
  const actor = getActiveActorForUser();
  if (!actor) {
    ui.notifications?.warn("No assigned character for this user.");
    return;
  }
  
  if (!canAccessAllPlayerOps()) {
    await updateMarchingOrderState({ op: "joinRank", rankId, actorId: actor.id });
    return;
  }
  await updateMarchingOrderState((state) => {
    for (const key of Object.keys(state.ranks)) {
      state.ranks[key] = (state.ranks[key] ?? []).filter((entryId) => entryId !== actor.id);
    }
    if (!state.ranks[rankId]) state.ranks[rankId] = [];
    state.ranks[rankId].push(actor.id);
  });
}

async function toggleLight(element) {
  const actorId = element?.closest("[data-actor-id]")?.dataset?.actorId;
  const checked = element?.checked ?? element?.querySelector?.("input")?.checked;
  if (!actorId) return;
  await updateMarchingOrderState((state) => {
    if (!state.light) state.light = {};
    if (!state.lightRanges) state.lightRanges = {};
    state.light[actorId] = Boolean(checked);
    if (checked && !state.lightRanges[actorId]) {
      state.lightRanges[actorId] = {
        bright: DEFAULT_MARCH_LIGHT_BRIGHT,
        dim: DEFAULT_MARCH_LIGHT_DIM
      };
    }
  }, { skipLocalRefresh: true });
  if (marchingOrderAppInstance?.element?.isConnected) {
    refreshSingleAppPreservingView(marchingOrderAppInstance);
  }
}

async function setLightRange(element) {
  if (!canAccessAllPlayerOps()) return;
  const actorId = element?.closest("[data-actor-id]")?.dataset?.actorId;
  const rangeKey = String(element?.dataset?.range ?? "").trim().toLowerCase();
  if (!actorId || !["bright", "dim"].includes(rangeKey)) return;
  const fallback = rangeKey === "bright" ? DEFAULT_MARCH_LIGHT_BRIGHT : DEFAULT_MARCH_LIGHT_DIM;
  const value = normalizeLightDistance(element?.value, fallback);
  await updateMarchingOrderState((state) => {
    if (!state.lightRanges) state.lightRanges = {};
    const current = getMarchLightRange(state, actorId);
    const next = {
      bright: rangeKey === "bright" ? value : current.bright,
      dim: rangeKey === "dim" ? value : current.dim
    };
    next.dim = Math.max(next.bright, next.dim);
    state.lightRanges[actorId] = next;
    if (!state.light) state.light = {};
    if (state.light[actorId] && rangeKey === "bright" && next.dim < next.bright) {
      state.lightRanges[actorId].dim = next.bright;
    }
  }, { skipLocalRefresh: true });
  if (marchingOrderAppInstance?.element?.isConnected) {
    refreshSingleAppPreservingView(marchingOrderAppInstance);
  }
}

async function copyMarchingText(asMarkdown) {
  const state = getMarchingOrderState();
  const lines = Object.entries(state.ranks).map(([rank, actorIds]) => {
    const names = (actorIds ?? []).map((actorId) => {
      const name = game.actors.get(actorId)?.name ?? "(missing)";
      if (!state.light?.[actorId]) return name;
      const range = getMarchLightRange(state, actorId);
      return `${name} [Torch ${range.bright}/${range.dim}ft]`;
    });
    const label = rank.charAt(0).toUpperCase() + rank.slice(1);
    if (asMarkdown) return `| ${label} | ${names.join(", ") || "-"} |`;
    return `${label}: ${names.join(", ") || "-"}`;
  });
  const text = asMarkdown
    ? `| Rank | Actors |\n| --- | --- |\n${lines.join("\n")}`
    : lines.join("\n");
  try {
    await writeClipboardText(text);
    ui.notifications?.info("Copied to clipboard.");
  } catch (err) {
    console.warn("Clipboard write failed:", err);
    ui.notifications?.warn("Failed to copy to clipboard. Check browser permissions.");
  }
}

async function clearMarchingAll() {
  const state = getMarchingOrderState();
  if (isLockedForUser(state, canAccessAllPlayerOps())) {
    ui.notifications?.warn("Marching order is locked by the GM.");
    return;
  }
  const confirmed = await Dialog.confirm({
    title: "Clear Marching Order",
    content: "<p>Clear all marching order entries?</p>"
  });
  if (!confirmed) return;
  await updateMarchingOrderState((state) => {
    state.ranks = { front: [], middle: [], rear: [] };
    state.notes = {};
    state.light = {};
    state.lightRanges = {};
    state.gmNotes = "";
  });
}

async function commitMarchingOrderState() {
  const state = getMarchingOrderState();
  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.MARCH_COMMITTED, foundry.utils.deepClone(state));
  ui.notifications?.info("Marching order snapshot saved.");
}

function toggleNotesDrawer(element) {
  const root = element?.closest(".po-window");
  const drawer = root?.querySelector(".po-notes-drawer");
  if (!drawer) return;
  const isOpen = drawer.classList.toggle("is-open");
  const actorId = element?.closest(".po-entry")?.dataset?.actorId;
  if (isOpen && actorId) {
    const row = drawer.querySelector(`[data-actor-id="${actorId}"]`);
    row?.scrollIntoView({ block: "nearest" });
  }
}

async function pingActorFromElement(element) {
  const actorId = element?.closest("[data-actor-id], .po-card")?.dataset?.actorId;
  const actor = actorId ? game.actors.get(actorId) : null;
  if (!actor) return;
  const token = actor.getActiveTokens?.(true, true)?.[0];
  if (!token) {
    ui.notifications?.warn(`${actor.name} has no active token on this scene.`);
    return;
  }
  const center = token?.center ?? token?.object?.center;
  if (!center || !canvas?.ping) return;
  canvas.ping(center, { pingType: "pulse" });
}

function canUserOpenActorSheet(actor, user = game.user) {
  return canUserControlActor(actor, user);
}

function openActorSheetFromElement(element) {
  const actorId = element?.closest("[data-actor-id], .po-card")?.dataset?.actorId;
  const actor = actorId ? game.actors.get(actorId) : null;
  if (!actor) return;
  if (!canUserOpenActorSheet(actor)) {
    ui.notifications?.warn(`You do not have permission to open ${actor.name}.`);
    return;
  }
  actor.sheet?.render(true);
}

function getRestWatchState() {
  const stored = game.settings.get(MODULE_ID, SETTINGS.REST_STATE);
  const merged = foundry.utils.mergeObject(buildDefaultRestWatchState(), stored ?? {}, {
    inplace: false,
    insertKeys: true,
    insertValues: true
  });
  const sourceSlots = Array.isArray(merged?.slots) ? merged.slots : buildStoredWatchSlots();
  merged.slots = sourceSlots.map((slot, index) => {
    const entrySource = Array.isArray(slot?.entries) ? slot.entries : [];
    const entries = entrySource
      .map((entry) => {
        const actorId = String(entry?.actorId ?? "").trim();
        if (!actorId) return null;
        return {
          actorId,
          notes: String(entry?.notes ?? "")
        };
      })
      .filter(Boolean);
    return {
      id: String(slot?.id ?? `watch-${index + 1}`),
      timeRange: String(slot?.timeRange ?? ""),
      entries
    };
  });
  if (merged.slots.length === 0) merged.slots = buildStoredWatchSlots();
  merged.locked = false;
  merged.lockedBy = "";
  return merged;
}

function getMarchingOrderState() {
  const stored = game.settings.get(MODULE_ID, SETTINGS.MARCH_STATE);
  const merged = foundry.utils.mergeObject(buildDefaultMarchingOrderState(), stored ?? {}, {
    inplace: false,
    insertKeys: true,
    insertValues: true
  });
  merged.locked = false;
  merged.lockedBy = "";
  return merged;
}

function buildVisibilityOptions(current) {
  return [
    { value: "names-only", label: "Names only", selected: current === "names-only" },
    {
      value: "names-passives",
      label: "Names + passives",
      selected: current === "names-passives"
    },
    {
      value: "names-passives-notes",
      label: "Names + passives + notes",
      selected: current === "names-passives-notes"
    }
  ];
}

function buildPlayerCharacterSelector(slots) {
  // Find all unique actors in the watch slots that belong to the current player
  const uniqueActorIds = new Set();
  slots.forEach((slot) => {
    (slot.entries ?? []).forEach((entry) => {
      const actor = game.actors.get(entry.actorId);
      if (actor && userOwnsActor(actor)) {
        uniqueActorIds.add(entry.actorId);
      }
    });
  });

  if (uniqueActorIds.size <= 1) return []; // Only show selector if 2+ characters

  const activeActorId = getActiveCharacterId();
  const characters = Array.from(uniqueActorIds)
    .map((actorId) => {
      const actor = game.actors.get(actorId);
      return {
        id: actorId,
        name: actor?.name ?? "Unknown",
        img: actor?.img ?? "",
        isActive: actorId === activeActorId
      };
    })
    .sort((a, b) => a.name.localeCompare(b.name));

  return characters;
}

function getActiveCharacterId() {
  // Check if user has a stored active character, otherwise use their current character
  const stored = sessionStorage.getItem(`po-active-char-${game.user.id}`);
  if (stored) return stored;
  return game.user.character?.id ?? null;
}

function setActiveCharacterId(actorId) {
  sessionStorage.setItem(`po-active-char-${game.user.id}`, actorId);
  // Also set as the user's active character
  if (actorId) {
    game.user.update({ character: actorId });
  }
}

async function switchActiveCharacter(element) {
  const actorId = element?.dataset?.actorId;
  if (!actorId) return;
  setActiveCharacterId(actorId);
  // Re-render to update the selector highlight and context
  const apps = Object.values(ui.windows).filter((app) =>
    app instanceof RestWatchApp || app instanceof RestWatchPlayerApp
  );
  for (const app of apps) {
    refreshSingleAppPreservingView(app);
  }
}

async function updateExhaustion(element) {
  if (!canAccessAllPlayerOps()) return; // GM only
  const actorId = element?.dataset?.actorId;
  const level = parseInt(element?.dataset?.level) ?? 0;
  if (!actorId) return;

  const activities = getRestActivities();
  if (!activities.activities[actorId]) activities.activities[actorId] = {};
  activities.activities[actorId].exhaustion = level;

  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.REST_ACTIVITIES, activities);
  refreshOpenApps();
  emitSocketRefresh();
}

async function updateActivity(element, options = {}) {
  const actorId = sanitizeSocketIdentifier(element?.dataset?.actorId, { maxLength: 64 });
  const activityType = normalizeSocketActivityType(element?.value ?? element?.dataset?.activity);
  if (!actorId || !activityType) return;

  if (canAccessAllPlayerOps()) {
    // GM updates directly
    const activities = getRestActivities();
    if (!activities.activities[actorId]) activities.activities[actorId] = {};
    activities.activities[actorId].activity = activityType;
    await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.REST_ACTIVITIES, activities);
    if (!options.skipLocalRefresh) refreshOpenApps();
    emitSocketRefresh();
  } else {
    // Player updates their own activity via socket (non-GMs can't modify world settings)
    game.socket.emit(SOCKET_CHANNEL, {
      type: "activity:update",
      userId: game.user.id,
      actorId,
      activity: activityType
    });
    if (!options.skipLocalRefresh) refreshOpenApps();
  }
}

async function resetAllActivities() {
  if (!canAccessAllPlayerOps()) return; // GM only
  const confirmed = await Dialog.confirm({
    title: "Reset Activities for New Day",
    content: "<p>This will reset all party members' exhaustion levels to 0 and activities to 'Rested'.</p><p><strong>This action cannot be undone.</strong></p>",
    yes: () => true,
    no: () => false
  });
  if (!confirmed) return;
  const state = getRestWatchState();
  const activities = buildDefaultActivityState();
  const actorIds = Array.from(new Set(
    (state.slots ?? []).flatMap((slot) => {
      const entries = slot.entries ?? [];
      const entryIds = entries.map((entry) => entry.actorId);
      return slot.actorId ? entryIds.concat([slot.actorId]) : entryIds;
    })
  ));

  actorIds.forEach((actorId) => {
    activities.activities[actorId] = {
      exhaustion: 0,
      activity: "rested"
    };
  });

  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.REST_ACTIVITIES, activities);

  for (const actorId of actorIds) {
    const actor = game.actors.get(actorId);
    if (!actor) continue;
    try {
      const exhaustion = actor.system?.attributes?.exhaustion;
      if (exhaustion && typeof exhaustion === "object" && "value" in exhaustion) {
        await actor.update({ "system.attributes.exhaustion.value": 0 });
      } else if (exhaustion !== undefined) {
        await actor.update({ "system.attributes.exhaustion": 0 });
      }
    } catch (error) {
      console.warn(`party-operations: failed to reset exhaustion for ${actorId}`, error);
    }
  }

  ui.notifications?.info("Activities reset for new day.");
  refreshOpenApps();
  emitSocketRefresh();
}



function buildWatchSlotsView(state, isGM, visibility) {
  const lockedForUser = isLockedForUser(state, isGM);
  const activeActorId = !isGM ? getActiveCharacterId() : null;
  const activities = getRestActivities();
  const sourceSlots = Array.isArray(state?.slots) && state.slots.length > 0
    ? state.slots
    : buildStoredWatchSlots();
  
  return sourceSlots.map((slot, index) => {
    // Migrate old format: if slot has actorId, convert to entries
    let entries = slot.entries ?? [];
    if (slot.actorId && entries.length === 0) {
      entries = [{ actorId: slot.actorId, notes: slot.notes ?? "" }];
    }
    
    const entriesView = entries.map((entry) => {
      const actor = game.actors.get(entry.actorId);
      if (!actor) return null;
      const canEditNotes = isGM || userOwnsActor(actor);
      const activityData = activities.activities[entry.actorId] ?? {};
      return {
        actorId: entry.actorId,
        actor: buildActorView(actor, isGM, visibility),
        notes: entry.notes ?? "",
        canClear: (isGM || userOwnsActor(actor)) && !lockedForUser,
        canEditNotes: canEditNotes && !lockedForUser,
        isActiveCharacter: !isGM && activeActorId === entry.actorId,
        activity: buildActivityView(actor, activityData)
      };
    }).filter(Boolean);

    const slotHighestPP = computeHighestPPForEntries(entriesView);
    const slotPpRange = computePassiveRangeForEntries(entriesView, "passivePerception");
    const slotPivRange = computePassiveRangeForEntries(entriesView, "passiveInvestigation");
    const slotNoDarkvision = computeNoDarkvisionForEntries(entriesView);

    return {
      id: slot.id ?? `watch-${index + 1}`,
      label: `Watch ${index + 1}`,
      timeRange: slot.timeRange ?? "",
      entries: entriesView,
      hasEntries: entriesView.length > 0,
      slotHighestPP,
      slotPpHighLabel: slotPpRange.highLabel,
      slotPpLowLabel: slotPpRange.lowLabel,
      slotPivHighLabel: slotPivRange.highLabel,
      slotPivLowLabel: slotPivRange.lowLabel,
      slotNoDarkvision,
      canAssign: isGM,
      canAssignMe: !isGM && !lockedForUser
    };
  });
}

function buildRanksView(state, isGM) {
  const lockedForUser = isLockedForUser(state, isGM);
  const formation = normalizeMarchingFormation(state.formation ?? "default");
  
  // Get formation-based capacity
  const getFormationCapacity = (rankId) => {
    switch (formation) {
      case "default":
        return rankId === "front" ? 2 : rankId === "middle" ? 3 : null;
      case "combat-ready":
        return rankId === "front" ? 2 : rankId === "middle" ? 2 : null;
      case "tight-corridor":
        return rankId === "front" ? 2 : rankId === "middle" ? 2 : null;
      case "low-visibility":
        return rankId === "front" ? 1 : rankId === "middle" ? 1 : null;
      default:
        return rankId === "front" ? 2 : rankId === "middle" ? 3 : null;
    }
  };

  const rankConfigs = {
    front: { capacity: getFormationCapacity("front"), desc: "First to engage", icon: "fa-shield" },
    middle: { capacity: getFormationCapacity("middle"), desc: "Support & balance", icon: "fa-users" },
    rear: { capacity: null, desc: "Rear guard", icon: "fa-arrow-turn-up" }
  };

  const base = buildEmptyRanks(isGM).map((rank) => {
    const config = rankConfigs[rank.id];
    const actorIds = state.ranks?.[rank.id] ?? [];
    const entries = actorIds
      .map((actorId) => {
        const actor = game.actors.get(actorId);
        if (!actor) return null;
        const hasLight = Boolean(state.light?.[actorId]);
        const lightRange = getMarchLightRange(state, actorId);
        const lightTooltip = hasLight
          ? `Torch active: Bright ${lightRange.bright} ft, Dim ${lightRange.dim} ft.`
          : "";
        const canEditNote = (isGM || userOwnsActor(actor)) && !lockedForUser;
        return {
          actorId,
          actor: buildActorView(actor, isGM, "names-passives"),
          hasLight,
          lightBright: lightRange.bright,
          lightDim: lightRange.dim,
          lightTooltip,
          notes: state.notes?.[actorId] ?? "",
          canEditNote
        };
      })
      .filter(Boolean);

    const capacity = config?.capacity;
    const capacityPercent = capacity ? Math.min(100, (entries.length / capacity) * 100) : 0;

    return {
      ...rank,
      ...config,
      entries,
      capacity,
      capacityPercent,
      collapsed: false,
      toggleLabel: "Collapse",
      toggleIcon: "fa-chevron-up"
    };
  });

  return base;
}

function buildNotesView(state, ranks, isGM) {
  const actorIds = ranks.flatMap((rank) => rank.entries.map((entry) => entry.actorId));
  const uniqueIds = Array.from(new Set(actorIds));
  return uniqueIds
    .map((actorId) => {
      const actor = game.actors.get(actorId);
      if (!actor) return null;
      const canEdit = isGM || userOwnsActor(actor);
      if (!isGM && !canEdit) return null;
      return {
        actorId,
        actorName: actor.name,
        text: state.notes?.[actorId] ?? "",
        canEdit
      };
    })
    .filter(Boolean);
}

function buildLightToggles(state, ranks, isGM) {
  if (!isGM) return [];
  const actorIds = ranks.flatMap((rank) => rank.entries.map((entry) => entry.actorId));
  const uniqueIds = Array.from(new Set(actorIds));
  return uniqueIds
    .map((actorId) => {
      const actor = game.actors.get(actorId);
      if (!actor) return null;
      const range = getMarchLightRange(state, actorId);
      return {
        actorId,
        actorName: actor.name,
        hasLight: Boolean(state.light?.[actorId]),
        bright: range.bright,
        dim: range.dim
      };
    })
    .filter(Boolean);
}

function getActorTokenImage(actor) {
  return actor?.prototypeToken?.texture?.src || actor?.img || "icons/svg/mystery-man.svg";
}

function formatClockLabel(hours24, minutes) {
  const hh = String(Math.max(0, Math.min(23, Number(hours24) || 0))).padStart(2, "0");
  const mm = String(Math.max(0, Math.min(59, Number(minutes) || 0))).padStart(2, "0");
  return `${hh}:${mm}`;
}

function isSimpleCalendarActive() {
  return Boolean(game.modules.get("foundryvtt-simple-calendar")?.active || game.modules.get("simple-calendar")?.active);
}

function getSimpleCalendarApiCandidates() {
  const moduleApi = game.modules.get("foundryvtt-simple-calendar")?.api ?? game.modules.get("simple-calendar")?.api ?? null;
  const rawCandidates = [
    globalThis.SimpleCalendar?.api,
    globalThis.SimpleCalendar,
    game?.simpleCalendar?.api,
    game?.simpleCalendar,
    moduleApi
  ];
  const unique = [];
  const seen = new Set();
  for (const candidate of rawCandidates) {
    if (!candidate || typeof candidate !== "object") continue;
    if (seen.has(candidate)) continue;
    seen.add(candidate);
    unique.push(candidate);
  }
  return unique;
}

function getSimpleCalendarApi() {
  const candidates = getSimpleCalendarApiCandidates();
  if (!candidates.length) return null;
  return candidates.find((api) => typeof api?.timestampToDate === "function") ?? candidates[0];
}

function hasKnownSimpleCalendarMutationMethods(api) {
  if (!api || typeof api !== "object") return false;
  return [
    api.addEvent,
    api.createEvent,
    api.addNote,
    api.createNote,
    api.addCalendarNote,
    api.updateEvent,
    api.updateNote,
    api.updateEntry,
    api.removeEvent,
    api.deleteEvent,
    api.removeNote,
    api.deleteNote,
    api.removeEntry
  ].some((fn) => typeof fn === "function");
}

function getSimpleCalendarMutationApi() {
  const candidates = getSimpleCalendarApiCandidates();
  if (!candidates.length) return null;
  const known = candidates.find((api) => hasKnownSimpleCalendarMutationMethods(api));
  if (known) return known;
  const discovered = candidates.find((api) => hasSimpleCalendarMutationApi(api));
  return discovered ?? null;
}

function collectSimpleCalendarMethods(source, test, prefix = "api", depth = 0, seen = new Set()) {
  if (!source || typeof source !== "object" || depth > 2) return [];
  const methods = [];
  for (const [key, value] of Object.entries(source)) {
    const path = `${prefix}.${key}`;
    if (typeof value === "function") {
      const token = `${path}:${String(value.name || "anonymous")}`;
      if (!seen.has(token) && test(key, path)) {
        seen.add(token);
        methods.push({ fn: value, ctx: source, name: path });
      }
      continue;
    }
    if (value && typeof value === "object") {
      methods.push(...collectSimpleCalendarMethods(value, test, path, depth + 1, seen));
    }
  }
  return methods;
}

function getSimpleCalendarMutationMethods(api) {
  if (!api) return { updateMethods: [], createMethods: [], removeMethods: [] };
  const isCreateMethod = (key, path) => /(add|create)/i.test(key) && /(note|event|entry)/i.test(path);
  const isUpdateMethod = (key, path) => /(update|edit|set)/i.test(key) && /(note|event|entry)/i.test(path);
  const isRemoveMethod = (key, path) => /(remove|delete)/i.test(key) && /(note|event|entry)/i.test(path);

  const preferredUpdate = [
    { fn: api.updateEvent, ctx: api, name: "api.updateEvent" },
    { fn: api.updateNote, ctx: api, name: "api.updateNote" },
    { fn: api.updateEntry, ctx: api, name: "api.updateEntry" }
  ].filter((entry) => typeof entry.fn === "function");
  const preferredCreate = [
    { fn: api.addEvent, ctx: api, name: "api.addEvent" },
    { fn: api.createEvent, ctx: api, name: "api.createEvent" },
    { fn: api.addNote, ctx: api, name: "api.addNote" },
    { fn: api.createNote, ctx: api, name: "api.createNote" },
    { fn: api.addCalendarNote, ctx: api, name: "api.addCalendarNote" }
  ].filter((entry) => typeof entry.fn === "function");
  const preferredRemove = [
    { fn: api.removeEvent, ctx: api, name: "api.removeEvent" },
    { fn: api.deleteEvent, ctx: api, name: "api.deleteEvent" },
    { fn: api.removeNote, ctx: api, name: "api.removeNote" },
    { fn: api.deleteNote, ctx: api, name: "api.deleteNote" },
    { fn: api.removeEntry, ctx: api, name: "api.removeEntry" }
  ].filter((entry) => typeof entry.fn === "function");

  const discoveredUpdate = collectSimpleCalendarMethods(api, isUpdateMethod).filter((candidate) => !preferredUpdate.some((entry) => entry.fn === candidate.fn));
  const discoveredCreate = collectSimpleCalendarMethods(api, isCreateMethod).filter((candidate) => !preferredCreate.some((entry) => entry.fn === candidate.fn));
  const discoveredRemove = collectSimpleCalendarMethods(api, isRemoveMethod).filter((candidate) => !preferredRemove.some((entry) => entry.fn === candidate.fn));

  const updateMethods = [...preferredUpdate, ...discoveredUpdate];
  const createMethods = [...preferredCreate, ...discoveredCreate];
  const removeMethods = [...preferredRemove, ...discoveredRemove];
  return { updateMethods, createMethods, removeMethods };
}

function hasSimpleCalendarMutationApi(api) {
  const methods = getSimpleCalendarMutationMethods(api);
  return methods.updateMethods.length > 0 || methods.createMethods.length > 0 || methods.removeMethods.length > 0;
}

function getCurrentWorldTimestamp() {
  return Number(game.time?.worldTime ?? 0);
}

function extractCalendarEntryId(result) {
  if (!result) return "";
  if (typeof result === "string") return result;
  return String(
    result.id
      ?? result._id
      ?? result.eventId
      ?? result.noteId
      ?? result.event?.id
      ?? result.note?.id
      ?? result.data?.id
      ?? result.data?._id
      ?? ""
  );
}

function isModuleDebugEnabled() {
  try {
    return Boolean(game.settings.get(MODULE_ID, SETTINGS.DEBUG_ENABLED));
  } catch {
    // Continue to legacy debug probes.
  }
  try {
    const devModeApi = game.modules.get("_dev-mode")?.api;
    if (typeof devModeApi?.getPackageDebugValue === "function") {
      return Boolean(devModeApi.getPackageDebugValue(MODULE_ID));
    }
  } catch {
    // Fall through to CONFIG debug checks.
  }
  return Boolean(globalThis.CONFIG?.debug?.[MODULE_ID] || globalThis.CONFIG?.debug?.partyOperations);
}

function logSimpleCalendarSyncDebug(message, details = {}) {
  if (!isModuleDebugEnabled()) return;
  try {
    console.debug(`[${MODULE_ID}] ${message}`, details);
  } catch {
    // Never fail user actions because of logging.
  }
}

function toSimpleCalendarDateObject(api, timestamp) {
  const worldTimeSeconds = Number(timestamp ?? getCurrentWorldTimestamp());
  if (!Number.isFinite(worldTimeSeconds)) return null;
  if (typeof api?.timestampToDate === "function") {
    try {
      const date = api.timestampToDate(worldTimeSeconds);
      return {
        year: Number(date?.year ?? 0),
        month: Number(date?.month ?? 0),
        day: Number(date?.day ?? 0),
        hour: Number(date?.hour ?? date?.hours ?? 0),
        minute: Number(date?.minute ?? date?.minutes ?? 0),
        second: Number(date?.second ?? date?.seconds ?? 0)
      };
    } catch {
      // Fallback below
    }
  }
  const day = Math.floor(worldTimeSeconds / 86400);
  const totalMinutes = ((Math.floor(worldTimeSeconds / 60) % 1440) + 1440) % 1440;
  return {
    year: 0,
    month: 1,
    day: day + 1,
    hour: Math.floor(totalMinutes / 60),
    minute: totalMinutes % 60,
    second: 0
  };
}

function buildSimpleCalendarPayloadVariants(api, payload) {
  const base = payload && typeof payload === "object" ? foundry.utils.deepClone(payload) : {};
  const rawStartTs = Number(base.timestamp ?? base.startTimestamp ?? base.startTime ?? getCurrentWorldTimestamp());
  const startTs = Number.isFinite(rawStartTs) ? rawStartTs : getCurrentWorldTimestamp();
  const rawEndTs = Number(base.endTimestamp ?? base.endTime ?? startTs);
  const endTs = Number.isFinite(rawEndTs) ? rawEndTs : (startTs + 60);
  const safeEndTs = endTs >= startTs ? endTs : (startTs + 60);
  const title = String(base.name ?? base.title ?? "Party Operations").trim() || "Party Operations";
  const content = String(base.content ?? base.description ?? "");
  const visible = base.playerVisible ?? base.visibleToPlayers ?? true;
  const allDay = Boolean(base.allDay ?? true);
  const startDate = toSimpleCalendarDateObject(api, startTs) ?? toSimpleCalendarDateObject(null, startTs);
  const endDate = toSimpleCalendarDateObject(api, safeEndTs) ?? toSimpleCalendarDateObject(null, safeEndTs);

  const variants = [
    base,
    {
      ...base,
      name: title,
      title,
      content,
      description: content,
      timestamp: startTs,
      startTime: startTs,
      endTime: safeEndTs,
      startTimestamp: startTs,
      endTimestamp: safeEndTs,
      allDay,
      public: true,
      isPrivate: false,
      playerVisible: visible,
      visibleToPlayers: visible
    }
  ];

  if (startDate) {
    variants.push({
      ...variants[1],
      date: startDate,
      startDate,
      endDate: endDate ?? startDate,
      start: startDate,
      end: endDate ?? startDate
    });
  }

  const unique = [];
  const seen = new Set();
  for (const variant of variants) {
    const token = JSON.stringify(variant);
    if (seen.has(token)) continue;
    seen.add(token);
    unique.push(variant);
  }
  return unique;
}

async function updateSimpleCalendarEntry(api, entryId, payload) {
  if (!api || !entryId) return false;
  const candidates = getSimpleCalendarMutationMethods(api).updateMethods;
  const payloadVariants = buildSimpleCalendarPayloadVariants(api, payload);
  let lastError = null;
  for (const candidate of candidates) {
    const fn = candidate?.fn;
    const ctx = candidate?.ctx ?? api;
    const methodName = String(candidate?.name ?? fn?.name ?? "unknownUpdateMethod");
    if (typeof fn !== "function") continue;
    for (const variant of payloadVariants) {
      try {
        await fn.call(ctx, entryId, variant);
        return true;
      } catch (error) {
        lastError = error;
        try {
          await fn.call(ctx, { id: entryId, ...variant });
          return true;
        } catch (nestedError) {
          lastError = nestedError;
          let signatureError = nestedError;
          try {
            await fn.call(ctx, variant, entryId);
            return true;
          } catch (fallbackError) {
            lastError = fallbackError;
            signatureError = fallbackError;
          }
          logSimpleCalendarSyncDebug("Update method signature attempts failed", {
            methodName,
            entryId,
            reason: String(signatureError?.message ?? signatureError ?? "unknown")
          });
          // Try next signature.
        }
      }
    }
  }
  logSimpleCalendarSyncDebug("Unable to update Simple Calendar injury entry", {
    entryId,
    methodsTried: candidates.map((fn) => String(fn.name || "anonymous")),
    reason: String(lastError?.message ?? lastError ?? "unknown")
  });
  return false;
}

async function createSimpleCalendarEntry(api, payload) {
  if (!api) return { success: false, id: "" };
  const candidates = getSimpleCalendarMutationMethods(api).createMethods;
  const payloadVariants = buildSimpleCalendarPayloadVariants(api, payload);
  let lastError = null;
  for (const candidate of candidates) {
    const fn = candidate?.fn;
    const ctx = candidate?.ctx ?? api;
    const methodName = String(candidate?.name ?? fn?.name ?? "unknownCreateMethod");
    if (typeof fn !== "function") continue;
    for (const variant of payloadVariants) {
      try {
        const result = await fn.call(ctx, variant);
        const id = extractCalendarEntryId(result);
        return { success: true, id };
      } catch (error) {
        lastError = error;
        let signatureError = error;
        try {
          const result = await fn.call(ctx, { ...variant });
          const id = extractCalendarEntryId(result);
          return { success: true, id };
        } catch (nestedError) {
          lastError = nestedError;
          signatureError = nestedError;
        }
        const variantDate = variant.startDate ?? variant.date ?? null;
        if (variantDate) {
          try {
            const result = await fn.call(ctx, variantDate, variant);
            const id = extractCalendarEntryId(result);
            return { success: true, id };
          } catch (dateFirstError) {
            lastError = dateFirstError;
            signatureError = dateFirstError;
          }
          try {
            const result = await fn.call(ctx, variant, variantDate);
            const id = extractCalendarEntryId(result);
            return { success: true, id };
          } catch (dateSecondError) {
            lastError = dateSecondError;
            signatureError = dateSecondError;
          }
        }
        logSimpleCalendarSyncDebug("Create method signature attempts failed", {
          methodName,
          reason: String(signatureError?.message ?? signatureError ?? "unknown")
        });
        // Try next signature.
      }
    }
  }
  const reason = String(lastError?.message ?? lastError ?? "unknown");
  logSimpleCalendarSyncDebug("Unable to create Simple Calendar injury entry", {
    methodsTried: candidates.map((fn) => String(fn.name || "anonymous")),
    reason
  });
  return { success: false, id: "", reason };
}

async function removeSimpleCalendarEntry(api, entryId) {
  if (!api || !entryId) return false;
  const candidates = getSimpleCalendarMutationMethods(api).removeMethods;
  for (const candidate of candidates) {
    const fn = candidate?.fn;
    const ctx = candidate?.ctx ?? api;
    if (typeof fn !== "function") continue;
    try {
      await fn.call(ctx, entryId);
      return true;
    } catch {
      // Try next signature.
    }
  }
  return false;
}

function formatRecoveryDueLabel(timestamp) {
  const worldTimeSeconds = Number(timestamp ?? 0);
  if (!Number.isFinite(worldTimeSeconds)) return "-";
  const api = getSimpleCalendarApi();
  if (isSimpleCalendarActive() && api?.timestampToDate) {
    try {
      const date = api.timestampToDate(worldTimeSeconds);
      const year = Number(date?.year ?? 0);
      const month = Number(date?.month ?? 0);
      const day = Number(date?.day ?? 0);
      const hour = Number(date?.hour ?? date?.hours ?? 0);
      const minute = Number(date?.minute ?? date?.minutes ?? 0);
      return `Y${year} M${month} D${day} ${formatClockLabel(hour, minute)}`;
    } catch {
      // Fall through to world-time label.
    }
  }
  const totalMinutes = ((Math.floor(worldTimeSeconds / 60) % 1440) + 1440) % 1440;
  const day = Math.floor(worldTimeSeconds / 86400);
  return `Day ${day} ${formatClockLabel(Math.floor(totalMinutes / 60), totalMinutes % 60)}`;
}

function getClockContext() {
  const worldTimeSeconds = getCurrentWorldTimestamp();
  const totalMinutes = ((Math.floor(worldTimeSeconds / 60) % 1440) + 1440) % 1440;
  const fallbackHours = Math.floor(totalMinutes / 60);
  const fallbackMinutes = totalMinutes % 60;
  const simpleCalendarActive = isSimpleCalendarActive();
  const simpleCalendarApi = getSimpleCalendarApi();

  if (simpleCalendarActive && simpleCalendarApi?.timestampToDate) {
    try {
      const date = simpleCalendarApi.timestampToDate(worldTimeSeconds);
      const hour = Number(date?.hour ?? date?.hours ?? fallbackHours);
      const minute = Number(date?.minute ?? date?.minutes ?? fallbackMinutes);
      const normalizedMinutes = ((Math.floor(hour) * 60 + Math.floor(minute)) % 1440 + 1440) % 1440;
      return {
        totalMinutes: normalizedMinutes,
        label: formatClockLabel(hour, minute),
        source: "Simple Calendar"
      };
    } catch {
      // Fall through to world time fallback.
    }
  }

  return {
    totalMinutes,
    label: formatClockLabel(fallbackHours, fallbackMinutes),
    source: "World Time"
  };
}

function parseClockToken(value) {
  if (!value) return null;
  const normalized = String(value).trim().toLowerCase();
  const match = normalized.match(/^(\d{1,2})(?::(\d{2}))?\s*(am|pm)?$/i);
  if (!match) return null;
  let hour = Number(match[1] ?? 0);
  const minute = Number(match[2] ?? 0);
  const suffix = match[3] ?? "";
  if (!Number.isFinite(hour) || !Number.isFinite(minute)) return null;
  if (suffix === "am") {
    if (hour === 12) hour = 0;
  } else if (suffix === "pm") {
    if (hour !== 12) hour += 12;
  }
  if (hour < 0 || hour > 23 || minute < 0 || minute > 59) return null;
  return hour * 60 + minute;
}

function parseSlotTimeRange(timeRange) {
  if (!timeRange) return null;
  const parts = String(timeRange).split("-");
  if (parts.length !== 2) return null;
  const start = parseClockToken(parts[0]);
  const end = parseClockToken(parts[1]);
  if (start === null || end === null) return null;
  return { start, end };
}

function minuteWithinRange(minute, start, end) {
  if (start === end) return true;
  if (start < end) return minute >= start && minute < end;
  return minute >= start || minute < end;
}

function resolveActiveWatchSlotId(slots, totalMinutes) {
  const ranges = slots
    .map((slot) => ({ id: slot.id, range: parseSlotTimeRange(slot.timeRange) }))
    .filter((entry) => entry.range);

  for (const entry of ranges) {
    if (minuteWithinRange(totalMinutes, entry.range.start, entry.range.end)) return entry.id;
  }

  if (!slots.length) return null;
  const slotMinutes = Math.max(1, Math.floor(1440 / slots.length));
  const index = Math.floor(totalMinutes / slotMinutes) % slots.length;
  return slots[index]?.id ?? null;
}

function buildMiniVisualizationContext({ visibility = "names-passives" } = {}) {
  const restState = getRestWatchState();
  const marchState = getMarchingOrderState();
  const activityState = getRestActivities();
  const clock = getClockContext();
  const activeWatchSlotId = resolveActiveWatchSlotId(restState.slots ?? [], clock.totalMinutes);
  const rankLabel = { front: "Front", middle: "Middle", rear: "Rear" };

  const watchByActorId = {};
  const restSlots = (restState.slots ?? []).map((slot, index) => {
    const entries = slot.entries?.length
      ? slot.entries
      : slot.actorId
        ? [{ actorId: slot.actorId, notes: slot.notes ?? "" }]
        : [];
    const slotId = slot.id ?? `watch-${index + 1}`;
    const isActive = slotId === activeWatchSlotId;
    const actors = entries
      .map((entry) => game.actors.get(entry.actorId))
      .filter(Boolean)
      .map((actor) => {
        if (!watchByActorId[actor.id]) watchByActorId[actor.id] = [];
        watchByActorId[actor.id].push(slotId);
        const activity = activityState.activities?.[actor.id]?.activity ?? "rested";
        const isOnWatch = isActive;
        const isSleeping = !isOnWatch && activity === "rested";
        const isAwake = isOnWatch || activity !== "rested";
        return {
          actorId: actor.id,
          name: actor.name,
          img: getActorTokenImage(actor),
          isOnWatch,
          isSleeping,
          isAwake,
          statusLabel: isOnWatch ? "On Watch" : isSleeping ? "Sleeping" : "Awake"
        };
      });

    return {
      id: slotId,
      label: `Watch ${index + 1}`,
      timeRange: slot.timeRange || "",
      isActive,
      actors,
      hasActors: actors.length > 0
    };
  });

  const rankByActorId = {};
  for (const key of ["front", "middle", "rear"]) {
    for (const actorId of marchState.ranks?.[key] ?? []) {
      if (actorId && !rankByActorId[actorId]) rankByActorId[actorId] = key;
    }
  }

  const orderedIds = getOrderedMarchingActors(marchState);
  const marchingActors = orderedIds
    .map((actorId) => game.actors.get(actorId))
    .filter(Boolean)
    .map((actor) => {
      const role = rankByActorId[actor.id] ?? "rear";
      const activity = activityState.activities?.[actor.id]?.activity ?? "rested";
      const isOnWatch = Boolean((watchByActorId[actor.id] ?? []).includes(activeWatchSlotId));
      const isSleeping = !isOnWatch && activity === "rested";
      const isAwake = isOnWatch || activity !== "rested";
      return {
        actorId: actor.id,
        name: actor.name,
        img: getActorTokenImage(actor),
        rank: rankLabel[role] ?? "Rear",
        watchLabel: (watchByActorId[actor.id] ?? []).join(", "),
        isOnWatch,
        isSleeping,
        isAwake,
        statusLabel: isOnWatch ? "On Watch" : isSleeping ? "Sleeping" : "Awake"
      };
    });

  const restingActors = restSlots.flatMap((slot) => slot.actors);

  return {
    clockLabel: clock.label,
    clockSource: clock.source,
    hasSimpleCalendar: clock.source === "Simple Calendar",
    activeWatchSlotId,
    restSlots,
    marchingActors,
    restingActors,
    hasRestSlots: restSlots.length > 0,
    hasMarchingActors: marchingActors.length > 0,
    visibility
  };
}

function userOwnsActor(actor) {
  return canUserControlActor(actor, game.user);
}

function canUserControlActor(actor, user = game.user) {
  if (!actor || !user) return false;
  if (canAccessAllPlayerOps(user)) return true;
  try {
    if (typeof actor.testUserPermission === "function") {
      return Boolean(
        actor.testUserPermission(user, "OWNER")
        || actor.testUserPermission(user, "OBSERVER")
      );
    }
  } catch {
    // Fall through to conservative checks.
  }
  const userCharacterId = String(user?.character?.id ?? "").trim();
  const actorId = String(actor?.id ?? "").trim();
  return Boolean(userCharacterId && actorId && userCharacterId === actorId);
}

function canDragEntry(actorId, isGM, locked) {
  if (!isGM) return false;
  return true;
}

function isLockedForUser(state, isGM) {
  return false;
}

function buildActorView(actor, isGM, visibility) {
  const data = {
    id: actor.id,
    name: actor.name,
    img: actor.img,
    passivePerception: getPassive(actor, "prc"),
    passiveInsight: getPassive(actor, "ins"),
    passiveInvestigation: getPassive(actor, "inv"),
    darkvision: getDarkvision(actor),
    stealthDisadv: getStealthDisadv(actor),
    ac: getArmorClass(actor),
    languages: getLanguages(actor)
  };

  if (isGM) return data;

  const showPassives = visibility === "names-passives" || visibility === "names-passives-notes";
  return {
    id: data.id,
    name: data.name,
    img: data.img,
    passivePerception: showPassives ? data.passivePerception : null,
    passiveInsight: null,
    passiveInvestigation: null,
    darkvision: null,
    stealthDisadv: null,
    ac: null,
    languages: null
  };
}

function getPassive(actor, skillKey) {
  const passive = actor?.system?.skills?.[skillKey]?.passive;
  if (passive !== undefined && passive !== null) return passive;
  // Fallback: 10 + skill modifier
  const mod = actor?.system?.skills?.[skillKey]?.mod;
  if (mod !== undefined && mod !== null) return 10 + mod;
  return null;
}

function getDarkvision(actor) {
  if (!actor) return null;
  // Check active token on canvas for darkvision/vision
  const token = actor.getActiveTokens?.(true, true)?.[0];
  if (token) {
    // Check if token has vision/darkvision enabled
    const visionConfig = token.document?.sight;
    if (visionConfig?.enabled && visionConfig?.visionRange > 0) {
      return visionConfig.visionRange; // Return the range (e.g., 60)
    }
  }
  // Fallback to actor data
  return actor?.system?.attributes?.senses?.darkvision ?? null;
}

function getStealthDisadv(actor) {
  return actor?.system?.traits?.stealth?.disadv ?? false;
}

function getArmorClass(actor) {
  return actor?.system?.attributes?.ac?.value ?? null;
}

function getLanguages(actor) {
  const languageState = actor?.system?.traits?.languages;
  if (!languageState) return null;

  const rawValue = languageState.value;
  let keys = [];
  if (Array.isArray(rawValue)) {
    keys = rawValue.map((entry) => String(entry ?? "").trim());
  } else if (rawValue instanceof Set) {
    keys = Array.from(rawValue).map((entry) => String(entry ?? "").trim());
  } else if (typeof rawValue === "string") {
    keys = rawValue.split(/[;,]/).map((entry) => String(entry ?? "").trim());
  } else if (rawValue && typeof rawValue === "object") {
    keys = Object.entries(rawValue)
      .filter(([, enabled]) => enabled === true || enabled === 1 || enabled === "1")
      .map(([key]) => String(key ?? "").trim());
    if (keys.length === 0) keys = Object.keys(rawValue).map((key) => String(key ?? "").trim());
  }

  const catalog = CONFIG?.DND5E?.languages ?? CONFIG?.languages ?? {};
  const resolveLabel = (key) => {
    const id = String(key ?? "").trim();
    if (!id || id.toLowerCase() === "undefined") return "";
    const raw = catalog?.[id];
    if (typeof raw === "string") return raw.includes(".") ? (game.i18n?.localize?.(raw) ?? raw) : raw;
    if (raw && typeof raw === "object") {
      const label = String(raw.label ?? raw.name ?? raw.value ?? id).trim();
      return label.includes(".") ? (game.i18n?.localize?.(label) ?? label) : label;
    }
    return id;
  };

  const customRaw = String(languageState.custom ?? languageState.special ?? "").trim();
  const customValues = customRaw
    ? customRaw.split(/[;,]/).map((entry) => String(entry ?? "").trim()).filter(Boolean)
    : [];

  const labels = [...keys.map((key) => resolveLabel(key)), ...customValues]
    .map((entry) => String(entry ?? "").trim())
    .filter((entry, index, arr) => entry && entry.toLowerCase() !== "undefined" && arr.indexOf(entry) === index);

  if (labels.length === 0) return null;
  if (labels.length <= 3) return labels.join(", ");
  return `${labels.length} langs`;
}

function computeHighestPP(slots) {
  const values = slots
    .flatMap((slot) => slot.entries ?? [])
    .map((entry) => entry.actor?.passivePerception)
    .filter((value) => typeof value === "number");
  if (values.length === 0) return "-";
  return Math.max(...values);
}

function computeHighestPPForEntries(entries) {
  const values = (entries ?? [])
    .map((entry) => entry.actor?.passivePerception)
    .filter((value) => typeof value === "number");
  if (values.length === 0) return null;
  return Math.max(...values);
}

function computePassiveRangeForEntries(entries, key) {
  const values = (entries ?? [])
    .map((entry) => entry?.actor?.[key])
    .filter((value) => typeof value === "number" && Number.isFinite(value));
  if (values.length === 0) {
    return {
      high: null,
      low: null,
      highLabel: "-",
      lowLabel: "-"
    };
  }
  const high = Math.max(...values);
  const low = Math.min(...values);
  return {
    high,
    low,
    highLabel: String(high),
    lowLabel: String(low)
  };
}

function computeNoDarkvision(slots) {
  for (const slot of slots) {
    const entries = slot.entries ?? [];
    for (const entry of entries) {
      if (entry.actor && !entry.actor.darkvision) {
        return slot.label;
      }
    }
  }
  return "";
}

function computeNoDarkvisionForEntries(entries) {
  for (const entry of entries ?? []) {
    if (entry.actor && !entry.actor.darkvision) return true;
  }
  return false;
}

function buildQuickNotes(state) {
  const notes = [];
  state.slots.forEach((slot, index) => {
    const entries = slot.entries ?? [];
    entries.forEach((entry) => {
      const actor = game.actors.get(entry.actorId);
      const text = String(entry.notes ?? "").trim();
      if (text.length > 0) {
        notes.push({
          label: `Watch ${index + 1}`,
          actorName: actor?.name ?? "Unknown",
          text
        });
      }
    });
  });
  return notes;
}

function setupMarchingDragAndDrop(html) {
  const state = getMarchingOrderState();
  const isGM = canAccessAllPlayerOps();
  const locked = state.locked;

  html.querySelectorAll(".po-entry").forEach((entry) => {
    const actorId = entry.dataset.actorId;
    const draggable = canDragEntry(actorId, isGM, locked);
    entry.setAttribute("draggable", draggable ? "true" : "false");
    entry.classList.toggle("is-draggable", draggable);
    if (!draggable) return;
    if (entry.dataset.poDndEntryBound === "1") return;
    entry.dataset.poDndEntryBound = "1";
    entry.addEventListener("dragstart", (event) => {
      event.dataTransfer?.setData("text/plain", actorId);
      event.dataTransfer?.setDragImage?.(entry, 20, 20);
    });

    const handle = entry.querySelector(".po-entry-handle");
    if (handle) {
      handle.setAttribute("draggable", "true");
      if (handle.dataset.poDndHandleBound !== "1") {
        handle.dataset.poDndHandleBound = "1";
        handle.addEventListener("dragstart", (event) => {
          event.dataTransfer?.setData("text/plain", actorId);
          event.dataTransfer?.setDragImage?.(entry, 20, 20);
          event.stopPropagation();
        });
      }
    }
  });

  html.querySelectorAll(".po-rank-col").forEach((column) => {
    if (column.dataset.poDndColBound === "1") return;
    column.dataset.poDndColBound = "1";
    column.addEventListener("dragover", (event) => {
      event.preventDefault();
      if (event.dataTransfer) event.dataTransfer.dropEffect = "move";
    });

    column.addEventListener("drop", async (event) => {
      event.preventDefault();
      if (!isGM) return;
      const liveState = getMarchingOrderState();
      if (isLockedForUser(liveState, isGM)) {
        ui.notifications?.warn("Marching order is locked by the GM.");
        return;
      }
      const actorId = event.dataTransfer?.getData("text/plain");
      if (!actorId) return;
      const rankId = column.dataset.rankId;
      if (!rankId) return;

      const targetEntry = event.target?.closest(".po-entry");
      const entryList = Array.from(column.querySelectorAll(".po-entry"));
      const insertIndex = targetEntry ? entryList.indexOf(targetEntry) : entryList.length;

      await updateMarchingOrderState((state) => {
        for (const key of Object.keys(state.ranks)) {
          state.ranks[key] = (state.ranks[key] ?? []).filter((id) => id !== actorId);
        }
        if (!state.ranks[rankId]) state.ranks[rankId] = [];
        const target = state.ranks[rankId];
        const safeIndex = Math.max(0, Math.min(insertIndex, target.length));
        target.splice(safeIndex, 0, actorId);
      }, { skipLocalRefresh: true });

      refreshSingleAppPreservingView(marchingOrderAppInstance);
    });
  });
}

function getFloatingLauncherPosition() {
  const fallback = getFloatingLauncherCenteredPosition();
  const stored = game.settings.get(MODULE_ID, SETTINGS.FLOATING_LAUNCHER_POS);
  if (!stored || typeof stored !== "object") return fallback;
  const left = Number(stored.left);
  const top = Number(stored.top);
  return {
    left: Number.isFinite(left) ? left : fallback.left,
    top: Number.isFinite(top) ? top : fallback.top
  };
}

function getFloatingLauncherCenteredPosition() {
  const launcher = document.getElementById("po-floating-launcher");
  const launcherWidth = Math.max(56, Number(launcher?.offsetWidth ?? 56));
  const launcherHeight = Math.max(172, Number(launcher?.offsetHeight ?? 172));
  const viewportWidth = Math.max(240, Number(window.innerWidth ?? 1200));
  const viewportHeight = Math.max(240, Number(window.innerHeight ?? 800));

  return {
    left: Math.max(8, Math.floor((viewportWidth - launcherWidth) / 2)),
    top: Math.max(8, Math.floor((viewportHeight - launcherHeight) / 2))
  };
}

function getFloatingLauncherLeftInset() {
  const controls = document.getElementById("controls");
  if (!controls) return 8;
  const rect = controls.getBoundingClientRect();
  if (!rect || !Number.isFinite(rect.right)) return 8;
  return Math.max(8, Math.floor(rect.right + 12));
}

function isFloatingLauncherLocked() {
  return Boolean(game.settings.get(MODULE_ID, SETTINGS.FLOATING_LAUNCHER_LOCKED));
}

function applyFloatingLauncherLockUi(launcher, locked) {
  if (!launcher) return;
  launcher.classList.toggle("is-locked", Boolean(locked));
  launcher.classList.toggle("is-unlocked", !Boolean(locked));
  const lockBtn = launcher.querySelector(".po-floating-lock");
  const unlockBtn = launcher.querySelector(".po-floating-unlock");
  const handle = launcher.querySelector(".po-floating-handle");
  if (lockBtn) lockBtn.style.display = locked ? "none" : "";
  if (unlockBtn) unlockBtn.style.display = locked ? "" : "none";
  if (handle) {
    handle.setAttribute("title", locked ? "Launcher locked (click unlock to move)" : "Drag to move");
  }
}

async function resetFloatingLauncherPosition() {
  const resetPos = getFloatingLauncherCenteredPosition();
  await game.settings.set(MODULE_ID, SETTINGS.FLOATING_LAUNCHER_POS, resetPos);
  let launcher = document.getElementById("po-floating-launcher");
  if (!launcher) {
    ensureFloatingLauncher();
    launcher = document.getElementById("po-floating-launcher");
  }
  if (launcher) {
    const pos = clampFloatingLauncherPosition(resetPos);
    applyFloatingLauncherInlineStyles(launcher, pos);
  }
}

function clampFloatingLauncherPosition(pos, options = {}) {
  const width = Math.max(240, window.innerWidth || 1200);
  const height = Math.max(240, window.innerHeight || 800);
  const launcher = document.getElementById("po-floating-launcher");
  const launcherWidth = Math.max(48, Number(launcher?.offsetWidth ?? 48));
  const launcherHeight = Math.max(140, Number(launcher?.offsetHeight ?? 140));
  const lockAware = options?.lockAware !== false;
  const locked = lockAware ? isFloatingLauncherLocked() : false;
  const maxLeft = Math.max(8, width - launcherWidth - 8);
  const requestedMinLeft = locked ? 8 : getFloatingLauncherLeftInset();
  const minLeft = Math.min(Math.max(8, requestedMinLeft), maxLeft);
  return {
    left: Math.max(minLeft, Math.min(maxLeft, Number(pos.left ?? minLeft))),
    top: Math.max(8, Math.min(height - launcherHeight - 8, Number(pos.top ?? 180)))
  };
}

async function saveFloatingLauncherPosition(pos) {
  const clamped = clampFloatingLauncherPosition(pos);
  await game.settings.set(MODULE_ID, SETTINGS.FLOATING_LAUNCHER_POS, clamped);
}

function applyClickOpenerInlineStyles(opener) {
  if (!opener) return;
  opener.style.position = "fixed";
  opener.style.left = "58px";
  opener.style.bottom = "84px";
  opener.style.zIndex = "10050";
  opener.style.display = "flex";
  opener.style.visibility = "visible";
  opener.style.opacity = "1";
  opener.style.alignItems = "center";
  opener.style.justifyContent = "center";
  opener.style.width = "40px";
  opener.style.height = "40px";
  opener.style.pointerEvents = "auto";
}

function applyFloatingLauncherInlineStyles(launcher, position = null) {
  if (!launcher) return;
  launcher.style.position = "fixed";
  launcher.style.zIndex = "10050";
  launcher.style.display = "flex";
  launcher.style.visibility = "visible";
  launcher.style.opacity = "1";
  launcher.style.pointerEvents = "auto";
  launcher.style.flexDirection = "column";
  launcher.style.gap = "6px";
  const pos = position ?? clampFloatingLauncherPosition(getFloatingLauncherPosition());
  launcher.style.left = `${pos.left}px`;
  launcher.style.top = `${pos.top}px`;
}

function ensureLauncherInViewport() {
  const launcher = document.getElementById("po-floating-launcher");
  if (!launcher) return;
  const rect = launcher.getBoundingClientRect?.();
  if (!rect) return;
  const outsideViewport =
    rect.right < 0 ||
    rect.left > window.innerWidth ||
    rect.bottom < 0 ||
    rect.top > window.innerHeight;
  if (!outsideViewport) return;
  const centered = getFloatingLauncherCenteredPosition();
  const clamped = clampFloatingLauncherPosition(centered, { lockAware: false });
  applyFloatingLauncherInlineStyles(launcher, clamped);
  saveFloatingLauncherPosition(clamped);
}

function scheduleLauncherRecoveryPass() {
  if (launcherRecoveryScheduled) return;
  launcherRecoveryScheduled = true;
  const finalDelay = LAUNCHER_RECOVERY_DELAYS_MS[LAUNCHER_RECOVERY_DELAYS_MS.length - 1];

  for (const delay of LAUNCHER_RECOVERY_DELAYS_MS) {
    window.setTimeout(() => {
      try {
        if (shouldShowFloatingLauncher()) {
          ensureClickOpener();
          ensureFloatingLauncher();
          ensureLauncherInViewport();
        } else {
          removeClickOpener();
          removeFloatingLauncher();
        }
        if (shouldShowSidebarLauncher()) ensureSidebarLauncher();
        else removeSidebarLauncher();
      } catch (error) {
        console.warn(`${MODULE_ID}: launcher recovery pass failed`, error);
      } finally {
        if (delay === finalDelay) {
          launcherRecoveryScheduled = false;
        }
      }
    }, delay);
  }
}

function queueInventoryRefresh(actor, reason = "inventory-update") {
  if (!actor || actor.documentName !== "Actor") return;
  const hookMode = getInventoryHookModeSetting();
  if (hookMode === INVENTORY_HOOK_MODES.OFF) return;
  const actorId = String(actor.id ?? "").trim();
  if (!actorId) return;

  const existing = pendingInventoryRefreshByActor.get(actorId);
  if (existing) window.clearTimeout(existing);

  const timeoutId = window.setTimeout(() => {
    pendingInventoryRefreshByActor.delete(actorId);
    refreshOpenApps();
    if (hookMode === INVENTORY_HOOK_MODES.SYNC && canAccessAllPlayerOps()) {
      scheduleIntegrationSync(reason);
    }
  }, 120);

  pendingInventoryRefreshByActor.set(actorId, timeoutId);
}

function hasInventoryDelta(changed) {
  if (!changed || typeof changed !== "object") return false;
  if (Object.prototype.hasOwnProperty.call(changed, "items")) return true;
  const itemDelta = foundry.utils.getProperty(changed, "items");
  return Boolean(itemDelta && typeof itemDelta === "object");
}

function openMainTab(tabId, renderOptions = { force: true }) {
  const normalized = normalizeMainTabId(tabId, "rest-watch");
  const suppressHistory = Boolean(renderOptions?.suppressHistory);
  logUiDebug("launcher", "openMainTab request", {
    tabId,
    normalized,
    template: getTemplateForMainTab(normalized),
    isGM: Boolean(canAccessAllPlayerOps())
  });

  if (normalized === "marching-order") {
    if (restWatchAppInstance?.element?.isConnected) {
      void restWatchAppInstance.close();
    }
    if (restWatchPlayerAppInstance?.element?.isConnected) {
      void restWatchPlayerAppInstance.close();
    }
    const app = marchingOrderAppInstance?.element?.isConnected
      ? marchingOrderAppInstance
      : new MarchingOrderApp(getResponsiveWindowOptions("marching-order"));
    app.render(renderOptions);
    if (!suppressHistory) writePoBrowserHistoryEntry({ type: "main", tab: "marching-order" });
    return app;
  }

  if (marchingOrderAppInstance?.element?.isConnected) {
    void marchingOrderAppInstance.close();
  }
  if (restWatchPlayerAppInstance?.element?.isConnected) {
    void restWatchPlayerAppInstance.close();
  }

  if (normalized === "gm") {
    if (!canAccessAllPlayerOps()) {
      ui.notifications?.warn("GM permissions are required for the GM section.");
      return null;
    }
    setActiveRestMainTab("gm");
    const app = restWatchAppInstance?.element?.isConnected
      ? restWatchAppInstance
      : new RestWatchApp(getResponsiveWindowOptions("rest-watch"));
    app._activePanel = "gm";
    app.render(renderOptions);
    if (!suppressHistory) writePoBrowserHistoryEntry({ type: "main", tab: "gm" });
    return app;
  }

  if (normalized === "operations") {
    setActiveRestMainTab("operations");
    const app = restWatchAppInstance?.element?.isConnected
      ? restWatchAppInstance
      : new RestWatchApp(getResponsiveWindowOptions("rest-watch"));
    app._activePanel = "operations";
    app.render(renderOptions);
    if (!suppressHistory) writePoBrowserHistoryEntry({ type: "main", tab: "operations" });
    return app;
  }

  setActiveRestMainTab("rest-watch");
  const app = restWatchAppInstance?.element?.isConnected
    ? restWatchAppInstance
    : new RestWatchApp(getResponsiveWindowOptions("rest-watch"));
  app._activePanel = "rest-watch";
  app.render(renderOptions);
  if (!suppressHistory) writePoBrowserHistoryEntry({ type: "main", tab: "rest-watch" });
  return app;
}

function openOperationsUi() {
  return openMainTab("operations", { force: true });
}

function openRestWatchUiForCurrentUser(renderOptions = { force: true }) {
  return openMainTab("rest-watch", renderOptions);
}

function openGmUi() {
  return openMainTab("gm", { force: true });
}

function normalizeLauncherPlacement(value) {
  const normalized = String(value ?? "").trim().toLowerCase();
  if (normalized === LAUNCHER_PLACEMENTS.SIDEBAR) return LAUNCHER_PLACEMENTS.SIDEBAR;
  if (normalized === LAUNCHER_PLACEMENTS.BOTH) return LAUNCHER_PLACEMENTS.BOTH;
  return LAUNCHER_PLACEMENTS.FLOATING;
}

function getLauncherPlacement() {
  try {
    return normalizeLauncherPlacement(game.settings.get(MODULE_ID, SETTINGS.LAUNCHER_PLACEMENT));
  } catch {
    return LAUNCHER_PLACEMENTS.FLOATING;
  }
}

function shouldShowFloatingLauncher() {
  const placement = getLauncherPlacement();
  return placement === LAUNCHER_PLACEMENTS.FLOATING || placement === LAUNCHER_PLACEMENTS.BOTH;
}

function shouldShowSidebarLauncher() {
  const placement = getLauncherPlacement();
  return placement === LAUNCHER_PLACEMENTS.SIDEBAR || placement === LAUNCHER_PLACEMENTS.BOTH;
}

function removeClickOpener() {
  document.getElementById("po-click-opener")?.remove();
}

function removeFloatingLauncher() {
  document.getElementById("po-floating-launcher")?.remove();
}

function removeSidebarLauncher() {
  document.getElementById("po-sidebar-launcher")?.remove();
}

async function setLauncherPlacement(placement) {
  const normalized = normalizeLauncherPlacement(placement);
  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.LAUNCHER_PLACEMENT, normalized);
  return normalized;
}

function handleLauncherAction(action, context = {}) {
  const tabId = getMainTabIdFromAction(action);
  if (tabId) {
    logUiDebug("launcher", "opening launcher action", {
      action,
      tabId,
      template: getTemplateForMainTab(tabId)
    });
    try {
      openMainTab(tabId, { force: true });
    } catch (error) {
      console.error(`${MODULE_ID}: launcher action failed`, { action, error });
      ui.notifications?.error(`Party Operations failed to open ${tabId}. Check console for details.`);
    }
    return;
  }
  if (action === "lock") {
    const launcher = context.launcherElement ?? document.getElementById("po-floating-launcher");
    if (!launcher) return;
    const current = clampFloatingLauncherPosition({
      left: parseFloat(launcher.style.left || "16"),
      top: parseFloat(launcher.style.top || "180")
    }, { lockAware: false });
    launcher.style.left = `${current.left}px`;
    launcher.style.top = `${current.top}px`;
    void saveFloatingLauncherPosition(current);
    void game.settings.set(MODULE_ID, SETTINGS.FLOATING_LAUNCHER_LOCKED, true);
    return;
  }
  if (action === "unlock") {
    void game.settings.set(MODULE_ID, SETTINGS.FLOATING_LAUNCHER_LOCKED, false);
    return;
  }
  if (action === "dock-sidebar") {
    void setLauncherPlacement(LAUNCHER_PLACEMENTS.SIDEBAR);
    return;
  }
  if (action === "dock-floating") {
    void setLauncherPlacement(LAUNCHER_PLACEMENTS.FLOATING);
    return;
  }
}

function ensureLauncherUi() {
  let error = null;
  const placement = getLauncherPlacement();
  try {
    if (shouldShowFloatingLauncher()) {
      ensureClickOpener();
      ensureFloatingLauncher();
      ensureLauncherInViewport();
      scheduleLauncherRecoveryPass();
    } else {
      removeClickOpener();
      removeFloatingLauncher();
    }

    if (shouldShowSidebarLauncher()) ensureSidebarLauncher();
    else removeSidebarLauncher();
  } catch (caught) {
    error = caught;
    console.error(`${MODULE_ID}: ensureLauncherUi failed`, caught);
  }

  const clickOpener = document.getElementById("po-click-opener");
  const floatingLauncher = document.getElementById("po-floating-launcher");
  const sidebarLauncher = document.getElementById("po-sidebar-launcher");
  return {
    ok: Boolean(clickOpener || floatingLauncher || sidebarLauncher) && !error,
    placement,
    clickOpener: Boolean(clickOpener),
    floatingLauncher: Boolean(floatingLauncher),
    sidebarLauncher: Boolean(sidebarLauncher),
    error: error ? String(error?.message ?? error) : null
  };
}

function getLauncherStatusSnapshot() {
  const clickOpener = document.getElementById("po-click-opener");
  const floatingLauncher = document.getElementById("po-floating-launcher");
  const sidebarLauncher = document.getElementById("po-sidebar-launcher");
  const placement = getLauncherPlacement();
  return {
    ok: Boolean(clickOpener || floatingLauncher || sidebarLauncher),
    placement,
    clickOpener: Boolean(clickOpener),
    floatingLauncher: Boolean(floatingLauncher),
    sidebarLauncher: Boolean(sidebarLauncher),
    sidebarPresent: Boolean(document.getElementById("sidebar")),
    moduleId: MODULE_ID
  };
}

async function forceLauncherRecovery(reason = "unknown") {
  let status = ensureLauncherUi();
  if (status?.ok) return { ...status, recovered: false, reason };

  try {
    await setLauncherPlacement(LAUNCHER_PLACEMENTS.BOTH);
  } catch {
    // Keep trying even if setting write fails.
  }

  try {
    await resetFloatingLauncherPosition();
  } catch {
    // Keep trying even if reset fails.
  }

  removeClickOpener();
  removeFloatingLauncher();
  removeSidebarLauncher();

  ensureClickOpener();
  ensureFloatingLauncher();
  ensureSidebarLauncher();
  ensureLauncherInViewport();

  status = ensureLauncherUi();
  const snapshot = getLauncherStatusSnapshot();
  if (!status?.ok && !snapshot.ok) {
    console.warn(`${MODULE_ID}: launcher recovery failed`, { reason, status, snapshot });
  }

  return {
    ...status,
    recovered: Boolean(status?.ok),
    reason,
    snapshot
  };
}

function buildPartyOperationsApi() {
  const api = {
    restWatch: () => openMainTab("rest-watch", { force: true }),
    marchingOrder: () => openMainTab("marching-order", { force: true }),
    operations: () => openMainTab("operations", { force: true }),
    gm: () => openMainTab("gm", { force: true }),
    gmMerchants: () => openGmMerchantsPage({ force: true }),
    refreshAll: () => refreshOpenApps(),
    getOperations: () => foundry.utils.deepClone(getOperationsLedger()),
    gatherResources: (options = {}) => runGatherResourcesAction(options),
    applyUpkeep: () => applyOperationalUpkeep(),
    getInjuryRecovery: () => foundry.utils.deepClone(getInjuryRecoveryState()),
    applyRecoveryCycle: () => applyRecoveryCycle(),
    runSessionAutopilot: () => runSessionAutopilot(),
    undoSessionAutopilot: () => undoLastSessionAutopilot(),
    syncInjuryCalendar: () => syncAllInjuriesToSimpleCalendar(),
    syncIntegrations: () => scheduleIntegrationSync("api"),
    getConfig: () => foundry.utils.deepClone(getModuleConfigSnapshot()),
    getTypedConfig: () => foundry.utils.deepClone(getPartyOpsConfigSetting()),
    saveTypedConfig: (input) => savePartyOpsConfigSetting(input),
    getInventoryHookMode: () => getInventoryHookModeSetting(),
    setInventoryHookMode: (mode) => setInventoryHookMode(mode),
    getLauncherPlacement: () => getLauncherPlacement(),
    setLauncherPlacement: (placement) => setLauncherPlacement(placement),
    getLootSourceConfig: () => foundry.utils.deepClone(getLootSourceConfig()),
    previewLoot: (draft) => generateLootPreviewPayload(draft),
    generateLootFromPackIds: (packIds, input, options) => generateLootFromPackIds(packIds, input, options),
    getLootPreviewResult: () => foundry.utils.deepClone(getLootPreviewResult()),
    diagnoseWorldData: (options) => diagnoseWorldData(options),
    repairWorldData: () => diagnoseWorldData({ repair: true }),
    resetLauncherPosition: () => resetFloatingLauncherPosition(),
    ensureLauncher: () => ensureLauncherUi(),
    showLauncher: () => ensureLauncherUi(),
    forceLauncherRecovery: (reason) => forceLauncherRecovery(reason),
    launcherStatus: () => getLauncherStatusSnapshot(),
    apiStatus: () => ({
      moduleActive: Boolean(game.modules?.get?.(MODULE_ID)?.active),
      hasGameApi: Boolean(game.partyOperations || game.partyops),
      hasModuleApi: Boolean(game.modules?.get?.(MODULE_ID)?.api),
      hasGlobalApi: Boolean(globalThis.partyOperations || globalThis.PartyOperations || globalThis.partyops),
      launcher: ensureLauncherUi()
    })
  };

  // Backward-compatible aliases for older macro snippets.
  api.openRestWatch = api.restWatch;
  api.openMarchingOrder = api.marchingOrder;
  api.openOperations = api.operations;
  api.openGM = api.gm;
  api.openGmMerchants = api.gmMerchants;
  api.gather = api.gatherResources;
  api.launcher = api.ensureLauncher;

  return api;
}

function registerPartyOperationsApi() {
  const api = buildPartyOperationsApi();
  game.partyOperations = api;
  game.partyops = api;
  globalThis.partyOperations = api;
  globalThis.PartyOperations = api;
  globalThis.partyops = api;

  try {
    Object.defineProperty(globalThis, "partyOperations", {
      configurable: true,
      get: () => game.partyOperations ?? api,
      set: (value) => {
        game.partyOperations = value;
        game.partyops = value;
      }
    });
  } catch {
    // Ignore if runtime prevents redefining globals.
  }

  try {
    Object.defineProperty(globalThis, "PartyOperations", {
      configurable: true,
      get: () => game.partyOperations ?? api,
      set: (value) => {
        game.partyOperations = value;
        game.partyops = value;
      }
    });
  } catch {
    // Ignore if runtime prevents redefining globals.
  }

  try {
    Object.defineProperty(globalThis, "partyops", {
      configurable: true,
      get: () => game.partyops ?? game.partyOperations ?? api,
      set: (value) => {
        game.partyOperations = value;
        game.partyops = value;
      }
    });
  } catch {
    // Ignore if runtime prevents redefining globals.
  }

  const moduleRef = game.modules?.get?.(MODULE_ID);
  if (moduleRef) {
    try {
      moduleRef.api = api;
    } catch (error) {
      try {
        Object.defineProperty(moduleRef, "api", {
          value: api,
          configurable: true,
          writable: true
        });
      } catch (defineError) {
        console.warn(`${MODULE_ID}: unable to attach api on module reference`, error, defineError);
      }
    }
  }

  return api;
}

function ensureClickOpener() {
  let opener = document.getElementById("po-click-opener");
  if (!opener) {
    opener = document.createElement("button");
    opener.id = "po-click-opener";
    opener.type = "button";
    opener.setAttribute("title", "Open Party Operations");
    opener.setAttribute("aria-label", "Open Party Operations");
    opener.innerHTML = '<i class="fas fa-compass"></i>';
    opener.addEventListener("click", () => {
      ensureFloatingLauncher();
      handleLauncherAction("rest");
    });
    document.body.appendChild(opener);
  }

  applyClickOpenerInlineStyles(opener);
}

function ensureSidebarLauncher() {
  const sidebar = document.getElementById("sidebar");
  if (!sidebar) return null;

  let launcher = document.getElementById("po-sidebar-launcher");
  if (!launcher) {
    launcher = document.createElement("section");
    launcher.id = "po-sidebar-launcher";
    launcher.classList.add("po-sidebar-launcher");
    sidebar.appendChild(launcher);
  } else if (launcher.parentElement !== sidebar) {
    sidebar.appendChild(launcher);
  }

  const setLauncherMarkup = (target) => {
    const buttonsMarkup = PO_SIDEBAR_VIEW_ITEMS
      .filter((item) => !item.gmOnly || canAccessAllPlayerOps())
      .map((item) => {
        const gmClass = item.gmOnly ? " po-sidebar-gm" : "";
        return `
        <button type="button" class="po-sidebar-btn${gmClass}" data-action="${item.action}" data-tab-id="${item.id}" data-target="${item.target}" title="${item.title}" aria-label="${item.title}">
          <i class="${item.icon}"></i><span>${item.label}</span>
        </button>`;
      })
      .join("");

    target.innerHTML = `
      <header class="po-sidebar-launcher-header">
        <h4 class="po-sidebar-launcher-title">Party Operations</h4>
        <button type="button" class="po-sidebar-btn po-sidebar-dock" data-action="dock-floating" title="Dock launcher on screen" aria-label="Dock launcher on screen">
          <i class="fas fa-external-link-alt"></i>
        </button>
      </header>
      <div class="po-sidebar-launcher-grid">
        ${buttonsMarkup}
      </div>
    `;
    logUiDebug("sidebar-launcher", "rebuilt sidebar launcher", {
      items: PO_SIDEBAR_VIEW_ITEMS
        .filter((item) => !item.gmOnly || canAccessAllPlayerOps())
        .map((item) => ({ id: item.id, action: item.action, target: item.target }))
    });
  };

  const hasRestBtn = Boolean(launcher.querySelector('.po-sidebar-btn[data-tab-id="rest-watch"]'));
  const hasOperationsBtn = Boolean(launcher.querySelector('.po-sidebar-btn[data-tab-id="operations"]'));
  const hasMarchBtn = Boolean(launcher.querySelector('.po-sidebar-btn[data-tab-id="marching-order"]'));
  const hasGmBtn = !canAccessAllPlayerOps() || Boolean(launcher.querySelector('.po-sidebar-btn[data-tab-id="gm"]'));
  const hasDockBtn = Boolean(launcher.querySelector('.po-sidebar-btn[data-action="dock-floating"]'));
  if (!hasRestBtn || !hasOperationsBtn || !hasMarchBtn || !hasGmBtn || !hasDockBtn) {
    setLauncherMarkup(launcher);
  }

  if (launcher.dataset.poSidebarLauncherBound !== "1") {
    launcher.dataset.poSidebarLauncherBound = "1";
    launcher.addEventListener("click", (event) => {
      const button = event.target?.closest(".po-sidebar-btn");
      if (!button) return;
      const action = button.dataset.action;
      if (!action) return;
      logUiDebug("sidebar-launcher", "sidebar launcher click", {
        action,
        tabId: button.dataset.tabId,
        target: button.dataset.target,
        template: getTemplateForMainTab(button.dataset.tabId)
      });
      handleLauncherAction(action);
    });
  }

  const gmButton = launcher.querySelector('.po-sidebar-btn[data-tab-id="gm"]');
  if (gmButton) gmButton.style.display = canAccessAllPlayerOps() ? "" : "none";
  return launcher;
}

function ensureFloatingLauncher() {
  let launcher = document.getElementById("po-floating-launcher");

  const setLauncherMarkup = (target) => {
    target.innerHTML = `
      <div class="po-floating-handle" title="Drag to move" aria-label="Drag to move"><i class="fas fa-grip-lines-vertical"></i></div>
      <button type="button" class="po-floating-btn" data-action="rest" title="Open Rest Watch" aria-label="Open Rest Watch">
        <i class="fas fa-moon"></i>
      </button>
      <button type="button" class="po-floating-btn" data-action="operations" title="Open Operations" aria-label="Open Operations">
        <i class="fas fa-clipboard-list"></i>
      </button>
      <button type="button" class="po-floating-btn" data-action="march" title="Open Marching Order" aria-label="Open Marching Order"><i class="fas fa-arrow-up"></i></button>
      <button type="button" class="po-floating-btn po-floating-gm" data-action="gm" title="Open GM Section" aria-label="Open GM Section">
        <i class="fas fa-user-shield"></i>
      </button>
      <button type="button" class="po-floating-btn po-floating-dock" data-action="dock-sidebar" title="Dock launcher in sidebar" aria-label="Dock launcher in sidebar">
        <i class="fas fa-columns"></i>
      </button>
      <button type="button" class="po-floating-btn po-floating-lock" data-action="lock" title="Lock launcher" aria-label="Lock launcher">
        <i class="fas fa-lock"></i>
      </button>
      <button type="button" class="po-floating-btn po-floating-unlock" data-action="unlock" title="Unlock launcher" aria-label="Unlock launcher">
        <i class="fas fa-lock-open"></i>
      </button>
    `;
  };

  if (!launcher) {
    launcher = document.createElement("div");
    launcher.id = "po-floating-launcher";
    launcher.classList.add("po-floating-launcher");
    setLauncherMarkup(launcher);
    document.body.appendChild(launcher);

    launcher.addEventListener("click", (event) => {
      const button = event.target?.closest(".po-floating-btn");
      if (!button) return;
      const action = button.dataset.action;
      if (!action) return;
      handleLauncherAction(action, { launcherElement: launcher });
    });

    const handle = launcher.querySelector(".po-floating-handle");
    let dragging = false;
    let startX = 0;
    let startY = 0;
    let originLeft = 0;
    let originTop = 0;
    let lastLockedDragNoticeAt = 0;

    const onMove = (event) => {
      if (!dragging) return;
      const next = clampFloatingLauncherPosition({
        left: originLeft + (event.clientX - startX),
        top: originTop + (event.clientY - startY)
      });
      launcher.style.left = `${next.left}px`;
      launcher.style.top = `${next.top}px`;
    };

    const onUp = async () => {
      if (!dragging) return;
      dragging = false;
      document.removeEventListener("pointermove", onMove);
      document.removeEventListener("pointerup", onUp);
      await saveFloatingLauncherPosition({
        left: parseFloat(launcher.style.left || String(getFloatingLauncherLeftInset())),
        top: parseFloat(launcher.style.top || "180")
      });
    };

    const startDrag = (event) => {
      if (isFloatingLauncherLocked()) {
        const now = Date.now();
        if (now - lastLockedDragNoticeAt > 1500) {
          lastLockedDragNoticeAt = now;
          ui.notifications?.info("Launcher position is locked. Click unlock to move it.");
        }
        event.preventDefault();
        return;
      }
      if (event.target?.closest(".po-floating-btn")) return;
      if (event.button !== undefined && event.button !== 0) return;
      dragging = true;
      startX = event.clientX;
      startY = event.clientY;
      originLeft = parseFloat(launcher.style.left || String(getFloatingLauncherLeftInset()));
      originTop = parseFloat(launcher.style.top || "180");
      document.addEventListener("pointermove", onMove);
      document.addEventListener("pointerup", onUp);
      event.preventDefault();
    };

    handle?.addEventListener("pointerdown", startDrag);
    launcher.addEventListener("pointerdown", startDrag);

    window.addEventListener("resize", () => {
      const clamped = clampFloatingLauncherPosition({
        left: parseFloat(launcher.style.left || String(getFloatingLauncherLeftInset())),
        top: parseFloat(launcher.style.top || "180")
      });
      launcher.style.left = `${clamped.left}px`;
      launcher.style.top = `${clamped.top}px`;
    });
  } else {
    const hasRestBtn = Boolean(launcher.querySelector('.po-floating-btn[data-action="rest"]'));
    const hasOperationsBtn = Boolean(launcher.querySelector('.po-floating-btn[data-action="operations"]'));
    const hasMarchBtn = Boolean(launcher.querySelector('.po-floating-btn[data-action="march"]'));
    const hasGmBtn = Boolean(launcher.querySelector('.po-floating-btn[data-action="gm"]'));
    const hasDockBtn = Boolean(launcher.querySelector('.po-floating-btn[data-action="dock-sidebar"]'));
    const hasLockBtn = Boolean(launcher.querySelector('.po-floating-btn[data-action="lock"]'));
    const hasUnlockBtn = Boolean(launcher.querySelector('.po-floating-btn[data-action="unlock"]'));
    if (!hasRestBtn || !hasOperationsBtn || !hasMarchBtn || !hasGmBtn || !hasDockBtn || !hasLockBtn || !hasUnlockBtn) {
      setLauncherMarkup(launcher);
    }
  }

  const gmButton = launcher.querySelector('.po-floating-btn[data-action="gm"]');
  if (gmButton) gmButton.style.display = canAccessAllPlayerOps() ? "" : "none";

  const pos = clampFloatingLauncherPosition(getFloatingLauncherPosition());
  applyFloatingLauncherInlineStyles(launcher, pos);
  applyFloatingLauncherLockUi(launcher, isFloatingLauncherLocked());
}

function getRollValidator() {
  if (globalThis?.Roll?.validate) return globalThis.Roll;
  if (foundry?.dice?.Roll?.validate) return foundry.dice.Roll;
  return null;
}

function isValidRollFormula(formula) {
  if (formula === null || formula === undefined) return true;
  if (typeof formula !== "string") return false;
  const value = formula.trim();
  if (!value) return true;
  const validator = getRollValidator();
  if (validator?.validate) return Boolean(validator.validate(value));
  try {
    new Roll(value);
    return true;
  } catch {
    return false;
  }
}

function isValidAsyncScript(source) {
  if (typeof source !== "string") return true;
  const code = source.trim();
  if (!code) return true;
  try {
    const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;
    new AsyncFunction(code);
    return true;
  } catch {
    return false;
  }
}

async function diagnoseWorldData(options = {}) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can diagnose world data.");
    return null;
  }

  const repair = Boolean(options.repair);
  const report = {
    scanned: {
      actors: game.actors.size,
      items: game.items.size,
      macros: game.macros.size
    },
    actors: [],
    items: [],
    activities: [],
    macros: [],
    repaired: {
      actors: 0,
      items: 0,
      activities: 0
    }
  };

  for (const actor of game.actors.contents) {
    const formula = actor.system?.attributes?.hp?.formula;
    if (typeof formula !== "string") continue;
    if (isValidRollFormula(formula)) continue;
    report.actors.push({
      id: actor.id,
      name: actor.name,
      formula
    });
    if (repair) {
      try {
        await actor.update({ "system.attributes.hp.formula": "0" });
        report.repaired.actors += 1;
      } catch (error) {
        console.warn(`${MODULE_ID}: failed to repair actor hp formula`, actor.id, error);
      }
    }
  }

  for (const item of game.items.contents) {
    const durationValue = item.system?.duration?.value;
    if (typeof durationValue === "string" && !isValidRollFormula(durationValue)) {
      report.items.push({
        id: item.id,
        name: item.name,
        durationValue
      });
      if (repair) {
        try {
          await item.update({ "system.duration.value": "" });
          report.repaired.items += 1;
        } catch (error) {
          console.warn(`${MODULE_ID}: failed to repair item duration`, item.id, error);
        }
      }
    }

    const activityUpdates = {};
    let activityRepairCount = 0;
    for (const [activityId, activity] of Object.entries(item.system?.activities ?? {})) {
      const parts = activity?.damage?.parts ?? [];
      parts.forEach((part, index) => {
        const formula = part?.custom?.formula;
        if (typeof formula !== "string") return;
        if (isValidRollFormula(formula)) return;
        report.activities.push({
          itemId: item.id,
          itemName: item.name,
          activityId,
          partIndex: index,
          formula
        });
        if (repair) {
          activityUpdates[`system.activities.${activityId}.damage.parts.${index}.custom.formula`] = "";
          activityRepairCount += 1;
        }
      });
    }

    if (repair && Object.keys(activityUpdates).length > 0) {
      try {
        await item.update(activityUpdates);
        report.repaired.activities += activityRepairCount;
      } catch (error) {
        console.warn(`${MODULE_ID}: failed to repair item activities`, item.id, error);
      }
    }
  }

  for (const macro of game.macros.contents) {
    if (isValidAsyncScript(macro.command)) continue;
    report.macros.push({
      id: macro.id,
      name: macro.name,
      type: macro.type,
      commandPreview: String(macro.command ?? "").slice(0, 80)
    });
  }

  const totalIssues = report.actors.length + report.items.length + report.activities.length + report.macros.length;
  const totalRepaired = report.repaired.actors + report.repaired.items + report.repaired.activities;
  if (repair) {
    ui.notifications?.info(`Party Operations repair finished. Issues: ${totalIssues}, repaired: ${totalRepaired}, macro scripts needing manual fix: ${report.macros.length}.`);
  } else {
    ui.notifications?.info(`Party Operations diagnose finished. Issues found: ${totalIssues}.`);
  }
  if (DEBUG_LOG) console.log(`${MODULE_ID}: world data diagnose report`, report);
  return report;
}

function setupPartyOperationsUI() {
  Hooks.on("getSceneControlButtons", (controls) => {
    if (!Array.isArray(controls)) return;
    if (controls.some((control) => control?.name === "party-operations")) return;

    const tools = [
      {
        name: "po-rest-watch",
        title: "Open Rest Watch",
        icon: "fas fa-moon",
        button: true,
        onClick: () => openMainTab("rest-watch", { force: true })
      },
      {
        name: "po-marching-order",
        title: "Open Marching Order",
        icon: "fas fa-arrow-up",
        button: true,
        onClick: () => openMainTab("marching-order", { force: true })
      },
      {
        name: "po-operations",
        title: "Open Operations",
        icon: "fas fa-clipboard-list",
        button: true,
        onClick: () => openMainTab("operations", { force: true })
      }
    ];

    if (canAccessAllPlayerOps()) {
      tools.push({
        name: "po-gm",
        title: "Open GM",
        icon: "fas fa-user-shield",
        button: true,
        onClick: () => openMainTab("gm", { force: true })
      });
    }

    controls.push({
      name: "party-operations",
      title: "Party Operations",
      icon: "fas fa-compass",
      visible: true,
      tools,
      activeTool: "po-rest-watch"
    });
  });

  // Keep launcher UI visible across re-renders.
  Hooks.on("renderSceneControls", (controls, html) => {
    ensureLauncherUi();
  });

  Hooks.on("canvasReady", () => {
    ensureLauncherUi();
  });

  Hooks.on("renderHotbar", () => {
    ensureLauncherUi();
  });

  Hooks.on("renderSidebarTab", () => {
    ensureLauncherUi();
  });

  Hooks.on("renderNavigation", () => {
    ensureLauncherUi();
  });
}

function registerHookModule(module) {
  const registrations = Array.isArray(module?.registrations) ? module.registrations : [];
  for (const registration of registrations) {
    if (!Array.isArray(registration) || registration.length < 2) continue;
    const eventName = String(registration[0] ?? "").trim();
    const handler = registration[1];
    if (!eventName || typeof handler !== "function") continue;
    Hooks.on(eventName, handler);
  }
}

function buildTimeHookModule() {
  return {
    id: "time",
    registrations: [
      ["updateWorldTime", async () => {
        // World time may tick frequently (for example every few seconds with calendar modules),
        // so avoid forcing a full app rerender on every tick.
        await notifyDailyInjuryReminders();
        if (!game.user?.isGM) return;
        await applyOperationalUpkeep({ automatic: true });
      }]
    ]
  };
}

function buildUserPresenceHookModule() {
  return {
    id: "user-presence",
    registrations: [
      ["updateUser", (user, changed) => {
        if (!user || !changed || game.user?.isGM) return;
        if (!Object.prototype.hasOwnProperty.call(changed, "active")) return;
        if (!user.isGM || !user.active) return;
        schedulePendingSopNoteSync("gm-activated");
      }]
    ]
  };
}

function buildTokenHookModule() {
  return {
    id: "tokens",
    registrations: [
      ["createToken", async (tokenDoc, options, userId) => {
        await applyAutoInventoryToUnlinkedToken(tokenDoc, options ?? {}, userId ?? null);
      }],
      ["preUpdateToken", (tokenDoc, changed, options) => {
        if (options?.poEnvironmentClamp) return;
        if (!changed || (changed.x === undefined && changed.y === undefined)) return;
        environmentMoveOriginByToken.set(tokenDoc.id, {
          x: Number(tokenDoc.x ?? 0),
          y: Number(tokenDoc.y ?? 0)
        });
      }],
      ["updateToken", async (tokenDoc, changed, options) => {
        await maybePromptEnvironmentMovementCheck(tokenDoc, changed, options ?? {});
      }]
    ]
  };
}

function buildInventoryHookModule() {
  return {
    id: "inventory",
    registrations: [
      ["updateActor", (actor, changed) => {
        if (!hasInventoryDelta(changed)) return;
        queueInventoryRefresh(actor, "inventory-update-actor");
      }],
      ["createItem", (item) => {
        const actor = item?.parent;
        if (!actor || actor.documentName !== "Actor") return;
        queueInventoryRefresh(actor, "inventory-create-item");
      }],
      ["updateItem", (item, changed) => {
        const actor = item?.parent;
        if (!actor || actor.documentName !== "Actor") return;
        if (!changed || typeof changed !== "object") return;

        const touchesQuantity = foundry.utils.getProperty(changed, "system.quantity") !== undefined;
        const touchesContainer = foundry.utils.getProperty(changed, "system.container") !== undefined;
        const touchesEquipped = foundry.utils.getProperty(changed, "system.equipped") !== undefined;
        const touchesWeight = foundry.utils.getProperty(changed, "system.weight") !== undefined;
        const touchesName = Object.prototype.hasOwnProperty.call(changed, "name");

        if (!touchesQuantity && !touchesContainer && !touchesEquipped && !touchesWeight && !touchesName) return;
        queueInventoryRefresh(actor, "inventory-update-item");
      }],
      ["deleteItem", (item) => {
        const actor = item?.parent;
        if (!actor || actor.documentName !== "Actor") return;
        queueInventoryRefresh(actor, "inventory-delete-item");
      }]
    ]
  };
}

function buildSettingHookModule() {
  const restKey = `${MODULE_ID}.${SETTINGS.REST_STATE}`;
  const marchKey = `${MODULE_ID}.${SETTINGS.MARCH_STATE}`;
  const actKey = `${MODULE_ID}.${SETTINGS.REST_ACTIVITIES}`;
  const opsKey = `${MODULE_ID}.${SETTINGS.OPS_LEDGER}`;
  const injuryKey = `${MODULE_ID}.${SETTINGS.INJURY_RECOVERY}`;
  const lootSourceKey = `${MODULE_ID}.${SETTINGS.LOOT_SOURCE_CONFIG}`;
  const integrationModeKey = `${MODULE_ID}.${SETTINGS.INTEGRATION_MODE}`;
  const journalVisibilityKey = `${MODULE_ID}.${SETTINGS.JOURNAL_ENTRY_VISIBILITY}`;
  const sessionSummaryRangeKey = `${MODULE_ID}.${SETTINGS.SESSION_SUMMARY_RANGE}`;
  const refreshKeys = new Set([restKey, marchKey, actKey, opsKey, injuryKey, lootSourceKey, journalVisibilityKey, sessionSummaryRangeKey]);
  const integrationSyncKeys = new Set([restKey, marchKey, opsKey, injuryKey, integrationModeKey]);

  return {
    id: "settings",
    registrations: [
      ["updateSetting", (setting) => {
        const settingKey = String(setting?.key ?? "").trim();
        if (!settingKey) return;
        if (consumeSuppressedSettingRefresh(settingKey)) return;
        if (refreshKeys.has(settingKey)) refreshOpenApps();
        if (game.user?.isGM && integrationSyncKeys.has(settingKey)) {
          scheduleIntegrationSync("update-setting");
        }
      }]
    ]
  };
}

function buildIntegrationHookModule() {
  return {
    id: "integration",
    registrations: [
      ["canvasReady", () => {
        if (!game.user?.isGM) return;
        scheduleIntegrationSync("canvas-ready");
      }]
    ]
  };
}

function getPartyOpsHookModules() {
  return [
    buildTimeHookModule(),
    buildUserPresenceHookModule(),
    buildTokenHookModule(),
    buildInventoryHookModule(),
    buildSettingHookModule(),
    buildIntegrationHookModule()
  ];
}

function registerPartyOpsHooks() {
  if (partyOpsHooksRegistered) return;
  partyOpsHooksRegistered = true;
  for (const hookModule of getPartyOpsHookModules()) {
    registerHookModule(hookModule);
  }
}

Hooks.once("init", () => {
  registerPartyOperationsApi();
  registerFeatureModules();
  registerPartyOpsSettings((key) => {
    if (key === SETTINGS.DEBUG_ENABLED) return;
    refreshOpenApps();
  });
  game.settings.register(MODULE_ID, SETTINGS.REST_STATE, {
    scope: "world",
    config: false,
    type: Object,
    default: buildDefaultRestWatchState()
  });

  game.settings.register(MODULE_ID, SETTINGS.REST_COMMITTED, {
    scope: "world",
    config: false,
    type: Object,
    default: buildDefaultRestWatchState()
  });

  game.settings.register(MODULE_ID, SETTINGS.MARCH_STATE, {
    scope: "world",
    config: false,
    type: Object,
    default: buildDefaultMarchingOrderState()
  });

  game.settings.register(MODULE_ID, SETTINGS.MARCH_COMMITTED, {
    scope: "world",
    config: false,
    type: Object,
    default: buildDefaultMarchingOrderState()
  });

  game.settings.register(MODULE_ID, SETTINGS.REST_ACTIVITIES, {
    scope: "world",
    config: false,
    type: Object,
    default: buildDefaultActivityState()
  });

  game.settings.register(MODULE_ID, SETTINGS.OPS_LEDGER, {
    scope: "world",
    config: false,
    type: Object,
    default: buildDefaultOperationsLedger()
  });

  game.settings.register(MODULE_ID, SETTINGS.INJURY_RECOVERY, {
    scope: "world",
    config: false,
    type: Object,
    default: buildDefaultInjuryRecoveryState()
  });

  game.settings.register(MODULE_ID, SETTINGS.INJURY_REMINDER_DAY, {
    scope: "client",
    config: false,
    type: String,
    default: ""
  });

  game.settings.register(MODULE_ID, SETTINGS.LOOT_SOURCE_CONFIG, {
    scope: "world",
    config: false,
    type: Object,
    default: buildDefaultLootSourceConfig()
  });

  game.settings.register(MODULE_ID, SETTINGS.AUTO_INV_ENABLED, {
    name: "Auto Inventory For Unlinked Tokens",
    hint: "When enabled, new unlinked NPC tokens get generated usable inventory on placement.",
    scope: "world",
    config: true,
    type: Boolean,
    default: true
  });

  game.settings.register(MODULE_ID, SETTINGS.AUTO_INV_WEAPON_PACK, {
    name: "Auto Inventory Weapon Pack",
    hint: "Compendium pack ID used for weapon lookups (for example dnd5e.items).",
    scope: "world",
    config: true,
    type: String,
    default: "dnd5e.items",
    onChange: () => autoInventoryPackIndexCache.clear()
  });

  game.settings.register(MODULE_ID, SETTINGS.AUTO_INV_ARMOR_PACK, {
    name: "Auto Inventory Armor Pack",
    hint: "Compendium pack ID used for armor/shield lookups.",
    scope: "world",
    config: true,
    type: String,
    default: "dnd5e.items",
    onChange: () => autoInventoryPackIndexCache.clear()
  });

  game.settings.register(MODULE_ID, SETTINGS.AUTO_INV_GEAR_PACK, {
    name: "Auto Inventory Gear Pack",
    hint: "Compendium pack ID used for adventuring gear lookups.",
    scope: "world",
    config: true,
    type: String,
    default: "dnd5e.items",
    onChange: () => autoInventoryPackIndexCache.clear()
  });

  game.settings.register(MODULE_ID, SETTINGS.AUTO_INV_CONSUMABLES_PACK, {
    name: "Auto Inventory Consumables Pack",
    hint: "Compendium pack ID used for potions and consumables lookups.",
    scope: "world",
    config: true,
    type: String,
    default: "dnd5e.items",
    onChange: () => autoInventoryPackIndexCache.clear()
  });

  game.settings.register(MODULE_ID, SETTINGS.AUTO_INV_CURRENCY_ENABLED, {
    name: "Auto Inventory Currency",
    hint: "If enabled, generated unlinked token inventory can include weighted currency bundles.",
    scope: "world",
    config: true,
    type: Boolean,
    default: true
  });

  game.settings.register(MODULE_ID, SETTINGS.AUTO_INV_ITEM_CHANCE_SCALAR, {
    name: "Auto Inventory Item Chance (%)",
    hint: "Scales non-mandatory equipment/gear chance for unlinked token auto inventory.",
    scope: "world",
    config: true,
    type: Number,
    range: {
      min: 0,
      max: 200,
      step: 5
    },
    default: AUTO_INV_DEFAULT_ITEM_CHANCE_SCALAR
  });

  game.settings.register(MODULE_ID, SETTINGS.AUTO_INV_CONSUMABLE_CHANCE_SCALAR, {
    name: "Auto Inventory Consumable Chance (%)",
    hint: "Scales potion and utility consumable chance for unlinked token auto inventory.",
    scope: "world",
    config: true,
    type: Number,
    range: {
      min: 0,
      max: 300,
      step: 5
    },
    default: AUTO_INV_DEFAULT_CONSUMABLE_CHANCE_SCALAR
  });

  game.settings.register(MODULE_ID, SETTINGS.AUTO_INV_CURRENCY_SCALAR, {
    name: "Auto Inventory Currency Scale (%)",
    hint: "Scales generated currency bundle amounts for unlinked token auto inventory.",
    scope: "world",
    config: true,
    type: Number,
    range: {
      min: 0,
      max: 300,
      step: 5
    },
    default: AUTO_INV_DEFAULT_CURRENCY_SCALAR
  });

  game.settings.register(MODULE_ID, SETTINGS.AUTO_INV_QUALITY_SHIFT, {
    name: "Auto Inventory Quality Shift",
    hint: "Shifts item quality band from CR (-2 to +2) for stricter or richer gear quality.",
    scope: "world",
    config: true,
    type: Number,
    range: {
      min: -2,
      max: 2,
      step: 1
    },
    default: AUTO_INV_DEFAULT_QUALITY_SHIFT
  });

  game.settings.register(MODULE_ID, SETTINGS.INTEGRATION_MODE, {
    name: "Integration Mode",
    hint: "Choose how Party Operations syncs state for DAE/automation modules.",
    scope: "world",
    config: true,
    type: String,
    choices: {
      auto: "Auto (DAE if active, otherwise flags)",
      off: "Off",
      flags: "Flags Only",
      dae: "DAE + Flags"
    },
    default: "auto"
  });

  game.settings.register(MODULE_ID, SETTINGS.SESSION_AUTOPILOT_SNAPSHOT, {
    scope: "world",
    config: false,
    type: Object,
    default: {}
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_ROLL_MODE, {
    name: "Gather Roll Mode",
    hint: "Choose how Gather Resource checks request Wisdom (Survival) rolls.",
    scope: "world",
    config: true,
    type: String,
    choices: {
      "prefer-monks": "Prefer Monk's TokenBar (fallback to Foundry)",
      "monks-only": "Monk's TokenBar Only",
      "foundry-only": "Foundry Only"
    },
    default: "prefer-monks"
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_ENABLED, {
    name: "Gather Resources Enabled",
    hint: "Enable or disable gather resource actions in Party Operations.",
    scope: "world",
    config: true,
    type: Boolean,
    default: GATHER_DEFAULTS.enabled
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_MIN_HOURS, {
    name: "Gather Minimum Hours",
    hint: "Minimum hours required for one gather attempt.",
    scope: "world",
    config: true,
    type: Number,
    range: {
      min: 1,
      max: 24,
      step: 1
    },
    default: GATHER_DEFAULTS.minimumHours
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_DISALLOW_COMBAT, {
    name: "Disallow Gather In Combat",
    hint: "Prevent gather attempts when the actor is an active combatant.",
    scope: "world",
    config: true,
    type: Boolean,
    default: GATHER_DEFAULTS.disallowCombat
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_DC_LUSH, {
    name: "Gather DC: Lush Forest / River Valley",
    hint: "Base DC for lush forest or river valley gather attempts.",
    scope: "world",
    config: true,
    type: Number,
    range: { min: 1, max: 30, step: 1 },
    default: GATHER_DEFAULTS.baseDc.lush_forest_or_river_valley
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_DC_TEMPERATE, {
    name: "Gather DC: Temperate Hills / Light Woodland",
    hint: "Base DC for temperate hills or light woodland gather attempts.",
    scope: "world",
    config: true,
    type: Number,
    range: { min: 1, max: 30, step: 1 },
    default: GATHER_DEFAULTS.baseDc.temperate_hills_or_light_woodland
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_DC_SPARSE, {
    name: "Gather DC: Sparse Plains / Rocky",
    hint: "Base DC for sparse plains or rocky terrain gather attempts.",
    scope: "world",
    config: true,
    type: Number,
    range: { min: 1, max: 30, step: 1 },
    default: GATHER_DEFAULTS.baseDc.sparse_plains_or_rocky
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_DC_COLD, {
    name: "Gather DC: Cold Mountains / Swamp",
    hint: "Base DC for cold mountains or swamp gather attempts.",
    scope: "world",
    config: true,
    type: Number,
    range: { min: 1, max: 30, step: 1 },
    default: GATHER_DEFAULTS.baseDc.cold_mountains_or_swamp
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_DC_DESERT, {
    name: "Gather DC: Desert / Blighted Wasteland",
    hint: "Base DC for desert or blighted wasteland gather attempts.",
    scope: "world",
    config: true,
    type: Number,
    range: { min: 1, max: 30, step: 1 },
    default: GATHER_DEFAULTS.baseDc.desert_blighted_wasteland
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_DEFAULT_SEASON_MOD, {
    name: "Gather Default Season Modifier",
    hint: "Default DC modifier from season shifts.",
    scope: "world",
    config: true,
    type: Number,
    range: { min: -10, max: 10, step: 1 },
    default: GATHER_DEFAULTS.seasonMod
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_DEFAULT_WEATHER_MOD, {
    name: "Gather Default Weather Modifier",
    hint: "Default DC modifier from weather conditions.",
    scope: "world",
    config: true,
    type: Number,
    range: { min: -10, max: 10, step: 1 },
    default: GATHER_DEFAULTS.weatherMod
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_DEFAULT_CORRUPTION_MOD, {
    name: "Gather Default Corruption Modifier",
    hint: "Default DC modifier from corruption effects.",
    scope: "world",
    config: true,
    type: Number,
    range: { min: -10, max: 10, step: 1 },
    default: GATHER_DEFAULTS.corruptionMod
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_ENABLE_HERBALISM_ADVANTAGE, {
    name: "Gather: Herbalism Advantage",
    hint: "Allow advantage for plant gathering mode when enabled by the GM.",
    scope: "world",
    config: true,
    type: Boolean,
    default: GATHER_DEFAULTS.herbalismAdvantageEnabled
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_ENABLE_HOSTILE_FAIL_FLAG, {
    name: "Gather: Hostile Terrain Encounter Flag",
    hint: "On failure in hostile terrain, flag for encounter checks.",
    scope: "world",
    config: true,
    type: Boolean,
    default: GATHER_DEFAULTS.hostileEncounterFlagEnabled
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_ENABLE_FAIL_BY5_COMPLICATION, {
    name: "Gather: Fail by 5+ Complication",
    hint: "Apply optional complications when the check fails by 5 or more.",
    scope: "world",
    config: true,
    type: Boolean,
    default: GATHER_DEFAULTS.failBy5ComplicationEnabled
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_ENABLE_SUCCESS_BY5_DOUBLE, {
    name: "Gather: Success by 5+ Doubles Rations",
    hint: "Double rations on checks that succeed by 5 or more.",
    scope: "world",
    config: true,
    type: Boolean,
    default: GATHER_DEFAULTS.successBy5DoubleEnabled
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_ENABLE_NAT20_BONUS, {
    name: "Gather: Natural 20 Bonus",
    hint: "Natural 20 grants +1d4 rations and safe campsite flag.",
    scope: "world",
    config: true,
    type: Boolean,
    default: GATHER_DEFAULTS.nat20BonusEnabled
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_ENABLE_NAT1_FLAG, {
    name: "Gather: Natural 1 Complication",
    hint: "Natural 1 triggers spoiled/poison/attract-danger complication flag.",
    scope: "world",
    config: true,
    type: Boolean,
    default: GATHER_DEFAULTS.nat1ComplicationEnabled
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_ENABLE_CORRUPTION_WATER_CHECK, {
    name: "Gather: Corruption Water Check",
    hint: "When gathering water in corrupted regions, run contamination check.",
    scope: "world",
    config: true,
    type: Boolean,
    default: GATHER_DEFAULTS.corruptionWaterCheckEnabled
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_CORRUPTION_SAVE_DC, {
    name: "Gather: Corruption Water Con Save DC",
    hint: "Constitution save DC used when contaminated water is found.",
    scope: "world",
    config: true,
    type: Number,
    range: { min: 1, max: 30, step: 1 },
    default: GATHER_DEFAULTS.corruptionConSaveDc
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_ENABLE_WATER_AUTO_FOUND, {
    name: "Gather: Water Auto-Found Toggle",
    hint: "Allow the obvious-water-source toggle to auto-find water.",
    scope: "world",
    config: true,
    type: Boolean,
    default: GATHER_DEFAULTS.waterAutoFoundEnabled
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_ENABLE_TRAVEL_TRADEOFF, {
    name: "Gather: Travel Tradeoff Enabled",
    hint: "Apply travel tradeoff when gathering during travel.",
    scope: "world",
    config: true,
    type: Boolean,
    default: GATHER_DEFAULTS.travelTradeoffEnabled
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_TRAVEL_TRADEOFF_DEFAULT, {
    name: "Gather: Default Travel Tradeoff",
    hint: "Default tradeoff used when gathering during travel.",
    scope: "world",
    config: true,
    type: String,
    choices: {
      [GATHER_TRAVEL_CHOICES.PACE]: "Reduce pace one step",
      [GATHER_TRAVEL_CHOICES.FELL_BEHIND]: "Fell behind + Con save"
    },
    default: GATHER_DEFAULTS.travelTradeoffDefault
  });

  game.settings.register(MODULE_ID, SETTINGS.GATHER_TRAVEL_CON_SAVE_DC, {
    name: "Gather: Travel Con Save DC",
    hint: "Constitution save DC when the actor falls behind during travel gathering.",
    scope: "world",
    config: true,
    type: Number,
    range: { min: 1, max: 30, step: 1 },
    default: GATHER_DEFAULTS.travelConSaveDc
  });

  game.settings.register(MODULE_ID, SETTINGS.LAUNCHER_PLACEMENT, {
    name: "Launcher Placement",
    hint: "Choose whether the Party Operations launcher is on-screen, in the sidebar, or both.",
    scope: "client",
    config: true,
    type: String,
    choices: {
      [LAUNCHER_PLACEMENTS.FLOATING]: "Floating on Screen",
      [LAUNCHER_PLACEMENTS.SIDEBAR]: "Pinned in Sidebar",
      [LAUNCHER_PLACEMENTS.BOTH]: "Show Both"
    },
    default: LAUNCHER_PLACEMENTS.FLOATING,
    onChange: () => ensureLauncherUi()
  });

  game.settings.register(MODULE_ID, SETTINGS.FLOATING_LAUNCHER_POS, {
    scope: "client",
    config: false,
    type: Object,
    default: {
      left: 16,
      top: 180
    }
  });

  game.settings.register(MODULE_ID, SETTINGS.FLOATING_LAUNCHER_LOCKED, {
    name: "Lock Launcher Position",
    hint: "When enabled, the floating Party Operations launcher cannot be dragged.",
    scope: "client",
    config: true,
    type: Boolean,
    default: false,
    onChange: () => ensureLauncherUi()
  });

  game.settings.register(MODULE_ID, SETTINGS.FLOATING_LAUNCHER_RESET, {
    name: "Reset Launcher Position",
    hint: "Set to true to reset launcher position, then it auto-clears.",
    scope: "client",
    config: true,
    type: Boolean,
    default: false,
    onChange: async (value) => {
      if (!value) return;
      await resetFloatingLauncherPosition();
      await game.settings.set(MODULE_ID, SETTINGS.FLOATING_LAUNCHER_RESET, false);
      ensureLauncherUi();
    }
  });

  game.settings.register(MODULE_ID, SETTINGS.PLAYER_AUTO_OPEN_REST, {
    name: "Auto-open Rest Watch for Players",
    hint: "When enabled, non-GM users automatically open Rest Watch when Foundry is ready.",
    scope: "world",
    config: true,
    type: Boolean,
    default: false
  });

  game.settings.register(MODULE_ID, SETTINGS.SHARED_GM_PERMISSIONS, {
    name: "Shared GM Permissions (Module)",
    hint: "When enabled, all players can use GM-level Party Operations controls. Changes still execute through the active GM client.",
    scope: "world",
    config: true,
    type: Boolean,
    default: true,
    onChange: () => refreshOpenApps()
  });

  game.settings.register(MODULE_ID, SETTINGS.JOURNAL_ENTRY_VISIBILITY, {
    name: "Operations Journal Visibility",
    hint: "Control how sensitive operation logs are exposed in shared journals.",
    scope: "world",
    config: true,
    type: String,
    choices: {
      [JOURNAL_VISIBILITY_MODES.PUBLIC]: "Public (full details to observers)",
      [JOURNAL_VISIBILITY_MODES.REDACTED]: "Redacted (sensitive details hidden)",
      [JOURNAL_VISIBILITY_MODES.GM_PRIVATE]: "GM Only (sensitive entries private)"
    },
    default: JOURNAL_VISIBILITY_MODES.REDACTED
  });

  game.settings.register(MODULE_ID, SETTINGS.SESSION_SUMMARY_RANGE, {
    name: "Session Summary Default Window",
    hint: "Default lookback window when creating a session summary journal.",
    scope: "world",
    config: true,
    type: String,
    choices: SESSION_SUMMARY_RANGE_OPTIONS,
    default: "last-24h"
  });

  game.settings.register(MODULE_ID, SETTINGS.JOURNAL_FILTER_DEBOUNCE_MS, {
    name: "Journal Filter Debounce (ms)",
    hint: "Delay before applying journal search input, to reduce UI re-renders.",
    scope: "client",
    config: true,
    type: Number,
    range: { min: 0, max: 1000, step: 10 },
    default: 180
  });

  game.settings.register(MODULE_ID, SETTINGS.JOURNAL_FOLDER_CACHE, {
    scope: "world",
    config: false,
    type: Object,
    default: { folders: {} }
  });

  game.settings.register(MODULE_ID, SETTINGS.INVENTORY_HOOK_MODE, {
    name: "Inventory Hook Mode",
    hint: "Controls actor inventory hook behavior for Party Operations refresh/sync.",
    scope: "world",
    config: true,
    type: String,
    choices: {
      [INVENTORY_HOOK_MODES.OFF]: "Off",
      [INVENTORY_HOOK_MODES.REFRESH]: "Refresh UI Only",
      [INVENTORY_HOOK_MODES.SYNC]: "Refresh UI + Integration Sync"
    },
    default: INVENTORY_HOOK_MODES.SYNC
  });

  game.keybindings.register(MODULE_ID, "openRestWatch", {
    name: "Open Rest Watch",
    editable: [],
    onDown: () => {
      openRestWatchUiForCurrentUser({ force: true });
      return true;
    }
  });

  game.keybindings.register(MODULE_ID, "openMarchingOrder", {
    name: "Open Marching Order",
    editable: [],
    onDown: () => {
      openMainTab("marching-order", { force: true });
      return true;
    }
  });
});

Hooks.once("ready", () => {
  registerPartyOperationsApi();
  void validatePartyOperationsTemplates();
  bindPoBrowserBackNavigation();
  
  // Setup UI controls for sidebar
  setupPartyOperationsUI();
  ensureLauncherUi();
  window.setTimeout(() => ensureLauncherUi(), 250);
  window.setTimeout(() => ensureLauncherUi(), 1000);
  window.setTimeout(() => ensureLauncherUi(), 3000);
  window.setTimeout(() => {
    forceLauncherRecovery("ready-self-heal").catch((error) => {
      console.warn(`${MODULE_ID}: launcher self-heal failed`, error);
    });
  }, 4200);
  notifyDailyInjuryReminders();

  // Auto-open player UI for non-GM players
  if (!game.user?.isGM) {
    // Intentionally do not auto-open UI on ready.
    schedulePendingSopNoteSync("ready");
  } else {
    scheduleIntegrationSync("ready");
    ensureOperationsJournalFolderTree().catch((error) => {
      console.warn(`${MODULE_ID}: failed to initialize operations journal folder tree`, error);
    });
    scheduleLootManifestCompendiumTypeFolderSync("ready").catch((error) => {
      console.warn(`${MODULE_ID}: failed to sync loot manifest compendium folders`, error);
    });
  }

  game.socket.on(SOCKET_CHANNEL, async (message) => {
    if (!message || typeof message !== "object") return;

    if (message.type === "players:openLootClaims") {
      const currentUserId = String(game.user?.id ?? "").trim();
      const targetUserId = String(message.userId ?? "").trim();
      const broadcast = !targetUserId || targetUserId === "*" || targetUserId.toLowerCase() === "all";
      if (!broadcast && targetUserId !== currentUserId) return;
      if (game.user?.isGM) return;

      const actorIdByUserId = message?.actorIdByUserId && typeof message.actorIdByUserId === "object"
        ? message.actorIdByUserId
        : null;
      const preferredActorId = actorIdByUserId
        ? normalizeLootClaimActorId(actorIdByUserId[currentUserId])
        : "";
      const selectedActorId = preferredActorId || normalizeLootClaimActorId(message.actorId);
      if (selectedActorId) setLootClaimActorSelection(selectedActorId);
      const selectedRunId = normalizeLootClaimRunId(message.runId);
      if (selectedRunId) setLootClaimRunSelection(selectedRunId);
      await waitForLootClaimsPublished(message?.publishedAt);
      const lootClaims = buildLootClaimsContext(game.user);
      logUiDebug("loot-claims", "prompting player loot claims UI", {
        currentUserId,
        targetUserId,
        broadcast,
        selectedActorId,
        selectedRunId,
        itemCount: Math.max(0, Number(message?.itemCount ?? lootClaims?.itemCount ?? 0) || 0),
        publishedAt: Math.max(0, Number(message?.publishedAt ?? 0) || 0)
      });
      const shouldOpen = await promptLootClaimsDialogForPlayer({
        itemCount: message?.itemCount,
        publishedBy: message?.publishedBy,
        publishedAt: message?.publishedAt,
        currencyRemaining: message?.currencyRemaining,
        lootClaims
      });
      if (!shouldOpen) return;
      openOperationsLootClaimsTabForPlayer({ force: true });
      return;
    }

    if (message.type === "players:openRest" && !game.user?.isGM) {
      openRestWatchUiForCurrentUser({ force: true });
      return;
    }

    if (message.type === "refresh") {
      if (message.userId && message.userId === game.user.id) return;
      // Small delay helps ensure settings updates have propagated before re-rendering
      setTimeout(() => refreshOpenApps(), 75);
      if (!game.user?.isGM) schedulePendingSopNoteSync("socket-refresh");
      return;
    }

    if (message.type === "ops:merchant-barter-result") {
      syncMerchantBarterStatusForOpenDialogs(message);
      return;
    }

    if (!game.user?.isGM) return; // only GM applies mutations

    if (message.type === "ops:setting-write") {
      const requester = getSocketRequester(message, { allowGM: false, requireActive: true });
      if (!requester) return;
      await applyPlayerSettingWriteRequest(message, requester);
      return;
    }

    if (message.type === "activity:update") {
      const requester = getSocketRequester(message, { allowGM: false, requireActive: true });
      const actorId = sanitizeSocketIdentifier(message.actorId, { maxLength: 64 });
      const activityType = normalizeSocketActivityType(message.activity);
      if (!requester || !actorId || !activityType) return;

      // Players can update their own activity
      const requesterActor = requester.character;
      if (!requesterActor || requesterActor.id !== actorId) return; // security check

      const activities = getRestActivities();
      if (!activities.activities[actorId]) activities.activities[actorId] = {};
      activities.activities[actorId].activity = activityType;
      await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.REST_ACTIVITIES, activities);
      refreshOpenApps();
      emitSocketRefresh();
      return;
    }

    if (message.type === "rest:mutate") {
      const requester = getSocketRequester(message, { allowGM: false, requireActive: true });
      const request = normalizeSocketRestRequest(message.request);
      if (!requester || !request) return;
      await applyRestRequest(request, requester);
      return;
    }
    if (message.type === "march:mutate") {
      const requester = getSocketRequester(message, { allowGM: false, requireActive: true });
      const request = normalizeSocketMarchRequest(message.request);
      if (!requester || !request) return;
      await applyMarchRequest(request, requester);
      return;
    }
    if (message.type === "ops:setSopNote") {
      const requester = getSocketRequester(message, { allowGM: false, requireActive: true });
      if (!requester) return;
      await applyPlayerSopNoteRequest(message, requester);
      return;
    }
    if (message.type === "ops:ledger-write") {
      const requester = getSocketRequester(message, { allowGM: false, requireActive: true });
      if (!requester) return;
      await applyPlayerOperationsLedgerWriteRequest(message, requester);
      return;
    }
    if (message.type === "ops:downtime-submit") {
      const requester = getSocketRequester(message, { allowGM: false, requireActive: true });
      if (!requester) return;
      await applyPlayerDowntimeSubmitRequest(message, requester);
      return;
    }
    if (message.type === "ops:downtime-clear") {
      const requester = getSocketRequester(message, { allowGM: false, requireActive: true });
      if (!requester) return;
      await applyPlayerDowntimeClearRequest(message, requester);
      return;
    }
    if (message.type === "ops:downtime-collect") {
      const requester = getSocketRequester(message, { allowGM: false, requireActive: true });
      if (!requester) return;
      await applyPlayerDowntimeCollectRequest(message, requester);
      return;
    }
    if (message.type === "ops:merchant-barter-request") {
      const requester = getSocketRequester(message, { allowGM: false, requireActive: true });
      if (!requester) return;
      await applyPlayerMerchantBarterRequest(message, requester);
      return;
    }
    if (message.type === "ops:merchant-trade") {
      const requester = getSocketRequester(message, { allowGM: false, requireActive: true });
      if (!requester) return;
      await applyPlayerMerchantTradeRequest(message, requester);
      return;
    }
    if (message.type === "ops:loot-claim") {
      const requester = getSocketRequester(message, { allowGM: false, requireActive: true });
      if (!requester) return;
      await applyPlayerLootClaimRequest(message, requester);
      return;
    }
    if (message.type === "ops:loot-claim-currency") {
      const requester = getSocketRequester(message, { allowGM: false, requireActive: true });
      if (!requester) return;
      await applyPlayerLootCurrencyClaimRequest(message, requester);
      return;
    }
    if (message.type === "ops:loot-vouch") {
      const requester = getSocketRequester(message, { allowGM: false, requireActive: true });
      if (!requester) return;
      await applyPlayerLootVouchRequest(message, requester);
      return;
    }
  });

  registerPartyOpsHooks();
});

async function applyPlayerSettingWriteRequest(message, requesterRef = null) {
  const requester = resolveRequester(requesterRef ?? message?.userId, { allowGM: false, requireActive: true });
  if (!requester) return;
  if (!canAccessAllPlayerOps(requester)) return;

  const settingKey = String(message?.settingKey ?? "").trim();
  if (!isWritableModuleSettingKey(settingKey)) return;
  const settingRecord = game.settings?.settings?.get?.(`${MODULE_ID}.${settingKey}`) ?? null;
  if (String(settingRecord?.scope ?? "").trim().toLowerCase() === "client") return;

  try {
    const fullSettingKey = `${MODULE_ID}.${settingKey}`;
    suppressNextSettingRefresh(fullSettingKey);
    await game.settings.set(MODULE_ID, settingKey, foundry.utils.deepClone(message?.value));
    refreshOpenApps();
    emitSocketRefresh();
  } catch (error) {
    logUiFailure("settings-proxy", "failed player-proxy setting write", error, {
      requesterId: String(requester?.id ?? ""),
      requesterName: String(requester?.name ?? "Player"),
      settingKey
    });
  }
}

async function applyPlayerSopNoteRequest(message, requesterRef = null) {
  const requester = resolveRequester(requesterRef ?? message?.userId, { allowGM: false, requireActive: true });
  if (!requester) return;

  const sopKey = String(message?.sopKey ?? "").trim();
  if (!SOP_KEYS.includes(sopKey)) return;
  const note = clampSocketText(message?.note, SOCKET_NOTE_MAX_LENGTH);

  await updateOperationsLedger((ledger) => {
    const sopNotes = ensureSopNotesState(ledger);
    sopNotes[sopKey] = note;
  });
}

async function applyPlayerOperationsLedgerWriteRequest(message, requesterRef = null) {
  const requester = resolveRequester(requesterRef ?? message?.userId, { allowGM: false, requireActive: true });
  if (!requester) return;
  const incomingLedger = message?.ledger;
  if (!incomingLedger || typeof incomingLedger !== "object" || Array.isArray(incomingLedger)) return;

  const defaults = buildDefaultOperationsLedger();
  const mergedLedger = foundry.utils.mergeObject(defaults, incomingLedger, {
    inplace: false,
    insertKeys: true,
    insertValues: true
  });

  await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.OPS_LEDGER, mergedLedger);
  scheduleIntegrationSync("operations-ledger");
  refreshOpenApps();
  emitSocketRefresh();
}

async function applyPlayerDowntimeSubmitRequest(message, requesterRef = null) {
  const requester = resolveRequester(requesterRef ?? message?.userId, { allowGM: false, requireActive: true });
  if (!requester) return;
  const entry = message?.entry && typeof message.entry === "object" ? message.entry : null;
  if (!entry) return;
  const previewLedger = getOperationsLedger();
  const previewDowntime = ensureDowntimeState(previewLedger);
  const normalizedEntry = normalizeDowntimeSubmission(entry, previewDowntime);
  if (!sanitizeSocketIdentifier(normalizedEntry.actorId, { maxLength: 64 })) return;
  await applyDowntimeSubmissionForUser(requester, normalizedEntry);
}

async function applyPlayerDowntimeClearRequest(message, requesterRef = null) {
  const requester = resolveRequester(requesterRef ?? message?.userId, { allowGM: false, requireActive: true });
  if (!requester) return;
  const actorId = sanitizeSocketIdentifier(message?.actorId, { maxLength: 64 });
  if (!actorId) return;
  const actor = game.actors.get(actorId);
  if (!actor || !canUserManageDowntimeActor(requester, actor)) return;
  await updateOperationsLedger((ledger) => {
    const downtime = ensureDowntimeState(ledger);
    if (!downtime.entries) return;
    delete downtime.entries[actorId];
  });
}

async function applyPlayerDowntimeCollectRequest(message, requesterRef = null) {
  const requester = resolveRequester(requesterRef ?? message?.userId, { allowGM: false, requireActive: true });
  if (!requester) return;
  const actorId = sanitizeSocketIdentifier(message?.actorId, { maxLength: 64 });
  if (!actorId) return;
  const outcome = await applyDowntimeCollectionForUser(requester, actorId);
  if (!outcome.ok) {
    ui.notifications?.warn(`Downtime collect failed (${requester.name}): ${outcome.message ?? "Unknown error."}`);
    return;
  }
  ui.notifications?.info(`${requester.name} collected downtime rewards for ${outcome.actorName}. ${getDowntimeCollectionSummary(outcome)}`);
}

async function applyPlayerMerchantBarterRequest(message, requesterRef = null) {
  const requester = resolveRequester(requesterRef ?? message?.userId, { allowGM: false, requireActive: true });
  if (!requester) return;
  const merchantId = sanitizeSocketIdentifier(message?.merchantId, { maxLength: 64 });
  const actorId = sanitizeSocketIdentifier(message?.actorId, { maxLength: 64 });
  const settlement = normalizeMerchantSettlementSelection(clampSocketText(message?.settlement, 120));
  if (!merchantId || !actorId) return;

  const resolved = await resolveMerchantBarterForUser(requester, { merchantId, actorId, settlement });
  const resolutionPayload = resolved?.ok && resolved?.resolution
    ? {
      applied: true,
      source: String(resolved.resolution?.source ?? "resolved"),
      ability: String(resolved.resolution?.ability ?? "cha"),
      abilityLabel: String(resolved.resolution?.abilityLabel ?? "Charisma"),
      checkTotal: Number(resolved.resolution?.checkTotal ?? 0),
      margin: Number(resolved.resolution?.margin ?? 0),
      success: Boolean(resolved.resolution?.success),
      delta: Number(resolved.resolution?.delta ?? 0),
      buyMarkupDelta: Number(resolved.resolution?.buyMarkupDelta ?? 0),
      sellRateDelta: Number(resolved.resolution?.sellRateDelta ?? 0),
      createdAt: Number(resolved.resolution?.createdAt ?? Date.now())
    }
    : null;

  game.socket.emit(SOCKET_CHANNEL, {
    type: "ops:merchant-barter-result",
    userId: String(requester?.id ?? ""),
    merchantId,
    actorId,
    settlement,
    ok: Boolean(resolved?.ok),
    summary: resolved?.ok
      ? String(resolved?.summary ?? "Barter resolved.")
      : String(resolved?.message ?? "Barter request failed."),
    resolution: resolutionPayload
  });

  if (!resolved?.ok) {
    ui.notifications?.warn(`Merchant barter failed (${requester.name}): ${resolved?.message ?? "Unknown error."}`);
    return;
  }
  ui.notifications?.info(`Resolved barter for ${requester.name}: ${resolved.summary}`);
}

async function applyPlayerMerchantTradeRequest(message, requesterRef = null) {
  const requester = resolveRequester(requesterRef ?? message?.userId, { allowGM: false, requireActive: true });
  if (!requester) return;
  const merchantId = sanitizeSocketIdentifier(message?.merchantId, { maxLength: 64 });
  const actorId = sanitizeSocketIdentifier(message?.actorId, { maxLength: 64 });
  const settlement = normalizeMerchantSettlementSelection(clampSocketText(message?.settlement, 120));
  if (!merchantId || !actorId) return;
  const normalizeLines = (raw) => {
    const source = Array.isArray(raw) ? raw : [];
    const rows = [];
    for (const entry of source) {
      const itemId = sanitizeSocketIdentifier(entry?.itemId, { maxLength: 64 });
      const qtyRaw = Number(entry?.qty ?? entry?.quantity ?? 0);
      const qty = Number.isFinite(qtyRaw) ? Math.max(0, Math.min(999, Math.floor(qtyRaw))) : 0;
      if (!itemId || qty <= 0) continue;
      rows.push({ itemId, qty });
    }
    return rows;
  };
  const tradePayload = {
    merchantId,
    actorId,
    settlement,
    buyItems: normalizeLines(message?.buyItems),
    sellItems: normalizeLines(message?.sellItems)
  };
  const barterKey = getMerchantBarterResolutionKey({
    userId: String(requester?.id ?? "").trim(),
    actorId,
    merchantId,
    settlement
  });
  const cachedBarterResolution = getMerchantBarterResolutionEntryByKey(barterKey);
  if (cachedBarterResolution?.applied) tradePayload.barterResolution = cachedBarterResolution;
  const outcome = await applyMerchantTradeForUser(requester, tradePayload);
  if (!outcome.ok) {
    ui.notifications?.warn(`Merchant trade failed (${requester.name}): ${outcome.message ?? "Unknown error."}`);
    return;
  }
  clearMerchantBarterResolutionEntryByKey(barterKey);
  ui.notifications?.info(`${requester.name} completed merchant trade for ${outcome.actorName}.`);
}

async function applyPlayerLootClaimRequest(message, requesterRef = null) {
  const requester = resolveRequester(requesterRef ?? message?.userId, { allowGM: false, requireActive: true });
  if (!requester) return;
  const actorId = sanitizeSocketIdentifier(message?.actorId, { maxLength: 64 });
  const itemId = sanitizeSocketIdentifier(message?.itemId, { maxLength: 64 });
  const runId = sanitizeSocketIdentifier(message?.runId, { maxLength: 64 });
  if (!actorId || !itemId) return;
  const outcome = await applyLootClaimForUser(requester, actorId, itemId, runId);
  if (!outcome.ok) {
    ui.notifications?.warn(`Loot claim failed (${requester.name}): ${outcome.message ?? "Unknown error."}`);
    return;
  }
  await postLootItemClaimToChat(outcome);
  ui.notifications?.info(`${requester.name} claimed ${outcome.itemName} for ${outcome.actorName}.`);
}

async function applyPlayerLootCurrencyClaimRequest(message, requesterRef = null) {
  const requester = resolveRequester(requesterRef ?? message?.userId, { allowGM: false, requireActive: true });
  if (!requester) return;
  const actorId = sanitizeSocketIdentifier(message?.actorId, { maxLength: 64 });
  const runId = sanitizeSocketIdentifier(message?.runId, { maxLength: 64 });
  if (!actorId) return;
  const outcome = await applyLootCurrencyClaimForUser(requester, actorId, runId);
  if (!outcome.ok) {
    ui.notifications?.warn(`Currency claim failed (${requester.name}): ${outcome.message ?? "Unknown error."}`);
    return;
  }
  await postLootCurrencyClaimToChat(outcome);
  const s = outcome.share ?? { pp: 0, gp: 0, sp: 0, cp: 0 };
  ui.notifications?.info(`${requester.name} claimed currency for ${outcome.actorName}: ${s.pp}pp ${s.gp}gp ${s.sp}sp ${s.cp}cp.`);
}

async function applyPlayerLootVouchRequest(message, requesterRef = null) {
  const requester = resolveRequester(requesterRef ?? message?.userId, { allowGM: false, requireActive: true });
  if (!requester) return;
  const actorId = sanitizeSocketIdentifier(message?.actorId, { maxLength: 64 });
  const itemId = sanitizeSocketIdentifier(message?.itemId, { maxLength: 64 });
  const runId = sanitizeSocketIdentifier(message?.runId, { maxLength: 64 });
  if (!actorId || !itemId) return;
  const shouldVouch = message?.shouldVouch !== false;
  const outcome = await applyLootVouchForUser(requester, actorId, itemId, shouldVouch, runId);
  if (!outcome.ok) {
    ui.notifications?.warn(`Loot voucher failed (${requester.name}): ${outcome.message ?? "Unknown error."}`);
    return;
  }
  ui.notifications?.info(`${requester.name} ${shouldVouch ? "vouched for" : "removed voucher from"} ${outcome.itemName}.`);
}

async function applyRestRequest(request, requesterRef) {
  if (!request || typeof request !== "object") return;
  const state = getRestWatchState();
  const requester = resolveRequester(requesterRef, { allowGM: true });
  if (!requester) return;

  if (state.locked) return;

  // clearAll is not supported via socket (GM clears directly)
  if (request.op === "clearAll") return;

  // assignMe and clearEntry must be requester's character
  const requesterActor = requester.character;
  if (request.op === "assignMe") {
    if (!requesterActor || requesterActor.id !== request.actorId) return; // security check
    const slot = state.slots.find((s) => s.id === request.slotId);
    if (!slot) return;
    // Migrate old format
    if (!slot.entries && slot.actorId) {
      slot.entries = [{ actorId: slot.actorId, notes: slot.notes ?? "" }];
      slot.actorId = null;
      slot.notes = "";
    }
    if (!slot.entries) slot.entries = [];
    // Add new entry
    slot.entries.push({ actorId: request.actorId, notes: "" });
    stampUpdate(state, requester);
    await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.REST_STATE, state);
    scheduleIntegrationSync("rest-watch-player-mutate");
    refreshOpenApps();
    emitSocketRefresh();
    return;
  }

  if (request.op === "clearEntry") {
    const slot = state.slots.find((s) => s.id === request.slotId);
    if (!slot) return;
    // Migrate old format
    if (!slot.entries && slot.actorId) {
      slot.entries = [{ actorId: slot.actorId, notes: slot.notes ?? "" }];
      slot.actorId = null;
      slot.notes = "";
    }
    if (!slot.entries) slot.entries = [];
    // Only clear own entry
    const entryIndex = slot.entries.findIndex((e) => e.actorId === requesterActor?.id);
    if (entryIndex === -1) return; // not found or not owned
    if (slot.entries[entryIndex].actorId !== request.actorId) return; // security check
    slot.entries.splice(entryIndex, 1);
    stampUpdate(state, requester);
    await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.REST_STATE, state);
    scheduleIntegrationSync("rest-watch-player-mutate");
    refreshOpenApps();
    emitSocketRefresh();
    return;
  }

  if (request.op === "setEntryNotes") {
    const slot = state.slots.find((s) => s.id === request.slotId);
    if (!slot) return;
    // Migrate old format
    if (!slot.entries && slot.actorId) {
      slot.entries = [{ actorId: slot.actorId, notes: slot.notes ?? "" }];
      slot.actorId = null;
      slot.notes = "";
    }
    if (!slot.entries) slot.entries = [];
    // Only allow notes edits for entry actor the requester can control.
    const entry = slot.entries.find((e) => e.actorId === request.actorId);
    if (!entry) {
      logUiDebug("rest-watch-notes", "socket reject setEntryNotes (entry not found)", {
        slotId: request.slotId,
        actorId: request.actorId,
        requesterId: String(requester?.id ?? "")
      });
      return;
    }
    const entryActor = game.actors.get(request.actorId);
    if (!entryActor || !canUserControlActor(entryActor, requester)) {
      logUiDebug("rest-watch-notes", "socket reject setEntryNotes (permission denied)", {
        slotId: request.slotId,
        actorId: request.actorId,
        requesterId: String(requester?.id ?? ""),
        requesterName: String(requester?.name ?? "Unknown")
      });
      return;
    }
    entry.notes = String(request.text ?? "");
    logUiDebug("rest-watch-notes", "socket apply setEntryNotes", {
      slotId: request.slotId,
      actorId: request.actorId,
      requesterId: String(requester?.id ?? ""),
      requesterName: String(requester?.name ?? "Unknown"),
      textLength: String(request.text ?? "").length
    });
    stampUpdate(state, requester);
    await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.REST_STATE, state);
    scheduleIntegrationSync("rest-watch-player-mutate");
    refreshOpenApps();
    emitSocketRefresh();
    return;
  }
}

async function applyMarchRequest(request, requesterRef) {
  if (!request || typeof request !== "object") return;
  const state = getMarchingOrderState();
  const requester = resolveRequester(requesterRef, { allowGM: true });
  if (!requester) return;
  const requesterActor = requester.character;

  // joinRank: must be requester's character
  if (request.op === "joinRank") {
    if (!requesterActor || requesterActor.id !== request.actorId) return; // security check
    for (const key of Object.keys(state.ranks)) {
      state.ranks[key] = (state.ranks[key] ?? []).filter((entryId) => entryId !== request.actorId);
    }
    if (!state.ranks[request.rankId]) state.ranks[request.rankId] = [];
    state.ranks[request.rankId].push(request.actorId);
    stampUpdate(state, requester);
    await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.MARCH_STATE, state);
    scheduleIntegrationSync("marching-order-player-mutate");
    refreshOpenApps();
    emitSocketRefresh();
    return;
  }

  // setActorNote: requester must be permitted for actor and actor must be in formation
  if (request.op === "setNote") {
    const targetActor = game.actors.get(request.actorId);
    if (!targetActor || !canUserControlActor(targetActor, requester)) {
      logUiDebug("march-notes", "socket reject setNote (permission denied)", {
        actorId: request.actorId,
        requesterId: String(requester?.id ?? ""),
        requesterName: String(requester?.name ?? "Unknown")
      });
      return;
    }
    const inFormation = Object.values(state.ranks ?? {}).some((actorIds) => (
      Array.isArray(actorIds) && actorIds.includes(request.actorId)
    ));
    if (!inFormation) {
      logUiDebug("march-notes", "socket reject setNote (actor not in formation)", {
        actorId: request.actorId,
        requesterId: String(requester?.id ?? ""),
        requesterName: String(requester?.name ?? "Unknown")
      });
      return;
    }
    if (!state.notes) state.notes = {};
    state.notes[request.actorId] = String(request.text ?? "");
    logUiDebug("march-notes", "socket apply setNote", {
      actorId: request.actorId,
      requesterId: String(requester?.id ?? ""),
      requesterName: String(requester?.name ?? "Unknown"),
      textLength: String(request.text ?? "").length
    });
    stampUpdate(state, requester);
    await setModuleSettingWithLocalRefreshSuppressed(SETTINGS.MARCH_STATE, state);
    scheduleIntegrationSync("marching-order-player-mutate");
    refreshOpenApps();
    emitSocketRefresh();
    return;
  }
}

function toggleCardNotes(element) {
  const entry = element?.closest(".po-watch-entry");
  const notes = entry?.querySelector(".po-notes");
  if (!notes) return;
  const isActive = notes.classList.toggle("is-active");
  notes.setAttribute("aria-hidden", isActive ? "false" : "true");
  if (element?.setAttribute) element.setAttribute("aria-expanded", isActive ? "true" : "false");
  if (isActive) {
    const input = notes.querySelector("textarea");
    input?.focus?.({ preventScroll: true });
  }
}

async function toggleCampfire(element) {
  if (!canAccessAllPlayerOps()) {
    ui.notifications?.warn("Only the GM can toggle campfire.");
    return;
  }
  const state = getRestWatchState();
  const newValue = !state.campfire;
  await updateRestWatchState((state) => {
    state.campfire = newValue;
  });
  const status = newValue ? "Campfire lit" : "Campfire extinguished";
  ui.notifications?.info(status);
}

function refreshOpenApps() {
  if (refreshOpenAppsQueued) return;
  refreshOpenAppsQueued = true;
  requestAnimationFrame(() => {
    refreshOpenAppsQueued = false;
    const canvasSnapshot = captureCanvasViewState();
    const ids = new Set([
      "rest-watch-app",
      "marching-order-app",
      "rest-watch-player-app",
      "party-operations-global-modifier-summary",
      "party-operations-gm-environment-page",
      "party-operations-gm-downtime-page",
      "party-operations-gm-merchants-page",
      "party-operations-gm-loot-page",
      "party-operations-gm-loot-claims-board"
    ]);
    const knownInstances = [
      restWatchAppInstance,
      marchingOrderAppInstance,
      restWatchPlayerAppInstance,
      globalModifierSummaryAppInstance,
      gmEnvironmentPageAppInstance,
      gmDowntimePageAppInstance,
      gmMerchantsPageAppInstance,
      gmLootPageAppInstance,
      gmLootClaimsBoardAppInstance
    ]
      .filter((app) => app?.element?.isConnected);
    const apps = Object.values(ui.windows).filter((app) =>
      app instanceof RestWatchApp ||
      app instanceof MarchingOrderApp ||
      app instanceof RestWatchPlayerApp ||
      app instanceof GlobalModifierSummaryApp ||
      app instanceof GmEnvironmentPageApp ||
      app instanceof GmDowntimePageApp ||
      app instanceof GmMerchantsPageApp ||
      app instanceof GmLootPageApp ||
      app instanceof GmLootClaimsBoardApp ||
      ids.has(app?.id ?? app?.options?.id)
    );
    const unique = Array.from(new Set([...apps, ...knownInstances]));
    for (const app of unique) {
      // Force re-prepare context and re-render for v12 ApplicationV2
      if (!app?.render) continue;
      if (appHasFocusedTypingInput(app)) {
        logUiDebug("refresh", "skipping rerender for app with focused text input", {
          appId: String(app?.id ?? app?.options?.id ?? ""),
          appClass: String(app?.constructor?.name ?? "Application")
        });
        continue;
      }
      const windowState = captureWindowState(app);
      if (windowState) {
        pendingWindowRestore.set(app, windowState);
      }
      renderAppWithPreservedState(app, { force: true, parts: ["main"], focus: false }, {
        preserveCanvas: false
      });
    }
    queueCanvasViewRestore(canvasSnapshot, {
      action: "refresh-open-apps",
      eventType: "refresh"
    });
  });
}

function setupRestWatchDragAndDrop(html) {
  const state = getRestWatchState();
  const isGM = canAccessAllPlayerOps();
  if (!isGM || isLockedForUser(state, isGM)) return;

  html.querySelectorAll(".po-watch-entry").forEach((entry) => {
    const actorId = entry.dataset.actorId;
    if (!actorId) return;
    entry.setAttribute("draggable", "true");
    entry.classList.add("is-draggable");
    if (entry.dataset.poRestDndBound === "1") return;
    entry.dataset.poRestDndBound = "1";
    entry.addEventListener("dragstart", (event) => {
      const slotId = entry.closest(".po-card")?.dataset?.slotId;
      if (!slotId) return;
      const payload = JSON.stringify({ actorId, fromSlotId: slotId });
      event.dataTransfer?.setData("text/plain", payload);
      event.dataTransfer?.setDragImage?.(entry, 20, 20);
    });
  });

  html.querySelectorAll(".po-card").forEach((card) => {
    if (card.dataset.poRestDropBound === "1") return;
    card.dataset.poRestDropBound = "1";

    card.addEventListener("dragover", (event) => {
      event.preventDefault();
      card.classList.add("is-drop-target");
      if (event.dataTransfer) event.dataTransfer.dropEffect = "move";
    });

    card.addEventListener("dragleave", () => {
      card.classList.remove("is-drop-target");
    });

    card.addEventListener("drop", async (event) => {
      event.preventDefault();
      card.classList.remove("is-drop-target");

      const raw = event.dataTransfer?.getData("text/plain") ?? "";
      let data;
      try {
        data = JSON.parse(raw);
      } catch {
        return;
      }
      const actorId = data?.actorId;
      const fromSlotId = data?.fromSlotId;
      const targetSlotId = card.dataset.slotId;
      if (!actorId || !fromSlotId || !targetSlotId) return;
      if (fromSlotId === targetSlotId) return;

      await updateRestWatchState((state) => {
        const slots = state.slots ?? [];
        slots.forEach((slot) => {
          if (!slot.entries && slot.actorId) {
            slot.entries = [{ actorId: slot.actorId, notes: slot.notes ?? "" }];
            slot.actorId = null;
            slot.notes = "";
          }
          if (!slot.entries) slot.entries = [];
          slot.entries = slot.entries.filter((entry) => entry.actorId !== actorId);
        });

        const target = slots.find((slot) => slot.id === targetSlotId);
        if (!target) return;
        target.entries.push({ actorId, notes: "" });
      }, { skipLocalRefresh: true });

      refreshSingleAppPreservingView(restWatchAppInstance);
    });
  });
}

function openRestWatchPlayerApp() {
  if (canAccessAllPlayerOps()) {
    const app = openMainTab("rest-watch", { force: true });
    app?.bringToTop?.();
    return app;
  }
  const existing = Object.values(ui.windows).find((app) => app instanceof RestWatchPlayerApp);
  if (existing) {
    existing.bringToTop?.();
    return existing;
  }
  const app = new RestWatchPlayerApp(getResponsiveWindowOptions("rest-watch-player"));
  app.render({ force: true });
  return app;
}

export function emitSocketRefresh() {
  game.socket.emit(SOCKET_CHANNEL, { type: "refresh", userId: game.user.id });
}

function emitOpenRestPlayers() {
  game.socket.emit(SOCKET_CHANNEL, { type: "players:openRest" });
}
