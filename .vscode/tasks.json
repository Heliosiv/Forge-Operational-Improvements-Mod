{
	"version": "2.0.0",
	"tasks": [
		{
			"label": "build-test-42-zip",
			"type": "shell",
			"command": "$ErrorActionPreference = 'Stop'; $version = ((Get-Content -Raw 'module.json' | ConvertFrom-Json).version); $staging = '.build-regular-staging'; $zipName = \"party-operations-v$version-regular.zip\"; $shaName = \"party-operations-v$version-regular.sha256.txt\"; if (Test-Path $staging) { Remove-Item $staging -Recurse -Force }; New-Item -ItemType Directory -Path $staging | Out-Null; Copy-Item 'module.json' $staging -Force; Copy-Item 'scripts' $staging -Recurse -Force; Copy-Item 'styles' $staging -Recurse -Force; Copy-Item 'templates' $staging -Recurse -Force; if (Test-Path 'packs') { Copy-Item 'packs' $staging -Recurse -Force }; if (Test-Path $zipName) { Remove-Item $zipName -Force }; Compress-Archive -Path (Join-Path $staging '*') -DestinationPath $zipName -CompressionLevel Optimal; $hash = (Get-FileHash -Path $zipName -Algorithm SHA256).Hash; \"SHA256=$hash\" | Set-Content -NoNewline $shaName; Add-Type -AssemblyName System.IO.Compression.FileSystem; $archive = [System.IO.Compression.ZipFile]::OpenRead((Resolve-Path $zipName)); try { $entry = $archive.Entries | Where-Object { $_.FullName -eq 'module.json' } | Select-Object -First 1; if (-not $entry) { throw 'module.json missing in zip'; }; $reader = New-Object System.IO.StreamReader($entry.Open()); $content = $reader.ReadToEnd(); $reader.Dispose(); $zipVersion = ((ConvertFrom-Json $content).version); Write-Output \"ZIP=$zipName\"; Write-Output \"SHA_FILE=$shaName\"; Write-Output \"ZIP_MODULE_VERSION=$zipVersion\"; Write-Output \"ZIP_ENTRY_COUNT=$($archive.Entries.Count)\"; Write-Output \"SHA256=$hash\" } finally { $archive.Dispose(); if (Test-Path $staging) { Remove-Item $staging -Recurse -Force } }",
			"problemMatcher": []
		},
		{
			"label": "build-current-test-zip",
			"type": "shell",
			"command": "powershell -NoProfile -Command \"$ErrorActionPreference = 'Stop'; $version = ((Get-Content -Raw 'module.json' | ConvertFrom-Json).version); $staging = '.build-regular-staging'; $zipName = \\\"party-operations-v$version-regular.zip\\\"; $shaName = \\\"party-operations-v$version-regular.sha256.txt\\\"; if (Test-Path $staging) { Remove-Item $staging -Recurse -Force }; New-Item -ItemType Directory -Path $staging | Out-Null; Copy-Item 'module.json' $staging -Force; Copy-Item 'scripts' $staging -Recurse -Force; Copy-Item 'styles' $staging -Recurse -Force; Copy-Item 'templates' $staging -Recurse -Force; if (Test-Path 'packs') { Copy-Item 'packs' $staging -Recurse -Force }; if (Test-Path $zipName) { Remove-Item $zipName -Force }; Compress-Archive -Path (Join-Path $staging '*') -DestinationPath $zipName -CompressionLevel Optimal; $hash = (Get-FileHash -Path $zipName -Algorithm SHA256).Hash; \\\"SHA256=$hash\\\" | Set-Content -NoNewline $shaName; Add-Type -AssemblyName System.IO.Compression.FileSystem; $archive = [System.IO.Compression.ZipFile]::OpenRead((Resolve-Path $zipName)); try { $entry = $archive.Entries | Where-Object { $_.FullName -eq 'module.json' } | Select-Object -First 1; if (-not $entry) { throw 'module.json missing in zip'; }; $reader = New-Object System.IO.StreamReader($entry.Open()); $content = $reader.ReadToEnd(); $reader.Dispose(); $zipVersion = ((ConvertFrom-Json $content).version); Write-Output \\\"ZIP=$zipName\\\"; Write-Output \\\"SHA_FILE=$shaName\\\"; Write-Output \\\"ZIP_MODULE_VERSION=$zipVersion\\\"; Write-Output \\\"ZIP_ENTRY_COUNT=$($archive.Entries.Count)\\\"; Write-Output \\\"SHA256=$hash\\\" } finally { $archive.Dispose(); if (Test-Path $staging) { Remove-Item $staging -Recurse -Force } }\"",
			"problemMatcher": []
		},
		{
			"label": "build-test-sequence-zip",
			"type": "shell",
			"command": "$ErrorActionPreference = 'Stop'; $version = ((Get-Content -Raw 'module.json' | ConvertFrom-Json).version); $staging = '.build-regular-staging'; $zipName = \"party-operations-v$version-regular.zip\"; $shaName = \"party-operations-v$version-regular.sha256.txt\"; if (Test-Path $staging) { Remove-Item $staging -Recurse -Force }; New-Item -ItemType Directory -Path $staging | Out-Null; Copy-Item 'module.json' $staging -Force; Copy-Item 'scripts' $staging -Recurse -Force; Copy-Item 'styles' $staging -Recurse -Force; Copy-Item 'templates' $staging -Recurse -Force; if (Test-Path 'packs') { Copy-Item 'packs' $staging -Recurse -Force }; if (Test-Path $zipName) { Remove-Item $zipName -Force }; Compress-Archive -Path (Join-Path $staging '*') -DestinationPath $zipName -CompressionLevel Optimal; $hash = (Get-FileHash -Path $zipName -Algorithm SHA256).Hash; \"SHA256=$hash\" | Set-Content -NoNewline $shaName; Add-Type -AssemblyName System.IO.Compression.FileSystem; $archive = [System.IO.Compression.ZipFile]::OpenRead((Resolve-Path $zipName)); try { $entry = $archive.Entries | Where-Object { $_.FullName -eq 'module.json' } | Select-Object -First 1; if (-not $entry) { throw 'module.json missing in zip'; }; $reader = New-Object System.IO.StreamReader($entry.Open()); $content = $reader.ReadToEnd(); $reader.Dispose(); $zipVersion = ((ConvertFrom-Json $content).version); Write-Output \"ZIP=$zipName\"; Write-Output \"SHA_FILE=$shaName\"; Write-Output \"ZIP_MODULE_VERSION=$zipVersion\"; Write-Output \"ZIP_ENTRY_COUNT=$($archive.Entries.Count)\"; Write-Output \"SHA256=$hash\" } finally { $archive.Dispose(); if (Test-Path $staging) { Remove-Item $staging -Recurse -Force } }",
			"problemMatcher": []
		},
		{
			"label": "package-current-test-zip",
			"type": "shell",
			"command": "$v=((Get-Content -Raw module.json|ConvertFrom-Json).version);$s='.build-regular-staging';$z=\"party-operations-v$v-regular.zip\";$h=\"party-operations-v$v-regular.sha256.txt\";if(Test-Path $s){Remove-Item $s -Recurse -Force};mkdir $s|Out-Null;Copy-Item module.json,scripts,styles,templates -Destination $s -Recurse -Force;if(Test-Path packs){Copy-Item packs $s -Recurse -Force};if(Test-Path $z){Remove-Item $z -Force};Compress-Archive -Path (Join-Path $s '*') -DestinationPath $z -CompressionLevel Optimal;$sha=(Get-FileHash $z -Algorithm SHA256).Hash;\"SHA256=$sha\"|Set-Content -NoNewline $h;Add-Type -AssemblyName System.IO.Compression.FileSystem;$a=[System.IO.Compression.ZipFile]::OpenRead((Resolve-Path $z));try{$e=$a.Entries|?{$_.FullName -eq 'module.json'}|Select-Object -First 1;$r=New-Object IO.StreamReader($e.Open());$j=$r.ReadToEnd();$r.Dispose();$vz=((ConvertFrom-Json $j).version);Write-Output \"ZIP=$z\";Write-Output \"SHA_FILE=$h\";Write-Output \"ZIP_MODULE_VERSION=$vz\";Write-Output \"SHA256=$sha\"}finally{$a.Dispose();if(Test-Path $s){Remove-Item $s -Recurse -Force}}",
			"problemMatcher": []
		}
	]
}